<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[仿写oc的一个右侧字母排序加上搜索框]]></title>
      <url>/2018/09/11/%E4%BB%BF%E5%86%99oc%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E5%AD%97%E6%AF%8D%E6%8E%92%E5%BA%8F%E5%8A%A0%E4%B8%8A%E6%90%9C%E7%B4%A2%E6%A1%86/</url>
      <content type="html"><![CDATA[<p>地址：<a href="https://github.com/yuntiaoOS/SearchControl-sort-IndexView-swift" target="_blank" rel="noopener">https://github.com/yuntiaoOS/SearchControl-sort-IndexView-swift</a></p>
<p>先看看效果图</p>
<p><img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fv5d2dszigg30af0j50xv.gif" alt="2018-09-10 19.25.55"></p>
<p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fv5d1k51j4g30ad0j87aa.gif" alt="2018-09-10 19.24.54"></p>
<p>初始是很简单的实现，只能是字符数组，后期有时间再改成T类型匹配更多的数据</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> searchController </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS GCDAsyncUdpSocket UDP 建立连接,实现组播]]></title>
      <url>/2018/08/31/iOS%20GCDAsyncUdpSocket%20UDP%20%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5,%E5%AE%9E%E7%8E%B0%E7%BB%84%E6%92%AD/</url>
      <content type="html"><![CDATA[<p>导入框架 #import “GCDAsyncUdpSocket.h”,<br>接收代理 @interface RootViewController : UIViewController&lt; GCDAsyncUdpSocketDelegate&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self initSendUDPSocket];</span><br><span class="line">    [self initReceiveUDPSocket];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 初始化发送 UDP socket </span><br><span class="line">-(void)initSendUDPSocket&#123;</span><br><span class="line">    self.sendUDPSocket = [[GCDAsyncUdpSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)];</span><br><span class="line">    NSError * error = nil;</span><br><span class="line">    [self.sendUDPSocket bindToPort:8888 error:&amp;error];// bindToPort:是服务器的port</span><br><span class="line">    if (error) &#123;    //监听错误打印错误信息</span><br><span class="line">        NSLog(@&quot;error:%@&quot;,error);</span><br><span class="line">    &#125;else &#123;         //监听成功则开始接收信息</span><br><span class="line">        [self.sendUDPSocket enableBroadcast:YES error:nil];   // !!!!!!开启组播</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;开启组播失败: %@&quot;,error);</span><br><span class="line">        &#125;</span><br><span class="line">        [self sendUDPData:@&quot;DDC&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 初始化接收 UDP socket( 从另外一个 port 返回数据)</span><br><span class="line">-(void)initReceiveUDPSocket&#123;</span><br><span class="line">    self.receiveUDPSocket = [[GCDAsyncUdpSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)];</span><br><span class="line">    NSError * error = nil;</span><br><span class="line">    [self.receiveUDPSocket bindToPort:8899 error:&amp;error];</span><br><span class="line">    if (error) &#123;    //监听错误打印错误信息</span><br><span class="line">        NSLog(@&quot;error:%@&quot;,error);</span><br><span class="line">    &#125;else &#123;         //监听成功则开始接收信息</span><br><span class="line">        [self.receiveUDPSocket beginReceiving:&amp;error];// 一直接收</span><br><span class="line">        // [self.receiveUDPSocket receiveOnce:&amp;error]; (只接收一次)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 发送UDP</span><br><span class="line">-(void)sendUDPData:(NSString *)str</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;to ddc : %@&quot;,str);</span><br><span class="line">    NSData *data =[str dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    [self.sendUDPSocket sendData:data toHost:@&quot;255.255.255.255&quot; port:8888 withTimeout:-1 tag:0];   // 注意：这里的发送也是异步的,&quot;255.255.255.255&quot;,是组播方式,withTimeout设置成-1代表超时时间为-1，即永不超时； </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)udpSocket:(GCDAsyncUdpSocket *)sock didSendDataWithTag:(long)tag</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;发送信息成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)udpSocket:(GCDAsyncUdpSocket *)sock didNotSendDataWithTag:(long)tag dueToError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;发送信息失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)udpSocket:(GCDAsyncUdpSocket *)sock didReceiveData:(NSData *)data fromAddress:(NSData *)address withFilterContext:(id)filterContext</span><br><span class="line">&#123;</span><br><span class="line">    NSString *aStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">    NSLog(@&quot;接收到消息: %@&quot;,aStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是iOS GCDAsyncUdpSocket UDP 建立连接,实现组播的全文介绍,希望对您学习和使用ios应用开发有所帮助</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> GCDAsyncUdpSocket </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于prefs:root 上架被拒问题]]></title>
      <url>/2018/08/29/%5B%E5%B7%B2%E8%A7%A3%E5%86%B3%5Dprefs:root%20%E4%B8%8A%E6%9E%B6%E8%A2%AB%E6%8B%92%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>项目app是做蓝牙的，但是最近上架app store被拒，苹果发来的邮件内容如下</p>
<p>Your app uses the “prefs:root=” non-public URL scheme, which is a private entity. The use of non-public APIs is not permitted on the App Store because it can lead to a poor user experience should these APIs change.</p>
<p>To resolve this issue, please revise your app to provide the associated functionality using public APIs or remove the functionality using the “prefs:root” or “App-Prefs:root” URL scheme.</p>
<p>看着这个prefs:root的字样，想到了qpp跳转到系统蓝牙页面的功能。所以猜测是因为现在苹果不支持这种api了，在审核的时候发现这字样的代码，就被拒了。</p>
<p>以前做跳转都是下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//iOS10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;prefs:root= Bluetooth&quot;] options:@&#123;&#125; completionHandler:nil];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;prefs:root= Bluetooth&quot;]];</span><br></pre></td></tr></table></figure>
<p>而明显，邮件的意思是现在不可以用这样的prefs的描述字段了。</p>
<p>在网上找到解决方法是想办法对prefs:root = Bluetooth字段做转换，这样可以在审核时逃过代码扫描，具体方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//将字符串转换为16进制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSData *encryptString = [[NSData alloc] initWithBytes:(unsigned char [])&#123;0x70,0x72,0x65,0x66,0x73,0x3a,0x72,0x6f,0x6f,0x74,0x3d,0x4e,0x4f,0x54,0x49,0x46,0x49,0x43,0x41,0x54,0x49,0x4f,0x4e,0x53,0x5f,0x49,0x44&#125; length:27];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *string = [[NSString alloc] initWithData:encryptString encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:string] options:@&#123;&#125; completionHandler:nil];</span><br></pre></td></tr></table></figure>
<p>关于这个问题，苹果的要求是不可以再使用prefs:root以及App-Prefs:root的接口来做app内部和系统设置的跳转了。现在做app系统设置跳转，官方的只能使用UIApplicationOpenSettingURLString.</p>
<p>并且，明确一点，就是打开url的api也是需要做适配的。</p>
<p>系统版本低于ios10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];</span><br></pre></td></tr></table></figure>
<p>系统版本高于ios10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString] options:@&#123;&#125; completionHandler:nil];</span><br></pre></td></tr></table></figure>
<p>一些网站上说使用prefs:root配合在info.plist上加入URL scheme值为prefs:的方案可以解决这个上架被拒的问题。但是经过我自己的测试，现在“prefs:root”是苹果不允许的，而且这个在info.plist中加入URL scheme值为prefs:也是不可以的。</p>
<p>也就是说使用“prefs:root”做跳转 以及 在info.plist中加入URL scheme值为prefs:，这两者，只要存在其中一项都会被app store拒绝的。</p>
<p>就是把原本在info.plist中的prefs去掉之后，就可以了！</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> 上架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[swift-view任意位置添加边框线（实线，虚线）]]></title>
      <url>/2018/08/24/swift-view%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E8%BE%B9%E6%A1%86%E7%BA%BF%EF%BC%88%E5%AE%9E%E7%BA%BF%EF%BC%8C%E8%99%9A%E7%BA%BF%EF%BC%89/</url>
      <content type="html"><![CDATA[<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">swift-view任意位置添加边框线（实线，虚线）</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">UIRectSide</span> : <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">public</span> <span class="keyword">let</span> rawValue: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="keyword">left</span> = <span class="type">UIRectSide</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> top = <span class="type">UIRectSide</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="keyword">right</span> = <span class="type">UIRectSide</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> bottom = <span class="type">UIRectSide</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> all: <span class="type">UIRectSide</span> = [.top, .<span class="keyword">right</span>, .<span class="keyword">left</span>, .bottom]</span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">self</span>.rawValue = rawValue;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">​    <span class="comment">///画虚线边框</span></span><br><span class="line"></span><br><span class="line">​    <span class="function"><span class="keyword">func</span> <span class="title">drawDashLine</span><span class="params">(strokeColor: UIColor, lineWidth: CGFloat = <span class="number">1</span>, lineLength: Int = <span class="number">10</span>, lineSpacing: Int = <span class="number">5</span>, corners: UIRectSide)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">let</span> shapeLayer = <span class="type">CAShapeLayer</span>()</span><br><span class="line"></span><br><span class="line">​        shapeLayer.bounds = <span class="keyword">self</span>.bounds</span><br><span class="line"></span><br><span class="line">​        shapeLayer.anchorPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">​        shapeLayer.fillColor = <span class="type">UIColor</span>.blue.cgColor</span><br><span class="line"></span><br><span class="line">​        shapeLayer.strokeColor = strokeColor.cgColor</span><br><span class="line"></span><br><span class="line">​        </span><br><span class="line"></span><br><span class="line">​        shapeLayer.lineWidth = lineWidth</span><br><span class="line"></span><br><span class="line">​        shapeLayer.lineJoin = kCALineJoinRound</span><br><span class="line"></span><br><span class="line">​        </span><br><span class="line"></span><br><span class="line">​        <span class="comment">//每一段虚线长度 和 每两段虚线之间的间隔</span></span><br><span class="line"></span><br><span class="line">​        shapeLayer.lineDashPattern = [<span class="type">NSNumber</span>(value: lineLength), <span class="type">NSNumber</span>(value: lineSpacing)]</span><br><span class="line"></span><br><span class="line">​        </span><br><span class="line"></span><br><span class="line">​        <span class="keyword">let</span> path = <span class="type">CGMutablePath</span>()</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> corners.<span class="built_in">contains</span>(.<span class="keyword">left</span>) &#123;</span><br><span class="line"></span><br><span class="line">​            path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="keyword">self</span>.layer.bounds.height))</span><br><span class="line"></span><br><span class="line">​            path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> corners.<span class="built_in">contains</span>(.top)&#123;</span><br><span class="line"></span><br><span class="line">​            path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">​            path.addLine(to: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.layer.bounds.width, y: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> corners.<span class="built_in">contains</span>(.<span class="keyword">right</span>)&#123;</span><br><span class="line"></span><br><span class="line">​            path.move(to: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.layer.bounds.width, y: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">​            path.addLine(to: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.layer.bounds.width, y: <span class="keyword">self</span>.layer.bounds.height))</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> corners.<span class="built_in">contains</span>(.bottom)&#123;</span><br><span class="line"></span><br><span class="line">​            path.move(to: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.layer.bounds.width, y: <span class="keyword">self</span>.layer.bounds.height))</span><br><span class="line"></span><br><span class="line">​            path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="keyword">self</span>.layer.bounds.height))</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        shapeLayer.path = path</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">self</span>.layer.addSublayer(shapeLayer)</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">///画实线边框</span></span><br><span class="line"></span><br><span class="line">​    <span class="function"><span class="keyword">func</span> <span class="title">drawLine</span><span class="params">(strokeColor: UIColor, lineWidth: CGFloat = <span class="number">1</span>, corners: UIRectSide)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">​        </span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> corners == <span class="type">UIRectSide</span>.all &#123;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">self</span>.layer.borderWidth = lineWidth</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">self</span>.layer.borderColor = strokeColor.cgColor</span><br><span class="line"></span><br><span class="line">​        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">let</span> shapeLayer = <span class="type">CAShapeLayer</span>()</span><br><span class="line"></span><br><span class="line">​            shapeLayer.bounds = <span class="keyword">self</span>.bounds</span><br><span class="line"></span><br><span class="line">​            shapeLayer.anchorPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">​            shapeLayer.fillColor = <span class="type">UIColor</span>.blue.cgColor</span><br><span class="line"></span><br><span class="line">​            shapeLayer.strokeColor = strokeColor.cgColor</span><br><span class="line"></span><br><span class="line">​            </span><br><span class="line"></span><br><span class="line">​            shapeLayer.lineWidth = lineWidth</span><br><span class="line"></span><br><span class="line">​            shapeLayer.lineJoin = kCALineJoinRound</span><br><span class="line"></span><br><span class="line">​            </span><br><span class="line"></span><br><span class="line">​            <span class="keyword">let</span> path = <span class="type">CGMutablePath</span>()</span><br><span class="line"></span><br><span class="line">​            </span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> corners.<span class="built_in">contains</span>(.<span class="keyword">left</span>) &#123;</span><br><span class="line"></span><br><span class="line">​                path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="keyword">self</span>.layer.bounds.height))</span><br><span class="line"></span><br><span class="line">​                path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> corners.<span class="built_in">contains</span>(.top)&#123;</span><br><span class="line"></span><br><span class="line">​                path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">​                path.addLine(to: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.layer.bounds.width, y: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> corners.<span class="built_in">contains</span>(.<span class="keyword">right</span>)&#123;</span><br><span class="line"></span><br><span class="line">​                path.move(to: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.layer.bounds.width, y: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">​                path.addLine(to: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.layer.bounds.width, y: <span class="keyword">self</span>.layer.bounds.height))</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> corners.<span class="built_in">contains</span>(.bottom)&#123;</span><br><span class="line"></span><br><span class="line">​                path.move(to: <span class="type">CGPoint</span>(x: <span class="keyword">self</span>.layer.bounds.width, y: <span class="keyword">self</span>.layer.bounds.height))</span><br><span class="line"></span><br><span class="line">​                path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="keyword">self</span>.layer.bounds.height))</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            </span><br><span class="line"></span><br><span class="line">​            shapeLayer.path = path</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">self</span>.layer.addSublayer(shapeLayer)</span><br><span class="line"></span><br><span class="line">​            </span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        </span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> view </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于线程顺序执行]]></title>
      <url>/2018/08/22/%E7%AD%89%E5%BE%85%EF%BC%8C%E7%9B%B4%E5%88%B0%E5%AE%8C%E6%88%90%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="1-使用你自己的串行调度队列"><a href="#1-使用你自己的串行调度队列" class="headerlink" title="1.使用你自己的串行调度队列:"></a>1.使用你自己的串行调度队列:</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_queue_create(<span class="string">"com.mycompany.serial-queue"</span>,</span><br><span class="line">    dispatch_queue_attr_make_with_qos_class(<span class="type">DISPATCH_QUEUE_SERIAL</span>, <span class="type">QOS_CLASS_USER_INITIATED</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"inside block 1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(queue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"inside block 2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-NSOperationQueue-与依赖项"><a href="#2-使用-NSOperationQueue-与依赖项" class="headerlink" title="2.使用 NSOperationQueue 与依赖项:"></a>2.使用 NSOperationQueue 与依赖项:</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">NSOperationQueue</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> op1 = <span class="type">NSBlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"inside block 1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> op2 = <span class="type">NSBlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"inside block 2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">op2.addDependency(op1) <span class="comment">// op2 may only execute after op1 is finished</span></span><br><span class="line"></span><br><span class="line">queue.addOperation(op1)</span><br><span class="line">queue.addOperation(op2)</span><br></pre></td></tr></table></figure>
<h3 id="3-使用串行-NSOperationQueue"><a href="#3-使用串行-NSOperationQueue" class="headerlink" title="3.使用串行 NSOperationQueue:"></a>3.使用串行 NSOperationQueue:</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">NSOperationQueue</span>()</span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">1</span> <span class="comment">// execute 1 operation at a time</span></span><br><span class="line"></span><br><span class="line">queue.addOperationWithBlock &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"inside block 1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.addOperationWithBlock &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"inside block 2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> 线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 全屏侧滑手势/UIScrollView/UISlider间滑动手势冲突]]></title>
      <url>/2018/08/22/iOS%20%E5%85%A8%E5%B1%8F%E4%BE%A7%E6%BB%91%E6%89%8B%E5%8A%BF:UIScrollView:UISlider%E9%97%B4%E6%BB%91%E5%8A%A8%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81/</url>
      <content type="html"><![CDATA[<p>## </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1708447-3ef7a155b61b3616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450" alt="img"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1708447-83ae3654030d8414.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/275" alt="img"></p>
<p>效果预览</p>
<h4 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h4><p>有一个支持全屏侧滑返回的视图控制器ViewController，ViewController.view上有一个UIScrollView，UIScrollView上有UISlider。俺直接在之前的示例Demo上演示，简书地址：<a href="https://www.jianshu.com/p/a9b1307b305b" target="_blank" rel="noopener">iOS 自定义转场动画</a> ，Github地址 ：<a href="https://github.com/wslcmk/WSLTransferAnimation.git" target="_blank" rel="noopener">WSLTransferAnimation</a><br><a id="more"></a></p>
<h4 id="二、问题展示"><a href="#二、问题展示" class="headerlink" title="二、问题展示"></a>二、问题展示</h4><ul>
<li>现象 1、UIScrollView当前在第一页即contentOffset.x=0时，左滑不能触发全屏侧滑pop返回的手势 ；</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1708447-a9eacdbc7092ff36.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/276" alt="img"></p>
<p>UIScrollView和全屏侧滑pop返回手势冲突示意图</p>
<ul>
<li>现象2 、问题1解决后，你会发现拖拽UIScrollView第一页上的UISlider时，向右拖拽时却触发了全屏侧滑pop返回的手势，而UISlider本身的拖拽事件却没有响应；向左拖拽UISlider时，响应的是UIScrollView的拖动事件，而UISlider本身的拖拽事件也没有响应。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1708447-dd07d227fe222ecb.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/276" alt="img"></p>
<p>UISlider与UIScrollView、全屏侧滑pop返回手势冲突示意图</p>
<ul>
<li>现象3 、当你长按UISlider超过150ms后直接拖拽，就不存在现象2中UISlider与UIScrollView、全屏侧滑返回的冲突问题了。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1708447-418b5c5d99e7de6c.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/276" alt="img"></p>
<p>手势冲突.gif</p>
<h4 id="三、分析解决问题"><a href="#三、分析解决问题" class="headerlink" title="三、分析解决问题"></a>三、分析解决问题</h4><p>这些问题很显然，肯定跟iOS事件的传递和响应链机制有关系，不了解的可以看看这篇文章 <a href="https://www.jianshu.com/p/2e074db792ba" target="_blank" rel="noopener">史上最详细的iOS之事件的传递和响应机制-原理篇</a>。</p>
<ul>
<li>分析解决问题 1<br>如果你了解事件的传递和响应链机制的话，应该能想到，是由于UIScrollView的内部手势方法阻断了全屏侧滑返回手势的的响应，那我们就找到这个方法，代码如下 ；</li>
</ul>
<p>创建一个UIScrollView的类别UIScrollView+GestureConflict，重写如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//处理UIScrollView上的手势和侧滑返回手势的冲突</span><br><span class="line">-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123;</span><br><span class="line"></span><br><span class="line">    // 首先判断otherGestureRecognizer是不是系统pop手势</span><br><span class="line">    if ([otherGestureRecognizer.view isKindOfClass:NSClassFromString(@&quot;UILayoutContainerView&quot;)]) &#123;</span><br><span class="line">        // 再判断系统手势的state是began还是fail，同时判断scrollView的位置是不是正好在最左边</span><br><span class="line">        if (otherGestureRecognizer.state == UIGestureRecognizerStateBegan &amp;&amp; self.contentOffset.x == 0) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析解决问题 2和3</li>
</ul>
<p>方案一：这个跟UIScrollView的一个属性delaysContentTouches有关。</p>
<p>scrollView.delaysContentTouches = NO;<br>delaysContentTouches 默认值为YES 表示延迟scrollView上子视图的响应，所以当直接拖动UISlider时，如果此时touch时间在150ms以内，UIScrollView会认为是拖动自己，从而拦截了event，导致UISlider接收不到滑动的event。但是只要长按住UISlider一会儿再拖动，此时touch时间超过150ms，因此滑动的event会发送到UISlider上，然后UISlider再作出响应；设置为NO后，拖动UISlider时就可以直接做出响应，解决了UISlider与UIScrollView之间的冲突，同时也解决了向右拖拽时却触发了全屏侧滑pop返回的问题。</p>
<p>方案二： 重写类别UIScrollView+GestureConflict中的如下方法来解决UISlider与UIScrollView之间的冲突，然后还需要执行下面 问题补充 中的操作来处理UISlider的滑动与全屏侧滑pop返回事件的冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//拦截事件的处理 事件传递给谁，就会调用谁的hitTest:withEvent:方法。</span><br><span class="line">//处理UISlider的滑动与UIScrollView的滑动事件冲突</span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    /*</span><br><span class="line">     直接拖动UISlider，此时touch时间在150ms以内，UIScrollView会认为是拖动自己，从而拦截了event，导致UISlider接受不到滑动的event。但是只要按住UISlider一会再拖动，此时此时touch时间超过150ms，因此滑动的event会发送到UISlider上。</span><br><span class="line">     */</span><br><span class="line">    UIView *view = [super hitTest:point withEvent:event];</span><br><span class="line"></span><br><span class="line">    if([view isKindOfClass:[UISlider class]]) &#123;</span><br><span class="line">        //如果接收事件view是UISlider,则scrollview禁止响应滑动</span><br><span class="line">        self.scrollEnabled = NO;</span><br><span class="line">    &#125; else &#123;   //如果不是,则恢复滑动</span><br><span class="line">        self.scrollEnabled = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>问题补充<br>示例Demo中的UISlider是在UIScrollView上的，如果UISlider不是在UIScrollView上，而是直接就在ViewController.view上，那也就会出现拖拽UISlider时却响应了全屏侧滑pop返回手势的问题。</li>
</ul>
<p>在支持全屏侧滑返回的UINavigationController的子类WSLNavigatioController中，遵守协议,实现如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -- UIGestureRecognizerDelegate</span><br><span class="line">//触发之后是否响应手势事件</span><br><span class="line">//处理侧滑返回与UISlider的拖动手势冲突</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch&#123;</span><br><span class="line">    //如果手势是触摸的UISlider滑块触发的，侧滑返回手势就不响应</span><br><span class="line">    if ([touch.view isKindOfClass:[UISlider class]]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四、应用示例"><a href="#四、应用示例" class="headerlink" title="四、应用示例"></a>四、应用示例</h4><p><img src="http://upload-images.jianshu.io/upload_images/1708447-9652702e9c19bc57.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/275" alt="img"></p>
<p>手势冲突应用示例.gif</p>
<p>好了，俺要去鹊桥跟俺家织女相会咯✌️</p>
<blockquote>
<p><em>作者：且行且珍惜_iOS</em></p>
<p><em>链接：<a href="https://www.jianshu.com/p/a9a322052f26" target="_blank" rel="noopener">https://www.jianshu.com/p/a9a322052f26</a></em></p>
</blockquote>
<p>本站内容均为本站转发，已尽可能注明出处。因未能核实来源或转发内容图片有权利瑕疵的，请及时联系本站，本站会第一时间进行修改或删除。 QQ : 3442093904 </p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> 侧滑手势 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift3.0 调用C函数]]></title>
      <url>/2018/08/17/Swift3.0%20%E8%B0%83%E7%94%A8C%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一般情况下Swit要想调用obj-c,c或c++代码必须通过obj-c以及桥接文件才可以办到,但是使用<code>@_silgen_name</code>,可以对于某些简单的代码,直接跳过桥接文件和.h头文件与C代码交互。</p>
</blockquote>
<h2 id="创建-c文件"><a href="#创建-c文件" class="headerlink" title="创建.c文件"></a>创建.c文件</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int add(int i, int j)&#123;</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mul(int i, int times)&#123;</span><br><span class="line">    <span class="keyword">return</span> i * times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建-swift文件-引用-c文件函数"><a href="#创建-swift文件-引用-c文件函数" class="headerlink" title="创建.swift文件,引用.c文件函数"></a>创建.swift文件,引用.c文件函数</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在全局作用域下进行声明</span></span><br><span class="line"><span class="comment">// swift 2.2使用关键字@asmname</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line">@_silen_name(<span class="string">"add"</span>) <span class="function"><span class="keyword">func</span> <span class="title">c_add</span><span class="params">(<span class="number">_</span> num1: Int, <span class="number">_</span> num2: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">@_silgen_name(<span class="string">"mul"</span>) <span class="function"><span class="keyword">func</span> <span class="title">c_mul</span><span class="params">(<span class="number">_</span> num: Int, <span class="number">_</span> times: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(c_add(<span class="number">80</span>, <span class="number">23</span>))</span><br><span class="line"><span class="built_in">print</span>(c_mul(<span class="number">3</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>例：<br>Swift 引用 “@_silgen_name”</p>
<p>@_silgen_name(“yudpsocket_server”) func c_yudpsocket<em>server(</em> host:UnsafePointer<int8>,port:Int32) -&gt; Int32</int8></p>
<p>@_silgen_name(“yudpsocket_recive”) func c_yudpsocket<em>recive(</em> fd:Int32,buff:UnsafePointer<byte>,len:Int32,ip:UnsafePointer<int8>,port:UnsafePointer<int32>) -&gt; Int32</int32></int8></byte></p>
<p>@_silgen_name(“yudpsocket_close”) func c_yudpsocket<em>close(</em> fd:Int32) -&gt; Int32</p>
<p>@_silgen_name(“yudpsocket_client”) func c_yudpsocket_client() -&gt; Int32</p>
<p>@_silgen_name(“yudpsocket_get_server_ip”) func c_yudpsocket_get_server<em>ip(</em> host:UnsafePointer<int8>,ip:UnsafePointer<int8>) -&gt; Int32</int8></int8></p>
<p>@_silgen_name(“yudpsocket_sentto”) func c_yudpsocket<em>sentto(</em> fd:Int32,buff:UnsafePointer<byte>,len:Int32,ip:UnsafePointer<int8>,port:Int32) -&gt; Int32</int8></byte></p>
<p>@_silgen_name(“enable_broadcast”) func c_enable<em>broadcast(</em> fd:Int32)</p>
<p>///////yudpsocket.c</p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <stdlib.h></stdlib.h></p>
<p>#include <sys socket.h=""></sys></p>
<p>#include <arpa inet.h=""></arpa></p>
<p>#include <sys types.h=""></sys></p>
<p>#include <string.h></string.h></p>
<p>#include <unistd.h></unistd.h></p>
<p>#include <netdb.h></netdb.h></p>
<p>#define yudpsocket_buff_len 8192</p>
<p>//return socket fd</p>
<p>int yudpsocket_server(const char *address, int port) {</p>
<p>​    //create socket<br>​<br>​    int socketfd=socket(AF_INET, SOCK_DGRAM, 0);<br>​<br>​    int reuseon = 1;<br>​<br>​    int r = -1;<br>​<br>​<br>​<br>​    //bind<br>​<br>​    struct sockaddr_in serv_addr;<br>​<br>​    memset( &amp;serv_addr, ‘\0’, sizeof(serv_addr));<br>​<br>​    serv_addr.sin_len = sizeof(struct sockaddr_in);<br>​<br>​    serv_addr.sin_family = AF_INET;<br>​<br>​    if (address == NULL || strlen(address) == 0 || strcmp(address, “255.255.255.255”) == 0) {<br>​<br>​    ​        r = setsockopt(socketfd, SOL_SOCKET, SO_BROADCAST, &amp;reuseon, sizeof(reuseon));<br>​    ​<br>​    ​        ​        serv_addr.sin_port = htons(port);<br>​    ​        ​<br>​    ​        ​        ​        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);<br>​    ​        ​        ​<br>​    ​        ​        ​        ​    } else {<br>​    ​        ​        ​        ​<br>​    ​        ​        ​        ​    ​        r = setsockopt(socketfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseon, sizeof(reuseon));<br>​    ​        ​        ​        ​    ​<br>​    ​        ​        ​        ​    ​        ​        serv_addr.sin_addr.s_addr = inet_addr(address);<br>​    ​        ​        ​        ​    ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        serv_addr.sin_port = htons(port);<br>​    ​        ​        ​        ​    ​        ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    }<br>​    ​        ​        ​        ​    ​        ​        ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    if (r == -1) {<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       return -1;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    }<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    r = bind(socketfd, (struct sockaddr <em>) &amp;serv_addr, sizeof(serv_addr));<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    if (r == 0) {<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        return socketfd;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    } else {<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        return -1;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    }<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    }<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    int yudpsocket_recive(int socket_fd, char </em>outdata, int expted_len, char <em>remoteip, int </em>remoteport) {<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    struct sockaddr_in cli_addr;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    socklen_t clilen = sizeof(cli_addr);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    memset(&amp;cli_addr, 0x0, sizeof(struct sockaddr_in));<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    int len = (int)recvfrom(socket_fd, outdata, expted_len, 0, (struct sockaddr <em>)&amp;cli_addr, &amp;clilen);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    char </em>clientip = inet_ntoa(cli_addr.sin_addr);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    memcpy(remoteip, clientip, strlen(clientip));<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    <em>remoteport = cli_addr.sin_port;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    return len;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    }<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    int yudpsocket_close(int socket_fd) {<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    return close(socket_fd);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    }<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    //return socket fd<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    int yudpsocket_client() {<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    //create socket<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    int socketfd = socket(AF_INET, SOCK_DGRAM, 0);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    int reuseon = 1;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    setsockopt(socketfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseon, sizeof(reuseon));<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    return socketfd;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    }<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    //enable broadcast<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    void enable_broadcast(int socket_fd) {<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    int reuseon = 1;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    setsockopt(socket_fd, SOL_SOCKET, SO_BROADCAST, &amp;reuseon, sizeof(reuseon));<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    }<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    int yudpsocket_get_server_ip(char </em>host, char <em>ip) {<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    struct hostent </em>hp;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    struct sockaddr_in address;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    hp = gethostbyname(host);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    if (hp == NULL) {<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        return -1;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    }<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    bcopy((char <em>)hp-&gt;h_addr, (char </em>)&amp;address.sin_addr, hp-&gt;h_length);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    char <em>clientip = inet_ntoa(address.sin_addr);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    memcpy(ip, clientip, strlen(clientip));<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    return 0;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    }<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    //send message to address and port<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    int yudpsocket_sentto(int socket_fd, char </em>msg, int len, char <em>toaddr, int topotr) {<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    struct sockaddr_in address;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    socklen_t addrlen = sizeof(address);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    memset(&amp;address, 0x0, sizeof(struct sockaddr_in));<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    address.sin_family = AF_INET;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    address.sin_port = htons(topotr);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    address.sin_addr.s_addr = inet_addr(toaddr);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    int sendlen = (int)sendto(socket_fd, msg, len, 0, (struct sockaddr </em>)&amp;address, addrlen);<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    return sendlen;<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​<br>​    ​        ​        ​        ​    ​        ​        ​        ​    ​    ​       ​    ​    ​    ​        ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​        ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    }</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 获取APP的CPU、内存等信息]]></title>
      <url>/2018/08/15/iOS%20%E8%8E%B7%E5%8F%96APP%E7%9A%84CPU%E3%80%81%E5%86%85%E5%AD%98%E7%AD%89%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<p>转载： <a href="https://www.cnblogs.com/mobilefeng/p/4977783.html" target="_blank" rel="noopener">iOS 获取APP的CPU、内存等信息</a></p>
<p>目标是开发一个SDK，嵌入到APP里面，用来统计当前APP的实时CPU、内存等信息</p>
<p>2015.11.17</p>
<p><a href="http://stackoverflow.com/questions/12889422/ios-cpu-usage-for-each-process-using-sysctl" target="_blank" rel="noopener">http://stackoverflow.com/questions/12889422/ios-cpu-usage-for-each-process-using-sysctl</a></p>
<p>这是第一个找到，采用的是sysctl函数</p>
<p>但是出来的CPU数据和instrument、GT的数据对不上（后两者数据比较接近）</p>
<a id="more"></a>
<p>2015.11.19</p>
<p><a href="https://github.com/TianJIANG/ios_monitor" target="_blank" rel="noopener">https://github.com/TianJIANG/ios_monitor</a></p>
<p>从guithub上搜到的，利用的主要是#import <mach mach.h=""> 里面的task_info 等，打开了一道新的大门，后续找到不少类似的方法</mach></p>
<p><a href="http://stackoverflow.com/questions/8223348/ios-get-cpu-usage-from-application" target="_blank" rel="noopener">http://stackoverflow.com/questions/8223348/ios-get-cpu-usage-from-application</a></p>
<p>这个答案也是给的这个方法，末尾额外加了一行代码， vm_dealloc，解决leaking问题</p>
<p>补充几个相关的：</p>
<p><a href="http://stackoverflow.com/questions/5182924/where-is-my-ipad-runtime-memory-going%E2%80%8C%E2%80%8B" target="_blank" rel="noopener">http://stackoverflow.com/questions/5182924/where-is-my-ipad-runtime-memory-going%E2%80%8C%E2%80%8B</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_693de6100101ffwm.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_693de6100101ffwm.html</a></p>
<p><a href="http://www.zhihu.com/question/22992491" target="_blank" rel="noopener">http://www.zhihu.com/question/22992491</a></p>
<p>Github 搜 “Activity Monitor”</p>
<p><a href="https://github.com/AndrewBarba/ActivityMonitor" target="_blank" rel="noopener">https://github.com/AndrewBarba/ActivityMonitor</a></p>
<p><a href="https://github.com/vsnrain/ActivityMonitor" target="_blank" rel="noopener">https://github.com/vsnrain/ActivityMonitor</a></p>
<p>此算法是获取当前APP的CPU，数值与Instrument、GT接近</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (void)GetCpuUsage &#123;</span><br><span class="line">    kern_return_t kr;</span><br><span class="line">    task_info_data_t tinfo;</span><br><span class="line">    mach_msg_type_number_t task_info_count;</span><br><span class="line">    </span><br><span class="line">    task_info_count = TASK_INFO_MAX;</span><br><span class="line">    kr = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)tinfo, &amp;task_info_count);</span><br><span class="line">    if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    task_basic_info_t      basic_info;</span><br><span class="line">    thread_array_t         thread_list;</span><br><span class="line">    mach_msg_type_number_t thread_count;</span><br><span class="line">    </span><br><span class="line">    thread_info_data_t     thinfo;</span><br><span class="line">    mach_msg_type_number_t thread_info_count;</span><br><span class="line">    </span><br><span class="line">    thread_basic_info_t basic_info_th;</span><br><span class="line">    uint32_t stat_thread = 0; // Mach threads</span><br><span class="line">    </span><br><span class="line">    basic_info = (task_basic_info_t)tinfo;</span><br><span class="line">    </span><br><span class="line">    // get threads in the task</span><br><span class="line">    kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);</span><br><span class="line">    if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (thread_count &gt; 0)</span><br><span class="line">        stat_thread += thread_count;</span><br><span class="line">    </span><br><span class="line">    long tot_sec = 0;</span><br><span class="line">    long tot_usec = 0;</span><br><span class="line">    float tot_cpu = 0;</span><br><span class="line">    int j;</span><br><span class="line">    </span><br><span class="line">    for (j = 0; j &lt; thread_count; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        thread_info_count = THREAD_INFO_MAX;</span><br><span class="line">        kr = thread_info(thread_list[j], THREAD_BASIC_INFO,</span><br><span class="line">                         (thread_info_t)thinfo, &amp;thread_info_count);</span><br><span class="line">        if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        basic_info_th = (thread_basic_info_t)thinfo;</span><br><span class="line">        </span><br><span class="line">        if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">            tot_sec = tot_sec + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;</span><br><span class="line">            tot_usec = tot_usec + basic_info_th-&gt;system_time.microseconds + basic_info_th-&gt;system_time.microseconds;</span><br><span class="line">            tot_cpu = tot_cpu + basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE * 100.0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; // for each thread</span><br><span class="line">    </span><br><span class="line">    kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;CPU Usage: %f \n&quot;, tot_cpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>此算法是获取当前APP的内存，数值与GT的一致，与Instrument不一致</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)GetCurrentTaskUsedMemory &#123;</span><br><span class="line">    task_basic_info_data_t taskInfo;</span><br><span class="line">    mach_msg_type_number_t infoCount = TASK_BASIC_INFO_COUNT;</span><br><span class="line">    kern_return_t kernReturn = task_info(mach_task_self(),</span><br><span class="line">                                         TASK_BASIC_INFO, (task_info_t)&amp;taskInfo, &amp;infoCount);</span><br><span class="line">    </span><br><span class="line">    if(kernReturn != KERN_SUCCESS) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;Memory Usage: %f&quot;, taskInfo.resident_size / 1024.0 / 1024.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>2015.11.20</p>
<p>XNU</p>
<p><a href="https://en.wikipedia.org/wiki/XNU" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/XNU</a></p>
<p>MACH</p>
<p><a href="https://en.wikipedia.org/wiki/Mach_(kernel" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Mach_(kernel</a>)</p>
<p>Kernel Programming Guide</p>
<p><a href="https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/KernelProgramming/About/About.html" target="_blank" rel="noopener">https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/KernelProgramming/About/About.html</a></p>
<p>github 上搜 mach_msg_type_number_t</p>
<p><a href="https://github.com/search?l=objective-c&amp;q=mach_msg_type_number_t&amp;type=Code&amp;utf8=✓" target="_blank" rel="noopener">https://github.com/search?l=objective-c&amp;q=mach_msg_type_number_t&amp;type=Code&amp;utf8=✓</a></p>
<p>2015.11.22</p>
<p>用VM Tracker查看内存，有那么几项</p>
<p>Resident Size｜Dirty Size｜Virtual Size</p>
<p><a href="http://stackoverflow.com/questions/5176074/what-do-dirty-and-resident-mean-in-relation-to-virtual-memory" target="_blank" rel="noopener">http://stackoverflow.com/questions/5176074/what-do-dirty-and-resident-mean-in-relation-to-virtual-memory</a></p>
<p>这篇解释了三者的差别，我理解我们应该跟踪的是Resident Size，但是数值上与VM Tracker上对不上 </p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">- (void)GetMemoryStatistics &#123;</span><br><span class="line">    </span><br><span class="line">    // Get Page Size</span><br><span class="line">    int mib[2];</span><br><span class="line">    int page_size;</span><br><span class="line">    size_t len;</span><br><span class="line">    </span><br><span class="line">    mib[0] = CTL_HW;</span><br><span class="line">    mib[1] = HW_PAGESIZE;</span><br><span class="line">    len = sizeof(page_size);</span><br><span class="line">    </span><br><span class="line">//    // 方法一: 16384</span><br><span class="line">//    int status = sysctl(mib, 2, &amp;page_size, &amp;len, NULL, 0);</span><br><span class="line">//    if (status &lt; 0) &#123;</span><br><span class="line">//        perror(&quot;Failed to get page size&quot;);</span><br><span class="line">//    &#125;</span><br><span class="line">//    // 方法二: 16384</span><br><span class="line">//    page_size = getpagesize();</span><br><span class="line">    // 方法三: 4096</span><br><span class="line">    if( host_page_size(mach_host_self(), &amp;page_size)!= KERN_SUCCESS )&#123;</span><br><span class="line">        perror(&quot;Failed to get page size&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Page size is %d bytes\n&quot;, page_size);</span><br><span class="line">    </span><br><span class="line">    // Get Memory Size</span><br><span class="line">    mib[0] = CTL_HW;</span><br><span class="line">    mib[1] = HW_MEMSIZE;</span><br><span class="line">    long ram;</span><br><span class="line">    len = sizeof(ram);</span><br><span class="line">    if (sysctl(mib, 2, &amp;ram, &amp;len, NULL, 0)) &#123;</span><br><span class="line">        perror(&quot;Failed to get ram size&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Ram size is %f MB\n&quot;, ram / (1024.0) / (1024.0));</span><br><span class="line">    </span><br><span class="line">    // Get Memory Statistics</span><br><span class="line">//    vm_statistics_data_t vm_stats;</span><br><span class="line">//    mach_msg_type_number_t info_count = HOST_VM_INFO_COUNT;</span><br><span class="line">    vm_statistics64_data_t vm_stats;</span><br><span class="line">    mach_msg_type_number_t info_count64 = HOST_VM_INFO64_COUNT;</span><br><span class="line">//    kern_return_t kern_return = host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vm_stats, &amp;info_count);</span><br><span class="line">    kern_return_t kern_return = host_statistics64(mach_host_self(), HOST_VM_INFO64, (host_info64_t)&amp;vm_stats, &amp;info_count64);</span><br><span class="line">    if (kern_return != KERN_SUCCESS) &#123;</span><br><span class="line">        printf(&quot;Failed to get VM statistics!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    double vm_total = vm_stats.wire_count + vm_stats.active_count + vm_stats.inactive_count + vm_stats.free_count;</span><br><span class="line">    double vm_wire = vm_stats.wire_count;</span><br><span class="line">    double vm_active = vm_stats.active_count;</span><br><span class="line">    double vm_inactive = vm_stats.inactive_count;</span><br><span class="line">    double vm_free = vm_stats.free_count;</span><br><span class="line">    double unit = (1024.0) * (1024.0);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;Total Memory: %f&quot;, vm_total * page_size / unit);</span><br><span class="line">    NSLog(@&quot;Wired Memory: %f&quot;, vm_wire * page_size / unit);</span><br><span class="line">    NSLog(@&quot;Active Memory: %f&quot;, vm_active * page_size / unit);</span><br><span class="line">    NSLog(@&quot;Inactive Memory: %f&quot;, vm_inactive * page_size / unit);</span><br><span class="line">    NSLog(@&quot;Free Memory: %f&quot;, vm_free * page_size / unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>1、关于Ram大小，用HW_MEMSIZE计算得到1000MB，是准确的</p>
<p>2、关于page size，上面提供了三种方法</p>
<p>其中方法一、二在64位机器上返回了16384，只有第三种方法返回了4096</p>
<p><a href="http://stackoverflow.com/questions/21552747/strange-behavior-on-64bit-ios-devices-when-retrieving-vm-statistics/33574804#33574804" target="_blank" rel="noopener">http://stackoverflow.com/questions/21552747/strange-behavior-on-64bit-ios-devices-when-retrieving-vm-statistics/33574804#33574804</a></p>
<p>这篇文章提出了此疑问，但是没有特别明确的解释</p>
<p>我认为page size应该是4096，用VM Tracker运行，截图如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/724646/201511/724646-20151122204832108-1884248755.png" alt="img"> </p>
<p>以第一项_LINKEDIT为例，13692*4096/1024/1024=53.48M，与Vitual Size吻合</p>
<p>3、关于vm_total、vm_wire、vm_active、vm_inactive、vm_free这几个值</p>
<p>其中一组运行结果如下：</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Page size is 4096 bytes</span><br><span class="line">Ram size is 1000.000000 MB</span><br><span class="line">2015-11-22 20:59:41.191 CompSDKDemo[1602:410503] Total Memory: 777.519531</span><br><span class="line">2015-11-22 20:59:41.191 CompSDKDemo[1602:410503] Wired Memory: 205.484375</span><br><span class="line">2015-11-22 20:59:41.192 CompSDKDemo[1602:410503] Active Memory: 374.941406</span><br><span class="line">2015-11-22 20:59:41.192 CompSDKDemo[1602:410503] Inactive Memory: 175.710938</span><br><span class="line">2015-11-22 20:59:41.192 CompSDKDemo[1602:410503] Free Memory: 21.382812</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>可以看到，Total Memory不是1000MB，这个如何解释呢？</p>
<p>a. 1000M应该是实际的RAM大小，而Total Memory，应该是Virtual Memory，两者是否一回事，有待商榷？</p>
<p>b. 从APP Store上下了一个System Monitor，如下：</p>
<p>可以看到，Wired、Active、Inactive的值都对得上，唯独Free的值对不上</p>
<p>不负责任的猜测，他的Free是通过1000M减其它三项得到的</p>
<p><img src="https://images2015.cnblogs.com/blog/724646/201511/724646-20151122210021530-1090895791.png" alt="img"></p>
<p>Source Code : Get Hardware Info of iPhone</p>
<p><a href="http://blog.sina.com.cn/s/blog_4a04a3c90100r9gn.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4a04a3c90100r9gn.html</a></p>
<p><a href="http://stackoverflow.com/questions/63166/how-to-determine-cpu-and-memory-consumption-from-inside-a-process" target="_blank" rel="noopener">How to determine CPU and memory consumption from inside a process? </a></p>
<p><a href="http://stackoverflow.com/questions/63166/how-to-determine-cpu-and-memory-consumption-from-inside-a-process" target="_blank" rel="noopener">http://stackoverflow.com/questions/63166/how-to-determine-cpu-and-memory-consumption-from-inside-a-process</a></p>
<p>总结下来，关于内存的有两个问题：</p>
<p>\1. active、inactive、wired、free加起来不等于1000M</p>
<p>　　这个可以先放一放，我们可以先不用管这部分</p>
<p>\2. 当前app消耗的内存，目前的算法与 Debug Gauges的值有偏差，与GT吻合</p>
<p>　　不过发现点击页面增长的值和发回释放的值，与Debug Gauges基本一致，因此可以使用</p>
<p>关于CPU，上面算法给出的值符合要求，可以使用；</p>
<p>接下来是：耗电量、网速、帧率</p>
<p>2015.11.23</p>
<p>耗电量，目前没有找到合适的工具</p>
<p>有两种获取电池电量信息的方法</p>
<p>方法一：</p>
<p>这个方法需要导入 IOKit 库，但是不知从什么时候开始，iOS系统不允许用户导入库</p>
<p><a href="http://www.cocoachina.com/bbs/read.php?tid=268692" target="_blank" rel="noopener">http://www.cocoachina.com/bbs/read.php?tid=268692</a></p>
<p>这篇文章提供了野路子方法，但是实施起来颇为不便，考虑到要做sdk，不适合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFTypeRef blob = IOPSCopyPowerSourcesInfo();</span><br><span class="line">CFArrayRef sources = IOPSCopyPowerSourcesList(blob);</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIDevice currentDevice].batteryLevel</span><br></pre></td></tr></table></figure>
<p>据说精度达到1%</p>
<p>找到一篇文章，提供了三种方法</p>
<p><a href="http://www.jianshu.com/p/11c1afdf5415" target="_blank" rel="noopener">iOS开发之runtime精准获取电池电量</a></p>
<p><a href="http://www.jianshu.com/p/11c1afdf5415" target="_blank" rel="noopener">http://www.jianshu.com/p/11c1afdf5415</a></p>
<p>网络流量</p>
<p><a href="https://github.com/QbsuranAlang/GetNetworkFlow/blob/master/GetNetworkFlow/GetNetworkFlow/ViewController.m" target="_blank" rel="noopener">https://github.com/QbsuranAlang/GetNetworkFlow/blob/master/GetNetworkFlow/GetNetworkFlow/ViewController.m</a></p>
<p>2015.11.24</p>
<p>经测试，mach方法获取的内存值与top命令拿到的RSS、VSS是一致的</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> CPU </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift 4新知：KVC和KVO新姿势]]></title>
      <url>/2018/07/27/Swift%204%E6%96%B0%E7%9F%A5%EF%BC%9AKVC%E5%92%8CKVO%E6%96%B0%E5%A7%BF%E5%8A%BF/</url>
      <content type="html"><![CDATA[<p>随着 keypath 得到增强，KVC 和 KVO 的 API 都有了一些进化。</p>
<h1 id="struct-也支持-KVC"><a href="#struct-也支持-KVC" class="headerlink" title="struct 也支持 KVC"></a>struct 也支持 KVC</h1><p>一个感人的进步就是 struct 也支持 KVC 了。但是并不是使用原有的<code>setValue：forKeypath</code>的api。而是利用了swfit 4增加的一个语法特性：自定义索引可以有参数名。<br>直接上代码吧：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ValueType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="type">ValueType</span>(name: <span class="string">"zhuo"</span>)</span><br><span class="line"><span class="keyword">let</span> name = \<span class="type">ValueType</span>.name</span><br><span class="line"></span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">object[keyPath: name] = <span class="string">"swift4"</span></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="keyword">let</span> valueOfName = object[keyPath:name]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>通过索引可以方便的进行KVC。</p>
<h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><p>遗憾的是依然只有 NSObject 才能支持 KVO。</p>
<p>Swift 4中的一个对此有影响的改变是继承 NSObject 的 swift class 不再默认全部 bridge 到 OC。原因可以参考我的前一篇博客：<a href="https://www.jianshu.com/p/6c5b45d9d042" target="_blank" rel="noopener">Swift 4新知：自动清除冗余代码减小包大小</a>。然而 KVO 又是一个纯 OC 的特性，所以如果是 swift class 需要在声明的时候增加 <code>@objcMembers</code> 关键字。否则在运行的时候你会得到一个 error：</p>
<blockquote>
<p>fatal error: Could not extract a String from KeyPath Swift.ReferenceWritableKeyPath<ios11.xxx, swift.string=""></ios11.xxx,></p>
</blockquote>
<p>另外一件事就是被观察的属性<strong>需要用dynamic修饰</strong>，否则也无法观察到。</p>
<p>一个好消息是不需要在对象被回收时手动 remove observer。但是这也带来了另外一个容易被忽略的事情：观察的闭包没有被强引用，需要我们自己添加引用，否则当前函数离开后这个观察闭包就会被回收了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span>Members <span class="class"><span class="keyword">class</span> <span class="title">OCClass</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> swiftClass: <span class="type">OCClass</span>!</span><br><span class="line">    <span class="keyword">var</span> ob: <span class="type">NSKeyValueObservation</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        swiftClass = <span class="type">OCClass</span>(name: <span class="string">"oc"</span>)</span><br><span class="line">        ob = swiftClass.observe(\.name) &#123; (ob, changed) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> new = ob.name</span><br><span class="line">            <span class="built_in">print</span>(new)</span><br><span class="line">        &#125;</span><br><span class="line">        swiftClass.name = <span class="string">"swift4"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>KVO 之后返回的是一个 <code>NSKeyValueObservation</code> 实例，需要自己控制这个实例的生命周期。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> KVC </tag>
            
            <tag> KVO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[升级Swift4.0遇到的坑]]></title>
      <url>/2018/07/25/%E5%8D%87%E7%BA%A7Swift4.0%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>转<a href="https://blog.csdn.net/ShmilyCoder/article/details/77948797" target="_blank" rel="noopener">https://blog.csdn.net/ShmilyCoder/article/details/77948797</a></p>
<h1 id="升级Swift4-0"><a href="#升级Swift4-0" class="headerlink" title="升级Swift4.0"></a>升级Swift4.0</h1><ul>
<li>并不是所有库都能做到及时支持Swift4.0，更何况是在现在连Xcode9也还是beta的状态</li>
<li>所以我们仅能做到将自己的业务代码（主工程代码）部分升级到Swift4.0，然后同时保留各种pod库在Swift3.2版本。</li>
<li>没办法，谁叫Swift4.0也还无法做到API兼容呢（但愿能在Swift5之前实现吧）。</li>
<li>至于我说的同时使用两个版本的Swift，这是没问题的，Xcode9支持在项目中同时使用Swift3.2和Swift4.0。</li>
</ul>
<h2 id="一-修改Swift版本"><a href="#一-修改Swift版本" class="headerlink" title="一. 修改Swift版本"></a>一. 修改Swift版本</h2><h4 id="1-如下图指定主工程的Swift版本为4-0"><a href="#1-如下图指定主工程的Swift版本为4-0" class="headerlink" title="1. 如下图指定主工程的Swift版本为4.0"></a>1. 如下图指定主工程的Swift版本为4.0</h4><p>Xcode图示.png</p>
<h4 id="2-修改pod库"><a href="#2-修改pod库" class="headerlink" title="2. 修改pod库"></a>2. 修改pod库</h4><ul>
<li>在Podfile文件的最下方加入如下代码，指定pod库的Swift版本为3.2(这样会使得所有的第三方pod库的Swift版本都为3.2)</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> |installer|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  installer.pods_project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      config.build_settings['<span class="type">SWIFT_VERSION'</span>] = '<span class="number">3.2</span>'</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    end </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end12345678</span><br></pre></td></tr></table></figure>
<h2 id="二-主工程中的代码修改"><a href="#二-主工程中的代码修改" class="headerlink" title="二. 主工程中的代码修改"></a>二. 主工程中的代码修改</h2><h3 id="1-列举一下Swift3-2到Swift4-0的改变-只是我项目中遇到的-："><a href="#1-列举一下Swift3-2到Swift4-0的改变-只是我项目中遇到的-：" class="headerlink" title="1. 列举一下Swift3.2到Swift4.0的改变(只是我项目中遇到的)："></a>1. 列举一下Swift3.2到Swift4.0的改变(只是我项目中遇到的)：</h3><ul>
<li>1). Swift4.0中对于扩展的属性(包括实例属性、static属性、class属性)，都只能使用get方法，不可使用set方法</li>
<li>2). Swift4.0中不再允许复写扩展中的方法(包括实例方法、static方法、class方法)<ul>
<li>比如:自定义的协议方法在extension中实现,若某个类遵循了该协议,其子类便不能重写该协议方法</li>
<li>解决的方法是: 在每个需要该协议的类里面都重新遵循该协议,实现协议方法</li>
<li>个人想到的办法,不知道有没有其他解决办法可以提供一下</li>
</ul>
</li>
<li>3). swift3使用#selector指定的方法，只有当方法权限为private时需要加@objc修饰符，现在Swift4.0全都要加@objc修饰符</li>
<li>4). 自定义的protocol协议中,有optional修饰的非必须实现的方法,需要用@objc修饰</li>
<li>5). 字体方面的一些重命名</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSFontAttributeName</span> --- .font </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者NSAttributedStringKey.font</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">NSForegroundColorAttributeName</span> --- .foregroundColor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//NSAttributedStringKey.foregroundColor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">NSStrikethroughStyleAttributeName</span> --- .strikethroughStyle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//NSAttributedStringKey.strikethroughStyle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串类型的,添加rawValue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">NSAttributedStringKey</span>.font.rawValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//等等等等..........</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//大部分类似以下,涉及富文本的方法均已改为了NSAttributedStringKey类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addAttributes(<span class="number">_</span> attrs: [<span class="type">NSAttributedStringKey</span> : <span class="type">Any</span>] = [:], range: <span class="type">NSRange</span>)<span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>
<h2 id="三-项目中遇到的一些的报错问题"><a href="#三-项目中遇到的一些的报错问题" class="headerlink" title="三. 项目中遇到的一些的报错问题"></a>三. 项目中遇到的一些的报错问题</h2><h3 id="3-1-“Closure-cannot-implicitly-capture-a-mutating-self-parameter”错误"><a href="#3-1-“Closure-cannot-implicitly-capture-a-mutating-self-parameter”错误" class="headerlink" title="3-1. “Closure cannot implicitly capture a mutating self parameter”错误"></a>3-1. “Closure cannot implicitly capture a mutating self parameter”错误</h3><blockquote>
<p>在struct中，如果我们在闭包中使用self，就会得到Closure cannot implicitly capture a mutating self parameter的错误提示。比如：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RecordModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> action: (() -&gt; ())?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.action = &#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.height = <span class="number">20</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Closure cannot implicitly capture a mutating self parameter报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h5 id="并且由于RecordModel的类型是struct，我们也没发在action闭包里添加截获列表。那么是不是就必须使用class了？答案是否定的。有两种方式可以解决这个问题。"><a href="#并且由于RecordModel的类型是struct，我们也没发在action闭包里添加截获列表。那么是不是就必须使用class了？答案是否定的。有两种方式可以解决这个问题。" class="headerlink" title="++并且由于RecordModel的类型是struct，我们也没发在action闭包里添加截获列表。那么是不是就必须使用class了？答案是否定的。有两种方式可以解决这个问题。++"></a>++并且由于RecordModel的类型是struct，我们也没发在action闭包里添加截获列表。那么是不是就必须使用class了？答案是否定的。有两种方式可以解决这个问题。++</h5></blockquote>
<h4 id="方案一：为closure增加一个inout类型的参数"><a href="#方案一：为closure增加一个inout类型的参数" class="headerlink" title="方案一：为closure增加一个inout类型的参数"></a>方案一：为closure增加一个inout类型的参数</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RecordModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> action: ((<span class="number">_</span> inSelf: <span class="keyword">inout</span> <span class="type">RecordModel</span>) -&gt; ())?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.action = &#123; (inSelf) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        inSelf.height = <span class="number">20</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h5 id="根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure-闭包-中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。"><a href="#根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure-闭包-中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。" class="headerlink" title="根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure(闭包)中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。"></a><em>根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure(闭包)中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。</em></h5></blockquote>
<h4 id="方案二：使用UnsafeMutablePointer"><a href="#方案二：使用UnsafeMutablePointer" class="headerlink" title="方案二：使用UnsafeMutablePointer"></a>方案二：使用UnsafeMutablePointer<pointee></pointee></h4><ul>
<li><h5 id="这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。"><a href="#这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。" class="headerlink" title="==这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。=="></a>==这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。==</h5></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RecordModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 定义一个闭包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> action: (() -&gt; ())?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> selfPointer = <span class="type">UnsafeMutablePointer</span>(&amp;<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.action = &#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        selfPointer.pointee.height = <span class="number">20</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>==Closure cannot implicitly capture a mutating self parameter错误的原因是在进出closure(闭包)之后，self的一致性没办法得到保证，所以编译器默认不允许在struct的closure(闭包)中使用self。如果我们确定这么做是安全的，就可以通过上面的两种方式解决这个问题。其中，方法二的性能更好一些。==</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote>
<h4 id="这里可以记一下指针和swift变量之间的关系："><a href="#这里可以记一下指针和swift变量之间的关系：" class="headerlink" title="这里可以记一下指针和swift变量之间的关系："></a>这里可以记一下指针和swift变量之间的关系：</h4></blockquote>
<ul>
<li>UnsafePointer对应let</li>
<li>UnsafeMutablePointer对应var</li>
<li>AutoreleasingUnsafeMutablePointer对应unowned UnsafeMutablePointer，用于inout的参数类型</li>
<li>UnsafeRawPointer对应let Any，raw系列都是对应相应的Any类型</li>
<li>UnsafeBufferPointer是non-owning的类型（unowned），用于collection的elements, buffer系列均如此</li>
</ul>
<h3 id="3-2-Declarations-from-extensions-cannot-be-overridden-yet-错误"><a href="#3-2-Declarations-from-extensions-cannot-be-overridden-yet-错误" class="headerlink" title="3-2. Declarations from extensions cannot be overridden yet 错误"></a>3-2. Declarations from extensions cannot be overridden yet 错误</h3><p>==这个错误大致是因为,协议方法是在extension里面的,不能被重写==</p>
<blockquote>
<p>解决办法:(仅供参考,如有更好的建议还望多多指教)</p>
</blockquote>
<ul>
<li>小编想到的解决办法就是在每一个需要此协议的类里面,重新遵循代理,实现该协议方法</li>
</ul>
<h3 id="3-3-“Method-‘initialize-’-defines-Objective-C-class-method-‘initialize’-which-is-not-permitted-by-Swift”"><a href="#3-3-“Method-‘initialize-’-defines-Objective-C-class-method-‘initialize’-which-is-not-permitted-by-Swift”" class="headerlink" title="3-3. “Method ‘initialize()’ defines Objective-C class method ‘initialize’, which is not permitted by Swift”"></a>3-3. “Method ‘initialize()’ defines Objective-C class method ‘initialize’, which is not permitted by Swift”</h3><p>==报错原因: 在于已经废弃的initialize方法,示例如下==</p>
<blockquote>
<ul>
<li>方法交叉(Method Swizzling)<ul>
<li>有时为了方便，也有可能是解决某些框架内的 bug，或者别无他法时，需要修改一个已经存在类的方法的行为。方法交叉可以让你交换两个方法的实现，相当于是用你写的方法来重载原有方法，并且还能够是原有方法的行为保持不变。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">initialize</span>() </span>&#123;<span class="comment">//此处报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处省略100行代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<ul>
<li>initialize该方法已经被Swift4.0废弃</li>
<li>在Swift3.0还勉强可以使用,但是会有警告;但是在4.0已经被完全废弃</li>
</ul>
<blockquote>
<p>==替代方法:==</p>
<ul>
<li><strong>在 app delegate 中实现方法交叉</strong></li>
<li>像上面通过类扩展进行方法交叉，而是简单地在 app delegate 的 application(_:didFinishLaunchingWithOptions:) 方法调用时调用该方法</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">initializeOnceMethod</span>() </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处省略100行代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在AppDelegate的方法中调用:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处省略100行代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">UIViewController</span>.initializeOnceMethod()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-‘dispatch-once’-is-unavailable-in-Swift-Use-lazily-initialized-globals-instead"><a href="#3-4-‘dispatch-once’-is-unavailable-in-Swift-Use-lazily-initialized-globals-instead" class="headerlink" title="3-4. ‘dispatch_once’ is unavailable in Swift: Use lazily initialized globals instead"></a>3-4. ‘dispatch_once’ is unavailable in Swift: Use lazily initialized globals instead</h3><blockquote>
<p>报错原因: dispatch_once在Swift4.0也已经被废弃</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">once</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> onceTaken:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    dispatch_once(&amp;once.onceTaken) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里dispatch_once就会报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处省略1000000行代码    </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="解决方法-通过给DispatchQueue添加扩展实现"><a href="#解决方法-通过给DispatchQueue添加扩展实现" class="headerlink" title="解决方法: 通过给DispatchQueue添加扩展实现"></a>解决方法: 通过给DispatchQueue添加扩展实现</h4></blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DispatchQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> _onceTracker = [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">once</span>(<span class="title">token</span>: <span class="title">String</span>, <span class="title">block</span>: () -&gt; ()) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        objc_sync_enter(<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            objc_sync_exit(<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _onceTracker.<span class="built_in">contains</span>(token) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        _onceTracker.append(token)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        block()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">async</span><span class="params">(block: @escaping <span class="params">()</span></span></span>-&gt;()) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.async(execute: block)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">after</span><span class="params">(time: DispatchTime, block: @escaping <span class="params">()</span></span></span>-&gt;()) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.asyncAfter(deadline: time, execute: block)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用字符串token作为once的ID，执行once的时候加了一个锁，避免多线程下的token判断不准确的问题。<br>使用的时候可以传token</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.once(token: <span class="string">"tableViewOnce"</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>( <span class="string">"Do This Once!"</span> )  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="number">1234</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者使用UUID也可以：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> _onceToken = <span class="type">NSUUID</span>().uuidString</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.once(token: _onceToken) &#123;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>( <span class="string">"Do This Once!"</span> )  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="number">123456</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>后续又遇到别的问题会继续更新</li>
<li>文章中如有解释不足之处,还望多多指教</li>
</ul>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> bug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 8： UIAlertController 默认样式颜色]]></title>
      <url>/2018/07/20/iOS8UIAlertController%20%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E9%A2%9C%E8%89%B2/</url>
      <content type="html"><![CDATA[<p>转： <a href="http://stackoverflow.com/questions/26448418/ios-8-uialertcontroller-default-style-color" target="_blank" rel="noopener">http://stackoverflow.com/questions/26448418/ios-8-uialertcontroller-default-style-color</a></p>
<p>注意事项: 本文中文内容可能为机器翻译,如要查看英文原文请点击上面连接.</p>
<p>我使用的默认样式 <code>UIAlertController</code> 和 <code>UIAlertAction</code> 但我相处如截图所示的白色背景的白色文本</p>
<p>这里是我的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil message:nil preferredStyle:UIAlertControllerStyleActionSheet];</span><br><span class="line">UIAlertAction* defaultAction = [UIAlertAction actionWithTitle:@&quot;0237826726&quot; style:UIAlertActionStyleDefault</span><br><span class="line">                                                              handler:^(UIAlertAction * action) &#123;</span><br><span class="line">                                                                    [self callPlaceNumber:@&quot;0237826726&quot;];</span><br><span class="line">                                                              &#125;];</span><br><span class="line">[alert addAction:defaultAction];</span><br><span class="line"></span><br><span class="line">UIAlertAction* cancel = [UIAlertAction actionWithTitle:@&quot;Cancel&quot; style:UIAlertActionStyleDefault</span><br><span class="line">                                                   handler:^(UIAlertAction * action) &#123;</span><br><span class="line">                                                       [alert dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">                                                   &#125;];</span><br><span class="line"></span><br><span class="line">[alert addAction:cancel];</span><br><span class="line">[self presentViewController:alert animated:YES completion:nil];</span><br></pre></td></tr></table></figure>
<p>我寻找着这个问题，我发现我可以添加 <code>tintColor</code> 的 <code>UIAlertController</code> 作为跟随，但它不工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert.view.tintColor = [UIColor blackColor];</span><br></pre></td></tr></table></figure>
<p>这是一种正常的行为还是在我的代码有何不妥吗？</p>
<p><img src="http://i.stack.imgur.com/bfoyV.png" alt="enter image description here"></p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法 1:"></a>解决方法 1:</h4><p>设置为 UIAlertController 的色调颜色可以通过 API 的外观：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[UIView appearanceWhenContainedIn:[UIAlertController class], nil] setTintColor:[UIColor blackColor]];</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> UIAlertController </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift - 与外设连接时的字符处理（普通字符串-十六进制互转）]]></title>
      <url>/2018/07/10/Swift%20-%20%E4%B8%8E%E5%A4%96%E8%AE%BE%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%EF%BC%88%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%BA%92%E8%BD%AC%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>tips：与外部设备通信难免会遇到字符间互转的问题，普通字符串-十六进制互转是很多app与设备连接时会采用的方案，在网上看到oc版的，于是有了下面的的swift版，亲测可用，不足之处希望能留言告知，谢谢</p>
<p> /// 十六进制转换为普通字符串的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringfromHexStr</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> bytes = [<span class="type">UInt8</span>]()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> dataBStr : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (index, <span class="number">_</span>) <span class="keyword">in</span> <span class="keyword">self</span>.enumerated()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> fromIndex = index*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> toIndex = index*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> toIndex &gt; (<span class="keyword">self</span>.<span class="built_in">count</span> - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> hexCharStr = <span class="keyword">self</span>.subString(fromIndex, length: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> r:<span class="type">CUnsignedInt</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span>(string: hexCharStr).scanHexInt32(&amp;r)</span><br><span class="line"></span><br><span class="line">            bytes.append(<span class="type">UInt8</span>(r))</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dataBStr = <span class="type">String</span>.<span class="keyword">init</span>(data: <span class="type">Data</span>(bytes: bytes), encoding: <span class="type">String</span>.<span class="type">Encoding</span>.ascii)!</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataBStr</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    ///普通字符串转换为十六进制的。</p>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func stringToHexString() -&gt; String &#123;</span><br><span class="line"></span><br><span class="line">        let strData = self.data(using: String.Encoding.utf8)</span><br><span class="line"></span><br><span class="line">        let bytes = strData?.withUnsafeBytes &#123;</span><br><span class="line"></span><br><span class="line">            [UInt8](UnsafeBufferPointer(start: $0, count: (strData?.count)!))</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var sumString : String = &quot;&quot;</span><br><span class="line"></span><br><span class="line">        for byte in bytes! &#123;</span><br><span class="line"></span><br><span class="line">            let newString = String(format: &quot;%x&quot;,byte&amp;0xff)</span><br><span class="line"></span><br><span class="line">            if newString.count == 1 &#123;</span><br><span class="line"></span><br><span class="line">                sumString = String(format: &quot;%@0%@&quot;,sumString,newString)</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line"></span><br><span class="line">                sumString = String(format: &quot;%@%@&quot;,sumString,newString)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        return sumString</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>补充oc的对照版</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">///普通字符串转换为十六进制的。</span><br><span class="line"></span><br><span class="line">\+ (NSString *)hexStringFromString:(NSString *)string&#123;</span><br><span class="line"></span><br><span class="line">    NSData *myD = [string dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    Byte *bytes = (Byte *)[myD bytes];</span><br><span class="line"></span><br><span class="line">    //下面是Byte 转换为16进制。</span><br><span class="line"></span><br><span class="line">    NSString *hexStr=@&quot;&quot;;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;[myD length];i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        NSString *newHexStr = [NSString stringWithFormat:@&quot;%x&quot;,bytes[i]&amp;0xff];///16进制数</span><br><span class="line"></span><br><span class="line">        if([newHexStr length]==1)</span><br><span class="line"></span><br><span class="line">            hexStr = [NSString stringWithFormat:@&quot;%@0%@&quot;,hexStr,newHexStr];</span><br><span class="line"></span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line">            hexStr = [NSString stringWithFormat:@&quot;%@%@&quot;,hexStr,newHexStr];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [NSString stringWithFormat:@&quot;%@0d0a&quot;,hexStr];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 十六进制转换为普通字符串的。</span><br><span class="line"></span><br><span class="line">\+ (NSString *)stringFromHexString:(NSString *)hexString &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    char *myBuffer = (char *)malloc((int)[hexString length] / 2 + 1);</span><br><span class="line"></span><br><span class="line">    bzero(myBuffer, [hexString length] / 2 + 1);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; [hexString length] - 1; i += 2) &#123;</span><br><span class="line"></span><br><span class="line">        unsigned int anInt;</span><br><span class="line"></span><br><span class="line">        NSString * hexCharStr = [hexString substringWithRange:NSMakeRange(i, 2)];</span><br><span class="line"></span><br><span class="line">        NSScanner * scanner = [[NSScanner alloc] initWithString:hexCharStr];</span><br><span class="line"></span><br><span class="line">        [scanner scanHexInt:&amp;anInt];</span><br><span class="line"></span><br><span class="line">        myBuffer[i / 2] = (char)anInt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString *unicodeString = [NSString stringWithCString:myBuffer encoding:4];</span><br><span class="line"></span><br><span class="line">//    NSLog(@&quot;------字符串=======%@&quot;,unicodeString);</span><br><span class="line"></span><br><span class="line">    return unicodeString;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Data </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift - 将Data数据转换为[UInt8]（bytes字节数组）]]></title>
      <url>/2018/07/10/Swift%20-%20%E5%B0%86Data%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E4%B8%BA%5BUInt8%5D%EF%BC%88bytes%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>假设我们有如下 Data 数据要转换：</p>
<h3 id="方法一：使用-UInt8-新的构造函数"><a href="#方法一：使用-UInt8-新的构造函数" class="headerlink" title="方法一：使用 [UInt8] 新的构造函数"></a>方法一：使用 [UInt8] 新的构造函数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> bytes = [<span class="type">UInt8</span>](data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bytes)</span><br></pre></td></tr></table></figure>
<p>方法二：通过 Pointer 指针获取</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bytes = data.withUnsafeBytes &#123;</span><br><span class="line"></span><br><span class="line">[<span class="type">UInt8</span>](<span class="type">UnsafeBufferPointer</span>(start: $<span class="number">0</span>, <span class="built_in">count</span>: data.<span class="built_in">count</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(bytes)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Data </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[终极 Shell]]></title>
      <url>/2018/07/10/%E7%BB%88%E6%9E%81%20Shell/</url>
      <content type="html"><![CDATA[<p># </p>
<p><a href="http://macshuo.com/wp-content/uploads/2013/07/zsh1.png" target="_blank" rel="noopener"><img src="http://macshuo.com/wp-content/uploads/2013/07/zsh1.png" alt="zsh"></a></p>
<p>在开始今天的 MacTalk 之前，先问两个问题吧：</p>
<p>1、相对于其他系统，Mac 的主要优势是什么？<br>2、你们平时用哪种 Shell？<br>……<br><a id="more"></a><br>第一个童靴可以坐下了，Mac 的最大优势是 GUI 和命令行的完美结合，不要把所有注意力放在 Mac 性感的腰身和明媚的显示屏上好吧，这不是妹纸！第二个童靴你可以出去面壁了，讲了这么多期 MacTalk 你告诉我还在用 Windows 的 cmd， 你让 Mac 君情何以堪？哪怕你就说在用 Linux 的 Bash 我也就原谅你了，踢飞！</p>
<p>上次在「如何学习一门编程语言」里提到了 Shell，也有读者问到 Shell 的问题，所以这次给大家说说 Shell 的事。</p>
<p>我在「趣谈个人建站」里介绍过一点 Shell，自己的东西借用下不丢人，把扯淡的拿掉，干货留下，就是如下内容：</p>
<p>Shell是Linux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。</p>
<p>Linux/Unix提供了很多种Shell，为毛要这么多Shell？难道用来炒着吃么？那我问你，你同类型的衣服怎么有那么多件？花色，质地还不一样。写程序比买衣服复杂多了，而且程序员往往负责把复杂的事情搞简单，简单的事情搞复杂。牛程序员看到不爽的Shell，就会自己重新写一套，慢慢形成了一些标准，常用的Shell有这么几种，sh、bash、csh等，想知道你的系统有几种shell，可以通过以下命令查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>
<p>显示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure>
<p>在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，这是个神马 Shell 呢？</p>
<p>目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：<a href="https://github.com/robbyrussell/oh-my-zsh。这玩意就像「X天叫你学会" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh。这玩意就像「X天叫你学会</a> C++」系列，可以让你神功速成，而且是真的。</p>
<p>好，下面我们看看如何安装、配置和使用 zsh。</p>
<h1 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h1><hr>
<p>如果你用 Mac，就可以直接看下一节<br>如果你用 Redhat Linux，执行：sudo yum install zsh<br>如果你用 Ubuntu Linux，执行：sudo apt-get install zsh<br>如果你用 Windows……去洗洗睡吧。</p>
<p>安装完成后设置当前用户使用 zsh：<code>chsh -s /bin/zsh</code>，根据提示输入当前用户的密码就可以了。</p>
<h1 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh my zsh"></a>安装oh my zsh</h1><hr>
<p>首先安装 git，安装方式同上，把 zsh 换成 git 即可。</p>
<p>安装「oh my zsh」可以自动安装也可以手动安装。</p>
<p>自动安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure>
<p>手动安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>都不复杂，安装完成之后退出当前会话重新打开一个终端窗口，你就可以见到这个彩色的提示了：</p>
<p><a href="http://macshuo.com/wp-content/uploads/2013/07/zsh11.png" target="_blank" rel="noopener"><img src="http://macshuo.com/wp-content/uploads/2013/07/zsh11.png" alt="zsh1"></a></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><hr>
<p>zsh 的配置主要集中在用户当前目录的.zshrc里，用 vim 或你喜欢的其他编辑器打开.zshrc，在最下面会发现这么一行字：</p>
<p><code># Customize to your needs…</code></p>
<p>可以在此处定义自己的环境变量和别名，当然，oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。</p>
<p>接下来进行别名的设置，我自己的部分配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">alias cls=&apos;clear&apos;</span><br><span class="line">alias ll=&apos;ls -l&apos;</span><br><span class="line">alias la=&apos;ls -a&apos;</span><br><span class="line">alias vi=&apos;vim&apos;</span><br><span class="line">alias javac=&quot;javac -J-Dfile.encoding=utf8&quot;</span><br><span class="line">alias grep=&quot;grep --color=auto&quot;</span><br><span class="line">alias -s html=mate   # 在命令行直接输入后缀为 html 的文件名，会在 TextMate 中打开</span><br><span class="line">alias -s rb=mate     # 在命令行直接输入 ruby 文件，会在 TextMate 中打开</span><br><span class="line">alias -s py=vi       # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似</span><br><span class="line">alias -s js=vi</span><br><span class="line">alias -s c=vi</span><br><span class="line">alias -s java=vi</span><br><span class="line">alias -s txt=vi</span><br><span class="line">alias -s gz=&apos;tar -xzvf&apos;</span><br><span class="line">alias -s tgz=&apos;tar -xzvf&apos;</span><br><span class="line">alias -s zip=&apos;unzip&apos;</span><br><span class="line">alias -s bz2=&apos;tar -xjvf&apos;</span><br></pre></td></tr></table></figure>
<p>zsh 的牛粪之处在于不仅可以设置通用别名，还能针对文件类型设置对应的打开程序，比如：</p>
<p><code>alias -s html=mate</code>，意思就是你在命令行输入 hello.html，zsh会为你自动打开 TextMat 并读取 hello.html； <code>alias -s gz=&#39;tar -xzvf&#39;</code>，表示自动解压后缀为 gz 的压缩包。</p>
<p>总之，只有想不到，木有做不到，吓尿了吧。</p>
<p>设置完环境变量和别名之后，基本上就可以用了，如果你是个主题控，还可以玩玩 zsh 的主题。在 .zshrc 里找到ZSH_THEME，就可以设置主题了，默认主题是：</p>
<p>ZSH_THEME=”robbyrussell”</p>
<p>oh my zsh 提供了数十种主题，相关文件在~/.oh-my-zsh/themes目录下，你可以随意选择，也可以编辑主题满足自己的变态需求，我采用了默认主题robbyrussell，不过做了一点小小的改动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROMPT=&apos;%&#123;$fg_bold[red]%&#125;➜ %&#123;$fg_bold[green]%&#125;%p%&#123;$fg[cyan]%&#125;%d %&#123;$fg_bold[blue]%&#125;$(git_prompt_info)%&#123;$fg_bold[blue]%&#125;% %&#123;$reset_color%&#125;&gt;&apos;</span><br><span class="line">#PROMPT=&apos;%&#123;$fg_bold[red]%&#125;➜ %&#123;$fg_bold[green]%&#125;%p %&#123;$fg[cyan]%&#125;%c %&#123;$fg_bold[blue]%&#125;$(git_prompt_info)%&#123;$fg_bold[blue]%&#125; % %&#123;$reset_color%&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>对照原来的版本，我把 c 改为 d，c 表示当前目录，d 表示绝对路径，另外在末尾增加了一个「 &gt; 」，改完之后的效果是这样的：</p>
<p><a href="http://macshuo.com/wp-content/uploads/2013/07/zsh2.png" target="_blank" rel="noopener"><img src="http://macshuo.com/wp-content/uploads/2013/07/zsh2.png" alt="zsh2"></a></p>
<p>大家可以尝试进行改造，也算个趣事。</p>
<p>最后我们来说说插件。</p>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><hr>
<p>oh my zsh 项目提供了完善的插件体系，相关的文件在~/.oh-my-zsh/plugins目录下，默认提供了100多种，大家可以根据自己的实际学习和工作环境采用，想了解每个插件的功能，只要打开相关目录下的 zsh 文件看一下就知道了。插件也是在.zshrc里配置，找到plugins关键字，你就可以加载自己的插件了，系统默认加载 git ，你可以在后面追加内容，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=(git textmate ruby autojump osx mvn gradle)</span><br></pre></td></tr></table></figure>
<p>下面简单介绍几个：</p>
<p>1、git：当你处于一个 git 受控的目录下时，Shell 会明确显示 「git」和 branch，如上图所示，另外对 git 很多命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考<code>~/.oh-my-zsh/plugins/git/git.plugin.zsh</code></p>
<p>2、textmate：mr可以创建 ruby 的框架项目，tm finename 可以用 textmate 打开指定文件。</p>
<p>3、osx：tab 增强，quick-look filename 可以直接预览文件，man-preview grep 可以生成 grep手册 的pdf 版本等。</p>
<p>4、autojump：zsh 和 autojump 的组合形成了 zsh 下最强悍的插件，今天我们主要说说这货。</p>
<p>首先安装autojump，如果你用 Mac，可以使用 brew 安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install autojump</span><br></pre></td></tr></table></figure>
<p>如果是 Linux，去下载 autojump 的最新版本，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/joelthelion/autojump.git</span><br></pre></td></tr></table></figure>
<p>解压缩后进入目录，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.py</span><br></pre></td></tr></table></figure>
<p>最后把以下代码加入.zshrc：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh</span><br></pre></td></tr></table></figure>
<p>至此，安装、配置、插件三位一体，终极 Shell 全面登场。退出终端会话重新登录，开始感受 zsh 的训疾如风！</p>
<h1 id="使用-zsh"><a href="#使用-zsh" class="headerlink" title="使用 zsh"></a>使用 zsh</h1><hr>
<p>1、兼容 bash，原来使用 bash 的兄弟切换过来毫无压力，该咋用咋用。</p>
<p>2、强大的历史纪录功能，输入 grep 然后用上下箭头可以翻阅你执行的所有 grep 命令。</p>
<p>3、智能拼写纠正，输入gtep mactalk * -R，系统会提示：zsh: correct ‘gtep’ to ‘grep’ [nyae]? 比妹纸贴心吧，她们向来都是让你猜的……</p>
<p>4、各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n/p/f/b上下左右切换。比如你想杀掉 java 的进程，只需要输入 kill java + tab键，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全</p>
<p>5、智能跳转，安装了autojump之后，zsh 会自动记录你访问过的目录，通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过hadoop-1.0.0目录，输入j hado 即可正确跳转。j –stat 可以看你的历史路径库。</p>
<p>6、目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</p>
<p>7、在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。</p>
<p>8、通配符搜索：ls -l <em>*/</em>.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find，文件太多就歇菜了。</p>
<p>9、更强的别名：请参考配置一节。</p>
<p>10、插件支持：请参考插件一节。</p>
<p>……</p>
<p>看完这篇文章，你就知道，zsh一出，无人再与争锋！终极二字不是盖的。</p>
<p>如果你是个正在使用 shell程序员，如果你依然准备使用 bash，那就去面壁和忏悔吧，别说你订阅过 MacTalk！</p>
<p>感谢那位开发了 oh my zsh 的无聊程序员，他可能没有因此收获物质上的利益，但是他的代码提升了无数程序员的效率，节省了大量的时间，我们说，程序员改变世界！</p>
<p>MacTalk 写的多了，朋友和家人都不太理解，这玩意赚不了钱争不了名，写来何用？我想，能够学习、编码、写作，并做出一点帮助别人的东西，总好过炒股炒房的价值吧，尽管人家比咱「富」多了……</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为iOS发行版构建增量技术]]></title>
      <url>/2018/07/02/%E4%B8%BAiOS%E5%8F%91%E8%A1%8C%E7%89%88%E6%9E%84%E5%BB%BA%E5%A2%9E%E9%87%8F%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p># </p>
<p><strong> <a href="http://shashikantjagtap.net/build-incrementation-techniques-for-ios-release-train/" target="_blank" rel="noopener">2018年5月9日</a> </strong> <a href="http://shashikantjagtap.net/author/shashikant86/" target="_blank" rel="noopener">Shashikant Jagtap</a></p>
<p>持续交付iOS应用程序对于在竞争激烈的市场中保持相关性至关重要。拥有基础设施的公司一旦开发就能够向客户发布功能，赢得了公司的竞争，从本地Xcode的某些人手动发布。在持续交付模式中，我们应该不断将iOS版本上传到iTunes Connect或TestFlight，以获得发布中涉及的所有技术和非技术人员的反馈。只要我们有适当的构建和版本化过程，将构建上传到iTunes Connects并没有什么坏处。在这篇文章中，我们将看到什么是在Continuous Delivery管道中自动增加构建号的最佳技术。<br><a id="more"></a></p>
<h1 id="释放火车"><a href="#释放火车" class="headerlink" title="释放火车"></a>释放火车</h1><p>在我们进入iOS应用程序的自动内部版本号之前，我们将看到版本号，内部版本号和版本列表在向iOS应用程序商店提交iOS应用程序时是如何工作的。Apple对 每个iOS开发人员都应该了解的<a href="https://developer.apple.com/library/content/technotes/tn2420/_index.html" target="_blank" rel="noopener">版本号和内部版本号</a>有很好的文档。版本号和内部版本号的组合唯一标识应用的App Store提交。</p>
<ul>
<li>版本号</li>
</ul>
<p>iOS应用程序的版本号与先前版本的应用程序不同。我们需要为新的应用版本创建单独的版本号。它类似于使用语义版本化在Github上创建发行版。法律的版本号是 1.0  ，1.1.1等，但你不能结合字母和数字，像ABC 。123   这将是非法版本号。版本号不能重新使用，因此您必须事先决定主要和次要版本。新的版本号值必须大于以前使用的值，并且应该随后递增。可以在 带有密钥的iOS应用程序的Info .plist文件中 找到当前版本号的值 CFBundleShortVersionString   或在上传的iOS应用程序的情况下，我们可以检查iTunes Connect来找出版本号。我们可以使用Apple的 agvtool   命令行工具检查当前版本号</p>
<p>Shell</p>
<table>
<thead>
<tr>
<th>1</th>
<th>$ xcrun agvtool what-marketing-version</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>内部编号</li>
</ul>
<p>可以为特定版本号上载多个版本，但是，为特定版本号上载的版本号应该是唯一的并且按递增顺序。版本号的值可以重复用于不同的版本号。可以在  具有CFBundleVersion   密钥的iOS应用程序的Info .plist文件中 找到当前内部版本号的值 。我们可以使用Apple的agvtool   命令行工具检查当前版本号 </p>
<p>Shell</p>
<table>
<thead>
<tr>
<th>1</th>
<th>$ xcrun agvtool what-version</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>释放火车</li>
</ul>
<p>为特定版本提交的构建数量形成该特定版本的Release Train。在发行版中，内部版本号是增量顺序且唯一的。火车可以具有特定功能的多个版本，如果需要，我们可以将任何版本升级到App Store。简而言之，发布系列是持续交付的基础。</p>
<h1 id="在发行版中建立增量"><a href="#在发行版中建立增量" class="headerlink" title="在发行版中建立增量"></a>在发行版中建立增量</h1><p>在发布版本中增加版本号的策略很少。我们会看到他们中的每一个人，并讨论哪一个对发布火车来说很棒。</p>
<ul>
<li><h2 id="agvtool"><a href="#agvtool" class="headerlink" title="agvtool"></a>agvtool</h2></li>
</ul>
<p>Apple拥有原生命令行工具来处理版本和编号。我们可以启用 agvtool   并编写脚本以在特定发布版本中自动增加内部版本号。为了启用agvtool，我们需要确保我们已经 在目标构建设置中正确设置了  <strong>当前项目版本</strong> 和  <strong>版本控制系统</strong>属性。选择目标版本设置并搜索“版本控制”。现在，将<strong>当前项目版本</strong>设置  <strong>为1</strong>  ，并将<strong>版本控制系统值</strong>选择  <strong>为“Apple Generic”。 </strong>接下来要验证的是确保  <strong>Info</strong>  选项卡具有Bundle版本和Bundle版本字符串，对于新项目，短值可能设置为1。</p>
<p>我们可以使用以下命令将内部版本号增加到下一个内部版本号</p>
<p>Shell</p>
<table>
<thead>
<tr>
<th>1</th>
<th>$ xcrun agvtool next-version -all</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>当我们从CI服务器执行此操作时，它会更新Info.plist文件，一旦构建成功上载，我们需要将这些文件提交回源控件。这是该技术的缺点之一。我们必须经常从CI服务器更新源代码管理。</p>
<ul>
<li><h2 id="PlistBuddy"><a href="#PlistBuddy" class="headerlink" title="PlistBuddy"></a>PlistBuddy</h2></li>
</ul>
<p>我们可以使用PlistBuddy工具实现构建号的版本修改，该工具用于动态更新plist文件。我们可以轻松编写脚本。</p>
<p>Shell</p>
<table>
<thead>
<tr>
<th>123</th>
<th>buildNumber=$(/usr/libexec/PlistBuddy -c “Print CFBundleVersion” “$PRODUCT_SETTINGS_PATH”)buildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c “Set :CFBundleVersion $buildNumber” “$PRODUCT_SETTINGS_PATH”</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这会将内部版本号增加一个。同样，这会更新Info.plist文件，我们需要在成功上载构建后将其提交回源控件</p>
<ul>
<li><h2 id="Fastlane插件"><a href="#Fastlane插件" class="headerlink" title="Fastlane插件"></a>Fastlane插件</h2></li>
</ul>
<p>还有其他一些第三方工具，如  <a href="https://fastlane.tools/" target="_blank" rel="noopener">Fastlane</a>  ，也可以做同样的事情。Fastlane有增加版本号和版本号的动作。该  <a href="https://docs.fastlane.tools/actions/increment_version_number/" target="_blank" rel="noopener">increment_version_number</a>  动作可以用来增加它有各种选项，以及版本号。我们可以碰到主要版本或次要版本，我们也可以指定版本号。</p>
<p>Shell</p>
<table>
<thead>
<tr>
<th>123</th>
<th>increment_version_number(  bump_type: “major” )</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>该  <a href="https://docs.fastlane.tools/actions/increment_build_number/" target="_blank" rel="noopener">increment_build_number </a>动作可以用于更新版本号值。</p>
<p>Shell</p>
<table>
<thead>
<tr>
<th>123</th>
<th>increment_build_number(  build_number: “5” )</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>有很多选项来管理版本号和版本号，但是这些操作也使用了agvtool。在这种情况下，我们必须使用另一个Fastlane操作来<a href="https://docs.fastlane.tools/actions/commit_version_bump/#commit_version_bump" target="_blank" rel="noopener">提交版本缓冲，</a>以将新版本提交回来自CI服务器的源代码控制。</p>
<p>Ruby</p>
<table>
<thead>
<tr>
<th>1234</th>
<th>commit_version_bump(  message: “Version Bump”,  xcodeproj: “./path/to/MyProject.xcodeproj”, )</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>同样，这种方法需要与Github集成，并且持续集成服务器的源代码控制频繁更改。</p>
<ul>
<li><h2 id="脚本版本号"><a href="#脚本版本号" class="headerlink" title="脚本版本号"></a>脚本版本号</h2></li>
</ul>
<p>还有一种方法不需要从Continuous Integration服务器提交版本号。这种技术使用基于某些幻数的Scripted构建，并相应地增加构建编号。你可以<a href="https://tgoode.com/2014/06/05/sensible-way-increment-bundle-version-cfbundleversion-xcode/" target="_blank" rel="noopener">在这里</a>阅读更多关于这个技巧</p>
<p>这种技术非常有效，我们只需要添加另一个执行此脚本的Run Script构建阶段。</p>
<p>Shell</p>
<table>
<thead>
<tr>
<th>1234567891011121314</th>
<th>#!/bin/bash #  update_build_number.sh#  Usage: <code>update_build_number.sh [branch]</code>#  Run this script after the ‘Copy Bundle Resources’ build phase#  Ref: <a href="http://tgoode.com/2014/06/05/sensible-way-increment-bundle-version-cfbundleversion-xcode/" target="_blank" rel="noopener">http://tgoode.com/2014/06/05/sensible-way-increment-bundle-version-cfbundleversion-xcode/</a> branch=${1:-‘master’}buildNumber=$(expr $(git rev-list $branch –count) - $(git rev-list HEAD..$branch –count))echo “Updating build number to $buildNumber using branch ‘$branch’.”/usr/libexec/PlistBuddy -c “Set :CFBundleVersion $buildNumber” “${TARGET_BUILD_DIR}/${INFOPLIST_PATH}”if [ -f “${BUILT_PRODUCTS_DIR}/${WRAPPER_NAME}.dSYM/Contents/Info.plist” ]; then  /usr/libexec/PlistBuddy -c “Set :CFBundleVersion $buildNumber” “${BUILT_PRODUCTS_DIR}/${WRAPPER_NAME}.dSYM/Contents/Info.plist”fi</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>无论什么时候我们上传新版本，这都会给出新的版本号 使用这种方法的好处是我们不必从Continuous Integration服务器提交版本缓冲。</p>
<h1 id="使用哪种技术？"><a href="#使用哪种技术？" class="headerlink" title="使用哪种技术？"></a>使用哪种技术？</h1><p>截至目前，我们已经看到了四种不同的技术来增加iOS版本系列中的内部版本号。选择适合您iOS应用的技术有点棘手。这是因为它取决于在团队中工作的iOS开发人员的技能。如果脚本和管理得当，所有技巧都可以运行。但是，我更喜欢使用脚本化构建的最后一个，因为它不涉及从Continuous Integration服务器更改源代码控制存储库。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在iOS持续交付管道中，自动化版本和内部版本号可以节省大量时间，并且可以轻松地使用上述构建增量技术轻松组织版本系列。您使用哪种策略进行构建增量？如果我错过任何事情，请告诉我。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ios 硬解码h264视频的坑]]></title>
      <url>/2018/06/29/ios%20%E7%A1%AC%E8%A7%A3%E7%A0%81h264%E8%A7%86%E9%A2%91%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>//<br>//  WBH264Play.m<br>//  wenba_rtc<br>//<br>//  Created by zhouweiwei on 16/11/20.<br>//  Copyright © 2016年 zhouweiwei. All rights reserved.<br>//</p>
<p>#import <foundation foundation.h=""></foundation></p>
<p>#import “WBH264Play.h”</p>
<p>#define kH264outputWidth  160</p>
<p>#define kH264outputHeight 120<br><a id="more"></a><br>static const uint8_t <em>avc_find_startcode_internal(const uint8_t </em>p, const uint8_t <em>end)<br>{<br>​    const uint8_t </em>a = p + 4 - ((intptr_t)p &amp; 3);<br>​<br>​    for (end -= 3; p &lt; a &amp;&amp; p &lt; end; p++) {<br>​        if (p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 1)<br>​            return p;<br>​    }<br>​<br>​    for (end -= 3; p &lt; end; p += 4) {<br>​        uint32_t x = <em>(const uint32_t</em>)p;<br>​        //      if ((x - 0x01000100) &amp; (~x) &amp; 0x80008000) // little endian<br>​        //      if ((x - 0x00010001) &amp; (~x) &amp; 0x00800080) // big endian<br>​        if ((x - 0x01010101) &amp; (~x) &amp; 0x80808080) { // generic<br>​            if (p[1] == 0) {<br>​                if (p[0] == 0 &amp;&amp; p[2] == 1)<br>​                    return p;<br>​                if (p[2] == 0 &amp;&amp; p[3] == 1)<br>​                    return p+1;<br>​            }<br>​            if (p[3] == 0) {<br>​                if (p[2] == 0 &amp;&amp; p[4] == 1)<br>​                    return p+2;<br>​                if (p[4] == 0 &amp;&amp; p[5] == 1)<br>​                    return p+3;<br>​            }<br>​        }<br>​    }<br>​<br>​    for (end += 3; p &lt; end; p++) {<br>​        if (p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 1)<br>​            return p;<br>​    }<br>​<br>​    return end + 3;<br>}</p>
<p>const uint8_t <em>avc_find_startcode(const uint8_t </em>p, const uint8_t <em>end)<br>{<br>​    const uint8_t </em>out= avc_find_startcode_internal(p, end);<br>​    if(p&lt;out &amp;&amp; out&lt;end &amp;&amp; !out[-1]) out–;<br>​    return out;<br>}</p>
<p>@interface H264HwDecoder()<br>{<br>​    NSThread <em>thread;<br>​    uint8_t</em> _vdata;<br>​    size_t _vsize;</p>
<p>​    uint8_t *_buf_out; // 原始接收的重组数据包</p>
<p>​    uint8_t <em>_sps;<br>​    size_t _spsSize;<br>​    uint8_t </em>_pps;<br>​    size_t _ppsSize;<br>​    VTDecompressionSessionRef _deocderSession;<br>​    CMVideoFormatDescriptionRef _decoderFormatDescription;<br>}<br>@end</p>
<p>@implementation H264HwDecoder</p>
<p>//解码回调函数<br>static void didDecompress(void <em>decompressionOutputRefCon, void </em>sourceFrameRefCon, OSStatus status, VTDecodeInfoFlags infoFlags, CVImageBufferRef imageBuffer, CMTime presentationTimeStamp, CMTime presentationDuration ) {</p>
<p>​    if (status != noErr || imageBuffer == nil) {<br>​        LOGE(@”Error decompresssing frame at time: %.3f error: %d infoFlags: %u”,<br>​             presentationTimeStamp.value/presentationTimeStamp.timescale, status, infoFlags);<br>​        return;<br>​    }<br>​<br>​    if (kVTDecodeInfo_FrameDropped &amp; infoFlags) {<br>​        LOGW(@”video frame droped”);<br>​        return;<br>​    }</p>
<p>//    int i,j;<br>//    if (CVPixelBufferIsPlanar(imageBuffer)) {<br>//        i  = (int)CVPixelBufferGetWidthOfPlane(imageBuffer, 0);<br>//        j = (int)CVPixelBufferGetHeightOfPlane(imageBuffer, 0);<br>//    } else {<br>//        i  = (int)CVPixelBufferGetWidth(imageBuffer);<br>//        j = (int)CVPixelBufferGetHeight(imageBuffer);<br>//    }<br>​<br>​    <strong>weak H264HwDecoder *decoder = (</strong>bridge H264HwDecoder <em>)decompressionOutputRefCon;<br>​    if (decoder.delegate != nil) {<br>​        CVPixelBufferRef </em>outputPixelBuffer = (CVPixelBufferRef <em>)sourceFrameRefCon;<br>​        </em>outputPixelBuffer = CVPixelBufferRetain(imageBuffer);<br>​        [decoder.delegate displayDecodedFrame:decoder.uid imageBuffer:imageBuffer];<br>​    }<br>}</p>
<ul>
<li><p>(BOOL)open:width:(uint16_t)width height:(uint16_t)height (NSObject<iwbh264hwdecoderdelegate>*)displayDelegate {</iwbh264hwdecoderdelegate></p>
<p>  [self close];</p>
<p>  if (width == 0 || height == 0) {<br>  ​    _out_width = kH264outputWidth;<br>  ​    _out_height = kH264outputHeight;<br>  }<br>  else {<br>  ​    _out_width = width;<br>  ​    _out_height = height;<br>  }<br>  _vsize = _out_width <em> _out_height </em> 3;<br>  _vdata = (uint8_t<em>)malloc(_vsize </em> sizeof(uint8_t));</p>
<p>  _buf_out = (uint8_t<em>)malloc(_out_width </em> _out_height * sizeof(uint8_t));</p>
<p>  self.delegate = displayDelegate;</p>
<p>  thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];<br>  //thread.name = @”Thread”;<br>  [thread start];</p>
<p>  return YES;<br>  }</p>
</li>
<li><p>(void)setH264DecoderInterface:(NSObject<iwbh264hwdecoderdelegate>*)displayDelegate {<br>  self.delegate = displayDelegate;<br>  }</iwbh264hwdecoderdelegate></p>
</li>
<li><p>(void)run {<br>  size_t out_size = 0;</p>
<p>  while (![[NSThread currentThread] isCancelled]) {<br>  ​    /<em>这里从网路端循环获取视频数据</em>/<br>  ​    if (api_video_get(_uid, _vdata, &amp;out_size) == 0 &amp;&amp; out_size &gt; 0) {<br>  ​        if ([self decodeNalu:_vdata withSize:out_size]) {<br>  ​        }<br>  ​    }</p>
<p>  ​    [NSThread sleepForTimeInterval:0.005];<br>  }<br>  }</p>
</li>
<li><p>(void)stop {<br>  LOGD(@”uid:%u decoder stop”, _uid);</p>
<p>  if (_thread != nil) {<br>  ​    if (!_thread.isCancelled) {<br>  ​        [_thread cancel];<br>  ​        LOGD(@”uid:%u thread cancel”, _uid);<br>  ​    }<br>  }</p>
<p>  LOGD(@”uid:%u decoder stoped”, _uid);</p>
<p>  if (_decoderFormatDesc != nil) {<br>  ​    CFRelease(_decoderFormatDesc);<br>  ​    _decoderFormatDesc = nil;<br>  }</p>
<p>  if (_deocderSession != nil) {<br>  ​    VTDecompressionSessionWaitForAsynchronousFrames(_deocderSession);<br>  ​    VTDecompressionSessionInvalidate(_deocderSession);<br>  ​    CFRelease(_deocderSession);<br>  ​    _deocderSession = nil;<br>  }</p>
<p>  _uid = 0;</p>
<p>  _out_width = kH264outputWidth;<br>  _out_height = kH264outputHeight;</p>
<p>  if (_vdata != NULL) {<br>  ​    free(_vdata);<br>  ​    _vdata = NULL;<br>  ​    _vsize = 0;<br>  }</p>
<p>  if (_sps != NULL) {<br>  ​    free(_sps);<br>  ​    _sps = NULL;<br>  ​    _spsSize = 0;<br>  }</p>
<p>  if (_pps != NULL) {<br>  ​    free(_pps);<br>  ​    _pps = NULL;<br>  ​    _ppsSize = 0;<br>  }</p>
<p>  if (_buf_out != NULL) {<br>  ​    free(_buf_out);<br>  ​    _buf_out = NULL;<br>  }</p>
<p>  self.delegate = nil;<br>  }</p>
</li>
<li><p>(void)close {<br>  [self stop];<br>  _thread = nil;</p>
<p>  LOGD(@”uid:%u decoder close”, _uid);<br>  }</p>
</li>
</ul>
<p>-(BOOL)initH264Decoder {<br>​    if (_deocderSession) {<br>​        return YES;<br>​    }</p>
<p>​    if (!_sps || !_pps || _spsSize == 0 || _ppsSize == 0) {<br>​        return NO;<br>​    }</p>
<p>​    const uint8_t<em> const parameterSetPointers[2] = { _sps, _pps };<br>​    const size_t parameterSetSizes[2] = { _spsSize, _ppsSize };<br>​    OSStatus status = CMVideoFormatDescriptionCreateFromH264ParameterSets(kCFAllocatorDefault,<br>​                                                                          2, //param count<br>​                                                                          parameterSetPointers,<br>​                                                                          parameterSetSizes,<br>​                                                                          4, //nal start code size<br>​                                                                          &amp;_decoderFormatDescription);<br>​    if (status == noErr) {<br>​        NSDictionary</em> destinationPixelBufferAttributes = @{<br>​                                                           (id)kCVPixelBufferPixelFormatTypeKey : [NSNumber numberWithInt:kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange]<br>​                                                           //硬解必须是 kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange 或者是kCVPixelFormatType_420YpCbCr8Planar<br>​                                                           //因为iOS是nv12  其他是nv21<br>​                                                           , (id)kCVPixelBufferWidthKey  : [NSNumber numberWithInt:kH264outputWidth]<br>​                                                           , (id)kCVPixelBufferHeightKey : [NSNumber numberWithInt:kH264outputHeight]<br>​                                                           //, (id)kCVPixelBufferBytesPerRowAlignmentKey : [NSNumber numberWithInt:kH264outputWidth*2]<br>​                                                           , (id)kCVPixelBufferOpenGLCompatibilityKey : [NSNumber numberWithBool:NO]<br>​                                                           , (id)kCVPixelBufferOpenGLESCompatibilityKey : [NSNumber numberWithBool:YES]<br>​                                                           };</p>
<p>​        VTDecompressionOutputCallbackRecord callBackRecord;<br>​        callBackRecord.decompressionOutputCallback = didDecompress;<br>​        callBackRecord.decompressionOutputRefCon = (__bridge void *)self;</p>
<p>​        status = VTDecompressionSessionCreate(kCFAllocatorDefault,<br>​                                              _decoderFormatDescription,<br>​                                              NULL,<br>​                                              (<strong>bridge CFDictionaryRef)destinationPixelBufferAttributes,<br>​                                              &amp;callBackRecord,<br>​                                              &amp;_deocderSession);<br>​        VTSessionSetProperty(_deocderSession, kVTDecompressionPropertyKey_ThreadCount, (</strong>bridge CFTypeRef)[NSNumber numberWithInt:1]);<br>​        VTSessionSetProperty(_deocderSession, kVTDecompressionPropertyKey_RealTime, kCFBooleanTrue);<br>​    } else {<br>​        LOGE(@”reset decoder session failed status=%d”, status);<br>​        return NO;<br>​    }<br>​<br>​    return YES;<br>}</p>
<ul>
<li><p>(BOOL)resetH264Decoder {<br>  if(_deocderSession) {<br>  ​    VTDecompressionSessionWaitForAsynchronousFrames(_deocderSession);<br>  ​    VTDecompressionSessionInvalidate(_deocderSession);<br>  ​    CFRelease(_deocderSession);<br>  ​    _deocderSession = NULL;<br>  }<br>  return [self initH264Decoder];<br>  }</p>
</li>
<li><p>(CVPixelBufferRef)decode:(uint8_t *)frame withSize:(uint32_t)frameSize {<br>  if (frame == NULL || _deocderSession == nil)<br>  ​    return NULL;</p>
<p>  CVPixelBufferRef outputPixelBuffer = NULL;<br>  CMBlockBufferRef blockBuffer = NULL;</p>
<p>  OSStatus status  = CMBlockBufferCreateWithMemoryBlock(NULL,<br>  ​                                                      (void *)frame,<br>  ​                                                      frameSize,<br>  ​                                                      kCFAllocatorNull,<br>  ​                                                      NULL,<br>  ​                                                      0,<br>  ​                                                      frameSize,<br>  ​                                                      FALSE,<br>  ​                                                      &amp;blockBuffer);<br>  if(status == kCMBlockBufferNoErr) {<br>  ​    CMSampleBufferRef sampleBuffer = NULL;<br>  ​    const size_t sampleSizeArray[] = {frameSize};<br>  //        status = CMSampleBufferCreateReady(kCFAllocatorDefault,<br>  //                                           blockBuffer,<br>  //                                           _decoderFormatDescription ,<br>  //                                           1, 0, NULL, 1, sampleSizeArray,<br>  //                                           &amp;sampleBuffer);<br>  ​    status = CMSampleBufferCreate(NULL, blockBuffer, TRUE, 0, 0, _decoderFormatDescription, 1, 0, NULL, 0, NULL, &amp;sampleBuffer);</p>
<p>  ​    if (status == kCMBlockBufferNoErr &amp;&amp; sampleBuffer) {<br>  ​        VTDecodeFrameFlags flags = 0;<br>  ​        VTDecodeInfoFlags flagOut = 0;<br>  ​        status = VTDecompressionSessionDecodeFrame(_deocderSession,<br>  ​                                                   sampleBuffer,<br>  ​                                                   flags,<br>  ​                                                   &amp;outputPixelBuffer,<br>  ​                                                   &amp;flagOut);</p>
<p>  ​        if (status == kVTInvalidSessionErr) {<br>  ​            LOGE(@”Invalid session, reset decoder session”);<br>  ​            [self resetH264Decoder];<br>  ​        } else if(status == kVTVideoDecoderBadDataErr) {<br>  ​            LOGE(@”decode failed status=%d(Bad data)”, status);<br>  ​        } else if(status != noErr) {<br>  ​            LOGE(@”decode failed status=%d”, status);<br>  ​        }<br>  ​    }</p>
<p>  ​    if (sampleBuffer != NULL)<br>  ​        CFRelease(sampleBuffer);<br>  }<br>  if (blockBuffer != NULL)<br>  ​    CFRelease(blockBuffer);</p>
<p>  return outputPixelBuffer;<br>  }</p>
</li>
<li><p>(BOOL)decodeNalu:(uint8_t *)frame withSize:(uint32_t)frameSize {<br>  // LOGD(@”&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始解码”);</p>
<p>  if (frame == NULL || frameSize == 0)<br>  ​    return NO;</p>
<p>  int size = frameSize;<br>  const uint8_t <em>p = frame;<br>  const uint8_t </em>end = p + size;<br>  const uint8_t <em>nal_start, </em>nal_end;<br>  int nal_len, nalu_type;</p>
<p>  size = 0;<br>  nal_start = avc_find_startcode(p, end);<br>  while (![[NSThread currentThread] isCancelled]) {<br>  ​    while (![[NSThread currentThread] isCancelled] &amp;&amp; nal_start &lt; end &amp;&amp; !*(nal_start++));<br>  ​    if (nal_start == end)<br>  ​        break;</p>
<p>  ​    nal_end = avc_find_startcode(nal_start, end);<br>  ​    nal_len = nal_end - nal_start;<br>  ​<br>  ​    nalu_type = nal_start[0] &amp; 0x1f;<br>  ​    if (nalu_type == 0x07) {<br>  ​        if (_sps == NULL) {<br>  ​            _spsSize = nal_len;<br>  ​            _sps = (uint8_t<em>)malloc(_spsSize);<br>  ​            memcpy(_sps, nal_start, _spsSize);<br>  ​        }<br>  ​    }<br>  ​    else if (nalu_type == 0x08) {<br>  ​        if (_pps == NULL) {<br>  ​            _ppsSize = nal_len;<br>  ​            _pps = (uint8_t</em>)malloc(_ppsSize);<br>  ​            memcpy(_pps, nal_start, _ppsSize);<br>  ​        }<br>  ​    }<br>  ​    else {<br>  ​        _buf_out[size + 0] = (uint8_t)(nal_len &gt;&gt; 24);<br>  ​        _buf_out[size + 1] = (uint8_t)(nal_len &gt;&gt; 16);<br>  ​        _buf_out[size + 2] = (uint8_t)(nal_len &gt;&gt; 8 );<br>  ​        _buf_out[size + 3] = (uint8_t)(nal_len);</p>
<p>  ​        memcpy(_buf_out + 4 + size, nal_start, nal_len);<br>  ​        size += 4 + nal_len;<br>  ​    }</p>
<p>  ​    nal_start = nal_end;<br>  }</p>
<p>  if ([self initH264Decoder]) {<br>  ​    CVPixelBufferRef pixelBuffer = NULL;<br>  ​    pixelBuffer = [self decode:_buf_out withSize:size];<br>  }</p>
<p>  return size &gt; 0 ? YES : NO;<br>  }</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> h264 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通过rtsp获取H264裸流并保存到mp4文件]]></title>
      <url>/2018/06/29/ffmpeg%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%20%E9%80%9A%E8%BF%87rtsp%E8%8E%B7%E5%8F%96H264%E8%A3%B8%E6%B5%81%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%88%B0mp4%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>转载： <a href="https://www.cnblogs.com/wenjingu/p/3990071.html" target="_blank" rel="noopener">ffmpeg学习（二） 通过rtsp获取H264裸流并保存到mp4文件</a></p>
<p>本篇将使用上节<a href="http://www.cnblogs.com/wenjingu/p/3977015.html" target="_blank" rel="noopener">http://www.cnblogs.com/wenjingu/p/3977015.html</a>中编译好的库文件通过rtsp获取网络上的h264裸流并保存到mp4文件中。</p>
<p>1、VS2010建立VC++  win32控制台项目</p>
<p>2、在工程目录下建立lib目录和include目录，将已编译好的lib拷打lib下，include拷到include下，dll拷到Debug目录下</p>
<p>3、工程属性–配置属性–VC++目录–包含目录，添加ffmpeg头文件目录及其他第三方头文件目录</p>
<p>​                                             链接器–常规–附加库目录，添加lib目录</p>
<p>​                                             链接器–输入–附加依赖项，添加各个lib名</p>
<p>4、设计和实现：</p>
<p>4.1 设计思路：</p>
<p>​       组件和网络初始化——&gt;打开网络流——&gt;获取网络流信息——&gt;根据网络流信息初始化输出流信息——&gt;创建并打开mp4文件——&gt;写mp4文件头</p>
<p>​                    ——&gt;循环读取输入流并写入mp4文件——&gt;写文件尾——&gt;关闭流，关闭文件<br>​<br>​                    <a id="more"></a></p>
<p>4.2 关键数据结构：</p>
<p>​       AVFormatContext，AVStream，AVCodecContext，AVPacket，AVFrame等，它们的关系解释如下：</p>
<p>​       一个AVFormatContext包含多个AVStream，每个码流包含了AVCodec和AVCodecContext，AVPicture是AVFrame的一个子集，</p>
<p>他们都是数据流在编解过程中用来保存数据缓存的对像，从数据流读出的数据首先是保存在AVPacket里，也可以理解为一个AVPacket最多只包含一个AVFrame，</p>
<p>而一个AVFrame可能包含好几个AVPacket，AVPacket是种数据流分包的概念。</p>
<p>4.3 关键函数：</p>
<p>int avformat_open_input(AVFormatContext <strong>ps, const char <em>filename, AVInputFormat </em>fmt, AVDictionary </strong>options); //打开网络流或文件流</p>
<p>int avformat_write_header(AVFormatContext <em>s, AVDictionary *</em>options);//根据文件名的后缀写相应格式的文件头</p>
<p>int av_read_frame(AVFormatContext <em>s, AVPacket </em>pkt);//从输入流中读取一个分包</p>
<p>int av_interleaved_write_frame(AVFormatContext <em>s, AVPacket </em>pkt);//往输出流中写一个分包</p>
<p>int av_write_trailer(AVFormatContext *s);//写输出流（文件）的文件尾</p>
<p>4.4 代码：</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus </span><br><span class="line">extern &quot;C&quot; &#123; </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &lt;libavcodec/avcodec.h&gt; </span><br><span class="line">#include &lt;libavdevice/avdevice.h&gt; </span><br><span class="line">#include &lt;libavformat/avformat.h&gt; </span><br><span class="line">#include &lt;libavfilter/avfilter.h&gt; </span><br><span class="line">#include &lt;libavutil/avutil.h&gt; </span><br><span class="line">#include &lt;libswscale/swscale.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt; </span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus </span><br><span class="line">&#125; </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p> 以上为引用C库和ffmpeg库的头文件。</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">static AVFormatContext *i_fmt_ctx;</span><br><span class="line">static AVStream *i_video_stream;</span><br><span class="line"></span><br><span class="line">static AVFormatContext *o_fmt_ctx;</span><br><span class="line">static AVStream *o_video_stream;</span><br><span class="line"></span><br><span class="line">static bool bStop = false;</span><br><span class="line"></span><br><span class="line">static unsigned __stdcall rtsp2mp4(void * pThis)</span><br><span class="line">&#123;</span><br><span class="line">    avcodec_register_all();</span><br><span class="line">    av_register_all();</span><br><span class="line">    avformat_network_init();</span><br><span class="line"></span><br><span class="line">    /* should set to NULL so that avformat_open_input() allocate a new one */</span><br><span class="line">    i_fmt_ctx = NULL;</span><br><span class="line">    char rtspUrl[] = &quot;rtsp://admin:12345@192.168.10.76:554&quot;;</span><br><span class="line">    const char *filename = &quot;1.mp4&quot;;</span><br><span class="line">    if (avformat_open_input(&amp;i_fmt_ctx, rtspUrl, NULL, NULL)!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;could not open input file\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (avformat_find_stream_info(i_fmt_ctx, NULL)&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;could not find stream info\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //av_dump_format(i_fmt_ctx, 0, argv[1], 0);</span><br><span class="line"></span><br><span class="line">    /* find first video stream */</span><br><span class="line">    for (unsigned i=0; i&lt;i_fmt_ctx-&gt;nb_streams; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i_fmt_ctx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)</span><br><span class="line">        &#123;</span><br><span class="line">            i_video_stream = i_fmt_ctx-&gt;streams[i];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i_video_stream == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;didn&apos;t find any video stream\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avformat_alloc_output_context2(&amp;o_fmt_ctx, NULL, NULL, filename);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * since all input files are supposed to be identical (framerate, dimension, color format, ...)</span><br><span class="line">    * we can safely set output codec values from first input file</span><br><span class="line">    */</span><br><span class="line">    o_video_stream = avformat_new_stream(o_fmt_ctx, NULL);</span><br><span class="line">    &#123;</span><br><span class="line">        AVCodecContext *c;</span><br><span class="line">        c = o_video_stream-&gt;codec;</span><br><span class="line">        c-&gt;bit_rate = 400000;</span><br><span class="line">        c-&gt;codec_id = i_video_stream-&gt;codec-&gt;codec_id;</span><br><span class="line">        c-&gt;codec_type = i_video_stream-&gt;codec-&gt;codec_type;</span><br><span class="line">        c-&gt;time_base.num = i_video_stream-&gt;time_base.num;</span><br><span class="line">        c-&gt;time_base.den = i_video_stream-&gt;time_base.den;</span><br><span class="line">        fprintf(stderr, &quot;time_base.num = %d time_base.den = %d\n&quot;, c-&gt;time_base.num, c-&gt;time_base.den);</span><br><span class="line">        c-&gt;width = i_video_stream-&gt;codec-&gt;width;</span><br><span class="line">        c-&gt;height = i_video_stream-&gt;codec-&gt;height;</span><br><span class="line">        c-&gt;pix_fmt = i_video_stream-&gt;codec-&gt;pix_fmt;</span><br><span class="line">        printf(&quot;%d %d %d&quot;, c-&gt;width, c-&gt;height, c-&gt;pix_fmt);</span><br><span class="line">        c-&gt;flags = i_video_stream-&gt;codec-&gt;flags;</span><br><span class="line">        c-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line">        c-&gt;me_range = i_video_stream-&gt;codec-&gt;me_range;</span><br><span class="line">        c-&gt;max_qdiff = i_video_stream-&gt;codec-&gt;max_qdiff;</span><br><span class="line"></span><br><span class="line">        c-&gt;qmin = i_video_stream-&gt;codec-&gt;qmin;</span><br><span class="line">        c-&gt;qmax = i_video_stream-&gt;codec-&gt;qmax;</span><br><span class="line"></span><br><span class="line">        c-&gt;qcompress = i_video_stream-&gt;codec-&gt;qcompress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avio_open(&amp;o_fmt_ctx-&gt;pb, filename, AVIO_FLAG_WRITE);</span><br><span class="line"></span><br><span class="line">    avformat_write_header(o_fmt_ctx, NULL);</span><br><span class="line"></span><br><span class="line">    int last_pts = 0;</span><br><span class="line">    int last_dts = 0;</span><br><span class="line"></span><br><span class="line">    int64_t pts, dts;</span><br><span class="line">    while (!bStop)</span><br><span class="line">    &#123;</span><br><span class="line">        AVPacket i_pkt;</span><br><span class="line">        av_init_packet(&amp;i_pkt);</span><br><span class="line">        i_pkt.size = 0;</span><br><span class="line">        i_pkt.data = NULL;</span><br><span class="line">        if (av_read_frame(i_fmt_ctx, &amp;i_pkt) &lt;0 )</span><br><span class="line">            break;</span><br><span class="line">        /*</span><br><span class="line">        * pts and dts should increase monotonically</span><br><span class="line">        * pts should be &gt;= dts</span><br><span class="line">        */</span><br><span class="line">        i_pkt.flags |= AV_PKT_FLAG_KEY;</span><br><span class="line">        pts = i_pkt.pts;</span><br><span class="line">        i_pkt.pts += last_pts;</span><br><span class="line">        dts = i_pkt.dts;</span><br><span class="line">        i_pkt.dts += last_dts;</span><br><span class="line">        i_pkt.stream_index = 0;</span><br><span class="line"></span><br><span class="line">        //printf(&quot;%lld %lld\n&quot;, i_pkt.pts, i_pkt.dts);</span><br><span class="line">        static int num = 1;</span><br><span class="line">        printf(&quot;frame %d\n&quot;, num++);</span><br><span class="line">        av_interleaved_write_frame(o_fmt_ctx, &amp;i_pkt);</span><br><span class="line">        //av_free_packet(&amp;i_pkt);</span><br><span class="line">        //av_init_packet(&amp;i_pkt);</span><br><span class="line">         Sleep(10);</span><br><span class="line">    &#125;</span><br><span class="line">    last_dts += dts;</span><br><span class="line">    last_pts += pts;</span><br><span class="line"></span><br><span class="line">    avformat_close_input(&amp;i_fmt_ctx);</span><br><span class="line"></span><br><span class="line">    av_write_trailer(o_fmt_ctx);</span><br><span class="line"></span><br><span class="line">    avcodec_close(o_fmt_ctx-&gt;streams[0]-&gt;codec);</span><br><span class="line">    av_freep(&amp;o_fmt_ctx-&gt;streams[0]-&gt;codec);</span><br><span class="line">    av_freep(&amp;o_fmt_ctx-&gt;streams[0]);</span><br><span class="line"></span><br><span class="line">    avio_close(o_fmt_ctx-&gt;pb);</span><br><span class="line">    av_free(o_fmt_ctx);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    //ffplayer();</span><br><span class="line">    bStop = false;</span><br><span class="line">    HANDLE   hth;  </span><br><span class="line">    unsigned  uiThreadID;  </span><br><span class="line">  </span><br><span class="line">    hth = (HANDLE)_beginthreadex( NULL,         // security  </span><br><span class="line">                                   0,            // stack size  </span><br><span class="line">                                   rtsp2mp4,  </span><br><span class="line">                                   NULL,           // arg list  </span><br><span class="line">                                   0,  //CREATE_SUSPENDED so we can later call ResumeThread()  </span><br><span class="line">                                   &amp;uiThreadID );  </span><br><span class="line">  </span><br><span class="line">    if ( hth == 0 ) </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Failed to create thread\n&quot;); </span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;按任意键停止录像\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    bStop = true;</span><br><span class="line">    printf(&quot;按任意键退出\n&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">       </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>原来的代码没有为存储流功能单独开线程，会导致写文件尾的语句执行不到，现在改为用一个单独的线程来执行。</p>
<p>5、测试</p>
<p><a href="https://images0.cnblogs.com/blog/174945/201409/241031392326665.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/174945/201409/241031401075565.png" alt="1"></a></p>
<p>如上图为存储视频流过程中程序的打印结果。生成的mp4文件可以用任意支持该格式的播放器播放。现在还无法做到一边存储一边回放录像，下篇再完善吧</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> rtsp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LIVE555再学习 -- VLC搭建RTSP服务器（转）]]></title>
      <url>/2018/06/29/LIVE555%E5%86%8D%E5%AD%A6%E4%B9%A0%20--%20VLC%E6%90%AD%E5%BB%BARTSP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>实时流协议 RTSP 是在实时传输协议的基础上工作的，主要实现对多媒体播放的控制。用户对多媒体信息的播放、暂停、前进和后退等功能就是通过对实时数据流的控制来实现的。 而这些播放控制功能的实现不仅需要多媒体播放器， 同时还需要实时流协议。实时流协议是通过请求报文和响应报文的交互实现的，请求报文和发送报文。</p>
<p>下面我们来再详细的介绍一下它的搭建。</p>
<p><strong>参看：VLC搭建RTSP服务器的过程</strong></p>
<h1 id="一、VLC搭建RTSP服务器的过程"><a href="#一、VLC搭建RTSP服务器的过程" class="headerlink" title="一、VLC搭建RTSP服务器的过程"></a>一、VLC搭建RTSP服务器的过程</h1><h2 id="服务器搭建："><a href="#服务器搭建：" class="headerlink" title="服务器搭建："></a><strong>服务器搭建：</strong></h2><h3 id="第一步，打开VLC"><a href="#第一步，打开VLC" class="headerlink" title="第一步，打开VLC"></a>第一步，打开VLC</h3><h3 id="第二步：在媒体下拉菜单下！有一个子菜单“串流”如图所示："><a href="#第二步：在媒体下拉菜单下！有一个子菜单“串流”如图所示：" class="headerlink" title="第二步：在媒体下拉菜单下！有一个子菜单“串流”如图所示："></a>第二步：在媒体下拉菜单下！有一个子菜单“串流”如图所示：</h3><p><img src="https://img-blog.csdn.net/20130703121814656" alt="img"></p>
<p>点击“串流”子菜单<br><a id="more"></a></p>
<p><img src="https://img-blog.csdn.net/20130703121828296" alt="img"></p>
<p>弹出一个窗口！如下图所示。</p>
<p><img src="https://img-blog.csdn.net/20130703121838531" alt="img"></p>
<p>添加一个你要串流的本地文件，我刚才传给你的那个长一点的文件。</p>
<p><img src="https://img-blog.csdn.net/20130703121848562" alt="img"></p>
<p> <img src="https://img-blog.csdn.net/20130703121931984" alt="img"></p>
<p> <img src="https://img-blog.csdn.net/20130703121942937" alt="img"></p>
<h3 id="第三步，会出现如下的界面："><a href="#第三步，会出现如下的界面：" class="headerlink" title="第三步，会出现如下的界面："></a>第三步，会出现如下的界面：</h3><p><img src="https://img-blog.csdn.net/20130703121955734" alt="img"></p>
<h3 id="第四：点击下一步"><a href="#第四：点击下一步" class="headerlink" title="第四：点击下一步"></a>第四：点击下一步</h3><p> <img src="https://img-blog.csdn.net/20130703122109250" alt="img"></p>
<h3 id="第五步：在下拉框内部，选择”rtsp”-然后点击右边的“添加”按钮，出现如下图片"><a href="#第五步：在下拉框内部，选择”rtsp”-然后点击右边的“添加”按钮，出现如下图片" class="headerlink" title="第五步：在下拉框内部，选择”rtsp”,然后点击右边的“添加”按钮，出现如下图片"></a>第五步：在下拉框内部，选择”rtsp”,然后点击右边的“添加”按钮，出现如下图片</h3><p><img src="https://img-blog.csdn.net/20130703122122156" alt="img"></p>
<p>注意：红框内部的两个蓝色的地方需要修改：一个是缺省的端口号5544！可以不改。</p>
<p>另外一个是URL的上下文，我这边写的是1！</p>
<p>加入你的本机IP地址是192.168.1.1.188，则产生的rtsp串是：“rtsp://192.168.1.188:5544/1”.</p>
<p>注意一点！在红框下面有一个“激活转码”复选框不要选中！</p>
<h3 id="第六步：点击“下一个”按钮。出现如下界面："><a href="#第六步：点击“下一个”按钮。出现如下界面：" class="headerlink" title="第六步：点击“下一个”按钮。出现如下界面："></a>第六步：点击“下一个”按钮。出现如下界面：</h3><p><img src="https://img-blog.csdn.net/20130703122158953" alt="img"></p>
<p>该图，可以不做任何修改，如果不需要组播。直接点击“串流”按钮即可！</p>
<p>会出下如下图：</p>
<p> <img src="https://img-blog.csdn.net/20130703122213515" alt="img"></p>
<p>注意！由于文件比较小，可以点一下红圈内的按钮，这样可以循环串流！</p>
<h2 id="客户端播放："><a href="#客户端播放：" class="headerlink" title="客户端播放："></a><strong>客户端播放：</strong></h2><h3 id="第一步：打开另一个VLC"><a href="#第一步：打开另一个VLC" class="headerlink" title="第一步：打开另一个VLC"></a>第一步：打开另一个VLC</h3><h3 id="第二步：如下图所示，选中篮筐中的子菜单："><a href="#第二步：如下图所示，选中篮筐中的子菜单：" class="headerlink" title="第二步：如下图所示，选中篮筐中的子菜单："></a>第二步：如下图所示，选中篮筐中的子菜单：</h3><p><img src="https://img-blog.csdn.net/20130703122223718" alt="img"></p>
<p>会弹出一个如下的窗口，如下图所示：</p>
<p> <img src="https://img-blog.csdn.net/20130703122245265" alt="img"></p>
<p>在URL栏里面输入刚才你的服务器的rtsp　　　ＵＲＬ地址：例如：rtsp://192.168.1.188:5544/1</p>
<p>点击蓝框内的“播放”按钮！，就可以播放刚才的服务器发过来的rtsp视频流。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> LIVE555 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IJKMediaFramework.framework的播放接口播放直播流的时候，会出现只有声音没有画面，但是我只要把app切换到后台再切换到回来的时候画面就出来了]]></title>
      <url>/2018/06/28/IJKMediaFramework.framework%E7%9A%84%E6%92%AD%E6%94%BE%E6%8E%A5%E5%8F%A3%E6%92%AD%E6%94%BE%E7%9B%B4%E6%92%AD%E6%B5%81%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%8F%AA%E6%9C%89%E5%A3%B0%E9%9F%B3%E6%B2%A1%E6%9C%89%E7%94%BB%E9%9D%A2%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E5%8F%AA%E8%A6%81%E6%8A%8Aapp%E5%88%87%E6%8D%A2%E5%88%B0%E5%90%8E%E5%8F%B0%E5%86%8D%E5%88%87%E6%8D%A2%E5%88%B0%E5%9B%9E%E6%9D%A5%E7%9A%84%E6%97%B6%E5%80%99%E7%94%BB%E9%9D%A2%E5%B0%B1%E5%87%BA%E6%9D%A5%E4%BA%86/</url>
      <content type="html"><![CDATA[<h1 id="IJKMediaFramework-framework的播放接口播放直播流的时候，会出现只有声音没有画面，但是我只要把app切换到后台再切换到回来的时候画面就出来了"><a href="#IJKMediaFramework-framework的播放接口播放直播流的时候，会出现只有声音没有画面，但是我只要把app切换到后台再切换到回来的时候画面就出来了" class="headerlink" title="IJKMediaFramework.framework的播放接口播放直播流的时候，会出现只有声音没有画面，但是我只要把app切换到后台再切换到回来的时候画面就出来了"></a>IJKMediaFramework.framework的播放接口播放直播流的时候，会出现只有声音没有画面，但是我只要把app切换到后台再切换到回来的时候画面就出来了</h1><p>使用打包出来的IJKMediaFramework.framework框架的时候，系统的依赖库也添加完毕，如果直接在根控制器上直接使用IJKMediaFramework.framework的播放接口播放直播流的时候，会出现只有声音没有画面，但是只要把app切换到后台再切换到回来的时候画面就出来了，一直都不知道什么原因。<br>解决方案</p>
<p>就是不要把IJKMediaFramework.framework的直播源播放的接口在根控制器使用</p>
<a id="more"></a>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> IJKMediaFramework.framework </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS——Tips]]></title>
      <url>/2018/06/25/iOS%E2%80%94%E2%80%94Tips/</url>
      <content type="html"><![CDATA[<p>iOS——Tips</p>
<p>退出app：exit(0)</p>
<a id="more"></a>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift知识小集]]></title>
      <url>/2018/06/20/Swift%20%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="https-segmentfault-com-a-1190000012431988"><a href="#https-segmentfault-com-a-1190000012431988" class="headerlink" title="(https://segmentfault.com/a/1190000012431988)"></a>(<a href="https://segmentfault.com/a/1190000012431988" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012431988</a>)</h1><ul>
<li><a href="https://segmentfault.com/t/swift/blogs" target="_blank" rel="noopener">swift</a></li>
</ul>
<p><em>3</em><a href="">**</a><em>**</em></p>
<p>以下内容均是笔者学习过程中<strong>收集</strong>的知识点，顺序比较跳跃，初衷是为了方便查阅，顺便加深记忆。<strong>内容会不断更新</strong>，如果有什么问题或者有好的 Swift 方面的语法糖或者知识点也可以提出来，我会挑选斟酌后收录，欢迎大家关注～</p>
<p><strong>环境：</strong></p>
<blockquote>
<p>Swift 4.0<br>Xcode 9.1</p>
</blockquote>
<h2 id="Associated-Object"><a href="#Associated-Object" class="headerlink" title="Associated Object"></a>Associated Object</h2><a id="more"></a>
<p>Objective-C 的 runtime 里的 Associated Object 允许我们在使用 Category 扩展现有的类的功能的时候，直接添加实例变量。在 Swift 中 extension 不能添加<strong>存储属性</strong>，我们可以利用 Associated Object 来实现，比如下面的 <code>title</code> 「实际上」是一个存储属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// MyClass.swift</span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line"></span><br><span class="line">// MyClassExtension.swift</span><br><span class="line">private var key: Void?</span><br><span class="line"></span><br><span class="line">extension MyClass &#123;</span><br><span class="line">    var title: String? &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return swift_getAssociatedObject(self, &amp;key) as? String</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set &#123;</span><br><span class="line">            swift_setAssociatedObject(self,</span><br><span class="line">                &amp;key, newValue,</span><br><span class="line">                .swift_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 测试</span><br><span class="line">func printTitle(_ input: MyClass) &#123;</span><br><span class="line">    if let title = input.title &#123;</span><br><span class="line">        print(&quot;Title: \(title)&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;没有设置&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = MyClass()</span><br><span class="line">printTitle(a)</span><br><span class="line">a.title = &quot;Swifter.tips&quot;</span><br><span class="line">printTitle(a)</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// 没有设置</span><br><span class="line">// Title: Swifter.tips”</span><br></pre></td></tr></table></figure>
<h2 id="Delegate-声明为-weak"><a href="#Delegate-声明为-weak" class="headerlink" title="Delegate 声明为 weak"></a>Delegate 声明为 weak</h2><p>Swift 中 Delegate 需要被声明成 <code>weak</code>，来避免访问到已被回收的内存而导致崩溃，如果我们像下面这样，是编译不过的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protocol MyClassDelegate &#123;</span><br><span class="line">    func method()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">    weak var delegate: MyClassDelegate?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController, MyClassDelegate &#123;</span><br><span class="line">    // ...</span><br><span class="line">    var someInstance: MyClass!</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        someInstance = MyClass()</span><br><span class="line">        someInstance.delegate = self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func method() &#123;</span><br><span class="line">        print(&quot;Do something&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译失败</span><br><span class="line">// &apos;weak&apos; may only be applied to class and class-bound protocol types, not &apos;MyClassDelegate&apos;</span><br></pre></td></tr></table></figure>
<p>这是因为 Swift 的 protocol 是可以被除了 class 以外的其他类型遵守的，而对于像 <code>struct</code> 或是 <code>enum</code> 这样的类型，本身就不通过引用计数来管理内存，所以也不可能用 <code>weak</code> 这样的 ARC 的概念来进行修饰。</p>
<p>想要在 Swift 中使用 weak delegate，我们就需要将 protocol 限制在 class 内：</p>
<ul>
<li>一种做法是将 protocol 声明为 Objective-C 的，这可以通过在 protocol 前面加上 <code>@objc</code> 关键字来达到，Objective-C 的 protocol 都只有类能实现，因此使用 weak 来修饰就合理了：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol MyClassDelegate &#123;</span><br><span class="line">    func method()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>另一种<strong>可能更好</strong>的办法是在 protocol 声明的名字后面加上 <code>class</code>，这可以为编译器显式地指明这个 protocol 只能由 <code>class</code> 来实现，避免了过多的不必要的 Objective-C 兼容：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol MyClassDelegate: class &#123;</span><br><span class="line">    func method()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可选协议和协议扩展"><a href="#可选协议和协议扩展" class="headerlink" title="可选协议和协议扩展"></a>可选协议和协议扩展</h2><p>Objective-C 中的 protocol 里存在 <code>@optional</code> 关键字，被这个关键字修饰的方法并非必须要被实现，原生的 Swift protocol 里没有可选项，所有定义的方法都是必须实现的，如果不是实现是无法编译的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: UIViewController,MyProtocol &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 编译失败</span><br><span class="line">// Type &apos;ViewController&apos; does not conform to protocol &apos;MyProtocol&apos;</span><br></pre></td></tr></table></figure>
<p>如果我们想要像 Objective-C 里那样定义可选的协议方法，就需要将协议本身和可选方法都定义为 Objective-C 的，也即在 protocol 定义之前加上 <code>@objc</code>，方法之前加上 <code>@objc optional</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol MyProtocol &#123;</span><br><span class="line">    @objc optional func myMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，对于所有的声明，它们的前缀修饰是完全分开的，<strong>也就是说你不能像是在 Objective-C 里那样用一个 @optional 指定接下来的若干个方法都是可选的了，</strong>必须对每一个可选方法添加前缀，对于没有前缀的方法来说，它们是默认必须实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol MyProtocol &#123;</span><br><span class="line">    @objc optional func optionalMethod()        // 可选</span><br><span class="line">    func necessaryMethod()                      // 必须</span><br><span class="line">    @objc optional func anotherOptionalMethod() // 可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一个不可避免的限制是</strong>，使用 <code>@objc</code> 修饰的 protocol 就只能被 <code>class</code> 实现了，也就是说，对于 <code>struct</code> 和 <code>enum</code> 类型，我们是无法令它们所实现的协议中含有可选方法或者属性的。另外，实现它的 <code>class</code> 中的方法还必须也被标注为 <code>@objc</code>，或者整个类就是继承自 <code>NSObject</code>。对于这种问题，在 Swift 2.0 中，我们有了另一种选择，那就是使用 <strong>protocol extension</strong>。我们可以在声明一个 protocol 之后再用 extension 的方式给出部分方法<strong>默认的实现</strong>，这样这些方法在实际的类中就是可选实现的了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protocol MyProtocol &#123;</span><br><span class="line">    func optionalMethod()        // 可选</span><br><span class="line">    func necessaryMethod()       // 必须</span><br><span class="line">    func anotherOptionalMethod() // 可选</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension MyProtocol &#123;</span><br><span class="line">    </span><br><span class="line">    //默认的可选实现</span><br><span class="line">    func optionalMethod() &#123;</span><br><span class="line">        print(&quot;optionalMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //默认的可选实现</span><br><span class="line">    func anotherOptionalMethod() &#123;</span><br><span class="line">        print(&quot;anotherOptionalMethod&quot;)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: UIViewController,MyProtocol &#123;</span><br><span class="line">    </span><br><span class="line">    // 必须的实现</span><br><span class="line">    func necessaryMethod() &#123;</span><br><span class="line">        print(&quot;necessaryMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        self.optionalMethod();</span><br><span class="line">        self.necessaryMethod();</span><br><span class="line">        self.anotherOptionalMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// optionalMethod</span><br><span class="line">// necessaryMethod</span><br><span class="line">// necessaryMethod</span><br></pre></td></tr></table></figure>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>Swift 中的单例非常简单，Swift 1.2 以及之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Singleton  &#123;</span><br><span class="line">    static let sharedInstance = Singleton()</span><br><span class="line">    private init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法不但是线程安全的，也是懒加载的，<code>let</code> 定义的属性本身就是线程安全的，同时 <code>static</code> 定义的是一个 class constant，拥有全局作用域和懒加载特性。</p>
<p>另外，这个类型中加入了一个私有的初始化方法，来覆盖默认的公开初始化方法，这让项目中的其他地方不能够通过 init 来生成自己的 <code>Singleton</code>实例，也保证了类型单例的唯一性。如果你需要的是类似 default 的形式的单例 (也就是说这个类的使用者可以创建自己的实例) 的话，可以去掉这个私有的 <code>init</code> 方法。</p>
<h2 id="输出格式化"><a href="#输出格式化" class="headerlink" title="输出格式化"></a>输出格式化</h2><p>在 Objective-C 中的 <code>%@</code> 这样的格式在指定的位置设定占位符，然后通过参数的方式将实际要输出的内容补充完整。例如 Objective-C 中常用的向控制台输出的 <code>NSLog</code> 方法就使用了这种格式化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float a = 1.234567;</span><br><span class="line">NSString *b = @&quot;Helllo&quot;;</span><br><span class="line">NSLog(@&quot;float：%.2f  str：%p&quot;,a,b);</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// float：1.23  str：0x1024a1078</span><br></pre></td></tr></table></figure>
<p>对应 Swift 中我们可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = 1.234567</span><br><span class="line">let b = &quot;Helllo&quot;</span><br><span class="line">let c = String(format:&quot;float：%.2f str：%p&quot;,a,b)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// float：1.23 str：0x604000249e10</span><br></pre></td></tr></table></figure>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p><code>@selector</code> 是 Objective-C 时代的一个关键字，它可以将一个方法转换并赋值给一个 SEL 类型，它的表现很类似一个动态的函数指针。在 Swift 中没有 <code>@selector</code> 了，取而代之，从 Swift 2.2 开始我们使用 <code>#selector</code> 来从暴露给 Objective-C 的代码中获取一个 <code>selector</code>，并且因为 <code>selector</code> 是 Objective-C runtime 的概念，在 Swift 4 中，默认情况下所有的 Swift 方法在 Objective-C 中都是不可见的，所以你需要在这类方法前面加上 <code>@objc</code> 关键字，将这个方法暴露给 Objective-C，才能进行使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let btn = UIButton.init(type: .system)</span><br><span class="line">btn.backgroundColor = UIColor.red</span><br><span class="line">btn.frame = CGRect(x: 100, y: 100, width: 150, height: 40)</span><br><span class="line">btn.setTitle(&quot;Button&quot;, for: .normal)</span><br><span class="line">//无参数</span><br><span class="line">btn.addTarget(self, action: #selector(btnClick), for: .touchUpInside)</span><br><span class="line">view.addSubview(btn)</span><br><span class="line"></span><br><span class="line">@objc func btnClick()  &#123;</span><br><span class="line">    print(&quot;button click !&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">//有参数</span><br><span class="line">btn.addTarget(self, action: #selector(btnClick(_ :)), for: .touchUpInside)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@objc func btnClick(_ button: UIButton)  &#123;</span><br><span class="line">    print(&quot;button click !&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将-protocol-的方法声明为-mutating"><a href="#将-protocol-的方法声明为-mutating" class="headerlink" title="将 protocol 的方法声明为 mutating"></a>将 protocol 的方法声明为 mutating</h2><p>Swift 的 protocol 不仅可以被 class 类型实现，也适用于 <code>struct</code> 和 <code>enum</code>，因为这个原因，我们在写给别人用的协议时需要多考虑是否使用 <code>mutating</code> 来修饰方法。Swift 的 <code>mutating</code> 关键字修饰方法是为了能在该方法中修改 <code>struct</code> 或是 <code>enum</code> 的变量，所以如果你没在协议方法里写 <code>mutating</code> 的话，别人如果用 <code>struct</code> 或者 <code>enum</code> 来实现这个协议的话，就不能在方法里改变自己的变量了，比如下面的代码是编译不过的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protocol Vehicle &#123;</span><br><span class="line">    </span><br><span class="line">    func changeColor()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MyCar: Vehicle &#123;</span><br><span class="line">    </span><br><span class="line">    var color = &quot;blue&quot;</span><br><span class="line">    </span><br><span class="line">    func changeColor() &#123;</span><br><span class="line">        color = &quot;red&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译失败</span><br><span class="line">// Cannot assign to property: &apos;self&apos; is immutable</span><br></pre></td></tr></table></figure>
<p>我们应该加上 <code>mutating</code> 关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protocol Vehicle &#123;</span><br><span class="line">    </span><br><span class="line">    mutating func changeColor()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MyCar: Vehicle &#123;</span><br><span class="line">    </span><br><span class="line">    var color = &quot;blue&quot;</span><br><span class="line">    </span><br><span class="line">    mutating func changeColor() &#123;</span><br><span class="line">        color = &quot;red&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    var car = MyCar()</span><br><span class="line">    print(car.color)</span><br><span class="line">    car.changeColor()</span><br><span class="line">    print(car.color)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// blue</span><br><span class="line">// 输出：</span><br><span class="line">// red</span><br></pre></td></tr></table></figure>
<h2 id="数组遍历-enumerate"><a href="#数组遍历-enumerate" class="headerlink" title="数组遍历 enumerate"></a>数组遍历 enumerate</h2><p>使用 NSArray 时一个很常遇见的的需求是在枚举数组内元素的同时也想使用对应的<strong>下标索引</strong>，在 Objective-C 中最方便的方式是使用 NSArray 的 <code>enumerateObjectsUsingBlock:</code> ，在 Swift 中存在一个效率，安全性和可读性都很好的替代，那就是快速枚举某个数组的<code>EnumerateGenerator</code>，它的元素是同时包含了元素下标索引以及元素本身的多元组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]</span><br><span class="line">for (idx, str) in arr.enumerated() &#123;</span><br><span class="line">    print(&quot;idx: \(idx) str: \(str)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">idx: 0 str: a</span><br><span class="line">idx: 1 str: b</span><br><span class="line">idx: 2 str: c</span><br><span class="line">idx: 3 str: d</span><br><span class="line">idx: 4 str: e</span><br></pre></td></tr></table></figure>
<h2 id="输入输出参数-inout"><a href="#输入输出参数-inout" class="headerlink" title="输入输出参数 inout"></a>输入输出参数 inout</h2><p>函数参数默认是<strong>常量</strong>，如果试图在函数体中更改参数值将会导致<strong>编译错误</strong>，比如下面的例子中尝试着交换值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func swapTwoInts(_ a: Int, _ b: Int) &#123;</span><br><span class="line">    let temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译失败</span><br><span class="line">// Cannot assign to value: &apos;a&apos; is a &apos;let&apos; constant</span><br><span class="line">// Cannot assign to value: &apos;b&apos; is a &apos;let&apos; constant</span><br></pre></td></tr></table></figure>
<p>如果想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123;</span><br><span class="line">    let temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Default-参数"><a href="#Default-参数" class="headerlink" title="Default 参数"></a>Default 参数</h2><p>Swift 的方法是支持默认参数的，也就是说在声明方法时，可以给某个参数指定一个默认使用的值。在调用该方法时要是传入了这个参数，则使用传入的值，如果缺少这个输入参数，那么直接使用设定的默认值进行调用。和其他很多语言的默认参数相比较，Swift 中的默认参数限制更少，并没有所谓 <strong>“默认参数之后不能再出现无默认值的参数”</strong>这样的规则，举个例子，下面两种方法的声明在 Swift 里都是合法可用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func sayHello1(str1: String = &quot;Hello&quot;, str2: String, str3: String) &#123;</span><br><span class="line">    print(str1 + str2 + str3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sayHello2(str1: String, str2: String, str3: String = &quot;World&quot;) &#123;</span><br><span class="line">    print(str1 + str2 + str3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHello1(str2: &quot; &quot;, str3: &quot;World&quot;)</span><br><span class="line">sayHello2(str1: &quot;Hello&quot;, str2: &quot; &quot;)</span><br><span class="line"></span><br><span class="line">//输出都是 Hello World</span><br></pre></td></tr></table></figure>
<h2 id="延迟加载-lazy"><a href="#延迟加载-lazy" class="headerlink" title="延迟加载 lazy"></a>延迟加载 lazy</h2><p>延时加载或者说延时初始化是很常用的优化方法，在构建和生成新的对象的时候，内存分配会在运行时耗费不少时间，<strong>如果有一些对象的属性和内容非常复杂的话，这个时间更是不可忽略</strong>。另外，有些情况下我们并不会立即用到一个对象的所有属性，而默认情况下初始化时，<strong>那些在特定环境下不被使用的存储属性，也一样要被初始化和赋值</strong>，也是一种浪费。在 Objective-C 中，一个延迟加载一般是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ClassA.h</span><br><span class="line">@property (nonatomic, copy) NSString *testString;</span><br><span class="line"></span><br><span class="line">// ClassA.m</span><br><span class="line">- (NSString *)testString &#123;</span><br><span class="line">     if (!_testString) &#123;</span><br><span class="line">         _testString = @&quot;Hello&quot;;</span><br><span class="line">        NSLog(@&quot;只在首次访问输出&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     return _testString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应在 Swift 中，使用 <code>lazy</code> 作为属性修饰符时，只能声明属性是<strong>变量</strong>，且我们需要显式地指定<strong>属性类型</strong>，否则会编译错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">    lazy let str: String = &#123;</span><br><span class="line">        let str = &quot;Hello&quot;</span><br><span class="line">        print(&quot;只在首次访问输出&quot;)</span><br><span class="line">        return str</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译失败</span><br><span class="line">// &apos;lazy&apos; cannot be used on a let</span><br><span class="line"></span><br><span class="line">class ClassA &#123;</span><br><span class="line">    lazy var str = &#123;</span><br><span class="line">        let str = &quot;Hello&quot;</span><br><span class="line">        print(&quot;只在首次访问输出&quot;)</span><br><span class="line">        return str</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译失败</span><br><span class="line">// Unable to infer complex closure return type</span><br></pre></td></tr></table></figure>
<p>我们应该声明为 <code>var</code> 并指定好类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">    lazy var str: String = &#123;</span><br><span class="line">        let str = &quot;Hello&quot;</span><br><span class="line">        print(&quot;只在首次访问输出&quot;)</span><br><span class="line">        return str</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    let ca = ClassA()</span><br><span class="line">    print(ca.str)</span><br><span class="line">    print(ca.str)</span><br><span class="line">    print(ca.str)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// 只在首次访问输出</span><br><span class="line">// Hello</span><br><span class="line">// Hello</span><br><span class="line">// Hello</span><br></pre></td></tr></table></figure>
<p>如果不需要做什么额外工作的话，也可以对这个 <code>lazy</code> 的属性直接写赋值语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lazy var str: String = &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<p>我们还可以利用 <code>lazy</code> 配合像 <code>map</code> 或是 <code>filter</code> 这类接受闭包并进行运行的方法一起，<strong>让整个行为变成延时进行的</strong>。在某些情况下这么做也对性能会有不小的帮助。例如，直接使用 map 时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let data = 1...3</span><br><span class="line">let result = data.map &#123;</span><br><span class="line">    (i: Int) -&gt; Int in</span><br><span class="line">    print(&quot;正在处理 \(i)&quot;)</span><br><span class="line">    return i * 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;准备访问结果&quot;)</span><br><span class="line">for i in result &#123;</span><br><span class="line">    print(&quot;操作后结果为 \(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;操作完毕&quot;)</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// 正在处理 1</span><br><span class="line">// 正在处理 2</span><br><span class="line">// 正在处理 3</span><br><span class="line">// 准备访问结果</span><br><span class="line">// 操作后结果为 2</span><br><span class="line">// 操作后结果为 4</span><br><span class="line">// 操作后结果为 6</span><br><span class="line">// 操作完毕</span><br></pre></td></tr></table></figure>
<p>而如果我们先进行一次 <code>lazy</code> 操作的话，我们就能得到延时运行版本的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let data = 1...3</span><br><span class="line">let result = data.lazy.map &#123;</span><br><span class="line">    (i: Int) -&gt; Int in</span><br><span class="line">    print(&quot;正在处理 \(i)&quot;)</span><br><span class="line">    return i * 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;准备访问结果&quot;)</span><br><span class="line">for i in result &#123;</span><br><span class="line">    print(&quot;操作后结果为 \(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;操作完毕&quot;)</span><br><span class="line"></span><br><span class="line">// 准备访问结果</span><br><span class="line">// 正在处理 1</span><br><span class="line">// 操作后结果为 2</span><br><span class="line">// 正在处理 2</span><br><span class="line">// 操作后结果为 4</span><br><span class="line">// 正在处理 3</span><br><span class="line">// 操作后结果为 6</span><br><span class="line">// 操作完毕</span><br></pre></td></tr></table></figure>
<p>对于那些不需要完全运行，可能提前退出的情况，使用 lazy 来进行性能优化效果会非常有效。</p>
<h2 id="编译标记"><a href="#编译标记" class="headerlink" title="编译标记"></a>编译标记</h2><p>在 Objective-C 中，我们经常在代码中插入 <code>#param</code> 符号来标记代码的区间，这样在 Xcode 的导航栏中我们就可以看到组织分块后的方法列表。在 Swift 中我们可以用 <code>MARK:</code> 来代替：</p>
<p><img src="https://segmentfault.com/img/remote/1460000012431993?w=962&amp;h=916" alt="img"></p>
<p>在 Objective-C 中还有一个很常用的编译标记，那就是 <code>#warning</code>，一个 <code>#warning</code> 标记可以在 Xcode 的代码编辑器中显示为明显的黄色警告条，非常适合用来提示代码的维护者和使用者需要对某些东西加以关注。在 Swift 中我们可以用 <code>FIXME:</code> 和 <code>TODO:</code> 配合 <code>shell</code> 来代替：</p>
<p><img src="https://segmentfault.com/img/remote/1460000012431994?w=2416&amp;h=944" alt="img"></p>
<p>脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TAGS=&quot;TODO:|FIXME:&quot;</span><br><span class="line">echo &quot;searching $&#123;SRCROOT&#125; for $&#123;TAGS&#125;&quot;</span><br><span class="line">find &quot;$&#123;SRCROOT&#125;&quot; \( -name &quot;*.swift&quot; \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching &quot;($TAGS).*\$&quot; | perl -p -e &quot;s/($TAGS)/ warning: \$1/&quot;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="https://segmentfault.com/img/remote/1460000012431995?w=526&amp;h=368" alt="img"><br><img src="https://segmentfault.com/img/remote/1460000012431996" alt="img"></p>
<h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>在 Swift 3 中，需要换行时是需要 <code>\n</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;xxxx\nxxx&quot;</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// xxxx</span><br><span class="line">// xxx</span><br></pre></td></tr></table></figure>
<p>在 swift 4 中，我们可以使用 <code>&quot;&quot;&quot;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let jsonStr = &quot;&quot;&quot;</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 123455,</span><br><span class="line">            &quot;nickname&quot;: &quot;xxxx&quot;,</span><br><span class="line">            &quot;isMale&quot;: true,</span><br><span class="line">            &quot;birthday&quot;: &quot;2000年3月24日&quot;,</span><br><span class="line">            &quot;personalURL&quot;: &quot;https://xxxxxx.github.io&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">          </span><br><span class="line">// 输出：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: 123455,</span><br><span class="line">    &quot;nickname&quot;: &quot;xxxx&quot;,</span><br><span class="line">    &quot;isMale&quot;: true,</span><br><span class="line">    &quot;birthday&quot;: &quot;2000年3月24日&quot;,</span><br><span class="line">    &quot;personalURL&quot;: &quot;https://xxxxxx.github.io&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串切割-split"><a href="#字符串切割-split" class="headerlink" title="字符串切割 split"></a>字符串切割 split</h2><p>我们需要切割某个字符串时可以用 <code>split</code> 方法，需要注意的是，返回的结果是个<strong>数组</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Hello，world !&quot;</span><br><span class="line">print(str.split(separator: &quot;，&quot;))</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// [&quot;Hello&quot;, &quot;world !&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    var name = &quot;ifelseboyxx&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 4 中 Apple 引入了新的 KeyPath 的表达方式，现在，对于类型 <code>MyClass</code> 中的<strong>变量</strong> <code>name</code>，对应的 KeyPath 可以写为 <code>\MyClass.name</code>，利用 KVC 修改 <code>name</code> 值的话，我们可以这么操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let object = MyClass()</span><br><span class="line">print(&quot;name: \(object.name)&quot;)</span><br><span class="line">// set</span><br><span class="line">object[keyPath: \MyClass.name] = &quot;ifelseboy&quot;</span><br><span class="line">// get</span><br><span class="line">print(&quot;name: \(object[keyPath: \MyClass.name])&quot;)</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// name: ifelseboyxx</span><br><span class="line">// name: ifelseboy</span><br></pre></td></tr></table></figure>
<p>另外 Swift 4 中 <code>struct</code> 同样支持 KVC ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = MyStruct(age: 18)</span><br><span class="line">print(&quot;我今年 \(obj.age) 岁了&quot;)</span><br><span class="line">obj[keyPath: \MyStruct.age] = 8</span><br><span class="line">print(&quot;我今年 \(obj[keyPath: \MyStruct.age]) 岁了&quot;)</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// 我今年 18 岁了</span><br><span class="line">// 我今年 8 岁了</span><br></pre></td></tr></table></figure>
<h2 id="Swift-中值类型和引用类型注意点"><a href="#Swift-中值类型和引用类型注意点" class="headerlink" title="Swift 中值类型和引用类型注意点"></a>Swift 中值类型和引用类型注意点</h2><p>KVC 一节中代码里有个注意点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = MyStruct(age: 18)</span><br><span class="line">//替换为</span><br><span class="line">let obj = MyStruct(age: 18)</span><br></pre></td></tr></table></figure>
<p>是编译不过的，会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot assign to immutable expression of type &apos;Int&apos;</span><br></pre></td></tr></table></figure>
<p>笔者初次也犯了这样的错误，想当然的认为 <code>MyClass</code> 用 <code>let</code> 声明的是没有问题的，<code>struct</code> 也一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let object = MyClass()</span><br></pre></td></tr></table></figure>
<p><strong>其实原因很简单，swift 中 Class 是引用类型的，而 struct 是值类型的：值类型在被赋给一个变量，或被传给函数时，实际是做了一次拷贝。引用类型在被赋给一个变量，或被传给函数时，传递的是引用。</strong></p>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>很遗憾，依然只有 <code>NSObject</code> 才能支持 KVO，另外由于 Swift 为了效率，默认禁用了动态派发，因此想用 Swift 来实现 KVO，我们还需要做额外的工作，那就是将想要观测的对象标记为 <code>dynamic</code> 和 <code>@objc</code>，下面的 ? 是 <code>ViewController</code>监听 <code>MyClass</code> 的 <code>date</code> 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class MyClass: NSObject &#123;</span><br><span class="line">    @objc dynamic var date = Date()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    </span><br><span class="line">    var myObject: MyClass!</span><br><span class="line">    var observation: NSKeyValueObservation?</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        myObject = MyClass()</span><br><span class="line">        print(&quot;当前日期：\(myObject.date)&quot;)</span><br><span class="line">    </span><br><span class="line">        observation = myObject.observe(\MyClass.date, options: [.old,.new], changeHandler: &#123; (_, change) in</span><br><span class="line">            if let newDate = change.newValue , let oldDate = change.oldValue &#123;</span><br><span class="line">                print(&quot;日期发生变化 old：\(oldDate) new：\(newDate) &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1) &#123;</span><br><span class="line">            self.myObject.date = Date()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// 当前日期：2017-12-07 06:31:26 +0000</span><br><span class="line">// 日期发生变化 old：2017-12-07 06:31:26 +0000 new：2017-12-07 06:31:27 +0000</span><br></pre></td></tr></table></figure>
<p>在 Objective-C 中我们几乎可以没有限制地对所有满足 KVC 的属性进行监听，<strong>而现在我们需要属性有 dynamic 和 @objc进行修饰</strong>。大多数情况下，我们想要观察的类包含这两个修饰 (除非这个类的开发者有意为之，否则一般也不会有人愿意多花功夫在属性前加上它们，因为这毕竟要损失一部分性能)，并且有时候我们很可能也无法修改想要观察的类的源码。遇到这样的情况的话，<strong>一个可能可行的方案是继承这个类并且将需要观察的属性使用 dynamic 和 @objc 进行重写。</strong>比如刚才我们的 <code>MyClass</code> 中如果 <code>date</code> <strong>没有相应标注的话</strong>，我们可能就需要一个新的 <code>MyChildClass</code>了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class MyClass: NSObject &#123;</span><br><span class="line">    var date = Date()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyChildClass: MyClass &#123;</span><br><span class="line">    @objc dynamic override var date: Date &#123;</span><br><span class="line">        get &#123; return super.date &#125;</span><br><span class="line">        set &#123; super.date = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    </span><br><span class="line">    var myObject: MyChildClass!</span><br><span class="line">    var observation: NSKeyValueObservation?</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        myObject = MyChildClass()</span><br><span class="line">        print(&quot;当前日期：\(myObject.date)&quot;)</span><br><span class="line">    </span><br><span class="line">        observation = myObject.observe(\MyChildClass.date, options: [.old,.new], changeHandler: &#123; (_, change) in</span><br><span class="line">            if let newDate = change.newValue , let oldDate = change.oldValue &#123;</span><br><span class="line">                print(&quot;日期发生变化 old：\(oldDate) new：\(newDate) &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1) &#123;</span><br><span class="line">            self.myObject.date = Date()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// 当前日期：2017-12-07 06:36:50 +0000</span><br><span class="line">// 日期发生变化 old：2017-12-07 06:36:50 +0000 new：2017-12-07 06:36:51 +0000</span><br></pre></td></tr></table></figure>
<h2 id="Swift-UIButton-状态的叠加"><a href="#Swift-UIButton-状态的叠加" class="headerlink" title="Swift UIButton 状态的叠加"></a>Swift UIButton 状态的叠加</h2><p>在 Objective-C 中，如果我们想叠加按钮的某个状态，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIButton * button = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">[button setTitle:@&quot;Test&quot; forState:UIControlStateNormal | UIControlStateSelected];</span><br></pre></td></tr></table></figure>
<p>对应的 Swift 我们可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let btn = UIButton.init(type: .custom)</span><br><span class="line">btn.setTitle(&quot;hehe&quot;, for: [.normal ,.selected])</span><br></pre></td></tr></table></figure>
<p>把需要叠加的状态用个<strong>数组</strong>装起来就行了。</p>
<h2 id="Swift-中的-“-synchronized”"><a href="#Swift-中的-“-synchronized”" class="headerlink" title="Swift 中的 “@synchronized”"></a>Swift 中的 “@synchronized”</h2><p>在 Objective-C 中，我们可以用 <code>@synchronized</code> 这个关键字可以用来修饰一个变量，并为其自动加上和解除互斥锁。这样，可以保证变量在作用范围内不会被其他线程改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)myMethod:(id)anObj &#123;</span><br><span class="line">    @synchronized(anObj) &#123;</span><br><span class="line">        // 在括号内持有 anObj 锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个方法很简单好用，但是很不幸的是在 Swift 中它已经 (或者是暂时) 不存在了。其实 <code>@synchronized</code> 在幕后做的事情是调用了 <code>objc_sync</code> 中的 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code> 方法，并且加入了一些异常判断。因此，在 Swift 中，如果我们忽略掉那些异常的话，我们想要 lock 一个变量的话，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func myMethod(anObj: AnyObject!) &#123;</span><br><span class="line">    objc_sync_enter(anObj)</span><br><span class="line"></span><br><span class="line">    // 在 enter 和 exit 之间持有 anObj 锁</span><br><span class="line"></span><br><span class="line">    objc_sync_exit(anObj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步，如果我们喜欢以前的那种形式，甚至可以写一个全局的方法，并接受一个闭包，来将 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code> 封装起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func synchronized(_ lock: AnyObject, closure: () -&gt; ()) &#123;</span><br><span class="line">    objc_sync_enter(lock)</span><br><span class="line">    closure()</span><br><span class="line">    objc_sync_exit(lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用：</span><br><span class="line">synchronized(self) &#123;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样使用起来就和 Objective-C 中 <code>@synchronized</code> 很像了。</p>
<p>再举个 ? ，如果我们想为某个类实现一个线程安全的 <code>setter</code>，可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Obj &#123;</span><br><span class="line">    var _str = &quot;123&quot;</span><br><span class="line">    var str: String &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return _str</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            synchronized(self) &#123;</span><br><span class="line">                _str = newValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义日志输出"><a href="#自定义日志输出" class="headerlink" title="自定义日志输出"></a>自定义日志输出</h2><p>在 Objective-C 中，我们通常会自定义日志输出来完善信息以及避免 <code>release</code> 下的输出，比如下面这种，可以额外提供行数、方法名等信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">#define XXLog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)</span><br><span class="line">#else</span><br><span class="line">#define XXLog(...)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line">    </span><br><span class="line">    XXLog(@&quot;ifelseboyxx&quot;);</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// 2017-12-08 13:32:02.211306+0800 Demo[17902:88775537] -[AppDelegate application:didFinishLaunchingWithOptions:] [Line 28] ifelseboyxx</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，我们可以这样自定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func xxprint&lt;T&gt;(_ message: T, filePath: String = #file, line: Int = #line, function: String = #function) &#123;</span><br><span class="line">    #if DEBUG</span><br><span class="line">        let fileName = (filePath as NSString).lastPathComponent.replacingOccurrences(of: &quot;.Swift&quot;, with: &quot;&quot;)</span><br><span class="line">        let dateFormatter = DateFormatter()</span><br><span class="line">        dateFormatter.locale = Locale.current</span><br><span class="line">        dateFormatter.dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;</span><br><span class="line">        print(&quot;[&quot; + dateFormatter.string(from: Date()) + &quot; &quot; + fileName + &quot; &quot; + function + &quot; \(line)&quot; + &quot;]：&quot; + &quot;\(message)&quot;)</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">        xxprint(&quot;ifelseboyxx&quot;)</span><br><span class="line">        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1) &#123;</span><br><span class="line">            xxprint(&quot;ifelseboyxx&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// [2017-12-08 13:49:38 ViewController.swift viewDidLoad() 27]：ifelseboyxx</span><br><span class="line">// [2017-12-08 13:49:39 ViewController.swift viewDidLoad() 29]：ifelseboyxx</span><br></pre></td></tr></table></figure>
<h2 id="Swift-中的-“readonly”"><a href="#Swift-中的-“readonly”" class="headerlink" title="Swift 中的 “readonly”"></a>Swift 中的 “readonly”</h2><p>在 Objective-C 中，我们通常把属性声明为 <code>readonly</code> 来提醒别人：“不要修改！！”，通常这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>如果外部尝试修改的话，会编译错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">   </span><br><span class="line">    Person *p = [Person new];</span><br><span class="line">    p.name = @&quot;ifelseboyxx&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译错误：</span><br><span class="line">// Assignment to readonly property</span><br></pre></td></tr></table></figure>
<p>有些情况下，我们希望内部可以点语法访问 <code>name</code> 属性，也就是 <code>self.name</code>，但是因为是 <code>readonly</code> 的，会编译错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.name = @&quot;ifelseboyxx&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 编译错误：</span><br><span class="line">// Assignment to readonly property</span><br></pre></td></tr></table></figure>
<p>这时候我们就会在内部的 <code>extension</code> 重新声明一个 <code>readwrite</code>的同样的属性，也就是<strong>“外部只读，内部可写”</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface Person ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readwrite, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，我们可能有同样的场景。这里就不得不提到 <code>private</code> 和 <code>fileprivate</code> 关键字了。<br><code>private</code>表示声明为私有的实体只能在其声明的范围内被访问。比如我在 <code>MyClass</code> 中声明了一个私有的 <code>name</code> 属性，外部访问的话会编译错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    private var name: String = &quot;Test&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        let only = MyClass()</span><br><span class="line">        print(only.name) </span><br><span class="line">        only.name = &quot;ifelseboyxxv587&quot;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译异常：</span><br><span class="line">// &apos;name&apos; is inaccessible due to &apos;private&apos; protection level</span><br></pre></td></tr></table></figure>
<p>而 <code>fileprivate</code>，看命名我们大概能猜到，就是将对实体的访问权限于它声明的源文件。通俗点讲，比如我上面的代码都是在 <code>ViewController.swift</code> 这个文件里的，我把 <code>private</code> 修改为 <code>fileprivate</code>，就不会编译错误了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    fileprivate var name: String = &quot;Test&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果非 <code>ViewController.swift</code> 文件，也想访问 <code>MyClass</code> 的 <code>name</code> 属性该怎么办呢？我们可以把 <code>name</code> 属性声明为 <code>fileprivate(set)</code>，就要就达到类似 Objective-C 中的 <code>readonly</code> 效果了 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// ViewController.swift 文件</span><br><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">    fileprivate(set) var name: String = &quot;Test&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        let only = MyClass()</span><br><span class="line">        print(only.name)</span><br><span class="line">        only.name = &quot;ifelseboyxxv587&quot;</span><br><span class="line">        print(only.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译正常，ViewController.swift 文件内可读可写</span><br><span class="line">// 输出：</span><br><span class="line">// Test</span><br><span class="line">// ifelseboyxxv587</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// AppDelegate.swift 文件</span><br><span class="line"></span><br><span class="line">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123;</span><br><span class="line">        // Override point for customization after application launch.</span><br><span class="line"></span><br><span class="line">    let only = MyClass()</span><br><span class="line">    print(only.name) //只能读</span><br><span class="line">    only.name = &quot;ifelseboyxxv587&quot; //这里报错，不能写</span><br><span class="line">        </span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译异常：</span><br><span class="line">// Cannot assign to property: &apos;name&apos; setter is inaccessible</span><br></pre></td></tr></table></figure>
<h2 id="作用域：do-语句块"><a href="#作用域：do-语句块" class="headerlink" title="作用域：do 语句块"></a>作用域：do 语句块</h2><p>在 Objective-C 中，我们可以利用 <code>{}</code> 来开辟新的作用域，来避免对象名称重复的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSString *ha = @&quot;测试一&quot;;</span><br><span class="line">    </span><br><span class="line">&#123;</span><br><span class="line">    NSString *ha = @&quot;测试二&quot;;</span><br><span class="line">    NSLog(@&quot;%@&quot;,ha);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;%@&quot;,ha);</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// 2017-12-11 16:55:20.303132+0800 Demo[48418:93027416] 测试二</span><br><span class="line">// 2017-12-11 16:55:20.303316+0800 Demo[48418:93027416] 测试一</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，取代 <code>{}</code> 的是 <code>do {}</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let ha = &quot;测试一&quot;</span><br><span class="line">        </span><br><span class="line">do &#123;</span><br><span class="line">    let ha = &quot;测试二&quot;</span><br><span class="line">    print(ha)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">print(ha)</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// 测试二</span><br><span class="line">// 测试一</span><br></pre></td></tr></table></figure>
<h2 id="倒序-reversed"><a href="#倒序-reversed" class="headerlink" title="倒序 reversed()"></a>倒序 reversed()</h2><p>在 Objective-C 中，我们如果想倒序数组一般这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;];</span><br><span class="line">    </span><br><span class="line">NSArray *reversedArray = [[array reverseObjectEnumerator] allObjects];</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// 2017-12-11 17:39:57.127466+0800 Demo[49004:93210504] (</span><br><span class="line">    3,</span><br><span class="line">    2,</span><br><span class="line">    1</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，相对简单点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr:[String] = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</span><br><span class="line">let reversedArr:[String] = arr.reversed()</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// [&quot;3&quot;, &quot;2&quot;, &quot;1&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="标签语句：指定跳出某个条件语句"><a href="#标签语句：指定跳出某个条件语句" class="headerlink" title="标签语句：指定跳出某个条件语句"></a>标签语句：指定跳出某个条件语句</h2><p>在 Objective-C 中，如果遇到多层嵌套的条件语句，我们如果想要指定跳出某个条件语句是很不方便的。比如有两个循环，<strong>一旦找到它们相同的，就立刻停止循环</strong>，我们可能会这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr1 = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;];</span><br><span class="line">NSArray *arr2 = @[@&quot;4&quot;,@&quot;6&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;2&quot;];</span><br><span class="line"></span><br><span class="line">BOOL finded = NO;</span><br><span class="line">for (NSString *x in arr1) &#123;</span><br><span class="line">    if (finded) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;x：%@&quot;,x);</span><br><span class="line">    for (NSString *y in arr2) &#123;</span><br><span class="line">        NSLog(@&quot;y：%@&quot;,y);</span><br><span class="line">        if ([x isEqualToString:y]) &#123;</span><br><span class="line">            NSLog(@&quot;找到相等的了：%@&quot;,x);</span><br><span class="line">            finded = YES;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要借助 <code>finded</code> 这个 <code>BOOL</code>，来方便我们跳出循环。在 Swift 中，我们就可以利用标签语句，来指定具体跳出哪个循环，语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标签名: 条件语句 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 ? 我们可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]</span><br><span class="line">let arr2 = [&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;9&quot;,&quot;2&quot;]</span><br><span class="line">        </span><br><span class="line">label: for x in arr1 &#123;</span><br><span class="line">    print(&quot;x： \(x)&quot;)</span><br><span class="line">    for y in arr2 &#123;</span><br><span class="line">        print(&quot;y： \(y)&quot;)</span><br><span class="line">        if x == y &#123;</span><br><span class="line">            print(&quot;找到相等的了：\(y)&quot;)</span><br><span class="line">            break label</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码，我们把第一层循环定义了标签：<code>label</code>。在第二层循环中，一旦条件成立，立刻跳出第一层循环 <code>label</code>。这个特性，可以说十分方便了！</p>
<h2 id="优雅的定义通知名称"><a href="#优雅的定义通知名称" class="headerlink" title="优雅的定义通知名称"></a>优雅的定义通知名称</h2><p>在 Objective-C 中，我们自定义通知时，对于名称的定义一般都有规范：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// xxx.h </span><br><span class="line">UIKIT_EXTERN NSString * const XXXXNotification;</span><br><span class="line"></span><br><span class="line">// xxx.m </span><br><span class="line">NSString * const XXXXNotification = @&quot;XXXXNotification&quot;;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，我们可以参考 <a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a> 的方式，创建个专门存放通知名的文件，扩展 <code>Notification.Name</code> 并以结构体 <code>struct</code> 方式声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// XXNotification.swift 文件</span><br><span class="line"></span><br><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">extension Notification.Name &#123;</span><br><span class="line">    public struct Task &#123;</span><br><span class="line">        public static let 通知名 = Notification.Name(rawValue: &quot;org.target名称.notification.name.task.通知名&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以愉快的使用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// add</span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(myNotification(_ :)), name: NSNotification.Name.Task.通知名, object: self)</span><br><span class="line"></span><br><span class="line">// post</span><br><span class="line">NotificationCenter.default.post(name: NSNotification.Name.Task.通知名, object: self)</span><br><span class="line"></span><br><span class="line">// remove</span><br><span class="line">NotificationCenter.default.removeObserver(self, name: NSNotification.Name.Task.通知名, object: self)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS12 Siri Shortcuts初探]]></title>
      <url>/2018/06/20/iOS12%20Siri%20Shortcuts%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>## </p>
<p>来源：<a href="https://www.jianshu.com/p/19b248333b18" target="_blank" rel="noopener">he15hiss</a></p>
<p><strong>简述</strong></p>
<p>开发者期待的2018 WWDC如期开始，然而今年并没有什么特别大的功能亮点，主要是进行一些bug修复和性能提升，而少之又少的功能里面最让我期待的还是Shortcuts,粗略的了解了下功能就是可以通过自定义一个短语，能过Siri来唤起特定的功能，可以在应用中添加“添加到Siri”按钮，点击后会把这个动作列到 My Shortcuts列表里面，还会有一个Shortcuts应用，用这个应用可以把一连串动作连接起来执行，也就是workflow的效果；这也是之前苹果收购workflow的原因。</p>
<p>大概了解了它的功能，下面就带大家看看如何开发一个这样的功能</p>
<p><strong>创建事件</strong><br><a id="more"></a><br><strong>1.使用NSUserActivity</strong></p>
<p>NSUserActivity提供了一个轻量级的方法实现donation功能，它还集成了其他苹果功能，如Handoff和Spotlight search, 要使用NSUserAcgivity首先在Info.plist里面定义NSUserActivityTypes类别，然后就可以定义NSUserActivity实例了，设置activityType、title、userInfo等属性, 还可以设置suggestedInvocationPhrase属性给用户Siri建议短语，最后调用 becomeCurrent()方法，这会使它加入Siri中</p>
<p><strong>2.使用自定义 INIntent</strong></p>
<p>系统提供的INIntent功能有限，iOS12之前系统并没有给我们提供自定义INIntent的功能，通过查看官方Demo发现可以使用Intents.intentdefinition文件添加自定义类型的INObject动作</p>
<p><img src="https://upload-images.jianshu.io/upload_images/532603-a97cb46a9e98b0d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p><strong>Custom Intent</strong></p>
<ul>
<li>Category为intent的类别，内部的选项基本包括常用的所有操作，如果没有对应的功能，还能选择通用类别</li>
<li>Title 标题，会显示在My Shortcuts列表内</li>
<li>Description 描述信息</li>
</ul>
<p>在Parameters类别中可以添加这个Intent对应的参数，最后还可以通过这些参数来显示不同的Title和Subtitle，之后编辑器会通过这个文件自动生成对应的INIntent类</p>
<p>然后就可以通过这个类来创建动作对象</p>
<p>创建完后通过INInteraction的donate方法就可以把对应的动作写进Shortcuts</p>
<p><strong>添加Siri短语</strong></p>
<p>我们可以在应用对应的位置添加“添加到Siri”按钮，引导用户把对应的动作用Siri短语来执行(苹果建议当用户完成一个动作后，引导用户把这个动作加入Siri, 而不是没进行过这个动作直接添加到Siri)，当然，用户也可以主动到设置中去设置。</p>
<p>添加和编辑主要用到INUIAddVoiceShortcutViewController和INUIEditVoiceShortcutViewController类，都有对应的代理回调设置后的结果</p>
<p><strong>处理Shortcuts事件</strong></p>
<p>添加完事件，当然最重要的还是回调处理，通过在AppDelegate代理就可以直接接收到进入到APP内的对应动作，代理中可以判断对应的动作，然后实现对应的功能就可以了</p>
<p><strong>Shortcuts管理</strong></p>
<p>苹果提供INVoiceShortcutCenter类对象对应用所有的Shortcuts进行管理，它是一个单例对象,提供设置和获取INShortcut的方法</p>
<p><strong>参考</strong></p>
<p><a href="https://developer.apple.com/documentation/sirikit#2979425" target="_blank" rel="noopener">https://developer.apple.com/documentation/sirikit#2979425</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Siri </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS逆向-ipa包重签名及非越狱手机安装多个微信]]></title>
      <url>/2018/06/20/iOS%E9%80%86%E5%90%91-ipa%E5%8C%85%E9%87%8D%E7%AD%BE%E5%90%8D%E5%8F%8A%E9%9D%9E%E8%B6%8A%E7%8B%B1%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85%E5%A4%9A%E4%B8%AA%E5%BE%AE%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>## </p>
<p>来源：<a href="https://www.jianshu.com/p/25e1f44c90f7" target="_blank" rel="noopener">czj_warrior</a></p>
<blockquote>
<p>前一段时间学了点儿逆向相关的一些东西，但是都是基于越狱手机上的操作，给视频类应用去广告之类的。随着苹果生态圈的逐渐完善、及苹果对自身系统的保护越来越严格，导致现在的iPhone手机并不像以前那样存在大量的越狱用户。</p>
</blockquote>
<p>前段时间我自己申请了个微信小号，申请小号的目的就是原来微信号好友中乱七八糟的人实在太多，感觉自己的朋友圈都是一些无关紧要的垃圾信息，曾经关闭了一段时间的朋友圈，但是最近遇到了好多技术上很强的同行，还想了解大佬们的动态。于是我就想着申请了个小号，但是麻烦来了，iPhone手机并不像安卓手机那样存在着微信多开之类的应用，将自己手机越狱吧成本太高，于是就想着通过技术手段安装多个微信，下面步入正题：</p>
<p><strong>为什么要重签名</strong><br><a id="more"></a><br>其实我们平时开发的App，程序运行主要就是加载一个Mach-o可执行文件。当我们将程序打包成ipa文件，上传到App Store的时候，期间就是进行了一些加壳操作，比如：数字证书签名等。重签名的目的就是将别人的程序重新签上我们的证书信息。也可以简单理解为将别人的加密文件解密，加上我们自己的加密算法。</p>
<p><strong>逆向当中的一些专业术语</strong></p>
<ul>
<li>加壳：利用特殊算法（iOS中数字证书），对可执行文件的编码进行改变，以达到保护程序代码的目的</li>
<li>脱壳：摘掉壳程序，将未加密的可执行文件Mach-o还原出来</li>
</ul>
<p><strong>查看应用是否加壳</strong></p>
<p>将下载好的ipa包解压缩之后，拿到里面的Mach-o文件，cd到所在目录，执行如下命令：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-9eb97ce35a42900e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/395" alt="img"></p>
<p>其中cryptid代表是否加壳，1代表加壳，0代表已脱壳。我们发现打印了两遍，其实代表着该可执行文件支持两种架构armv7和arm64.</p>
<p><strong>查看应用支持哪种架构</strong></p>
<p>终端下执行如下命令查看架构信息</p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-2da4a61512e66035.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/569" alt="img"></p>
<p>除了查看架构信息，还可以利用该指令导出某种特定架构、合并多种架构：</p>
<ul>
<li>导出特定架构</li>
</ul>
<p>lipo 文件路径 -thin 架构类型 -output 输出文件路径</p>
<ul>
<li>合并多种架构</li>
</ul>
<p>lipo 文件路径1 文件路径2 -output 输出文件路径</p>
<p><strong>怎么给应用脱壳</strong></p>
<p>给应用脱壳有两种途径：</p>
<p>一、直接从一些第三方应用商店里面下载你想脱壳的应用，例如：PP助手、iTools等</p>
<p>二、自己脱壳，利用GitHub上开源的一些工具，常用的有Clutch、dumdecrypted。具体如何使用，请自行Google</p>
<p><strong>前期准备工作：</strong></p>
<p>一台iPhone，越不越狱都行</p>
<p>开发者证书或者企业证书（个人账号也行，但是应用安装上之后，有效期只有7天）</p>
<p>电脑安装<a href="https://dantheman827.github.io/ios-app-signer/" target="_blank" rel="noopener"> iOS App Signer</a></p>
<p>其实重签名的方式有很多，比如：可以利用sigh resign命令，在终端下操作，还可以借助一些逆向相关的重签名工具，本文采用iOS App Signer</p>
<p>了解以上基本概念之后，下面正式开始史上最详细的重签名过程，以微信为例：</p>
<p><strong>第一步：准备好脱壳后的微信App</strong></p>
<p>我是直接从PP助手上下载的，感兴趣的可以自己手动脱壳</p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-b8abb0c3d2bafe54.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p><strong>第二步：将对用的ipa文件解压，修改一些东西</strong></p>
<p>注意：个人证书不能重签Extension文件，所以要删除ipa包中包含的相应文件，包括Watch里面的Extension，为了方便一般直接将Watch文件删除：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-a6b099be78f15712.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-3400d184b8416375.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p><strong>第三步：利用iOS App Signer给微信重签名</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-4b9e106aea7e7f3b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<ul>
<li>第一项：对应的.ipa或者.app路径</li>
<li>第二项：我们自己的签名证书</li>
<li>第三项：证书对应的Profile文件，默认项Re-Sign Only是无效的，选择证书下存在的Profile文件）</li>
<li>第四项：重签名之后的Bundle identifier（选择了Profile文件，一般会自动填写）</li>
</ul>
<p>下面几项可以随便写</p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-0677ef63d5cf2426.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>签名完毕之后对应的文件夹下会生成重签名之后的ipa包</p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-2b65b64a25448ceb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/498" alt="img"></p>
<p><strong>注意：</strong>利用iOS App Signer重签名，在删除掉相应的Extension，选择路径的时候，一定要选择Payload文件夹下对应的.app文件，否则会报找不到Payload文件夹的错误：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-94ebb729570240f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p><strong>安装重签名之后的微信</strong></p>
<p>可以用PP助手安装，也可以用Xcode安装，我采用Xocde安装：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-33808e5a3de12398.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>不出意外地话，第二个微信就成功的安装到了你的手机上。如果装不上的话，基本上大部分原因就是证书不对。。。</p>
<p><strong>最终效果</strong></p>
<p>多个证书可以多次重新签名，安装多个相同的应用</p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-bb18a68e1b41f3f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/187" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-0060b9ba584a5305.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/187" alt="img"></p>
<p>这篇文章图有点儿多。。。。。</p>
<p><strong>注意：重签名方式安装的微信，是对微信APP的一种破解，会被官方认定为非安全软件，有被封号的危险。</strong>但是这种方式对破解各种其他软件都是有用的，利用逆向相关的知识，我们可以利用这种知识做很多我们想做的事儿！！！（不要做非法的事情哈！）</p>
<p><strong>遇到的坑</strong></p>
<p>错误一：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-916b8a457750c2a0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/528" alt="img"></p>
<p>解决办法：证书不对，仔细检查下证书</p>
<p>错误二</p>
<p><img src="https://upload-images.jianshu.io/upload_images/423503-a724bf28bf14ed68.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>解决办法：删除ipa包里面的watch相关的文件</p>
<p><strong>总结</strong></p>
<p>过程其实很简单，我始终认为借助一些工具能完成的东西，都是很简单的，因为不需要敲代码。总算给自己iPhone装上了多个微信，原来还打算买个安卓手机呢，哈哈，给自己省了一大笔钱。。。</p>
<blockquote>
<p><em>作者：czj_warrior</em></p>
<p><em>链接：<a href="https://www.jianshu.com/p/25e1f44c90f7" target="_blank" rel="noopener">https://www.jianshu.com/p/25e1f44c90f7</a></em></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> iOS逆向 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac下利用Hexo+GitHub轻松搭建自己的博客]]></title>
      <url>/2018/06/13/Mac%E4%B8%8B%E5%88%A9%E7%94%A8Hexo+GitHub%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p># </p>
<p>2016年10月23日 15:03:21</p>
<p>阅读数：3620</p>
<p>今年4月份就在mac下利用hexo搭建了一个博客，因换了一台电脑，项目丢失，需重新安装。</p>
<p>整理一下安装流程：</p>
<p>1.hexo是基于nodejs的，需安装nodejs，安装nodejs最好选择homebrew</p>
<p>2.首先查看电脑是否安装ruby，因为homebrew安装依赖ruby</p>
<p>3.安装顺序：homebrew—-&gt;nodejs—-&gt;hexo</p>
<hr>
<a id="more"></a>
<p><strong>安装homebrew</strong></p>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”  </li>
</ol>
<p><strong>安装nodejs</strong></p>
<hr>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>brew install node  </li>
</ol>
<p>在安装nodejs过程中，提示如下警告：</p>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>You have Xcode 8 installed without the CLT;  </li>
</ol>
<p>根据提示进行安装</p>
<p><strong>安装hexo</strong></p>
<hr>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>sudo npm install -g hexo  </li>
</ol>
<p><strong>创建文件夹</strong></p>
<hr>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>mkdir blog  </li>
<li>cd blog  </li>
<li>hexo init  </li>
</ol>
<p>此时blog文件下出现了很多文件和文件夹，如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20161023150045062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>生成一套静态网页</strong></p>
<hr>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>hexo generate /<strong> 生成一套静态网页 </strong>/  </li>
<li>hexo server /<strong> 在服务器上运行 </strong>/  </li>
</ol>
<p>在浏览器上运行<a href="http://localhost:4000就能看到如下的网站首页：" target="_blank" rel="noopener">http://localhost:4000就能看到如下的网站首页：</a></p>
<p><img src="https://img-blog.csdn.net/20161023150235594?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>撰写博客</strong></p>
<p>进入终端，使用cd命令进入到有Hexo框架的目录里面，输入：</p>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>hexo new post “我的第一篇博客”  </li>
</ol>
<p>随后出现如下的消息：</p>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>INFO  Created: ~/blog/source/_posts/我的第一篇博客.md  </li>
</ol>
<p>证明创建文章成功，“我的第一篇博客”这个md文件会创建在source/_posts/的文件下。该md文件在自动生成时会带有一些属性：</p>
<p>title:     定义了博文的标题</p>
<p>date:   定义了创作博文的时间</p>
<p>tags:   定义了博文的标签</p>
<p>除了这个三个属性以外我们还可以扩展一些属性：</p>
<p>update:  定义了最后修改的时间</p>
<p>comments：定义能否评论此博文(默认为true)</p>
<p>categories: 定义了博文的种类</p>
<p><strong>配置文件  –  _config.yml说明</strong></p>
<p>Hexo的每一个功能的配置文件都是_config.yml， 具体说明看下面的注解：</p>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li># Hexo Configuration  </li>
<li>## Docs: <a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">https://hexo.io/docs/configuration.html</a>  </li>
<li>## Source: <a href="https://github.com/hexojs/hexo/" target="_blank" rel="noopener">https://github.com/hexojs/hexo/</a>  </li>
<li></li>
<li># Site                 ##修改以适应搜索引擎的收录  </li>
<li>title: Hexo            ##定义网站的标题  </li>
<li>subtitle:              ##定义网站的副标题  </li>
<li>description:           ##定义网站的描述  </li>
<li>author: jason jwl      ##定义网站的负责人  </li>
<li>language:              ##定义网站的语言,默认zh-Hans  </li>
<li>timezone:              ##定义网站的时区  </li>
<li></li>
<li># URL  </li>
<li>## If your site is put in a subdirectory, set url as ‘<a href="http://yoursite.com/child">http://yoursite.com/child</a>‘ and root as ‘/child/‘  </li>
<li>url: <a href="http://yoursite.com">http://yoursite.com</a>   ##定义网站访问的域名  </li>
<li>root: /      ##定义所在Web文件夹在哪个目录  </li>
<li>permalink: :year/:month/:day/:title/  ##定义时间格式  </li>
<li>permalink_defaults:  </li>
<li></li>
<li># Directory  </li>
<li>source_dir: source   ##定义从哪个文件夹获取博客资料  </li>
<li>public_dir: public   ##定义生成静态网站到哪个文件夹  </li>
<li></li>
<li>archive_dir: archives  </li>
<li>category_dir: categories  </li>
<li>code_dir: downloads/code  </li>
<li>i18n_dir: :lang  </li>
<li>skip_render:  </li>
<li></li>
<li># Writing  </li>
<li>new_post_name: :title.md # File name of new posts  </li>
<li>default_layout: post  </li>
<li>titlecase: false # Transform title into titlecase  </li>
<li>external_link: true # Open external links in new tab  </li>
<li>filename_case: 0  </li>
<li>render_drafts: false  </li>
<li>post_asset_folder: false  </li>
<li>relative_link: false  </li>
<li>future: true  </li>
<li>highlight:  </li>
<li>enable: true  </li>
<li>line_number: true  </li>
<li>auto_detect: false  </li>
<li>tab_replace:  </li>
<li></li>
<li># Category &amp; Tag  </li>
<li>default_category: uncategorized  </li>
<li>category_map:  </li>
<li>tag_map:  </li>
<li></li>
<li># Date / Time format  </li>
<li>## Hexo uses Moment.js to parse and display date  </li>
<li>## You can customize the date format as defined in  </li>
<li>## <a href="http://momentjs.com/docs/#/displaying/format/" target="_blank" rel="noopener">http://momentjs.com/docs/#/displaying/format/</a>  </li>
<li>date_format: YYYY-MM-DD  </li>
<li>time_format: HH:mm:ss  </li>
<li></li>
<li># Pagination  </li>
<li>## Set per_page to 0 to disable pagination  </li>
<li>per_page: 10  ##定义每一页多少条博客  </li>
<li>pagination_dir: page  </li>
<li></li>
<li># Extensions  </li>
<li>## Plugins: <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a>  </li>
<li>## Themes: <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a>  </li>
<li>theme: landscape  ##定义使用的主题  </li>
<li></li>
<li># Deployment  </li>
<li>## Docs: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a>  </li>
<li>deploy:  </li>
<li>type:  </li>
</ol>
<p><strong>注意：</strong></p>
<p><strong>另外修改这些属性时，请注意格式，属性和值要空一个格，比如theme: landscape。</strong></p>
<hr>
<p><strong>本地同步github</strong></p>
<p>在github上new Repository，并命名为xxxxx.github.io(xxxxx是你github的账号名)，然后把本地项目提交到github的远程项目。具体操作步骤可以参考我以前写的一篇博客：<a href="http://blog.csdn.net/jasonjwl/article/details/49682217" target="_blank" rel="noopener">http://blog.csdn.net/jasonjwl/article/details/49682217</a>。然后在浏览器上输入xxxxx.github.io就能访问自己的博客了。</p>
<p>同步到github，发现网站访问不了。并且github给我发了一封邮件，如下所示：</p>
<p><img src="https://img-blog.csdn.net/20161023231400936?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>经测试不是主题的问题。</p>
<p>个人建议不通过手动同步github，优先考虑通过修改_config.yml让hexo帮助我们同步github，方便快捷，配置如下所示：</p>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>deploy:  </li>
<li>type: git  </li>
<li>repo: <a href="https://github.com/xxx/xxx.github.io.git" target="_blank" rel="noopener">https://github.com/xxx/xxx.github.io.git</a>  </li>
<li>branch: master  </li>
<li>xxx为个人github的name  </li>
</ol>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>hexo deploy  </li>
</ol>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>hexo d  </li>
</ol>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>ERROR Deployer not found: git  </li>
</ol>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>npm install hexo-deployer-git –save  </li>
</ol>
<p>当你增加新的文章或者插件时，可以通过以下三个命令进行同步操作：</p>
<p><strong>[plain]</strong> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/jasonjwl/article/details/52887575#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>hexo clean  </li>
<li>hexo generate  </li>
<li>hexo deploy  </li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IBDesignable和IBInspectable（xcode的所见即所得）]]></title>
      <url>/2018/06/13/IBDesignable%E5%92%8CIBInspectable%EF%BC%88xcode%E7%9A%84%E6%89%80%E8%A7%81%E5%8D%B3%E6%89%80%E5%BE%97%EF%BC%89/</url>
      <content type="html"><![CDATA[<p># </p>
<p>转<a href="https://www.jianshu.com/u/9f2fa4dcf955" target="_blank" rel="noopener">Better_奔</a></p>
<h2 id="IBDesignable的基本使用"><a href="#IBDesignable的基本使用" class="headerlink" title="IBDesignable的基本使用"></a>IBDesignable的基本使用</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>IBDesignable</code>主要用于<code>xcode</code>版本的所见即所得（实时渲染），在<code>storyBoard</code>，<code>xib</code>或者代码中设置View的属性，<code>storyBoard</code>，<code>xib</code>能实时的渲染。<br><a id="more"></a></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>单独使用<code>IBDesignable</code>时,步骤如下：</p>
<p>①在自定义的<code>UIView</code>的子类前使用<code>@IBDesignable</code><br>②在界面的中自定义子<code>View</code>的<code>User Defined Runtime Attributes</code>中设置运行时的属性或者可以用代码进行出操作。</p>
<p>看个🌰：</p>
<p>①创建一个<code>swift</code>工程,在的<code>Main.storyboard</code>中使用默认的<code>ViewController</code>控制器视图，在上面添加一个简单的<code>View</code>，并设置背景为红色。效果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1422632-c99221c79417b980.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>image.png</p>
<p>②自定义一个类<code>MyView</code>与添加的红色<code>View</code>相关联。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1422632-19ce9239a19af056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/508" alt="img"></p>
<p>image.png</p>
<p>③在类名前进行标注<code>@IBDesignable</code>并且在<code>User Defined Runtime Attributes</code>设置圆角属性。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1422632-5fdc581ddd7182d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/576" alt="img"></p>
<p>image.png</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1422632-09117a6f626d876c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/526" alt="img"></p>
<p>image.png</p>
<p>效果图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1422632-f8d42674d825ddd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>image.png</p>
<p>④也可以在代码中进行额外的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@IBDesignable</span><br><span class="line">class MyView: UIView &#123;</span><br><span class="line">    var backgroundView: UIView?</span><br><span class="line">    var label: UILabel?</span><br><span class="line">    var imageView: UIImageView?</span><br><span class="line">    //运行时调用的方法</span><br><span class="line">    required init?(coder aDecoder: NSCoder) &#123;</span><br><span class="line">        super.init(coder: aDecoder)</span><br><span class="line">        createUI()</span><br><span class="line">    &#125;</span><br><span class="line">    //在实时渲染时调用的方法</span><br><span class="line">    override init(frame: CGRect) &#123;</span><br><span class="line">        super.init(frame: frame)</span><br><span class="line">        createUI()</span><br><span class="line">    &#125;</span><br><span class="line">    private func createUI() &#123;</span><br><span class="line">    //在实时渲染时没有效果，在运行时有效果。</span><br><span class="line">          //self.backgroundColor = UIColor.black</span><br><span class="line">        self.backgroundView = &#123;</span><br><span class="line">            let view = UIView.init(frame: CGRect.init(x: 10, y: 10, width: 80, height: 80))</span><br><span class="line">            view.backgroundColor = UIColor.yellow</span><br><span class="line">            self.addSubview(view)</span><br><span class="line">            return view</span><br><span class="line">        &#125;()</span><br><span class="line">        self.label = &#123;</span><br><span class="line">            let label = UILabel.init(frame: CGRect.init(x: 20, y: 20, width: 40, height: 30))</span><br><span class="line">            label.text = &quot;你好&quot;</span><br><span class="line">            self.addSubview(label)</span><br><span class="line">            return label</span><br><span class="line">        &#125;()</span><br><span class="line">        self.imageView = &#123;</span><br><span class="line">            let imV = UIImageView.init(frame: CGRect.init(x: 30, y: 30, width: 40, height: 30))</span><br><span class="line">            let bunlde = Bundle.init(for: self.classForCoder)</span><br><span class="line">            imV.image = UIImage.init(named: &quot;caomei&quot;, in: bunlde, compatibleWith: nil)</span><br><span class="line">            self.addSubview(imV)</span><br><span class="line">            return imV</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特别注意：</strong></p>
<ul>
<li>不要去重写<code>func draw(_ rect: CGRect)</code>方法，否则会失效。</li>
<li>一些<code>storyBoard</code>，<code>xib</code>原本就可以设置的属性，例如<code>backgroundColor</code>用代码是没有效果的。</li>
<li>在其中不能使用<code>self.frame</code>的属性来布局，因为其中<code>self.frame</code>是未知的。只能使用约束。</li>
<li>网上有资料显示，OC使用中如果需要使用资源，例如：图片资源，运行时和渲染时的<code>Bundle</code>不同，需要使用如下代码，请自行验证。</li>
<li><font color="red"><code>swift</code>中关于资源使用<code>let bunlde = Bundle.init(for: self.classForCoder)</code>来获取<code>Bundle</code>,使用<code>Main</code>无效果</font>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#if TARGET_INTERFACE_BUILDER</span><br><span class="line">   //IB调试时调用</span><br><span class="line">   bundle=[NSBundle bundleForClass:[self class]];</span><br><span class="line">#else</span><br><span class="line">   bundle=[NSBundle mainBundle];</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="只是用IBDesignable实时渲染代码执行的顺序"><a href="#只是用IBDesignable实时渲染代码执行的顺序" class="headerlink" title="只是用IBDesignable实时渲染代码执行的顺序"></a>只是用IBDesignable实时渲染代码执行的顺序</h3><p>每次修改<code>User Defined Runtime Attributes</code>的值都执行一次<code>init(frame: CGRect)</code>进行渲染</p>
<h2 id="IBInspectable的基本使用"><a href="#IBInspectable的基本使用" class="headerlink" title="IBInspectable的基本使用"></a>IBInspectable的基本使用</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>以上是只使用实时渲染时的操作，不过<code>IBInspectable</code>和<code>IBDesignable</code>结合使用才更显魅力。</p>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>①在自定义的类之前加上<code>@IBDesignable</code><br>②在类中自定义几个属性，这几个属性都可以在<code>storyBoard</code>，<code>xib</code>中手动操作，属性使用修饰词<code>@IBInspectable</code><br>③重写<code>draw(_ rect: CGRect)</code>中的方法进行具体操作。</p>
<p>继续看🌰：</p>
<p>①依据之前的经验，加一个<code>IBInspectableViewController</code>自带<code>Xib</code>，并且在其上加一个<code>View</code>，和自定义的类<code>CornerRadiousView</code>关联，如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1422632-7c90964ae75bef3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>image.png</p>
<p>②在自定义的类中，添加自定义的属性，并且重写<code>draw(_ rect: CGRect)</code>方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@IBDesignable</span><br><span class="line">class CornerRadiousView: UIView &#123;</span><br><span class="line">      @IBInspectable var radius: CGFloat = 0</span><br><span class="line">    @IBInspectable var image: UIImage? = nil</span><br><span class="line">    override func draw(_ rect: CGRect) &#123;</span><br><span class="line">    let layer = CALayer.init()</span><br><span class="line">        layer.frame = CGRect.init(x: 0, y: 0, width: 240, height: 240)</span><br><span class="line">        layer.cornerRadius = self.radius</span><br><span class="line">        layer.backgroundColor = UIColor.blue.cgColor</span><br><span class="line">        self.layer.addSublayer(layer)</span><br><span class="line">        let imageView = UIImageView.init(frame: CGRect.init(x: 20, y: 20, width: 200, height: 200))</span><br><span class="line">        imageView.image = self.image</span><br><span class="line">        self.addSubview(imageView)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>xib</code>中设置之后，效果图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1422632-8f5c3783488d7392.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>效果图.png</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1422632-dcccc38661463143.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/528" alt="img"></p>
<p>属性框.png</p>
<p><strong>特别注意</strong></p>
<ul>
<li>从<code>xib</code>中取出视图的方式注意，<code>Bundle</code>不要使用<code>Main</code>以免失效。</li>
<li>在<code>draw</code>方法中<code>self.layer.frame</code>是可以得到的，放心使用。</li>
<li>自定义的<code>View</code>在设置圆角，在<code>draw</code>中赋值我使用<code>self.layer.cornerRadius</code>，没有效果，原因不明，故<code>add</code>一个的<code>layer</code>，设置圆角才有效果，原因不明。（知道的请告知下！谢谢）</li>
</ul>
<h3 id="使用IBInspectable和IBDesignable时代码执行顺序"><a href="#使用IBInspectable和IBDesignable时代码执行顺序" class="headerlink" title="使用IBInspectable和IBDesignable时代码执行顺序"></a>使用IBInspectable和IBDesignable时代码执行顺序</h3><p><code>自定义属性的set方法</code>–&gt;<code>draw(_ rect: CGRect)</code>,不再执行<code>init(frame: CGRect)</code></p>
<hr>
<p>最后附上学习<code>Demo</code>以便理解：<br><a href="https://link.jianshu.com/?t=http://git.oschina.net/peterone/ibdesignableandibinspectable" target="_blank" rel="noopener">IBDesignableAndIBInspectable</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> IBDesignable </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS改变UIImageView的image时添加渐变]]></title>
      <url>/2018/06/07/iOS%E6%94%B9%E5%8F%98UIImageView%E7%9A%84image%E6%97%B6%E6%B7%BB%E5%8A%A0%E6%B8%90%E5%8F%98/</url>
      <content type="html"><![CDATA[<p>#</p>
<hr>
<p>当改变UIImageView的image属性时，UI会立刻从一张图片切换到另一张图片，显得十分生硬，本文记录如何为改变UIImageView的image属性时加入淡入淡出的效果。</p>
<p>现在有四张UIImage，初始化后将其存入数组中:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.imgs = @[[<span class="type">UIImage</span> imageNamed:@<span class="string">"bg01"</span>],</span><br><span class="line">              [<span class="type">UIImage</span> imageNamed:@<span class="string">"bg02"</span>],</span><br><span class="line">              [<span class="type">UIImage</span> imageNamed:@<span class="string">"bg03"</span>],</span><br><span class="line">              [<span class="type">UIImage</span> imageNamed:@<span class="string">"bg04"</span>]];</span><br><span class="line"><span class="keyword">self</span>.imageView.image = <span class="keyword">self</span>.imgs[<span class="number">0</span>];<span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>有一按钮，其事件如下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">IBAction</span>)switchImg:(id)sender &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>现在填充其实现来完成UIImageView改变image时加入1秒的淡入淡出</p>
<p>方法1. 使用<code>CATransition</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CATransition</span> *transition = [<span class="type">CATransition</span> animation];</span><br><span class="line">transition.type = kCATransitionFade;</span><br><span class="line">transition.duration = <span class="number">1</span>.0f;</span><br><span class="line">transition.timingFunction = [<span class="type">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">[<span class="keyword">self</span>.imageView.layer addAnimation:transition forKey:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">UIImage</span> *currentImage = <span class="keyword">self</span>.imageView.image;</span><br><span class="line"><span class="type">NSUInteger</span> index = [<span class="keyword">self</span>.imgs indexOfObject:currentImage];</span><br><span class="line">index = (index + <span class="number">1</span>) % [<span class="keyword">self</span>.imgs <span class="built_in">count</span>];</span><br><span class="line"><span class="keyword">self</span>.imageView.image = <span class="keyword">self</span>.imgs[index];<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p>方法2. 使用UIView类方法<code>transitionWithView</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIImage</span> *currentImage = <span class="keyword">self</span>.imageView.image;</span><br><span class="line"><span class="type">NSUInteger</span> index = [<span class="keyword">self</span>.imgs indexOfObject:currentImage];</span><br><span class="line">index = (index + <span class="number">1</span>) % [<span class="keyword">self</span>.imgs <span class="built_in">count</span>];</span><br><span class="line"></span><br><span class="line">[<span class="type">UIView</span> transitionWithView:<span class="keyword">self</span>.imageView duration:<span class="number">1</span> options:<span class="type">UIViewAnimationOptionTransitionCrossDissolve</span> animations:^&#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView.image = <span class="keyword">self</span>.imgs[index];</span><br><span class="line">&#125; completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> UIImageView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift文件管理必知的一些操作]]></title>
      <url>/2018/05/31/Swift%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%BF%85%E7%9F%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p># </p>
<p>转：<a href="https://www.jianshu.com/u/480a52903ce5" target="_blank" rel="noopener">叫我干苦力的码农</a></p>
<p><strong>前言</strong>:作为一个iOS开发人员,我们都了解沙盒机制,每个应用程序都有自己独立的储存空间(大名就是”沙盒”),沙盒是:应用程序只能对自己创建的文件系统读取文件，这个独立、封闭、安全的空间,它一般存放着程序包含的文件(即可执行文件)/图片/音频/视频/plish文件/sqlite数据库及其他文件.<br><strong>然后让我们看一下沙盒的位置及目录文件</strong></p>
<p>. 根目录获取方式</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> home = <span class="type">NSHomeDirectory</span>() <span class="keyword">as</span> <span class="type">NSString</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"沙盒根目录:\\(home)"</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>然后把通过文件查找(如图1所示:),我们就会发现根目录下面的文件夹,具体文件夹如下所述:</strong></p>
<p><strong>.</strong> 根目录下面的文件夹分别是Document / Library / temp</p>
<p>1). Document：一般需要持久的数据都放在此目录中，可以在当中添加子文件夹，iTunes备份和恢复的时候，会包括此目录:<br><em>Document获取方式</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">DocumentPath</span> = <span class="type">NSSearchPathForDirectoriesInDomains</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>,<span class="type">NSSearchPathDomainMask</span>.<span class="type">AllDomainsMask</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>2). temp：创建临时文件的目录，当iOS设备重启时，文件会被自动清除:<br><em>tempPath获取方式</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tempPath = <span class="type">NSSearchPathForDirectoriesInDomains</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">CachesDirectory</span>,<span class="type">NSSearchPathDomainMask</span>.<span class="type">AllDomainsMask</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>3). Library：设置程序的默认设置和其他状态信息:<br><em>Library获取方式</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> libraryPath = <span class="type">NSSearchPathForDirectoriesInDomains</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">LibraryDirectory</span>,<span class="type">NSSearchPathDomainMask</span>.<span class="type">AllDomainsMask</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p><strong>通过上面部分我们了解了沙盒的位置及根目录下面的一切东西,我们就来具体看看怎么对文件和文件夹的操作,操作它我们使用NSFileManager，NSFileHandle等类来实现, 具体操作我也总结以下几点</strong></p>
<p><strong>1. 创建文件夹</strong><br>1).第一种方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDire: <span class="type">String</span> = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/Rookie/Files"</span></span><br><span class="line">   <span class="keyword">let</span> fileManager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">   <span class="keyword">try</span>! fileManager.createDirectoryAtPath(myDire,</span><br><span class="line">                                          withIntermediateDirectories: <span class="literal">true</span>, attributes: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>2).第二种方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSSearchPathDirectory.DocumentDirectory 查找Documents文件夹</span></span><br><span class="line"><span class="comment">// NSSearchPathDomainMask.UserDomainMask 在用户的应用程序下查找</span></span><br><span class="line">    <span class="keyword">let</span> manager2 = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> urlForDocument2 = manager2.<span class="type">URLsForDirectory</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>, inDomains: <span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">        <span class="keyword">let</span> url2 = urlForDocument2[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">        createFolder(<span class="string">"RookieSon"</span>, baseUrl: url2)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createFolder</span><span class="params">(name:String,baseUrl:NSURL)</span></span>&#123;</span><br><span class="line">        <span class="keyword">let</span> manager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> <span class="type">RookieSon</span> = baseUrl.<span class="type">URLByAppendingPathComponent</span>(name, isDirectory: <span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"文件夹: \\(RookieSon)"</span>)</span><br><span class="line">        <span class="keyword">let</span> exist = manager.fileExistsAtPath(<span class="type">RookieSon</span>.path!)</span><br><span class="line">        <span class="keyword">if</span> !exist &#123;</span><br><span class="line">            <span class="keyword">try</span>! manager.createDirectoryAtURL(<span class="type">RookieSon</span>,withIntermediateDirectories: <span class="literal">true</span>, attributes: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种方法我们创建的文件格式是file:// 开头的</li>
</ul>
<p><strong>2. 了解一个具体目录下的所有文件</strong><br>1).对指定路径执行浅搜索，返回指定目录路径下的文件、子目录及符号链接的列表</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentsOfPath = <span class="keyword">try</span>? manager.contentsOfDirectoryAtPath(url.path!)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"contentsOfPath: \\(contentsOfPath)"</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contentsOfPath: <span class="type">Optional</span>([<span class="string">".DS_Store"</span>, <span class="string">"arr.plist"</span>, <span class="string">"Rookie"</span>, <span class="string">"RookieSon"</span>, <span class="string">"RookieString.png"</span>, <span class="string">"RookieString.txt"</span>, <span class="string">"String.png"</span>, <span class="string">"test.txt"</span>])</span><br></pre></td></tr></table></figure>
<p>2).类似上面的，对指定路径执行浅搜索，返回指定目录路径下的文件、子目录及符号链接的列表</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentsOfURL = <span class="keyword">try</span>? manager.contentsOfDirectoryAtURL(url, includingPropertiesForKeys: <span class="literal">nil</span>, options: <span class="type">NSDirectoryEnumerationOptions</span>.<span class="type">SkipsHiddenFiles</span>)</span><br></pre></td></tr></table></figure>
<p>3).深度遍历，会递归遍历子文件夹（但不会递归符号链接）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enumeratorAtPath = manager.enumeratorAtPath(url.path!)</span><br></pre></td></tr></table></figure>
<p>4).类似上面的，深度遍历，会递归遍历子文件夹（但不会递归符号链接）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enumeratorAtURL = manager.enumeratorAtURL(url, includingPropertiesForKeys: <span class="literal">nil</span>, options: <span class="type">NSDirectoryEnumerationOptions</span>.<span class="type">SkipsHiddenFiles</span>, errorHandler:<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>5).深度遍历，会递归遍历子文件夹（包括符号链接，所以要求性能的话用enumeratorAtPath</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subPaths = manager.subpathsAtPath(url.path!)</span><br></pre></td></tr></table></figure>
<p><strong> 3. 判断文件或者我们的文件夹是否存在</strong><br>使用: <code>public func fileExistsAtPath(path: String) -&gt; Bool</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isFileManager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">    <span class="keyword">let</span> isFilePath:<span class="type">String</span> = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/RookieString.txt"</span></span><br><span class="line">    <span class="keyword">let</span> exist = isFileManager.fileExistsAtPath(isFilePath)</span><br><span class="line">    <span class="built_in">print</span>(exist)</span><br></pre></td></tr></table></figure>
<p><strong>4. 将对象写入指定文件中</strong><br>使用:<br><code>public func writeToFile(path: String, atomically useAuxiliaryFile: Bool, encoding enc: NSStringEncoding) throws</code><br><code>public func writeToFile(path: String, atomically useAuxiliaryFile: Bool) -&gt; Bool</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>).将<span class="type">String</span>保存到文件夹中</span><br><span class="line">    <span class="keyword">let</span> <span class="type">StringPath</span>: <span class="type">String</span> = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/RookieString.txt"</span></span><br><span class="line">            <span class="keyword">let</span> stringInfo = <span class="string">"存储的String"</span></span><br><span class="line">            <span class="keyword">try</span>! stringInfo.writeToFile(<span class="type">StringPath</span>, atomically: <span class="literal">true</span>, encoding: <span class="type">NSUTF8StringEncoding</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"String存储文件位置 : \\(StringPath)"</span>)</span><br><span class="line"> <span class="number">2</span>).将<span class="type">Image</span>保存到文件中</span><br><span class="line"><span class="keyword">let</span> imagePath:<span class="type">String</span> = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/String.png"</span></span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>(named: <span class="string">"1"</span>)</span><br><span class="line"> <span class="number">3</span>).将数组保存到文件中</span><br><span class="line">     <span class="keyword">let</span> imageData:<span class="type">NSData</span> = <span class="type">UIImagePNGRepresentation</span>(image!)!</span><br><span class="line">        imageData.writeToFile(imagePath, atomically: <span class="literal">true</span>)</span><br><span class="line"> <span class="number">4</span>).将字典保存到文件中</span><br><span class="line">     <span class="keyword">let</span> arr = <span class="type">NSArray</span>(objects:<span class="string">"Rookie"</span>,<span class="string">"YX"</span>,<span class="string">"fight"</span>)</span><br><span class="line">        <span class="keyword">let</span> arrayPath: <span class="type">String</span> = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/arr.plist"</span></span><br><span class="line">        arr.writeToFile(arrayPath, atomically: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p><strong>5. 创建文件</strong><br>使用:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">URLsForDirectory</span><span class="params">(directory: NSSearchPathDirectory, inDomains domainMask: NSSearchPathDomainMask)</span></span> -&gt; [<span class="type">NSURL</span>]</span><br><span class="line"></span><br><span class="line"> <span class="comment">//在文档目录下新建test.txt文件</span></span><br><span class="line">    <span class="keyword">let</span> testManager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">    <span class="keyword">let</span> testurlForDocument = testManager.<span class="type">URLsForDirectory</span>( <span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>,</span><br><span class="line">                                                           inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">    <span class="keyword">let</span> testUrl = testurlForDocument[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">    createFile(<span class="string">"test.txt"</span>, fileBaseUrl: testUrl)</span><br><span class="line"><span class="comment">//  创建文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">createFile</span><span class="params">(name:String,fileBaseUrl:NSURL)</span></span>&#123;</span><br><span class="line">        <span class="keyword">let</span> manager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> file = fileBaseUrl.<span class="type">URLByAppendingPathComponent</span>(name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"文件: \\(file)"</span>)</span><br><span class="line">        <span class="keyword">let</span> exist = manager.fileExistsAtPath(file.path!)</span><br><span class="line">        <span class="keyword">if</span> !exist &#123;</span><br><span class="line">            <span class="keyword">let</span> data = <span class="type">NSData</span>(base64EncodedString:<span class="string">"aGVsbG8gd29ybGQ="</span>,options:.<span class="type">IgnoreUnknownCharacters</span>)</span><br><span class="line">            <span class="keyword">let</span> createSuccess = manager.createFileAtPath(file.path!,contents:data,attributes:<span class="literal">nil</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"文件创建结果: \\(createSuccess)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>6. 对文件进行复制</strong><br>1).第一种方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> copyManager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> homeDirectory = <span class="type">NSHomeDirectory</span>()</span><br><span class="line">        <span class="keyword">let</span> fromUrl = homeDirectory + <span class="string">"/Documents/RookieString.txt"</span></span><br><span class="line">        <span class="keyword">let</span> toUrl = homeDirectory + <span class="string">"/Documents/copyed.txt"</span></span><br><span class="line">        <span class="keyword">try</span>! copyManager.copyItemAtPath(fromUrl, toPath: toUrl)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2).定位到用户文档目录:</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> copyManager2 = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> copyUrlForDocument2 = copyManager2.<span class="type">URLsForDirectory</span>( <span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>, inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">        <span class="keyword">let</span> copyUrl2 = copyUrlForDocument2[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">        <span class="comment">// 将test.txt文件拷贝到文档目录根目录下的copyed.txt文件</span></span><br><span class="line">        <span class="keyword">let</span> fromUrl2 = copyUrl2.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"/Documents/RookieString.txt"</span>)</span><br><span class="line">        <span class="keyword">let</span> toUrl2 = copyUrl2.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"copyed.txt"</span>)</span><br><span class="line">        <span class="keyword">try</span>! copyManager2.copyItemAtURL(fromUrl2, toURL: toUrl2)</span><br></pre></td></tr></table></figure>
<p><strong>7. 移动文件夹</strong><br>1).第一种方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> moveManager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> moveHomeDirectory = <span class="type">NSHomeDirectory</span>()</span><br><span class="line">        <span class="keyword">let</span> moveFromUrl = moveHomeDirectory + <span class="string">"/Documents/hangge.txt"</span></span><br><span class="line">        <span class="keyword">let</span> moveToUrl = moveHomeDirectory + <span class="string">"/Documents/moved"</span></span><br><span class="line">        <span class="keyword">try</span>! moveManager.moveItemAtPath(moveFromUrl, toPath: moveToUrl)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2).定位到用户文档目录:</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> moveManager2 = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> moveHomeDirectory2 = moveManager2.<span class="type">URLsForDirectory</span>( <span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>, inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">        <span class="keyword">let</span> moveUrl = moveHomeDirectory2[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> moveFromUrl2 = moveUrl.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"test.txt"</span>)</span><br><span class="line">        <span class="keyword">let</span> moveToUrl2 = moveUrl.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"copyed.txt"</span>)</span><br><span class="line">        <span class="comment">// 移动srcUrl中的文件（test.txt）到toUrl中（copyed.txt）</span></span><br><span class="line">        <span class="keyword">try</span>! moveManager2.moveItemAtURL(moveFromUrl2, toURL: moveToUrl2)</span><br></pre></td></tr></table></figure>
<p><strong>8. 删除文件</strong><br>1).第一种方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">DelectManager</span> = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> <span class="type">DelectFromUrl</span> = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/hangge.txt"</span></span><br><span class="line">        <span class="keyword">try</span>! <span class="type">DelectManager</span>.removeItemAtPath(<span class="type">DelectFromUrl</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2).定位到用户文档目录:</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">Delectmanager</span> = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> <span class="type">DelecturlForDocument</span> = <span class="type">Delectmanager</span>.<span class="type">URLsForDirectory</span>( <span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>,</span><br><span class="line">                                                                   inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="type">Delecturl</span> = <span class="type">DelecturlForDocument</span>[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="type">DelecttoUrl</span> = <span class="type">Delecturl</span>.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"copyed.txt"</span>)</span><br><span class="line">        <span class="comment">// 删除文档根目录下的toUrl路径的文件（copyed.txt文件）</span></span><br><span class="line">        <span class="keyword">try</span>! <span class="type">Delectmanager</span>.removeItemAtURL(<span class="type">DelecttoUrl</span>)</span><br></pre></td></tr></table></figure>
<p><strong>9. 删除目录下所有的文件</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：获取所有文件，然后遍历删除</span></span><br><span class="line">        <span class="keyword">let</span> <span class="type">DelectAllManager</span> = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> <span class="type">DelectAllmyDirectory</span> = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/Files"</span></span><br><span class="line">        <span class="keyword">let</span> <span class="type">DelectAllfileArray</span>:[<span class="type">AnyObject</span>]? = <span class="type">DelectAllManager</span>.subpathsAtPath(<span class="type">DelectAllmyDirectory</span>)</span><br><span class="line">        <span class="keyword">for</span> fn <span class="keyword">in</span> <span class="type">DelectAllfileArray</span>!&#123;</span><br><span class="line">            <span class="keyword">try</span>! <span class="type">DelectAllManager</span>.removeItemAtPath(<span class="type">DelectAllmyDirectory</span> + <span class="string">"/\\(fn)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法2：删除目录后重新创建该目录</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="type">DelectAllfileManager2</span> = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> <span class="type">DelectAllmyDirectory2</span> = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/Files"</span></span><br><span class="line">        <span class="keyword">try</span>! <span class="type">DelectAllfileManager2</span>.removeItemAtPath(<span class="type">DelectAllmyDirectory2</span>)</span><br><span class="line">        <span class="keyword">try</span>! <span class="type">DelectAllfileManager2</span>.createDirectoryAtPath(<span class="type">DelectAllmyDirectory2</span>, withIntermediateDirectories: <span class="literal">true</span>,</span><br><span class="line">                                                         attributes: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><strong>10. 读取我们所建的文</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">       <span class="keyword">let</span> urlsForDocDirectory = manager.<span class="type">URLsForDirectory</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>, inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">       <span class="keyword">let</span> docPath:<span class="type">NSURL</span> = urlsForDocDirectory[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">       <span class="keyword">let</span> file = docPath.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"test.txt"</span>)</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//方法1</span></span><br><span class="line">       <span class="keyword">let</span> readHandler = <span class="keyword">try</span>! <span class="type">NSFileHandle</span>(forReadingFromURL:file)</span><br><span class="line">       <span class="keyword">let</span> data = readHandler.readDataToEndOfFile()</span><br><span class="line">       <span class="keyword">let</span> readString = <span class="type">NSString</span>(data: data, encoding: <span class="type">NSUTF8StringEncoding</span>)</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"文件内容: \\(readString)"</span>)</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//方法2</span></span><br><span class="line">       <span class="keyword">let</span> data1 = manager.contentsAtPath(file.path!)</span><br><span class="line">       <span class="keyword">let</span> readString1 = <span class="type">NSString</span>(data: data1!, encoding: <span class="type">NSUTF8StringEncoding</span>)</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"文件内容: \\(readString1)"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>11. 在任意位置写入数据</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> urlsForDocDirectory = manager.<span class="type">URLsForDirectory</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>, inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">        <span class="keyword">let</span> docPath:<span class="type">NSURL</span> = urlsForDocDirectory[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">        <span class="keyword">let</span> file = docPath.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"test.txt"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> string = <span class="string">"添加一些文字到文件末尾"</span></span><br><span class="line">        <span class="keyword">let</span> appendedData = string.dataUsingEncoding(<span class="type">NSUTF8StringEncoding</span>, allowLossyConversion: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">let</span> writeHandler = <span class="keyword">try</span>? <span class="type">NSFileHandle</span>(forWritingToURL:file)</span><br><span class="line">        writeHandler!.seekToEndOfFile()</span><br><span class="line">        writeHandler!.writeData(appendedData!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// MARK:-  文件权限判断</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">fliesManagerPower</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">let</span> manager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> urlsForDocDirectory = manager.<span class="type">URLsForDirectory</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>, inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">        <span class="keyword">let</span> docPath:<span class="type">NSURL</span> = urlsForDocDirectory[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">        <span class="keyword">let</span> file = docPath.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"test.txt"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> readable = manager.isReadableFileAtPath(file.path!)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"可读: \\(readable)"</span>)</span><br><span class="line">        <span class="keyword">let</span> writeable = manager.isWritableFileAtPath(file.path!)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"可写: \\(writeable)"</span>)</span><br><span class="line">        <span class="keyword">let</span> executable = manager.isExecutableFileAtPath(file.path!)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"可执行: \\(executable)"</span>)</span><br><span class="line">        <span class="keyword">let</span> deleteable = manager.isDeletableFileAtPath(file.path!)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"可删除: \\(deleteable)"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//         获取文件属性（创建时间，修改时间，文件大小，文件类型等信息）</span></span><br><span class="line">        <span class="keyword">let</span> manager1 = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">        <span class="keyword">let</span> urlsForDocDirectory1 = manager1.<span class="type">URLsForDirectory</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>,</span><br><span class="line">                                                             inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">        <span class="keyword">let</span> docPath1:<span class="type">NSURL</span> = urlsForDocDirectory1[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">        <span class="keyword">let</span> file1 = docPath1.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"test.txt"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> attributes = <span class="keyword">try</span>? manager.attributesOfItemAtPath(file1.path!) <span class="comment">//结果为AnyObject类型</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"attributes: \\(attributes!)"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>12. 文件权限判断</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">       <span class="keyword">let</span> urlsForDocDirectory = manager.<span class="type">URLsForDirectory</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>, inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">       <span class="keyword">let</span> docPath:<span class="type">NSURL</span> = urlsForDocDirectory[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">       <span class="keyword">let</span> file = docPath.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"test.txt"</span>)</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">let</span> readable = manager.isReadableFileAtPath(file.path!)</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"可读: \\(readable)"</span>)</span><br><span class="line">       <span class="keyword">let</span> writeable = manager.isWritableFileAtPath(file.path!)</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"可写: \\(writeable)"</span>)</span><br><span class="line">       <span class="keyword">let</span> executable = manager.isExecutableFileAtPath(file.path!)</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"可执行: \\(executable)"</span>)</span><br><span class="line">       <span class="keyword">let</span> deleteable = manager.isDeletableFileAtPath(file.path!)</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"可删除: \\(deleteable)"</span>)</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//         获取文件属性（创建时间，修改时间，文件大小，文件类型等信息）</span></span><br><span class="line">       <span class="keyword">let</span> manager1 = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">       <span class="keyword">let</span> urlsForDocDirectory1 = manager1.<span class="type">URLsForDirectory</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>,</span><br><span class="line">                                                            inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">       <span class="keyword">let</span> docPath1:<span class="type">NSURL</span> = urlsForDocDirectory1[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">       <span class="keyword">let</span> file1 = docPath1.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"test.txt"</span>)</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">let</span> attributes = <span class="keyword">try</span>? manager.attributesOfItemAtPath(file1.path!) <span class="comment">//结果为AnyObject类型</span></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"attributes: \\(attributes!)"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>13. 获取文件属性（创建时间，修改时间，文件大小，文件类型等信息)</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line"><span class="keyword">let</span> urlsForDocDirectory = manager.<span class="type">URLsForDirectory</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>,</span><br><span class="line">    inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line"><span class="keyword">let</span> docPath:<span class="type">NSURL</span> = urlsForDocDirectory[<span class="number">0</span>] **<span class="keyword">as</span>** <span class="type">NSURL</span></span><br><span class="line"><span class="keyword">let</span> file = docPath.<span class="type">URLByAppendingPathComponent</span>(<span class="string">"test.txt"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> attributes = <span class="keyword">try</span>? manager.attributesOfItemAtPath(file.path!) <span class="comment">//结果为AnyObject类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"attributes: \\(attributes!)"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>14. 文件/文件夹比较</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">       <span class="keyword">let</span> urlsForDocDirectory = manager.<span class="type">URLsForDirectory</span>(<span class="type">NSSearchPathDirectory</span>.<span class="type">DocumentDirectory</span>,</span><br><span class="line">                                                          inDomains:<span class="type">NSSearchPathDomainMask</span>.<span class="type">UserDomainMask</span>)</span><br><span class="line">       <span class="keyword">let</span> docPath:<span class="type">NSURL</span> = urlsForDocDirectory[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSURL</span></span><br><span class="line">       <span class="keyword">let</span> contents = <span class="keyword">try</span>! manager.contentsOfDirectoryAtPath(docPath.path!)</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//下面比较前面两个文件是否内容相同（该方法也可以用来比较目录）</span></span><br><span class="line">       <span class="keyword">let</span> <span class="built_in">count</span> = contents.<span class="built_in">count</span></span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">count</span> &gt; <span class="number">1</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> path1 = docPath.path! + <span class="string">"/"</span> + (contents[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">String</span>)</span><br><span class="line">           <span class="keyword">let</span> path2 = docPath.path! + <span class="string">"/"</span> + (contents[<span class="number">1</span>] <span class="keyword">as</span> <span class="type">String</span>)</span><br><span class="line">           <span class="keyword">let</span> <span class="built_in">equal</span> = manager.contentsEqualAtPath(path1,andPath:path2)</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">"比较结果: \\(equal)"</span>)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> files </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hit-test view扩大UIButton的响应热区]]></title>
      <url>/2018/05/30/Hit-test%20view%E6%89%A9%E5%A4%A7UIButton%E7%9A%84%E5%93%8D%E5%BA%94%E7%83%AD%E5%8C%BA/</url>
      <content type="html"><![CDATA[<p>## </p>
<p>相信大家都遇到小图button点击热区太小问题，各种计算不说，写出的代码还很难看不便于维护，如果我们用用<em>hit-test view</em>的知识你就能轻松地解决这个问题。</p>
<p>直接上代码 我用的extension UIButton ，也可自行调整到自定义button中</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIButton</span> </span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RuntimeKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> minimumHitTestWidth = <span class="type">UnsafeRawPointer</span>.<span class="keyword">init</span>(bitPattern: <span class="string">"minimumHitTestWidth"</span>.hashValue)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> minimumHitTestHeight = <span class="type">UnsafeRawPointer</span>.<span class="keyword">init</span>(bitPattern: <span class="string">"minimumHitTestHeight"</span>.hashValue)     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> minimumHitTestWidth:<span class="type">CGFloat</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line"></span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, <span class="type">UIButton</span>.<span class="type">RuntimeKey</span>.minimumHitTestWidth!, newValue, .<span class="type">OBJC_ASSOCIATION_COPY_NONATOMIC</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>  objc_getAssociatedObject(<span class="keyword">self</span>, <span class="type">UIButton</span>.<span class="type">RuntimeKey</span>.minimumHitTestWidth!) <span class="keyword">as</span>? <span class="type">CGFloat</span> ?? <span class="number">40</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> minimumHitTestHeight:<span class="type">CGFloat</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line"></span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, <span class="type">UIButton</span>.<span class="type">RuntimeKey</span>.minimumHitTestHeight!, newValue, .<span class="type">OBJC_ASSOCIATION_COPY_NONATOMIC</span>)</span><br><span class="line"></span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>  objc_getAssociatedObject(<span class="keyword">self</span>, <span class="type">UIButton</span>.<span class="type">RuntimeKey</span>.minimumHitTestHeight!) <span class="keyword">as</span>? <span class="type">CGFloat</span> ?? <span class="number">40</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">point</span><span class="params">(inside point: CGPoint, with event: UIEvent?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hitTestingBounds(<span class="keyword">self</span>.bounds, <span class="keyword">self</span>.minimumHitTestWidth, <span class="keyword">self</span>.minimumHitTestHeight).<span class="built_in">contains</span>(point)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hitTestingBounds</span><span class="params">(<span class="number">_</span> bounds:CGRect,<span class="number">_</span> minimumHitTestWidth:CGFloat,<span class="number">_</span> minimumHitTestHeight:CGFloat)</span></span> -&gt; <span class="type">CGRect</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> hitTestingBounds : <span class="type">CGRect</span> = bounds;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minimumHitTestWidth &gt; bounds.size.width) &#123;</span><br><span class="line"></span><br><span class="line">            hitTestingBounds.size.width = minimumHitTestWidth;</span><br><span class="line"></span><br><span class="line">            hitTestingBounds.origin.x -= (hitTestingBounds.size.width - bounds.size.width)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minimumHitTestHeight &gt; bounds.size.height) &#123;</span><br><span class="line"></span><br><span class="line">            hitTestingBounds.size.height = minimumHitTestHeight;</span><br><span class="line"></span><br><span class="line">            hitTestingBounds.origin.y -= (hitTestingBounds.size.height - bounds.size.height)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hitTestingBounds; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> UIButton </tag>
            
            <tag> swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift3.0朝圣之路-使用Runtime在分类Extension中添加属性]]></title>
      <url>/2018/05/30/Swift3.0%E6%9C%9D%E5%9C%A3%E4%B9%8B%E8%B7%AF-%E4%BD%BF%E7%94%A8Runtime%E5%9C%A8%E5%88%86%E7%B1%BBExtension%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>我最近自学Swift3.0，由于之前没学过Swift，只能将OC的代码“翻译”成Swift，在此过程慢慢学习Swift，Swift3.0的资料少，遇到了不少坑，今天就介绍一个。</p>
<p>在OC里面，咱给分类添加属性是这么写的，即使用<code>Runtime</code>中的<code>objc_setAssociatedObject</code>和<code>objc_getAssociatedObject</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setQuickTapEnable:(BOOL)quickTapEnable&#123;</span><br><span class="line">    objc_setAssociatedObject(self, JKSecurityButtonQuickTapEnableKey, @(quickTapEnable), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)quickTapEnable&#123;</span><br><span class="line">    return [objc_getAssociatedObject(self, JKSecurityButtonQuickTapEnableKey) boolValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这次咱用Swift3.0给ViewController的Extension（相当于OC里面的Category）添加一个属性JKPro，赋值后再取出来打印，练练手。<br>ViewControll类文件的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.jkPro = <span class="string">"通过类别拓展的属性"</span></span><br><span class="line">        <span class="type">NSLog</span>(<span class="keyword">self</span>.jkPro!)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"标记"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewControll Extension文件的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 平常写法[不推荐]</span></span><br><span class="line">    <span class="keyword">var</span> jkPro: <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">"key"</span>, newValue, .<span class="type">OBJC_ASSOCIATION_COPY_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="string">"key"</span>) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你觉得有问题吗？ 我告诉你，有<br>运行多次后会出现随机性的崩溃，也就是说基本上能正常运行和打印结果，但是偶尔会出现崩溃，<del>我也一直没找到根本原因</del>，不过找到了解决方案。<br>崩溃后会进入下面的界面：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/129450-bb2ff30bf60ab4d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>常规写法崩溃</p>
<p>运行10次左右会随机出现崩溃，提示</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: unexpectedly found <span class="literal">nil</span> <span class="keyword">while</span> unwrapping an <span class="type">Optional</span> value</span><br></pre></td></tr></table></figure>
<p>，也就是中间出现了nil</p>
<p>再看看崩溃点的代码： 解包出错！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/129450-c2dc4f1b0c85a4f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>常规写法崩溃信息</p>
<p>那就从源头找问题，后面改成下面写法来测试崩溃，运行多次后发现是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_getAssociatedObject</span><br></pre></td></tr></table></figure>
<p>返回的值为nil，导致解包崩溃。</p>
<p>有时正常，有时nil，什么鬼❓❓❓❓❓❓</p>
<p><img src="https://upload-images.jianshu.io/upload_images/129450-3b46460e62b81f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>常规写法崩溃信息</p>
<p>再看看<code>objc_setAssociatedObject</code>函数方法，用到了<code>UnsafeRawPointer</code>类型的参数，没接触过，那就从<code>UnsafeRawPointer</code>入手</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">objc_setAssociatedObject</span><span class="params">(<span class="number">_</span> object: Any!, <span class="number">_</span> key: UnsafeRawPointer!, <span class="number">_</span> value: Any!, <span class="number">_</span> policy: objc_AssociationPolicy)</span></span></span><br></pre></td></tr></table></figure>
<p>通常咱用字符串来命名以及区分Key值，然而<code>UnsafeRawPointer</code>并没有<code>String</code>参数的init方法，倒是有个<code>Int</code>参数的init方法，但是咱不能用数字做Key吧，队友一看代码能知道啥意思吗？庆幸的是<code>String</code>的<code>hashValue (哈希值)</code>可以返回Int值，而字符串的哈希值和字符串是一一对应的，测试多次都没出现崩溃，完美。<br>下面就是一种解决方案，应该还有其他的，只是等着大家去发现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///  推荐写法</span></span><br><span class="line"><span class="keyword">var</span> jkPro: <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> key: <span class="type">UnsafeRawPointer</span>! = <span class="type">UnsafeRawPointer</span>.<span class="keyword">init</span>(bitPattern: <span class="string">"key"</span>.hashValue)</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, key, newValue, .<span class="type">OBJC_ASSOCIATION_COPY_NONATOMIC</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> key: <span class="type">UnsafeRawPointer</span>! = <span class="type">UnsafeRawPointer</span>.<span class="keyword">init</span>(bitPattern: <span class="string">"key"</span>.hashValue)</span><br><span class="line">        <span class="keyword">let</span> obj: <span class="type">String</span>? = objc_getAssociatedObject(<span class="keyword">self</span>, key) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="————————-继续改进————————"><a href="#————————-继续改进————————" class="headerlink" title="————————-继续改进————————-"></a>————————-继续改进————————-</h2><p>之前崩溃原因已找到，之所以出现nil，是因为2次使用的<code>Key</code>内存地址不一样导致的，即取值和设值的Key内存地址不一样导致取出nil，解包nil崩溃。<br>同一字符串的哈希值是一样的，所以方向是对的，于是下午继续优化了下。使用结构体<code>struct</code>作为容器声明不同的Key，以后改也只要一个改地方就行，便于管理，而且相比上午的写法代码量更少，更简洁。<br>如果有其他的思路，欢迎一起讨论。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进写法【推荐】</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RuntimeKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> jkKey = <span class="type">UnsafeRawPointer</span>.<span class="keyword">init</span>(bitPattern: <span class="string">"JKKey"</span>.hashValue)</span><br><span class="line">    <span class="comment">/// ...其他Key声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jkPro: <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, <span class="type">ViewController</span>.<span class="type">RuntimeKey</span>.jkKey, newValue, .<span class="type">OBJC_ASSOCIATION_COPY_NONATOMIC</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  objc_getAssociatedObject(<span class="keyword">self</span>, <span class="type">ViewController</span>.<span class="type">RuntimeKey</span>.jkKey) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<p>我所有Swift3.0练习Demo都放到了Github上，并且在不断更新。<br>转：<a href="https://link.jianshu.com/?t=https://github.com/XiFengLang/Swift3.0-" target="_blank" rel="noopener">Swift3.0朝圣之路-全集地址</a></p>
<p>&gt;</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Runtime </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS事件响应链中Hit-Test View的应用]]></title>
      <url>/2018/05/30/iOS%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E9%93%BE%E4%B8%ADHit-Test%20View%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p># </p>
<p>转载：<a href="https://www.jianshu.com/u/f3ee59f55183" target="_blank" rel="noopener">孙大龙Lemon</a></p>
<p>**关注</p>
<p>2015.12.12 11:19* 字数 1421 阅读 22015评论 15喜欢 150</p>
<p>最近又看了遍苹果的官方文档<a href="https://link.jianshu.com/?t=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Fios%2Fdocumentation%2FEventHandling%2FConceptual%2FEventHandlingiPhoneOS%2Fevent_delivery_responder_chain%2Fevent_delivery_responder_chain.html" target="_blank" rel="noopener">《Event Handling Guide for iOS》</a>，对事件响应链中的<strong>hit-test view</strong> 又多了些理解，个人觉的官方文档对这块讲的非常简单，很多东西都是点到为止，<strong>hit-test view</strong>的知识在项目的任何地方都用到了，但自己反而感知不到，接下来我会给大家讲<strong>hit-test view</strong>的原理，以及项目中能解决痛点的三个应用 。<br><a id="more"></a><br>什么叫 <strong>hit-test view</strong>？文档说：<em>The lowest view in the view hierarchy that contains the touch point becomes the hit-test view</em>，我的理解是：当你点击了屏幕上的某个view，这个动作由硬件层传导到操作系统，然后又从底层封装成一个事件（Event）顺着view的层级往上传导，一直要找到含有这个点击点<strong>且</strong>层级最高（文档说是最低，我理解是视图树的根节点，或者最靠近你的手指的view）的view来响应事件，这个view就是<strong>hit-test view</strong>。</p>
<p>文档中说，决定谁<strong>hit-test view</strong>是通过不断递归调用view中的 <em>- (UIView \</em>)hitTest: withEvent:<em> 方法和 </em>-(BOOL)pointInside: withEvent:* 方法来实现的，文段中的这段话太好理解，于是我仿照官方文档中这张图做了个Demo -&gt; <a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fslemon%2FHitTestViewUsage" target="_blank" rel="noopener">Github地址</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/144142-3afc2c85792ade41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="img"></p>
<p>apple doucument pic</p>
<p>重载图中view的方法添加相应的log便于观察：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//in every view .m overide those methods</span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;进入A_View---hitTest withEvent ---&quot;);</span><br><span class="line">    UIView * view = [super hitTest:point withEvent:event];</span><br><span class="line">    NSLog(@&quot;离开A_View--- hitTest withEvent ---hitTestView:%@&quot;,view);</span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;A_view--- pointInside withEvent ---&quot;);</span><br><span class="line">    BOOL isInside = [super pointInside:point withEvent:event];</span><br><span class="line">    NSLog(@&quot;A_view--- pointInside withEvent --- isInside:%d&quot;,isInside);</span><br><span class="line">    return isInside;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;A_touchesBegan&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;A_touchesMoved&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;A_touchesEnded&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击图中View_D，看下会发生什么</p>
<p><img src="https://upload-images.jianshu.io/upload_images/144142-9850f716526bb4e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>View_D log</p>
<p>一是发现<em>touchesBegan、touchesMoved、touchesEnded</em>这些方法都是发生在找到<strong>hit-test view</strong>之后，因为touch事件是针对能响应事件的确定的某个view，比如你手指划出了scrollview的范围，只要你不松手继续滑动，scrollview依然会响应滑动事件继续滚动；二是寻找<strong>hit-test view</strong>的事件链传导了两遍，而且两次的调用堆栈是不同的，这点我有点搞不懂，为啥需要两遍，查阅了很多资料也不知道原因，发现真机和模拟器以及不同的系统版本之间还会有些区别（此为真机iOS9），大家可以下载我的<a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fslemon%2FHitTestViewUsage" target="_blank" rel="noopener">Demo</a>进行测试与研究。</p>
<p>把这个寻找的逻辑换成代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([self pointInside:point withEvent:event]) &#123;</span><br><span class="line">        for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123;</span><br><span class="line">            CGPoint convertedPoint = [subview convertPoint:point fromView:self];</span><br><span class="line">            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];</span><br><span class="line">            if (hitTestView) &#123;</span><br><span class="line">                return hitTestView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return self;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有某个view的两个子view位置重叠，根据<a href="https://link.jianshu.com/?t=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Fios%2Fdocumentation%2FWindowsViews%2FConceptual%2FViewPG_iPhoneOS%2FWindowsandViews%2FWindowsandViews.html%23%2F%2Fapple_ref%2Fdoc%2Fuid%2FTP40009503-CH2-SW24" target="_blank" rel="noopener">View Programming Guide for iOS</a>文档中说的 <em>Visually, the content of a subview obscures all or part of the content of its parent view. If the subview is totally opaque, then the area occupied by the subview completely obscures the corresponding area of the parent. If the subview is partially transparent, the content from the two views is blended together prior to being displayed on the screen. Each superview stores its subviews in an ordered array and the order in that array also affects the visibility of each subview. If two sibling subviews overlap each other, the one that was added last (or was moved to the end of the subview array) appears on top of the other.</em> 那最高层（逻辑最靠近手指的）view是view subviews数组的最后一个元素，只要寻找是从数组的第一个元素开始遍历，hit-test view的逻辑依然是有效的。</p>
<p>找到<strong>hit-test view</strong>后，它会有最高的优先权去响应逐级传递上来的Event，如它不能响应就会传递给它的superview，依此类推，一直传递到UIApplication都无响应者，这个Event就会被系统丢弃了。</p>
<h2 id="Hit-test-view的应用举例："><a href="#Hit-test-view的应用举例：" class="headerlink" title="Hit-test view的应用举例："></a>Hit-test view的应用举例：</h2><h3 id="1、扩大UIButton的响应热区"><a href="#1、扩大UIButton的响应热区" class="headerlink" title="1、扩大UIButton的响应热区"></a>1、扩大UIButton的响应热区</h3><p>相信大家都遇到小图button点击热区太小问题，之前我是用UIButton的<em>setImage</em>方法来设置图片解决，但是调起坐标就坑了，得各种计算不说，写出的代码还很难看不便于维护，如果我们用用<em>hit-test view</em>的知识你就能轻松地解决这个问题。</p>
<p>重载UIButton的<em>-(BOOL)pointInside: withEvent:</em>方法，让Point即使落在Button的Frame外围也返回YES。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//in custom button .m</span><br><span class="line">//overide this method</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    return CGRectContainsPoint(HitTestingBounds(self.bounds, self.minimumHitTestWidth, self.minimumHitTestHeight), point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGRect HitTestingBounds(CGRect bounds, CGFloat minimumHitTestWidth, CGFloat minimumHitTestHeight) &#123;</span><br><span class="line">    CGRect hitTestingBounds = bounds;</span><br><span class="line">    if (minimumHitTestWidth &gt; bounds.size.width) &#123;</span><br><span class="line">        hitTestingBounds.size.width = minimumHitTestWidth;</span><br><span class="line">        hitTestingBounds.origin.x -= (hitTestingBounds.size.width - bounds.size.width)/2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (minimumHitTestHeight &gt; bounds.size.height) &#123;</span><br><span class="line">        hitTestingBounds.size.height = minimumHitTestHeight;</span><br><span class="line">        hitTestingBounds.origin.y -= (hitTestingBounds.size.height - bounds.size.height)/2;</span><br><span class="line">    &#125;</span><br><span class="line">    return hitTestingBounds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、子view超出了父view的bounds响应事件"><a href="#2、子view超出了父view的bounds响应事件" class="headerlink" title="2、子view超出了父view的bounds响应事件"></a>2、子view超出了父view的bounds响应事件</h3><p>项目中常常遇到button已经超出了父view的范围但仍需可点击的情况，比如自定义Tabbar中间的大按钮，如下图闲鱼的app，点击超出Tabbar bounds的区域也需要响应，此时重载父view的<em>-(UIView \</em>)hitTest: withEvent:<em>方法，去掉点击必须在父view内的判断，然后子view就能成为 <em>*hit-test view</em></em>用于响应事件了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/144142-3b8eacb1afb47c93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="img"></p>
<p>xiansyu</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *  此注释掉的方法用来判断点击是否在父View Bounds内，</span><br><span class="line">     *  如果不在父view内，就会直接不会去其子View中寻找HitTestView，return 返回</span><br><span class="line">     */</span><br><span class="line">//    if ([self pointInside:point withEvent:event]) &#123;</span><br><span class="line">        for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123;</span><br><span class="line">            CGPoint convertedPoint = [subview convertPoint:point fromView:self];</span><br><span class="line">            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];</span><br><span class="line">            if (hitTestView) &#123;</span><br><span class="line">                return hitTestView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return self;</span><br><span class="line">//    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、ScrollView-page滑动"><a href="#3、ScrollView-page滑动" class="headerlink" title="3、ScrollView page滑动"></a>3、ScrollView page滑动</h3><p>这是app store 应用的app封面预览功能</p>
<p><img src="https://upload-images.jianshu.io/upload_images/144142-cee9b6532795a034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="img"></p>
<p>scrollview page</p>
<p>上图的交互常常见于很多海报、封面展示的app，实现这个交互的方法有很多，但选择用scrollView来横向滑动来做是最简单的，让scrollview.pageEnabel = YES，就有了翻页的感觉，但这样scoreView的实际可滑动区域就只有一张照片那么宽，如果想让边侧留出的距离(蓝色框部分)响应滑动事件的话应该怎么办呢？这个时候又可以用到hit-test view的知识了，在scrollview的父view中把蓝色部分的事件都传递给scrollView就可以了，具体看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//in scrollView.superView .m</span><br><span class="line"></span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *hitTestView = [super hitTest:point withEvent:event];</span><br><span class="line">    if (hitTestView) &#123;</span><br><span class="line">        hitTestView = self.scrollView;</span><br><span class="line">    &#125;</span><br><span class="line">    return hitTestView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事件响应链是UI层一个非常重要的概念，想做出非常棒的交互和动画，必须对其有一个深入的理解。我列举的只是我在开发中遇到的一些问题，如果有其他的对事件响应链的应用希望大家和我一起交流探讨。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> 响应链 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[窥探Swift之数组安全索引与数组切片]]></title>
      <url>/2018/05/28/%E7%AA%A5%E6%8E%A2Swift%E4%B9%8B%E6%95%B0%E7%BB%84%E5%AE%89%E5%85%A8%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/</url>
      <content type="html"><![CDATA[<h1 id="窥探Swift之数组安全索引与数组切片"><a href="#窥探Swift之数组安全索引与数组切片" class="headerlink" title="窥探Swift之数组安全索引与数组切片"></a><a href="https://www.cnblogs.com/ludashi/p/5179275.html" target="_blank" rel="noopener">窥探Swift之数组安全索引与数组切片</a></h1><p>　　今天是元宵节，祝大家元宵节快乐！在Swift中的数组和字典中下标是非常常见的，数组可以通过索引下标进行元素的查询，字典可以通过键下标来获取相应的值。在使用数组时，一个常见的致命错误就是数组越界。如果在你的应用程序中数组越界了，那么对不起，如果由着程序的性子的话是会崩溃的。为了防止崩溃呢，我们会对集合做一些安全的处理。比如对数组进行扩展，从而对数组的索引进行安全检查，保证数组的index在正常范围内。在Objective-C中也是经常对数组，字典等做一些处理操作。</p>
<p>　　今天的博客的主要内容是先对Objective-C中常用集合的安全扩展进行介绍，由此在窥探一下Swift语言中的处理。并且还会介绍Swift中自定义下标，说白了自定义下标其实就是通过下标的形式与特定的下标值来访问一个对象。自定义下标在有些场合中是非常实用的。然后下方还会给出数组切片的概念与实用方式。废话少说进入今天的主题。</p>
<p>一、安全的索引集合元素</p>
<p>　　对一个集合索引进行安全检查是很有必要的，也是经常实用的，最常见的就是对数组和字典索引的安全检查，该部分内容就是类比这Objective-C中的数组索引的安全检查来扩充Swift的数组，从而让你的Swift数组也同样具备对数组安全检查的功能。</p>
<p>　　1. Objective-C中NSArray对索引的安全扩展</p>
<p>　　下方这段代码是非常简单的，它是对Objective-C中的NSArray做的扩展，该方法位于NSArray相关的延展中。在你的项目中，如果添加了此段延展代码，那么你就可以通过objectAtIndexSafe:方法对数组进行安全的索引。有代码不难看出在定义该函数参数时，我们将index声明为NSUInteger，也就是正整数，这就排除了你对下标传入一个负数。紧接着又对index的合法性进行验证，如果index不在数组有效范围内，那么就返回nil。当你查找的元素不存在时，你返回nil是不会造成程序崩溃的，因为nil的地址是0x0, 这和归零若引用有些类似。</p>
<p>　　当然下方只是NSArray安全扩展其中一个方法，还有许多扩展的安全方法，比如数组的增删改查都可以进行相应的安全扩展，扩展的方式和思路与下方这段简单代码类似，再次就不花过多的篇幅对其进行介绍了。</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 - (id)objectAtIndexSafe:(NSUInteger)index &#123;</span><br><span class="line">2     if (index &gt; self.count-1) &#123;</span><br><span class="line">3         return nil;</span><br><span class="line">4     &#125;</span><br><span class="line">5     return [self objectAtIndex:index];</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>　　</p>
<p>　　2.Swift中对Array的安全扩展</p>
<p>　　上面简单的对Objective-C中的安全方法进行了简单的介绍，就算是对Swift相关内容的引子吧，下方将会给出Swift语言中类似的方法。对Swift相关方法介绍时，我会尽量的详细一些，因为毕竟本篇博客主要是关于Swift内容的。接下来将对上面Objective-C中NSArray数组索引安全验证的方法使用Swift语言进行重新。当然重写的内容也是非常容易理解的。</p>
<p>　　　　（1）主要是对subscript方法进行重载，在重载的subscript方法中，对index的范围通过三目运算符进行了安全检查。如果index在0..&lt;count这个半开区间内，那么就返回当前索引的值，如果不在该范围内就返回nil, 下方就是对Array索引的安全检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 extension Array &#123;</span><br><span class="line">2     subscript (safe index: Int) -&gt; Element? &#123;</span><br><span class="line">3         return (0..&lt;count).contains(index) ? self[index] : nil</span><br><span class="line">4     &#125;</span><br><span class="line">5 &#125;</span><br></pre></td></tr></table></figure>
<p>　　　　</p>
<p>　　　　（2）上面是对Swift中的Array进行了安全索引扩展，接下来就是简单的使用了，下方的代码段是对上面安全扩展函数的测试。首先创建了一个数组testArray, 然后创建了一个索引数组indexs, 然后遍历indexs中的元素值，将其作为testArray的下标，对testArray进行检索。当然检索时，使用的是我们上面定义的safe方法，并且在indexs下标数组中存在非法的下标。在这种情况下，我们来验证一下我们的安全方法。</p>
<p>　　　　当然在数组遍历中，我们使用了for-in循环取出indexs中的每个index, 然后使用guard语句取出testArray中的值。使用guard语句能很好的过滤掉因为非法的index而返回的nil值。具体代码段如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160205134129741-410346246.png" alt="img"></p>
<p>　　　　上面的代码段理解起来并不难，上述测试代码的运行结果如下所示，从运行结果可以很好的说明问题，并且在index非法时不会崩溃，并合理的给出相应的错误提示，请看下方具体运行结果。</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160205134817882-1459948311.png" alt="img"></p>
<p>　　　　上面的延展也可以通过对整个集合类型，也就是CollectionType进行扩展，不过在扩展CollectionType时要对Index使用where子句进行限制，使Index必须符合Comparable协议，具体实现如下所示，不过下面的方法比较少用，因为一般是数组存在越界的情况，因为在字典中，如果你对一个不存在的键进行值的索引，会返回nil值，而不会崩溃。但是在数组中，你对不存在的index进行索引，就会抛出错误。下方是另一种处理方式，不过该方式用的比较少。</p>
<p>　　　　实现下方延展后，同样可以在数组中使用safe方法。</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219131435081-784419369.png" alt="img"></p>
<p>　　</p>
<p>二、使用多个索引下标的数组</p>
<p>　　延展的功能是非常强大的，该部分将会给出另一个数组的延展。该延展的功能是可以通过多个索引给数组设置值，以及通过多个索引一次性获取多个数组的值。该功能是非常强大的，接下来将一步步实现该功能。</p>
<p>　　1. 了解zip()函数以及Zip2Sequence</p>
<p>　　　　在实现数组多个索引扩展时，需要使用到zip()函数，zip()函数接收两个序列，并且返回一个Zip2Sequence类型的数据。zip()函数究竟是干嘛的呢？接下来将会通过一个小的实例来搞一下zip()函数。首先看一下Apple的帮助文档上对zip()函数的介绍。具体如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219141933925-2078157118.png" alt="img"></p>
<p> 　　　　上面那句英文的意思大概就是“基于两个基本序列构建了一个序列对，在序列对中，第i对，代表着每个基本序列中的第i个元素。”在zip函数定义的过程中，我们可以看到，zip()是一个泛型函数，其接收两个SequenceType类型的参数，然后返回一个Zip2Sequence类型的数据。新创建的序列对就存在于Zip2Sequence中。说这么多还是来个小Demo实惠一些，通过一个小实例，看zip()函数的用法一目了然。</p>
<p>　　　　(1) 创建两个数组zip1和zip2, 将这两个数组作为zip()函数的参数，将两个数组进行合并。具体实现如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219154659253-1427565472.png" alt="img"></p>
<p>　　　　(2) 通过上面的程序可以看出，zipSum是一个Zip2Sequence&lt;Array<int>, Array<int>&gt;类型的常量，我们可以使用dump()对zipSum常量进行打印，观察其中的数据存储结构，具体结构如下所示：</int></int></p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219155008425-2071073573.png" alt="img"></p>
<p>　　　　输出结果如下，由结果容易看出，在序列中有两个元素，第一个元素对应着数组zip1, 第二个元素对应着数组zip2。 </p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219155046581-657495057.png" alt="img"></p>
<p>　　　　(3)接下来就是对zipSum这个序列通过for-in循环进行遍历，下方就是对zipSum进行遍历的代码。</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219160311613-207228770.png" alt="img"></p>
<p>　　　　　　上面对zipSum遍历的结果如下所示，由下方输出结果可知，输出是成对遍历的，如果某个数组中的元素是多余的，那么就会被忽略掉。</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219161821847-263203693.png" alt="img"></p>
<p>　　2. 数组多个索引的延展实现</p>
<p>　　　　在这个将要实现的延展中，我们对Array进行了扩展，在延展中对subscript方法进行重载，使其可以接受多个下标，并且对多个下标对应的值进行索引，并把索引结果组成数组。在subscript方法中通过get方法获取索引相应的值，通过set方法为相应的索引值进行设置。下方代码段就是该延展的实现：　　　　</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 1 extension Array &#123;</span><br><span class="line"> 2     subscript(i1: Int, i2: Int, rest: Int...) -&gt; [Element] &#123;</span><br><span class="line"> 3         //通过实现get方法，获取数组中相应的值</span><br><span class="line"> 4         get &#123;</span><br><span class="line"> 5             var result: [Element] = [self[i1], self[i2]]</span><br><span class="line"> 6             for index in rest &#123;</span><br><span class="line"> 7                 result.append(self[index])</span><br><span class="line"> 8             &#125;</span><br><span class="line"> 9             return result</span><br><span class="line">10         &#125;</span><br><span class="line">11         </span><br><span class="line">12         //通过set方法，对数组相应的索引进行设置</span><br><span class="line">13         set (values) &#123;</span><br><span class="line">14             for (index, value) in zip([i1, i2] + rest, values) &#123;</span><br><span class="line">15                 self[index] = value</span><br><span class="line">16             &#125;</span><br><span class="line">17         &#125;</span><br><span class="line">18     &#125;</span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>　　　　在上述延展的实现中，并没有多少困难的地方。在subs两个cript函数中，使用的是可变参数，subscript函数参数的个数是两个以上（包括两个）。然后就是通过zip()函数以及对zip()函数返回的结果集进行遍历，从而对多个下标索引进行值的设置。经过上述延展，我们就可以通过多个索引对数组进行操作了。上述延展的使用方式如下：　</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219164815316-1907649161.png" alt="img"></p>
<p>三、数组切片</p>
<p>　　数组切片在OC中也是不存在的，是Swift新引入的概念，该部分将会对数组切片进行讨论，研究一下数组切片的使用方式及其特点。下方先通过一个小Demo来看一下如何生成数组切片。下方代码段先将一个字符串通过map函数转换成一个数组arrayTest, 然后我们创建一个该数组的切片。下方代码段创建了arrayTest数组中的下标3到下标6这个范围区间中的切片，arraySlices就是数组切片变量，它是ArraySlice<string>类型的，具体代码段如下所示。</string></p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219173136238-1056758933.png" alt="img"></p>
<p>　　在数组切片中有一点需要注意，数组切片的下标与原始数组中的下标保持一致。如果要取出切片arraySlices中的第一个值，我们要使用arraySlices[3], 而不是arraySlices[0], 如果使用arraySlices[0]就会报错，如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219173726019-1405556997.png" alt="img"></p>
<p>　　</p>
<p>　　因为数组是值类型，尽管切片与原数组有着对应的数组下标，但是切片是原始数组的部分拷贝，所以修改切片或者修改原数组，两者互不影响，下方示例给出了该测试，如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219174939550-1098254819.png" alt="img"></p>
<p>　　　</p>
<p>　　如果把切片转换成枚举，那么切片中与原始数组对应的下标关系将不存在，下方是将切片转换成枚举序列，然后对其进行遍历，代码如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219175757628-1014755793.png" alt="img"></p>
<p>　　上述代码段输出结果如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/545446/201602/545446-20160219175827644-1276857687.png" alt="img"></p>
<p>　　　　今天博客就先写到这儿，关于数组的延展还有许多，以后有机会再讨论。其实我们还可以通过一些方式来为我们自己的对象添加下标。也就是可以通过下标来访问对象属性，这个以后在讨论吧。　　 </p>
<p>作者：<a href="http://home.cnblogs.com/u/ludashi/" target="_blank" rel="noopener">青玉伏案</a><br>出处：<a href="http://www.cnblogs.com/ludashi/" target="_blank" rel="noopener">http://www.cnblogs.com/ludashi/</a><br>本文版权归作者和共博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<br>如果文中有什么错误，欢迎指出。以免更多的人被误导。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为啥数组越界抛异常而字典确不会？]]></title>
      <url>/2018/05/28/%E4%B8%BA%E5%95%A5%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E6%8A%9B%E5%BC%82%E5%B8%B8%E8%80%8C%E5%AD%97%E5%85%B8%E7%A1%AE%E4%B8%8D%E4%BC%9A%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>转： <a href="https://www.jianshu.com/u/ac893eccce9e" target="_blank" rel="noopener">八条8tiao</a></p>
<h4 id="数组遭受了不平等对待吗？"><a href="#数组遭受了不平等对待吗？" class="headerlink" title="数组遭受了不平等对待吗？"></a>数组遭受了不平等对待吗？</h4><p>在我们访问数组的时候，如果发生了越界，那么我们一定会收到错误。以swift语言为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let array = [1,2,3]</span><br><span class="line">array[10] // error ！！！！！！！！！</span><br></pre></td></tr></table></figure>
<p>数组中只包含三个元素，但我们用下标10去访问，发生越界错误。</p>
<p>但是当我们访问一个不在字典中的元素的时候，确不会发生类似的情况！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let dic = [&quot;a&quot;: 1, &quot;b&quot;: 2]</span><br><span class="line">dic[&quot;z&quot;]  // 虽然不存在，但不会出现异常</span><br></pre></td></tr></table></figure>
<p>同样的问题，不同的待遇，这是为啥呢？</p>
<h4 id="究其原因"><a href="#究其原因" class="headerlink" title="究其原因"></a>究其原因</h4><p>我们来查看一下swift中数组和字典下标访问的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Array&lt;Element&gt; &#123;</span><br><span class="line">    subscript(index: Int) -&gt; Element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Dictionary&lt;Key: Hashable, Value&gt; &#123;</span><br><span class="line">    subscript(key: Key) -&gt; Value?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较两者的实现，我们可以得到问题的原因：</p>
<ul>
<li>数组下标访问返回的不是一个optional类型</li>
<li>subscript方法无法throw错误</li>
</ul>
<p>所以对于数组而言，swift除了弄个fatalError以外，没有其它的替代方案了。而字典返回的是optional类型值，如果发生什么意外状况，即使subscript不能throw errors，字典也可以悠然的返回一个nil。</p>
<h4 id="让我们定义另个版本"><a href="#让我们定义另个版本" class="headerlink" title="让我们定义另个版本"></a>让我们定义另个版本</h4><p>其实我们可以给数组做一个扩展，实现一个即使数组访问越界也不会抛异常的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension Array &#123;</span><br><span class="line">    subscript(safe index: Int) -&gt; Element? &#123;</span><br><span class="line">        return index &gt;= 0 &amp;&amp; index &lt; count ? self[index] : nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用 extension 关键字来给Array做一个扩展，要注意的是：我们无法覆盖原有的subscript方法，</p>
<blockquote>
<p><strong>注意：subscript方法是可以被重载的，也就是说允许同时有多个subscript方法存在</strong></p>
</blockquote>
<p>我们只增加一个新的subscript方法，并明确指定一个外部参数就可以了，我们现在可以这样访问数组了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3]</span><br><span class="line">array[safe: 10] // 返回nil，而不是异常</span><br></pre></td></tr></table></figure>
<p>我们需要在下标访问的时候增加一个label，这个时候虽然我们越界了，但我们却像字典那样，收获了一个nil。</p>
<blockquote>
<p><strong>本文的目的是讨论一下字典与数组下标实现的区别以及subscript的一些特点：不可throw，可以重载等但绝对不是在说数组越界后应该不应该抛出异常。抛不抛出异常要从数组的数据结构应用场景等多方面考虑。</strong></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift3 GCD]]></title>
      <url>/2018/05/25/Swift3%20GCD/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>Swift3 的gcd变化很大，这里列举一下，大家可以有个对照：</p>
<h3 id="1、Create-a-serial-queue-创建一个serial-queue"><a href="#1、Create-a-serial-queue-创建一个serial-queue" class="headerlink" title="1、Create a serial queue 创建一个serial queue"></a>1、Create a serial queue 创建一个serial queue</h3><p>OC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.leacode.gcd.serialqueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123;</span><br><span class="line">    // 在queue线程执行</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // 回到主线程</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Swift3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let queue = DispatchQueue(label: &quot;com.leacode.gcd.serialqueue&quot;)</span><br><span class="line">    queue.async &#123;</span><br><span class="line">        // 在queue线程执行</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">            // 回到主线程</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、Create-a-concurrent-queue-创建一个concurrent-queue"><a href="#2、Create-a-concurrent-queue-创建一个concurrent-queue" class="headerlink" title="2、Create a concurrent queue 创建一个concurrent queue"></a>2、Create a concurrent queue 创建一个concurrent queue</h3><p>OC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.leacode.gcd.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        // 在queue线程执行</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            // 回到主线程</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>Swift3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let queue = DispatchQueue(label: &quot;com.leacode.gcd.concurrentqueue&quot;, attributes: [.concurrent])</span><br><span class="line">    queue.async &#123;</span><br><span class="line">        // 在queue线程执行</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">            // 回到主线程</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-系统提供的Concurrent-Dispatch-Queue："><a href="#3-系统提供的Concurrent-Dispatch-Queue：" class="headerlink" title="3.系统提供的Concurrent Dispatch Queue："></a>3.系统提供的Concurrent Dispatch Queue：</h3><p>从ios8开始苹果引入了一个新的概念 QoS（quality of service），有了更贴近使用场景的描述以及更细致的划分，代码如下<br>OC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0) &#123;</span><br><span class="line">        dispatch_queue_attr_t globalDispatchQueueBackground = dispatch_queue_attr_make_with_qos_class(nil, QOS_CLASS_BACKGROUND, 0);</span><br><span class="line">        dispatch_queue_attr_t globalDispatchQueueUtility = dispatch_queue_attr_make_with_qos_class(nil, QOS_CLASS_UTILITY, 0);</span><br><span class="line">        dispatch_queue_attr_t globalDispatchQueueDefault = dispatch_queue_attr_make_with_qos_class(nil, QOS_CLASS_DEFAULT, 0);</span><br><span class="line">        dispatch_queue_attr_t globalDispatchQueueUserInitiated = dispatch_queue_attr_make_with_qos_class(nil, QOS_CLASS_USER_INITIATED, 0);</span><br><span class="line">        dispatch_queue_attr_t globalDispatchQueueUserInteractive = dispatch_queue_attr_make_with_qos_class(nil, QOS_CLASS_USER_INTERACTIVE, 0);</span><br><span class="line">        dispatch_queue_attr_t globalDispatchQueueUnspecified = dispatch_queue_attr_make_with_qos_class(nil, QOS_CLASS_UNSPECIFIED, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_queue_t globalDispatchQueueHigh =  dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">        dispatch_queue_t globalDispatchQueueDefault =  dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">        dispatch_queue_t globalDispatchQueueLow =  dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</span><br><span class="line">        dispatch_queue_t globalDispatchQueueBackground =  dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if #available(iOS 8.0, *) &#123;</span><br><span class="line">            let globalDispatchQueueBackground = DispatchQueue.global(qos: DispatchQoS.QoSClass.background)</span><br><span class="line">            let globalDispatchQueueUtility = DispatchQueue.global(qos: DispatchQoS.QoSClass.utility)</span><br><span class="line">            let globalDispatchQueueDefault = DispatchQueue.global(qos: DispatchQoS.QoSClass.default)</span><br><span class="line">            let globalDispatchQueueUserInitiated = DispatchQueue.global(qos: DispatchQoS.QoSClass.userInteractive)</span><br><span class="line">            let globalDispatchQueueUserInteractive = DispatchQueue.global(qos: DispatchQoS.QoSClass.userInteractive)</span><br><span class="line">            let globalDispatchQueueUnspecified = DispatchQueue.global(qos: DispatchQoS.QoSClass.unspecified)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let globalDispatchQueueBackground = DispatchQueue.global(priority: DispatchQueue.GlobalQueuePriority.background)</span><br><span class="line">            let globalDispatchQueueLow = DispatchQueue.global(priority: DispatchQueue.GlobalQueuePriority.low)</span><br><span class="line">            let globalDispatchQueueDefault = DispatchQueue.global(priority: DispatchQueue.GlobalQueuePriority.default)</span><br><span class="line">            let globalDispatchQueueHigh = DispatchQueue.global(priority: DispatchQueue.GlobalQueuePriority.high)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-dispatch-after"><a href="#4-dispatch-after" class="headerlink" title="4.dispatch_after"></a>4.dispatch_after</h3><p>这部分Swift3的变化较大<br>OC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC);</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;3秒后执行&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Swift3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let time = DispatchTime.now() + 3</span><br><span class="line">DispatchQueue.main.asyncAfter(deadline: time) &#123; </span><br><span class="line">    // 3秒后执行</span><br><span class="line">    print(&quot;3秒后执行&quot;)</span><br><span class="line">&#125;</span><br><span class="line"> DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 6) &#123;</span><br><span class="line">       // 6秒后执行2</span><br><span class="line">       print(&quot;6秒后执行&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-挂起和恢复"><a href="#5-挂起和恢复" class="headerlink" title="5.挂起和恢复"></a>5.挂起和恢复</h3><p>OC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend(queue);</span><br><span class="line">dispatch_resume(queue);</span><br></pre></td></tr></table></figure>
<p>Swift3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.suspend()</span><br><span class="line">queue.resume()</span><br></pre></td></tr></table></figure>
<h3 id="6-判断间隔一段时间group是否执行结束"><a href="#6-判断间隔一段时间group是否执行结束" class="headerlink" title="6.判断间隔一段时间group是否执行结束"></a>6.判断间隔一段时间group是否执行结束</h3><p>OC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.leacode.gcd.queue1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.leacode.gcd.queue2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_queue_t queue3 = dispatch_queue_create(&quot;com.leacode.gcd.queue3&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_queue_t queue4 = dispatch_queue_create(&quot;com.leacode.gcd.queue4&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_group_async(group, queue1, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue2, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue3, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue4, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_time_t group_time = dispatch_time(DISPATCH_TIME_NOW, 1ull*NSEC_PER_SEC);</span><br><span class="line">long result = dispatch_group_wait(group, group_time);</span><br><span class="line">if (result == 0) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * 属于Dispatch Group的全部处理执行结束</span><br><span class="line">     */</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    /*</span><br><span class="line">     * 属于Dispatch Group的某一个处理还在进行中</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Swift3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let queue1 = DispatchQueue(label: &quot;com.leacode.group.queue1&quot;)</span><br><span class="line">let queue2 = DispatchQueue(label: &quot;com.leacode.group.queue2&quot;)</span><br><span class="line">let queue3 = DispatchQueue(label: &quot;com.leacode.group.queue3&quot;)</span><br><span class="line">let group = DispatchGroup()</span><br><span class="line"></span><br><span class="line">queue1.async(group: group) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">queue2.async(group: group) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">queue3.async(group: group) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 以下代码可以判断间隔时间为1秒后group是否执行完毕，并执行相应的处理</span><br><span class="line">*/</span><br><span class="line">let afterTime = DispatchTime.now() + 1</span><br><span class="line">let result = group.wait(timeout: afterTime)</span><br><span class="line"></span><br><span class="line">if result == .success &#123;</span><br><span class="line">      /*</span><br><span class="line">       * 属于Dispatch Group的全部处理执行结束</span><br><span class="line">       */</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 属于Dispatch Group的某一个处理还在进行中</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    group.notify(queue: DispatchQueue.main) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-dispatch-once"><a href="#7-dispatch-once" class="headerlink" title="7.dispatch_once"></a>7.dispatch_once</h3><p>这里我们用单例来举例，oc和swift中都是通过创建一个static对象来创建单例子，在swift3中只需要写一个static变量就可以了：<br>OC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (id)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    static MyClass *myclass = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        myclass = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return myclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    static let singleton = MyClass()</span><br><span class="line">    private init() &#123;</span><br><span class="line">        print(&quot;foo&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在swift中已经取消掉dispatch_once了，可以看苹果的说明<a href="https://link.jianshu.com/?t=https://swift.org/migration-guide/" target="_blank" rel="noopener">链接</a></p>
<p>The free function dispatch_once<br>is no longer available in Swift. In Swift, you can use lazily initialized globals or static properties and get the same thread-safety and called-once guarantees as dispatch_once<br>provided</p>
<p>可以通过设置懒加载的全局属性或者静态属性来达到线程安全且执行一次的效果。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[where Self]]></title>
      <url>/2018/05/25/swift-Tips/</url>
      <content type="html"><![CDATA[<p>extension BorderDesignable where Self: UIView 中的where Self是什么意思?</p>
<p>你的<code>BorderDesignable</code>这个协议只能被 UIView 继承</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift-predecessor(), successor(), advancedBy()]]></title>
      <url>/2018/05/24/Swift-predecessor(),%20successor(),%20advancedBy()/</url>
      <content type="html"><![CDATA[<h6 id="Swift-predecessor-successor-advancedBy"><a href="#Swift-predecessor-successor-advancedBy" class="headerlink" title="Swift-predecessor(), successor(), advancedBy()"></a>Swift-predecessor(), successor(), advancedBy()</h6><p>—————— 以下为Swift 3.0 的方法 ——————————</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;hello world!&quot;  </span><br><span class="line">str[str.startIndex]  </span><br><span class="line">打印结果：  </span><br><span class="line">//h</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">//访问其结束前一个字符</span><br><span class="line">//str[str.endIndex.predecessor()]  </span><br><span class="line">//在Swift3.0 predecessor使用以下代替：</span><br><span class="line">str[str.index(before: str.endIndex)]</span><br><span class="line">打印结果：</span><br><span class="line">//!</span><br><span class="line"></span><br><span class="line">//访问其开始后一个字符</span><br><span class="line">str[str.startIndex.successor()]  </span><br><span class="line">//在Swift3.0 successor使用以下代替：</span><br><span class="line">str[str.index(after: str.startIndex)]</span><br><span class="line">打印结果：</span><br><span class="line">//e</span><br><span class="line"></span><br><span class="line">//访问其开始后一个字符</span><br><span class="line">let index = str.startIndex.advancedBy(7) </span><br><span class="line">//在Swift3.0 advancedBy使用以下代替： </span><br><span class="line">let index = str.index(str.startIndex, offsetBy: 7)</span><br><span class="line">打印结果：</span><br><span class="line">//7</span><br><span class="line">str[index]  </span><br><span class="line">打印结果：</span><br><span class="line">//输出 o</span><br><span class="line">1234567891011121314151617181920212223242526272829</span><br></pre></td></tr></table></figure>
<p>—————— 以下为Swift 2.0 的方法 ——————————</p>
<p>在截取字符串时遇到几个没用过的函数特此记.<br>startIndex:访问String第一个位置的字符<br>endIndex: 访问String最后一个位置的字符</p>
<p>predecessor(), successor(), advancedBy()<br>一个String.Index值可以通过调用predecessor()方法来访问其前一个index,<br>调用successor()来访问其后一个index<br>调用advancedBy()来指定访问相对位置的index</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;hello world!&quot;  </span><br><span class="line">str[str.startIndex]  </span><br><span class="line">打印结果：  </span><br><span class="line">//h</span><br><span class="line"></span><br><span class="line">//访问其结束前一个字符</span><br><span class="line">str[str.endIndex.predecessor()]  </span><br><span class="line">打印结果：</span><br><span class="line">//!</span><br><span class="line"></span><br><span class="line">//访问其开始后一个字符</span><br><span class="line">str[str.startIndex.successor()]  </span><br><span class="line">打印结果：</span><br><span class="line">//e</span><br><span class="line"></span><br><span class="line">//访问其开始后一个字符</span><br><span class="line">let index = str.startIndex.advancedBy(7)  </span><br><span class="line">打印结果：</span><br><span class="line">//7</span><br><span class="line">str[index]  </span><br><span class="line">打印结果：</span><br><span class="line">//输出 o</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[swift 简单的Time单例，延迟，循环，任你选]]></title>
      <url>/2018/05/24/swift%20%E7%AE%80%E5%8D%95%E7%9A%84Time%E5%8D%95%E4%BE%8B%EF%BC%8C%E5%BB%B6%E8%BF%9F%EF%BC%8C%E5%BE%AA%E7%8E%AF%EF%BC%8C%E4%BB%BB%E4%BD%A0%E9%80%89/</url>
      <content type="html"><![CDATA[<p>swift 简单的Time单例，延迟，循环，任你选</p>
<p>import Foundation</p>
<p>typealias ZZWTimeBlock = () -&gt; Void</p>
<p>class ZZWTimeManager: NSObject{</p>
<p>​    static let sharedInstance = ZZWTimeManager()</p>
<p>​    var cycyleTimer : Timer?</p>
<p>​    <a id="more"></a></p>
<p>​    private var block : ZZWTimeBlock?</p>
<p>​        // 添加定时器</p>
<p>​    func addCycleTimer(<em> delay:Double,</em> repeats: Bool) {</p>
<p>​        if let cycyleTimer =  ZZWTimeManager.sharedInstance.cycyleTimer {</p>
<p>​            cycyleTimer.invalidate()</p>
<p>​        }</p>
<p>​        ZZWTimeManager.sharedInstance.cycyleTimer = Timer(timeInterval: delay, target: self, selector: #selector(makeBlePowerCheck), userInfo: nil, repeats: repeats)</p>
<p>​        RunLoop.main.add(cycyleTimer!, forMode:RunLoopMode.commonModes)</p>
<p>​    }</p>
<p>​    </p>
<p>​    // 移除定时器</p>
<p>​    public func removeCycleTimer() {</p>
<p>​        // 从运行循环中移除</p>
<p>​        ZZWTimeManager.sharedInstance.cycyleTimer?.invalidate()</p>
<p>​        ZZWTimeManager.sharedInstance.cycyleTimer = nil</p>
<p>​    }</p>
<p>​    </p>
<p>​    deinit {</p>
<p>​        removeCycleTimer()</p>
<p>​    }</p>
<p>​        @objc private func makeBlePowerCheck()  {</p>
<p>​    </p>
<p>​        block!()</p>
<p>​    }</p>
<p>​        func timeOnDoDoDo(timeB: @escaping  ZZWTimeBlock) {</p>
<p>​        block = timeB</p>
<p>​    }</p>
<p>}</p>
<p>简单使用 ：</p>
<p>ZZWTimeManager.sharedInstance.addCycleTimer(60, true)</p>
<p>​        ZZWTimeManager.sharedInstance.timeOnDoDoDo {</p>
<p>​           print（“哈哈哈哈哈”）</p>
<p>​        }</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift3.0 指针]]></title>
      <url>/2018/05/23/Swift3.0%20%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>最近试着用Swift基于AudioQueue写一个音乐播放器，但是AudioQueue的API都是C函数，避免不了操作指针。经常卡在指针上，于是决定先静下心来学习一下Swift中的指针。baidu了很多，但是没有系统讲解Swift指针的文章，一边学一边记录，写下这些作为积累。这次学习分为四个部分:<code>UnsafePointer</code>, <code>UnsafeMutablePointer</code>, <code>UnsafeRawPointer</code>, <code>UnsafeMutableRawPointer</code>。有不对的地方欢迎指出！<br>在Swift中，指针由结构体 <code>struct UnsafePointer&lt;Pointee&gt;</code> 或 <code>struct UnsafeMutablePointer&lt;Pointee&gt;</code> 表示，但是不能通过”&amp;”获取一个<code>UnsafePointer</code> 或 <code>UnsafeMutablePointer</code>的实例，只能作为<code>inout</code>参数使用。<code>UnsafePointer</code>相对于<code>UnsafeMutablePointer</code>，其所指向的地址的值是不可变的</p>
<h2 id="一、UnsafeMutablePointer"><a href="#一、UnsafeMutablePointer" class="headerlink" title="一、UnsafeMutablePointer"></a>一、UnsafeMutablePointer</h2><p>被<code>UnsafeMutablePointe</code>引用的内存有三种状态：<br>\1. Not Allocated<br>\2. Allocated but not initialized<br>\3. Allocated and initialized<br>只有在状态3时，可以安全的使用<code>pointee</code>属性来<code>set</code>和<code>get</code>。<br><a id="more"></a></p>
<h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><p><code>allocate()</code> <code>initialize()</code> <code>deinitialize</code> <code>deallocate()</code> 这四个方法来管理这个指针，并确保指针的<code>pointee</code>不会出错</p>
<h4 id="1-allocate"><a href="#1-allocate" class="headerlink" title="(1) allocate"></a>(1) allocate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a_unsafe_mutable_pointer = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 0)1</span><br></pre></td></tr></table></figure>
<p>Tips:<br>\1. 需要指明要声明的指针类型</p>
<ol>
<li><code>allocate</code>是静态方法</li>
</ol>
<h4 id="2-initialize"><a href="#2-initialize" class="headerlink" title="(2) initialize"></a>(2) initialize</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_unsafe_mutable_pointer.initialize(to: 5)</span><br><span class="line">//或</span><br><span class="line">a_unsafe_mutable_pointer.pointee = 5123</span><br></pre></td></tr></table></figure>
<p>这两种方法的结果是相同的</p>
<h4 id="3-deinitialize"><a href="#3-deinitialize" class="headerlink" title="(3) deinitialize"></a>(3) deinitialize</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_unsafe_mutable_pointer.deinitialize(count: 1)1</span><br></pre></td></tr></table></figure>
<p>该方法貌似没有真正deintialize，只是返回了一个指向相同地址的<code>UnsafeMutableRawPointer</code>,并且<code>a_unsafe_mutable_pointer.pointee</code>仍然是可以正常使用</p>
<h4 id="4-deallocate"><a href="#4-deallocate" class="headerlink" title="(4) deallocate"></a>(4) deallocate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_unsafe_mutable_pointer.deallocate(capacity: 1)1</span><br></pre></td></tr></table></figure>
<p>此时a_unsafe_mutable_pointer不可用了。</p>
<h3 id="2-互相转化"><a href="#2-互相转化" class="headerlink" title="2.互相转化"></a>2.互相转化</h3><h4 id="1-UnsafeMutablePointer-gt-Swift"><a href="#1-UnsafeMutablePointer-gt-Swift" class="headerlink" title="(1) UnsafeMutablePointer -&gt; Swift"></a>(1) UnsafeMutablePointer -&gt; Swift</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a : Int = a_unsafe_mutable_pointer.pointee1</span><br></pre></td></tr></table></figure>
<h4 id="2-Swift-gt-UnsafeMutablePointer"><a href="#2-Swift-gt-UnsafeMutablePointer" class="headerlink" title="(2) Swift -&gt; UnsafeMutablePointer"></a>(2) Swift -&gt; UnsafeMutablePointer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a : UnsafeMutablePointer = &amp;a 1</span><br></pre></td></tr></table></figure>
<p>以上代码是错误的，只能作为函数参数使用,如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func printPointer(ptr:UnsafeMutablePointer&lt;Int&gt;) &#123;</span><br><span class="line">        print(&quot;UnsafeMutablePointer:\(ptr)&quot;)</span><br><span class="line">        print(&quot;pointee:\(ptr.pointee)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">printPointer(ptr:&amp;a)12345</span><br></pre></td></tr></table></figure>
<h3 id="3-暂时绑定"><a href="#3-暂时绑定" class="headerlink" title="3.暂时绑定"></a>3.暂时绑定</h3><p>将该内存暂时绑定为一种类型，例子中将Int型绑定为Int8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a_unsafe_mutable_pointer.initialize(to: 0x0102030A)</span><br><span class="line">a_unsafe_mutable_pointer.withMemoryRebound(to: Int8.self, capacity: 1, &#123;</span><br><span class="line">    ptr in</span><br><span class="line">    print(String(ptr.pointee,radix:16)) //1</span><br><span class="line">    print(String(ptr.advanced(by: 1).pointee,radix:16)) //2</span><br><span class="line">    print(String(ptr.advanced(by: 2).pointee,radix:16)) //3</span><br><span class="line">    print(String(ptr.advanced(by: 3).pointee,radix:16)) //a</span><br><span class="line">&#125;)12345678</span><br></pre></td></tr></table></figure>
<h2 id="二、UnsafePointer"><a href="#二、UnsafePointer" class="headerlink" title="二、UnsafePointer"></a>二、UnsafePointer</h2><ol>
<li><code>UnsafePointer</code>中的<code>pointee</code>属性只能<code>get</code>不能<code>set</code>。</li>
<li><code>UnsafePointer</code>中没有<code>allocate</code>方法。</li>
</ol>
<h3 id="1-初始化-1"><a href="#1-初始化-1" class="headerlink" title="1.初始化"></a>1.初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a_unsafe_pointer = UnsafePointer&lt;Int&gt;.init(a_unsafe_mutable_pointer)1</span><br></pre></td></tr></table></figure>
<p>可以由<code>UnsafeMutablePointer</code>、<code>OpaquePointer</code>或其他<code>UnsafePointer</code>创建一个<code>UnsafePointer</code>指针。其他与<code>UnsafeMutablePointer</code>类似</p>
<h3 id="2-互相转换"><a href="#2-互相转换" class="headerlink" title="2.互相转换"></a>2.互相转换</h3><h4 id="1-UnsafeMutablePointer-gt-UnsafePointer"><a href="#1-UnsafeMutablePointer-gt-UnsafePointer" class="headerlink" title="(1) UnsafeMutablePointer -&gt; UnsafePointer"></a>(1) UnsafeMutablePointer -&gt; UnsafePointer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a_unsafe_pointer = UnsafePointer&lt;Int&gt;.init(a_unsafe_mutable_pointer)1</span><br></pre></td></tr></table></figure>
<h4 id="2-UnsafePointer-gt-UnsafeMutablePointer"><a href="#2-UnsafePointer-gt-UnsafeMutablePointer" class="headerlink" title="(2) UnsafePointer -&gt; UnsafeMutablePointer"></a>(2) UnsafePointer -&gt; UnsafeMutablePointer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a_unsafe_mutable_pointer = UnsafePointer&lt;Int&gt;.init(mutating:a_unsafe_pointer)1</span><br></pre></td></tr></table></figure>
<h4 id="3-UnsafePointer-gt-Swift"><a href="#3-UnsafePointer-gt-Swift" class="headerlink" title="(3) UnsafePointer -&gt; Swift"></a>(3) UnsafePointer -&gt; Swift</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a : Int = a_unsafe_pointer.pointee1</span><br></pre></td></tr></table></figure>
<h4 id="4-Swift-gt-UnsafePointer"><a href="#4-Swift-gt-UnsafePointer" class="headerlink" title="(4) Swift -&gt; UnsafePointer"></a>(4) Swift -&gt; UnsafePointer</h4><p>与<code>UnsafeMutablePointer</code>类似，只能作为函数参数引用</p>
<h3 id="3-withUnsafePointer方法"><a href="#3-withUnsafePointer方法" class="headerlink" title="3.withUnsafePointer方法"></a>3.withUnsafePointer方法</h3><p><code>withUnsafePointer</code>方法可以直接使用指针,但是不能改变<code>pointee</code>的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var a = 0</span><br><span class="line">var b = a</span><br><span class="line">a = withUnsafePointer(to: &amp;a, &#123;</span><br><span class="line">        ptr in</span><br><span class="line">        return ptr.pointee + 2 </span><br><span class="line">        //此时，新开辟空间，令a指向该地址，其值为2</span><br><span class="line">        //b仍指向a原来的地址，值为0</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var _ = withUnsafePointer(to: &amp;b, &#123;</span><br><span class="line">            ptr in</span><br><span class="line">            let size = MemoryLayout&lt;Int&gt;.size //8</span><br><span class="line">            //advance(by:Int)移动指针到a</span><br><span class="line">            let movedPointer = ptr.advanced(by: -size) </span><br><span class="line">            print(&quot;b:\(ptr.pointee)&quot;) //b = 0</span><br><span class="line">            print(&quot;a:\(movedPointer.pointee)&quot;) //a = 2</span><br><span class="line">        &#125;)1234567891011121314151617</span><br></pre></td></tr></table></figure>
<h2 id="三、UnsafeMutableRawPointer"><a href="#三、UnsafeMutableRawPointer" class="headerlink" title="三、UnsafeMutableRawPointer"></a>三、UnsafeMutableRawPointer</h2><p><code>UnsafeMutableRawPointer</code>按我的理解就是无类型的原始指针</p>
<h3 id="1-分配内存"><a href="#1-分配内存" class="headerlink" title="1.分配内存"></a>1.分配内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var size = MemoryLayout&lt;Int&gt;.size</span><br><span class="line">//其中alignTo是开辟内存中的对齐，不是很了解，貌似会影响效率，太底层了，不太懂</span><br><span class="line">var a_unsafe_mutable_raw_pointer = UnsafeMutableRawPointer.allocate(bytes: size, alignedTo: size)123</span><br></pre></td></tr></table></figure>
<p>这时，这个<code>a_unsafe_mutable_raw_pointer</code>感觉没啥用，还是需要转换为<code>UnsafeMutablePointer</code>来对内存进行操作。</p>
<h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h3><p>初始化内存为Int类型，并赋值为1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_unsafe_mutable_raw_pointer.initializeMemory(as: Int.self, to: 1)1</span><br></pre></td></tr></table></figure>
<h3 id="3-绑定UnsafeMutablePointer"><a href="#3-绑定UnsafeMutablePointer" class="headerlink" title="3.绑定UnsafeMutablePointer"></a>3.绑定UnsafeMutablePointer</h3><p>绑定了<code>UnsafeMutablePointer</code>,使用<code>UnsafeMutablePointer</code>才能对内存进行赋值,有两种方法绑定：<br>(1) <code>bindMemory()</code><br>该方法绑定内存为指定类型并返回一个<code>UnsafeMutablePointer&lt;指定类型&gt;</code>的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a_unsafe_mutable_pointer = a_unsafe_mutable_raw_pointer.bindMemory(to: Int.self, capacity: 1)1</span><br></pre></td></tr></table></figure>
<p>(2) <code>assumingMemoryBound()</code><br>该方法意思是直接转换这个原始指针为一个<code>UnsafeMutablePointer&lt;指定类型&gt;</code>的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a_unsafe_mutable_pointer = a_unsafe_mutable_raw_pointer.assumingMemoryBound(to: Int.self)1</span><br></pre></td></tr></table></figure>
<p>-<br>这样，就可以使用这个<code>a_unsafe_mutable_pointer</code>进行其他操作了。</p>
<h3 id="4-deallocate-1"><a href="#4-deallocate-1" class="headerlink" title="4.deallocate"></a>4.deallocate</h3><p>最后，需要释放内存，首先要deinitialize，再deallocate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a_unsafe_mutable_pointer.deinitialize()</span><br><span class="line">a_unsafe_mutable_raw_pointer.deallocate(bytes: size, alignedTo: size)12</span><br></pre></td></tr></table></figure>
<h3 id="5-转换"><a href="#5-转换" class="headerlink" title="5.转换"></a>5.转换</h3><p>(1) Swift -&gt; UnsafeMutableRawPointer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 10</span><br><span class="line">var ptr = UnsafeMutableRawPointer(&amp;a)12</span><br></pre></td></tr></table></figure>
<p>(2) UnsafeMutableRawPointer -&gt; Swift<br>其过程应当为<code>UnsafeMutableRawPointer</code>转换为<code>UnsafeMutablePointer</code>，再由<code>UnsafeMutablePointer</code>转换为<code>Swift</code>指针</p>
<h2 id="四、UnsafeRawPointer"><a href="#四、UnsafeRawPointer" class="headerlink" title="四、UnsafeRawPointer"></a>四、UnsafeRawPointer</h2><p><code>UnsafeRawPointer</code>只能由其他指针用<code>init</code>方法得到，与<code>UnsafePointer</code>类似，没有<code>allocate</code>静态方法。但是，与<code>UnsafeMutableRawPointer</code>类似的有两种绑定方法，绑定成<code>UnsafePointer</code>指针。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[swift简单粗暴方式实现任意模式切换]]></title>
      <url>/2018/05/23/swift%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>本来想写个UIApearance的教程改应用模式切换的，结果搞出来一个非常赞的方法来实现任意模式的切换。</p>
<p>不了解UIApearance的可以点<a href="https://link.jianshu.com/?t=http://www.cocoachina.com/ios/20150723/12671.html" target="_blank" rel="noopener">这里</a>看看了解下。</p>
<h4 id="说下思路："><a href="#说下思路：" class="headerlink" title="说下思路："></a>说下思路：</h4><p>本来我是想通过extension和子类化，自定义UIApearance可以调用的方法来实现模式的切换，具体方式就不写了，说真的，有点麻烦，也不容易封装，本来是想推荐给大家在找不到合适的方式而且不想使用通知的时候尝试下，后来突然想到如果我直接用block把对象本身传回来，不是可以任意修改样式了吗，然后就有了这个。</p>
<h4 id="期间做了许多尝试："><a href="#期间做了许多尝试：" class="headerlink" title="期间做了许多尝试："></a>期间做了许多尝试：</h4><a id="more"></a>
<p>1.本来想在自定义UIApearance方法时把block作为参数，结果UIApearance的自定义方法有严格的限制，然后失败了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Swift</span><br><span class="line">func propertyForAxis1(axis1: IntegerType, axis2: IntegerType, axisN: IntegerType) -&gt; PropertyType</span><br><span class="line">func setProperty(property: PropertyType, forAxis1 axis1: IntegerType, axis2: IntegerType)</span><br><span class="line"> </span><br><span class="line">// OBJECTIVE-C</span><br><span class="line">- (PropertyType)propertyForAxis1:(IntegerType)axis1 axis2:(IntegerType)axis2 … axisN:(IntegerType)axisN;</span><br><span class="line">- (void)setProperty:(PropertyType)property forAxis1:(IntegerType)axis1 axis2:(IntegerType)axis2 … axisN:(IntegerType)axisN;</span><br></pre></td></tr></table></figure>
<p>2.然后我想到了使用子类化，增加block的属性进行操作，然后结合UIApearance的自定义方法，通过传递模式类型来选择执行哪个block。这个方法很有效，但是也很麻烦，因为你用到的所有需要改变模式的UI空间都需要子类化一遍。</p>
<p>3.之后我直接删掉了block的属性，专门定制化在某个模式见切换的UI控件，比如一个View的子类专门黑白切换，另一个浅灰深灰切换，然后在自定义的方法里直接根据传入的模式修改颜色，在使用时只要把对应的控件继承对应的子类就好了。这样的好处是不用每个对象都写两套修改方案，节省代码。坏处是如果不同类型的控件很多，就需要定义很多的子类，而且对与那些已经完成的项目添加模式切换也会比较坑爹。</p>
<p>4.再后来突然想到第2次尝试的方法可以优化下，直接把block通过extension+runtime的方式直接给系统控件添加block作为存储属性。结果失败了，因为set方法编译无法通过。下面贴一下通过extension+runtime添加存储属性的方法，大家可以自己尝试下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private struct AssociatedKeys &#123;</span><br><span class="line">        static var aStringKey = &quot;aStringKey&quot;</span><br><span class="line">    &#125;</span><br><span class="line">var aString: String? &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return objc_getAssociatedObject(self, &amp;AssociatedKeys. aStringKey) as? String</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            if let newValue = newValue &#123;</span><br><span class="line">                objc_setAssociatedObject( self, &amp;AssociatedKeys. aStringKey, newValue as NSString?, .OBJC_ASSOCIATION_COPY_NONATOMIC )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>5.然后我就以学习的目的想想办法看能不能解决，做了许多尝试，中间demo崩了多少次都不想说了，之后终于set方法通过了，然后去用，发现get方法每次取到得都是nil，然后又想办法，到最后终于解决掉这个在extension里创建block类型的存储属性的方法。过程没办法说了，其实就是把自定义block类型与AnyObject相互转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsafeBitCast(anyObjectValue, MyBlock.self)</span><br><span class="line">unsafeBitCast(myBlockValue, AnyObject.self)</span><br></pre></td></tr></table></figure>
<p>6.解决之后再去尝试模式切换，结果给了我一个很大的惊喜。通过（extension+runtime自定义block存储属性）+ 自定义UIApearance方法，我发现只要给UIView加上这段代码，所有问题都解决了，这是我做之前都没想到的，效果好的让我想哭……</p>
<h4 id="以上全废话，看完的都是好朋友"><a href="#以上全废话，看完的都是好朋友" class="headerlink" title="以上全废话，看完的都是好朋友"></a>以上全废话，看完的都是好朋友</h4><p>代码并不多，下面看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">typealias Block = @convention(block) (UIView) -&gt; Void</span><br><span class="line">extension UIView&#123;</span><br><span class="line">    </span><br><span class="line">    private struct AssociatedKeys &#123;</span><br><span class="line">        static var blockName1 = &quot;blockName1&quot;</span><br><span class="line">        static var blockName2 = &quot;blockName2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    //自定义的UIApearance方法，调用方法为 UIView.appearance().setType(1) UIApearance的具体特性可以自己去尝试和查资料</span><br><span class="line">    //通过type切换模式</span><br><span class="line">    dynamic func setType(type: Int)&#123;</span><br><span class="line">        switch type &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            if block1 != nil &#123;</span><br><span class="line">                block1!(self)</span><br><span class="line">            &#125;</span><br><span class="line">        default:</span><br><span class="line">            if block2 != nil &#123;</span><br><span class="line">                block2!(self)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var block1: Block?&#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let value = objc_getAssociatedObject(self, &amp;AssociatedKeys.blockName1)</span><br><span class="line">            return unsafeBitCast(value, Block.self)</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            if let newValue = newValue &#123;</span><br><span class="line">                let value:AnyObject = unsafeBitCast(newValue, AnyObject.self)</span><br><span class="line">                objc_setAssociatedObject( self, &amp;AssociatedKeys.blockName1, value, .OBJC_ASSOCIATION_COPY )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var block2: Block?&#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let value = objc_getAssociatedObject(self, &amp;AssociatedKeys.blockName2)</span><br><span class="line">            return unsafeBitCast(value, Block.self)</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            if let newValue = newValue &#123;</span><br><span class="line">                let value:AnyObject = unsafeBitCast(newValue, AnyObject.self)</span><br><span class="line">                objc_setAssociatedObject( self, &amp;AssociatedKeys.blockName2, value, .OBJC_ASSOCIATION_COPY )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据这种模式直接复制粘贴可以添加block3，block4…<br>然后是使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> //aView是个UIView 不同的UIVIew子类互不影响</span><br><span class="line"> //模式1时做的内容 </span><br><span class="line"> aView.block1 = &#123; view in</span><br><span class="line">  view.backgroundColor = UIColor.redColor()</span><br><span class="line"> &#125;</span><br><span class="line">//模式2时做的内容</span><br><span class="line"> aView.block2 = &#123;view in</span><br><span class="line">     view.backgroundColor = UIColor.blueColor()</span><br><span class="line"> &#125;</span><br><span class="line"> //aLabel是一个UILabel</span><br><span class="line"> aLabel.block1 = &#123; view in</span><br><span class="line">     let lab = view as! UILabel</span><br><span class="line">     lab.backgroundColor = UIColor.redColor()</span><br><span class="line">     lab.textColor = UIColor.blueColor()</span><br><span class="line"> &#125;</span><br><span class="line"> aLabel.block2 = &#123;view in</span><br><span class="line">     let lab = view as! UILabel</span><br><span class="line">     lab.backgroundColor = UIColor.blueColor()</span><br><span class="line">     lab.textColor = UIColor.redColor()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIView.appearance().setType(1)</span><br><span class="line">UIView.appearance().setType(0)</span><br></pre></td></tr></table></figure>
<p>你可以在block里写任何你想改变的效果。<br>把UIView的extension写进项目里，然后给所有切换模式改变颜色的UI控件设置block1和block2，另外建议那些大量的相同类型的UI控件同时继承同一个子类直接定制。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>如果应用要添加模式设置，尤其是已完成的项目，用这种方式修改起来会比较简单，可以尝试下。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NSString 被忽视的方法 stringByTrimmingCharactersInSet]]></title>
      <url>/2018/05/23/NSString%20%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84%E6%96%B9%E6%B3%95%20stringByTrimmingCharactersInSet/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>2016.09.06 13:29* 字数 195 阅读 3207评论 2喜欢 13赞赏 1</p>
<p>在app中，处理用户的输入是很头疼的，NSString自带了这个方法，可以去除用户输入的前后空格（注意只是前后哦）或是里面的特殊符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;  我是一个程序猿   &quot;;</span><br><span class="line">NSString *newStr = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];</span><br><span class="line">NSLog(@&quot;处理之前|%@|, 处理之后|%@|&quot;, str, newStr);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>输出结果: 处理之前| 我是一个程序猿 |, 处理之后|我是一个程序猿|</p>
<ul>
<li>即 上述方法能去除用户前后输入文字的空格</li>
<li>也可以去除文字中的特殊符号(一种过滤)<br>这里不得不说到NSCharacterSet类, NSCharacterSet其实是许多字符或者数字或者符号的集合,如果需要过滤用户输入的字符串,需要自行创建NSCharacterSet对象,并且输入要过滤的字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@&quot;@／：()；（）¥「」＂、[]&#123;&#125;#%-*+=_\\|~＜＞$€^•&apos;@#$%^&amp;*()_+&apos;\&quot;&quot;];</span><br></pre></td></tr></table></figure>
<ul>
<li>其中 NSCharacterSet提供了很多字符集</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (NSCharacterSet *)controlCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)whitespaceCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)whitespaceAndNewlineCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)decimalDigitCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)letterCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)lowercaseLetterCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)uppercaseLetterCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)nonBaseCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)alphanumericCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)decomposableCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)illegalCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)punctuationCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)capitalizedLetterCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)symbolCharacterSet;</span><br><span class="line">+ (NSCharacterSet *)newlineCharacterSet NS_AVAILABLE(10_5, 2_0);</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
            <tag> NSString </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[string/// 在指定字符串第一次搜索结果位置前/后插入字符串]]></title>
      <url>/2018/05/18/Swift4.0%20%20%20string:::%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E4%BD%8D%E7%BD%AE%E5%89%8D:%E5%90%8E%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>Swift4.0   string/// 在指定字符串第一次搜索结果位置前/后插入字符串</p>
<p>extension String {</p>
<p>​    func positionOf(sub:String, backwards:Bool)-&gt;Int {</p>
<p>​        var pos = -1</p>
<p>​        </p>
<p>​        guard let inde  = self.range(of: sub)?.upperBound else {</p>
<p>​           </p>
<p>​            return pos</p>
<p>​            </p>
<p>​        }</p>
<p>​<br><a id="more"></a><br>​        if backwards {</p>
<p>​            pos = (self.range(of: sub)?.upperBound.encodedOffset)!</p>
<p>​        }else{</p>
<p>​            pos = (self.range(of: sub)?.lowerBound.encodedOffset)!</p>
<p>​        }</p>
<p>​       </p>
<p>​        return pos</p>
<p>​    }</p>
<p>​    /// 在指定字符串第一次搜索结果位置前/后插入字符串</p>
<p>​    ///</p>
<p>​    /// - Parameters:</p>
<p>​    ///   - sub: 指定字符串</p>
<p>​    ///   - inserSourceStr: 插入字符串</p>
<p>​    /// - Returns: 字符串,为查询到sub返回self</p>
<p>​    func insertStr(<em> sub:String,</em> inserSourceStr:String,_ backwards:Bool = true)  -&gt; String {</p>
<p>​        let position = self.positionOf(sub: sub, backwards: backwards)</p>
<p>​        </p>
<p>​        if position &lt; 0 {</p>
<p>​            return self</p>
<p>​        }</p>
<p>​        </p>
<p>​        let insertindex = self.index(self.startIndex, offsetBy: position)</p>
<p>​        var returnStr  = self</p>
<p>​        returnStr.insert(contentsOf: inserSourceStr, at: insertindex)</p>
<p>​        </p>
<p>​        return returnStr</p>
<p>​    }</p>
<p>}</p>
<p>直接copy即可使用</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> string </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[配置Xcode常用变量]]></title>
      <url>/2018/05/17/Xcode%E9%85%8D%E7%BD%AE%E5%B8%B8%E7%94%A8%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<p>：环境变量宏（Build Setting Macros）引用格式：${MACRO}，同Build Phases Run Script中的语法。</p>
<p>PROJECT = HelloWorld</p>
<p><strong>PROJECT_DIR</strong> =~/Projects/Learn Objective-C/HelloWorld</p>
<p>PROJECT_FILE_PATH =${PROJECT_DIR}/HelloWorld.xcodeproj</p>
<p>PROJECT_NAME = HelloWorld</p>
 <a id="more"></a>
<p>SOURCE_ROOT =${PROJECT_DIR}</p>
<p>SRCROOT =${PROJECT_DIR}</p>
<p>SDKROOT = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk</p>
<p>SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk</p>
<p>SDK_NAME = macosx10.9</p>
<p><a href="http://www.bubuko.com/infodetail-1446347.html" target="_blank" rel="noopener">Xcode 配置常用变量（SRCROOT, PROJECT_DIR, PROJECT_NAME）</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift项目中手动添加桥接文件]]></title>
      <url>/2018/05/17/Swift%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E6%A1%A5%E6%8E%A5%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>######</p>
<p>1:先新建一个New. File<br>……………………………/≤.<br><img src="https://img-blog.csdn.net/20170422155158380?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGF1c2VuMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>2:选择Header File<br><img src="https://img-blog.csdn.net/20170422155317396?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGF1c2VuMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><a id="more"></a><br>3:给Header File命名</p>
<p><img src="https://img-blog.csdn.net/20170422155343459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGF1c2VuMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>4:添加关联<br><img src="https://img-blog.csdn.net/20170422155405131?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGF1c2VuMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>5:输入Header File文件的路径<br><img src="https://img-blog.csdn.net/20170422155450379?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGF1c2VuMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>6:以上操作完成之后,command + B编译一下,如果错误,的话,会提示你找不到这个Header File</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何从 GitHub 上下载单个文件夹？]]></title>
      <url>/2018/05/17/%E5%A6%82%E4%BD%95%E4%BB%8E%20GitHub%20%E4%B8%8A%E4%B8%8B%E8%BD%BD%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>用 SVN 即可</p>
<p>举例说明:</p>
<p>譬如这个项目:<a href="https://link.zhihu.com/?target=https%3A//github.com/Mooophy/Cpp-Primer" target="_blank" rel="noopener"><a href="https://github.com/3lvis" target="_blank" rel="noopener">3lvis</a>/<strong>Sync</strong></a>,我只想看 <strong>iOSDemo</strong> 文件夹的代码怎么办?先打开 ch03, 其 URL 为:”<a href="https://github.com/3lvis/Sync/tree/master/iOSDemo" target="_blank" rel="noopener">https://github.com/3lvis/Sync/tree/master/iOSDemo</a>“</p>
<p>将 <strong>/tree/master/ </strong>换成  <strong>/trunk/ </strong></p>
<p>“<a href="https://github.com/3lvis/Sync/trunk/iOSDemo" target="_blank" rel="noopener">https://github.com/3lvis/Sync/trunk/iOSDemo</a>“</p>
<p>然后, 输入:svn checkout  <a href="https://github.com/3lvis/Sync/trunk/iOSDemo" target="_blank" rel="noopener">https://github.com/3lvis/Sync/trunk/iOSDemo</a></p>
<p>PS: 第一次使用的话, 可能会出现下面这个提示:<br><a id="more"></a><br>R)eject, accept (t)emporarily or accept (p)ermanently?</p>
<p>输入 P 就行了.</p>
<p>如果不是master分支 :</p>
<p>只需要将 /trunk/ 换成 <strong>/branches/branchname/</strong> 就行了 ，</p>
<p>例如fix/447， 换成 **/branches/fix/447/</p>
<p>下载过程中可能出现下面错误：</p>
<p>svn: E000002: Unable to create pristine install stream</p>
<p>原因是因为项目目录的.svn缺少一个tmp的文件夹</p>
<p>解决方法:在.svn目录新建一个tmp文件夹；或者在/iOSDemo下添加tmp文件夹两种方法都可以</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift fallthrough语句]]></title>
      <url>/2018/05/17/Swift%20fallthrough%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>在 Swift 中的 switch 语句，只要第一个匹配的情况(case) 完成执行，而不是通过随后的情况(case)的底部，如它在 C 和 C++ 编程语言中的那样。以下是 C 和 C++ 的 switch 语句的通用语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch(expression)&#123;</span><br><span class="line">   case constant-expression  :</span><br><span class="line">      statement(s);</span><br><span class="line">      break; /* optional */</span><br><span class="line">   case constant-expression  :</span><br><span class="line">      statement(s);</span><br><span class="line">      break; /* optional */</span><br><span class="line">  </span><br><span class="line">   /* you can have any number of case statements */</span><br><span class="line">   default : /* Optional */</span><br><span class="line">      statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们需要使用 break 语句退出 case 语句，否则执行控制都将落到下面提供匹配 case 语句随后的 case 语句。<br><a id="more"></a></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>以下是 Swift 的 switch 语句的通用语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch expression &#123;</span><br><span class="line">   case expression1  :</span><br><span class="line">      statement(s)</span><br><span class="line">      fallthrough /* optional */</span><br><span class="line">   case expression2, expression3  :</span><br><span class="line">      statement(s)</span><br><span class="line">      fallthrough /* optional */</span><br><span class="line">  </span><br><span class="line">   default : /* Optional */</span><br><span class="line">      statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用 fallthrough 语句，那么程序会在 switch 语句执行匹配 case 语句后退出来。我们将使用以下两个例子，以说明其功能和用法。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>以下是 Swift 编程 switch 语句中不使用 fallthrough 一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Cocoa</span><br><span class="line"></span><br><span class="line">var index = 10</span><br><span class="line"></span><br><span class="line">switch index &#123;</span><br><span class="line">   case 100  :</span><br><span class="line">      println( &quot;Value of index is 100&quot;)</span><br><span class="line">   case 10,15  :</span><br><span class="line">      println( &quot;Value of index is either 10 or 15&quot;)</span><br><span class="line">   case 5  :</span><br><span class="line">      println( &quot;Value of index is 5&quot;)</span><br><span class="line">   default :</span><br><span class="line">      println( &quot;default case&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上述代码被编译和执行时，它产生了以下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value of index is either 10 or 15</span><br></pre></td></tr></table></figure>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>以下是 Swift 编程中 switch 语句带有 fallthrough 的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import Cocoa</span><br><span class="line"></span><br><span class="line">var index = 10</span><br><span class="line"></span><br><span class="line">switch index &#123;</span><br><span class="line">   case 100  :</span><br><span class="line">      println( &quot;Value of index is 100&quot;)</span><br><span class="line">      fallthrough</span><br><span class="line">   case 10,15  :</span><br><span class="line">      println( &quot;Value of index is either 10 or 15&quot;)</span><br><span class="line">      fallthrough</span><br><span class="line">   case 5  :</span><br><span class="line">      println( &quot;Value of index is 5&quot;)</span><br><span class="line">   default :</span><br><span class="line">      println( &quot;default case&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上述代码被编译和执行时，它产生了以下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value of index is either 10 or 15</span><br><span class="line">Value of index is 5</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> fallthrough </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS字典的介绍]]></title>
      <url>/2018/05/17/%E5%AD%97%E5%85%B8%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>import UIKit</p>
<p>/<em><br> 字典的介绍<br> 1.字典允许按照某个键访问元素<br> 2.字典是由两部分组成, 一个键(key)集合, 一个是值(value)集合<br> 3.键集合是不能有重复的元素, 值集合可以有重复的元素, 键和值是成对出现的<br> 4.Swift 字典类型是Dictionary 也是一个泛型集合<br> 5.字典分为  可变字典和 不可变字典<br> let 修饰不可变字典   var修饰可变字典
 </em>/</p>
<p>//1.定义字典<br>//1&gt;定义不可变字典<br>//OC   @{@”name”:@”summer”,@”age”:@18}<br>//系统会自动判断后面[]中存放的键值对,还是一个一个元素<br>let dict = [“name” : “summer”, “age” : 18, “height” : 1.88] as [String : Any]<br><a id="more"></a><br>//2&gt;定义可变字典<br>//var mutableDict = Dictionary<string, nsobject="">() //方式一<br>//AnyObject: 一般指定类型  NSObject: 一般用于创建对象<br>//var mutableDict = [String : NSObject](）   //方式二<br>var mutableDict = [String  :  AnyObject ](） //常用  方式三</string,></p>
<p>//2.对可变字典的基本操作(增删改查)<br>//2.1&gt; 添加元素<br>mutableDict[“name”] = “summer” as AnyObject?<br>mutableDict[“age”] = 18 as AnyObject?<br>mutableDict[“height”] = 1.88 as AnyObject?<br>mutableDict[“weight”] = 60 as AnyObject?<br>mutableDict<br>//2.2&gt; 删除元素<br>mutableDict.removeValue(forKey: “age”)<br>mutableDict<br>//2.3&gt;修改元素<br>//  区别:如果字典中已经有了对应的key, 那么会直接修改原来key中保存的value<br>//  如果字典中没有对应的key, 那么添加对应的key/value<br>mutableDict[“name”] = “sun” as AnyObject?<br>mutableDict<br>mutableDict [“sex”] = “女” as AnyObject?<br>mutableDict<br>//2.4&gt; 获取某一个元素<br>mutableDict[“sex”]</p>
<p>//3.遍历字典<br>//3.1&gt;遍历字典中所有的key<br>for key in mutableDict.keys{<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(key)</span><br></pre></td></tr></table></figure></p>
<p>}<br>//3.2&gt;遍历字典中所以的值<br>for value in mutableDict.values{<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(value)</span><br></pre></td></tr></table></figure></p>
<p>}<br>//3.3&gt;遍历所有的键值对<br>for (key, value) in mutableDict{<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(key)</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure></p>
<p>}</p>
<p>//4.字典的合并<br>//即使类型一致也不能相加进行合并<br>//let dict1 = [“name”:”summer”, “age” : 18] as [String : Any]<br>//let dict2 = [“sex” : “男”, “phoneNumber” : “+86 0393”] as [String : Any]<br>//<br>//let resultDict = dict1 + dict2  //写法是错误的</p>
<p>//如果必须合并  那么只能<br>var dict1 = [“name”:”summer”, “age” : 18] as [String : Any]<br>let dict2 = [“sex” : “男”, “phoneNumber” : “+86 0393”] as [String : Any]</p>
<p>for (key, value) in dict2{<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict1[key] = value as AnyObject?</span><br></pre></td></tr></table></figure></p>
<p>}<br>dict1</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS高手进阶之]]></title>
      <url>/2018/05/16/Swift%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%B3%9B%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p> 转自：<a href="http://codecloud.net/swift-23-1230.html" target="_blank" rel="noopener">http://codecloud.net/swift-23-1230.html</a><br>泛型代码可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。<br>泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。例如，Swift 的数组和字典类型都是泛型集。你可以创建一个Int数组，也可创建一个String数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的。<br>泛型所解决的问题<br>这里是一个标准的，非泛型函数swapTwoInts,用来交换两个Int值：<br>func swapTwoInts(inout a: Int, inout b: Int)<br>​    let temporaryA = a<br>​    a = b<br>​    b = temporaryA<br>}</p>
<a id="more"></a>
<p>这个函数使用写入读出（in-out）参数来交换a和b的值，请参考[写入读出参数][1]。<br>swapTwoInts函数可以交换b的原始值到a，也可以交换a的原始值到b，你可以调用这个函数交换两个Int变量值：<br>var someInt = 3<br>var anotherInt = 107<br>swapTwoInts(&amp;someInt, &amp;anotherInt)<br>println(“someInt is now (someInt), and anotherInt is now (anotherInt)”)<br>// 输出 “someInt is now 107, and anotherInt is now 3”<br>swapTwoInts函数是非常有用的，但是它只能交换Int值，如果你想要交换两个String或者Double，就不得不写更多的函数，如 swapTwoStrings和swapTwoDoublesfunctions，如同如下所示：<br>func swapTwoStrings(inout a: String, inout b: String) {<br>​    let temporaryA = a<br>​    a = b<br>​    b = temporaryA<br>}<br>func swapTwoDoubles(inout a: Double, inout b: Double) {<br>​    let temporaryA = a<br>​    a = b<br>​    b = temporaryA<br>}<br>你可能注意到 swapTwoInts、 swapTwoStrings和swapTwoDoubles函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是Int、String和Double。<br>但实际应用中通常需要一个用处更强大并且尽可能的考虑到更多的灵活性单个函数，可以用来交换两个任何类型值，很幸运的是，泛型代码帮你解决了这种问题。（一个这种泛型函数后面已经定义好了。）<br>注意： 在所有三个函数中，a和b的类型是一样的。如果a和b不是相同的类型，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个String类型的变量和一个Double类型的变量互相交换值。如果一定要做，Swift 将报编译错误。<br>泛型函数<br>泛型函数可以工作于任何类型，这里是一个上面swapTwoInts函数的泛型版本，用于交换两个值：<br>func swapTwoValues<t>(inout a: T, inout b: T) {<br>​    let temporaryA = a<br>​    a = b<br>​    b = temporaryA<br>}<br>swapTwoValues函数主体和swapTwoInts函数是一样的，它只在第一行稍微有那么一点点不同于swapTwoInts，如下所示：<br>func swapTwoInts(inout a: Int, inout b: Int)<br>func swapTwoValues<t>(inout a: T, inout b: T)<br>这个函数的泛型版本使用了占位类型名字（通常此情况下用字母T来表示）来代替实际类型名（如In、String或Doubl）。占位类型名没有提示T必须是什么类型，但是它提示了a和b必须是同一类型T，而不管T表示什么类型。只有swapTwoValues函数在每次调用时所传入的实际类型才能决定T所代表的类型。<br>另外一个不同之处在于这个泛型函数名后面跟着的展位类型名字（T）是用尖括号括起来的（）。这个尖括号告诉 Swift 那个T是swapTwoValues函数所定义的一个类型。因为T是一个占位命名类型，Swift 不会去查找命名为T的实际类型。<br>swapTwoValues函数除了要求传入的两个任何类型值是同一类型外，也可以作为swapTwoInts函数被调用。每次swapTwoValues被调用，T所代表的类型值都会传给函数。<br>在下面的两个例子中,T分别代表Int和String：<br>var someInt = 3<br>var anotherInt = 107<br>swapTwoValues(&amp;someInt, &amp;anotherInt)<br>// someInt is now 107, and anotherInt is now 3<br>var someString = “hello”<br>var anotherString = “world”<br>swapTwoValues(&amp;someString, &amp;anotherString)<br>// someString is now “world”, and anotherString is now “hello”<br>注意 上面定义的函数swapTwoValues是受swap函数启发而实现的。swap函数存在于 Swift 标准库，并可以在其它类中任意使用。如果你在自己代码中需要类似swapTwoValues函数的功能，你可以使用已存在的交换函数swap函数。<br>类型参数<br>在上面的swapTwoValues例子中，占位类型T是一种类型参数的示例。类型参数指定并命名为一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（如）。<br>一旦一个类型参数被指定，那么其可以被使用来定义一个函数的参数类型（如swapTwoValues函数中的参数a和b），或作为一个函数返回类型，或用作函数主体中的注释类型。在这种情况下，被类型参数所代表的占位类型不管函数任何时候被调用，都会被实际类型所替换（在上面swapTwoValues例子中，当函数第一次被调用时，T被Int替换，第二次调用时，被String替换。）。<br>你可支持多个类型参数，命名在尖括号中，用逗号分开。<br>命名类型参数<br>在简单的情况下，泛型函数或泛型类型需要指定一个占位类型（如上面的swapTwoValues泛型函数，或一个存储单一类型的泛型集，如数组），通常用一单个字母T来命名类型参数。不过，你可以使用任何有效的标识符来作为类型参数名。<br>如果你使用多个参数定义更复杂的泛型函数或泛型类型，那么使用更多的描述类型参数是非常有用的。例如，Swift 字典（Dictionary）类型有两个类型参数，一个是键，另外一个是值。如果你自己写字典，你或许会定义这两个类型参数为KeyType和ValueType，用来记住它们在你的泛型代码中的作用。<br>注意 请始终使用大写字母开头的驼峰式命名法（例如T和KeyType）来给类型参数命名，以表明它们是类型的占位符，而非类型值。<br>泛型类型<br>通常在泛型函数中，Swift 允许你定义你自己的泛型类型。这些自定义类、结构体和枚举作用于任何类型，如同Array和Dictionary的用法。<br>这部分向你展示如何写一个泛型集类型–Stack（栈）。一个栈是一系列值域的集合，和Array（数组）类似，但其是一个比 Swift 的Array类型更多限制的集合。一个数组可以允许其里面任何位置的插入/删除操作，而栈，只允许在集合的末端添加新的项（如同push一个新值进栈）。同样的一个栈也只能从末端移除项（如同pop一个值出栈）。<br>注意 栈的概念已被UINavigationController类使用来模拟试图控制器的导航结构。你通过调用UINavigationController的pushViewController:animated:方法来为导航栈添加（add）新的试图控制器；而通过popViewControllerAnimated:的方法来从导航栈中移除（pop）某个试图控制器。每当你需要一个严格的后进先出方式来管理集合，堆栈都是最实用的模型。<br>下图展示了一个栈的压栈(push)/出栈(pop)的行为：<br>![此处输入图片的描述][2]<br>现在有三个值在栈中；<br>第四个值“pushed”到栈的顶部；<br>现在有四个值在栈中，最近的那个在顶部；<br>栈中最顶部的那个项被移除，或称之为“popped”；<br>移除掉一个值后，现在栈又重新只有三个值。<br>这里展示了如何写一个非泛型版本的栈，Int值型的栈：<br>struct IntStack {<br>​    var items = Int<a href=""></a><br>​    mutating func push(item: Int) {<br>​        items.append(item)<br>​    }<br>​    mutating func pop() -&gt; Int {<br>​        return items.removeLast()<br>​    }<br>}<br>这个结构体在栈中使用一个Array性质的items存储值。Stack提供两个方法：push和pop，从栈中压进一个值和移除一个值。这些方法标记为可变的，因为他们需要修改（或转换）结构体的items数组。<br>上面所展现的IntStack类型只能用于Int值，不过，其对于定义一个泛型Stack类（可以处理任何类型值的栈）是非常有用的。<br>这里是一个相同代码的泛型版本：<br>struct Stack<t> {<br>​    var items = T<a href=""></a><br>​    mutating func push(item: T) {<br>​        items.append(item)<br>​    }<br>​    mutating func pop() -&gt; T {<br>​        return items.removeLast()<br>​    }<br>}<br>注意到Stack的泛型版本基本上和非泛型版本相同，但是泛型版本的占位类型参数为T代替了实际Int类型。这种类型参数包含在一对尖括号里（<t>），紧随在结构体名字后面。<br>T定义了一个名为“某种类型T”的节点提供给后来用。这种将来类型可以在结构体的定义里任何地方表示为“T”。在这种情况下，T在如下三个地方被用作节点：<br>创建一个名为items的属性，使用空的T类型值数组对其进行初始化；<br>指定一个包含一个参数名为item的push方法，该参数必须是T类型；<br>指定一个pop方法的返回值，该返回值将是一个T类型值。<br>当创建一个新单例并初始化时， 通过用一对紧随在类型名后的尖括号里写出实际指定栈用到类型，创建一个Stack实例，同创建Array和Dictionary一样：<br>var stackOfStrings = Stack<string>()<br>stackOfStrings.push(“uno”)<br>stackOfStrings.push(“dos”)<br>stackOfStrings.push(“tres”)<br>stackOfStrings.push(“cuatro”)<br>// 现在栈已经有4个string了<br>下图将展示stackOfStrings如何push这四个值进栈的过程：<br>![此处输入图片的描述][3]<br>从栈中pop并移除值”cuatro”：<br>let fromTheTop = stackOfStrings.pop()<br>// fromTheTop is equal to “cuatro”, and the stack now contains 3 strings<br>下图展示了如何从栈中pop一个值的过程： ![此处输入图片的描述][4]<br>由于Stack是泛型类型，所以在 Swift 中其可以用来创建任何有效类型的栈，这种方式如同Array和Dictionary。<br>类型约束<br>swapTwoValues函数和Stack类型可以作用于任何类型，不过，有的时候对使用在泛型函数和泛型类型上的类型强制约束为某种特定类型是非常有用的。类型约束指定了一个必须继承自指定类的类型参数，或者遵循一个特定的协议或协议构成。<br>例如，Swift 的Dictionary类型对作用于其键的类型做了些限制。在[字典][5]的描述中，字典的键类型必须是可哈希，也就是说，必须有一种方法可以使其是唯一的表示。Dictionary之所以需要其键是可哈希是为了以便于其检查其是否包含某个特定键的值。如无此需求，Dictionary即不会告诉是否插入或者替换了某个特定键的值，也不能查找到已经存储在字典里面的给定键值。<br>这个需求强制加上一个类型约束作用于Dictionary的键上，当然其键类型必须遵循Hashable协议（Swift 标准库中定义的一个特定协议）。所有的 Swift 基本类型（如String，Int， Double和 Bool）默认都是可哈希。<br>当你创建自定义泛型类型时，你可以定义你自己的类型约束，当然，这些约束要支持泛型编程的强力特征中的多数。抽象概念如可哈希具有的类型特征是根据他们概念特征来界定的，而不是他们的直接类型特征。<br>类型约束语法<br>你可以写一个在一个类型参数名后面的类型约束，通过冒号分割，来作为类型参数链的一部分。这种作用于泛型函数的类型约束的基础语法如下所示（和泛型类型的语法相同）：<br>func someFunction<t: someclass,="" u:="" someprotocol="">(someT: T, someU: U) {<br>​    // function body goes here<br>}<br>上面这个假定函数有两个类型参数。第一个类型参数T，有一个需要T必须是SomeClass子类的类型约束；第二个类型参数U，有一个需要U必须遵循SomeProtocol协议的类型约束。<br>类型约束行为<br>这里有个名为findStringIndex的非泛型函数，该函数功能是去查找包含一给定String值的数组。若查找到匹配的字符串，findStringIndex函数返回该字符串在数组中的索引值（Int），反之则返回nil：<br>func findStringIndex(array: String[], valueToFind: String) -&gt; Int? {<br>​    for (index, value) in enumerate(array) {<br>​        if value == valueToFind {<br>​            return index<br>​        }<br>​    }<br>​    return nil<br>}<br>findStringIndex函数可以作用于查找一字符串数组中的某个字符串:<br>let strings = [“cat”, “dog”, “llama”, “parakeet”, “terrapin”]<br>if let foundIndex = findStringIndex(strings, “llama”) {<br>​    println(“The index of llama is (foundIndex)”)<br>}<br>// 输出 “The index of llama is 2”<br>如果只是针对字符串而言查找在数组中的某个值的索引，用处不是很大，不过，你可以写出相同功能的泛型函数findIndex，用某个类型T值替换掉提到的字符串。<br>这里展示如何写一个你或许期望的findStringIndex的泛型版本findIndex。请注意这个函数仍然返回Int，是不是有点迷惑呢，而不是泛型类型?那是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数不会编译，原因在例子后面会说明：<br>func findIndex<t>(array: T[], valueToFind: T) -&gt; Int? {<br>​    for (index, value) in enumerate(array) {<br>​        if value == valueToFind {<br>​            return index<br>​        }<br>​    }<br>​    return nil<br>}<br>上面所写的函数不会编译。这个问题的位置在等式的检查上，“if value == valueToFind”。不是所有的 Swift 中的类型都可以用等式符（==）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 没法猜到对于这个类或结构体而言“等于”的意思。正因如此，这部分代码不能可能保证工作于每个可能的类型T，当你试图编译这部分代码时估计会出现相应的错误。<br>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个Equatable协议，该协议要求任何遵循的类型实现等式符（==）和不等符（!=）对任何两个该类型进行比较。所有的 Swift 标准类型自动支持Equatable协议。<br>任何Equatable类型都可以安全的使用在findIndex函数中，因为其保证支持等式操作。为了说明这个事实，当你定义一个函数时，你可以写一个Equatable类型约束作为类型参数定义的一部分：<br>func findIndex<t: equatable="">(array: T[], valueToFind: T) -&gt; Int? {<br>​    for (index, value) in enumerate(array) {<br>​        if value == valueToFind {<br>​            return index<br>​        }<br>​    }<br>​    return nil<br>}<br>findIndex中这个单个类型参数写做：T: Equatable，也就意味着“任何T类型都遵循Equatable协议”。<br>findIndex函数现在则可以成功的编译过，并且作用于任何遵循Equatable的类型，如Double或String:<br>let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)<br>// doubleIndex is an optional Int with no value, because 9.3 is not in the array<br>let stringIndex = findIndex([“Mike”, “Malcolm”, “Andrea”], “Andrea”)<br>// stringIndex is an optional Int containing a value of 2<br>关联类型<br>当定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分是非常有用的。一个关联类型给定作用于协议部分的类型一个节点名（或别名）。作用于关联类型上实际类型是不需要指定的，直到该协议接受。关联类型被指定为typealias关键字。<br>关联类型行为<br>这里是一个Container协议的例子，定义了一个ItemType关联类型：<br>protocol Container {<br>​    typealias ItemType<br>​    mutating func append(item: ItemType)<br>​    var count: Int { get }<br>​    subscript(i: Int) -&gt; ItemType { get }<br>}<br>Container协议定义了三个任何容器必须支持的兼容要求：<br>必须可能通过append方法添加一个新item到容器里；<br>必须可能通过使用count属性获取容器里items的数量，并返回一个Int值；<br>必须可能通过容器的Int索引值下标可以检索到每一个item。<br>这个协议没有指定容器里item是如何存储的或何种类型是允许的。这个协议只指定三个任何遵循Container类型所必须支持的功能点。一个遵循的类型也可以提供其他额外的功能，只要满足这三个条件。<br>任何遵循Container协议的类型必须指定存储在其里面的值类型，必须保证只有正确类型的items可以加进容器里，必须明确可以通过其下标返回item类型。<br>为了定义这三个条件，Container协议需要一个方法指定容器里的元素将会保留，而不需要知道特定容器的类型。Container协议需要指定任何通过append方法添加到容器里的值和容器里元素是相同类型，并且通过容器下标返回的容器元素类型的值的类型是相同类型。<br>为了达到此目的，Container协议声明了一个ItemType的关联类型，写作typealias ItemType。The protocol does not define what ItemType is an alias for—that information is left for any conforming type to provide（这个协议不会定义ItemType是遵循类型所提供的何种信息的别名）。尽管如此，ItemType别名支持一种方法识别在一个容器里的items类型，以及定义一种使用在append方法和下标中的类型，以便保证任何期望的Container的行为是强制性的。<br>这里是一个早前IntStack类型的非泛型版本，适用于遵循Container协议：<br>struct IntStack: Container {<br>​    // original IntStack implementation<br>​    var items = Int<a href=""></a><br>​    mutating func push(item: Int) {<br>​        items.append(item)<br>​    }<br>​    mutating func pop() -&gt; Int {<br>​        return items.removeLast()<br>​    }<br>​    // conformance to the Container protocol<br>​    typealias ItemType = Int<br>​    mutating func append(item: Int) {<br>​        self.push(item)<br>​    }<br>​    var count: Int {<br>​    return items.count<br>​    }<br>​    subscript(i: Int) -&gt; Int {<br>​        return items*    }}IntStack类型实现了Container协议的所有三个要求，在IntStack类型的每个包含部分的功能都满足这些要求。此外，IntStack指定了Container的实现，适用的ItemType被用作Int类型。对于这个Container协议实现而言，定义typealias ItemType = Int，将抽象的ItemType类型转换为具体的Int类型。感谢Swift类型参考，你不用在IntStack定义部分声明一个具体的Int的ItemType。由于IntStack遵循Container协议的所有要求，只要通过简单的查找append方法的item参数类型和下标返回的类型，Swift就可以推断出合适的ItemType来使用。确实，如果上面的代码中你删除了 typealias ItemType = Int这一行，一切仍旧可以工作，因为它清楚的知道ItemType使用的是何种类型。你也可以生成遵循Container协议的泛型Stack类型：struct Stack<t>: Container {    // original Stack<t> implementation    var items = T<a href=""></a>    mutating func push(item: T) {        items.append(item)    }    mutating func pop() -&gt; T {        return items.removeLast()    }    // conformance to the Container protocol    mutating func append(item: T) {        self.push(item)    }    var count: Int {    return items.count    }    subscript(i: Int) -&gt; T {        return items    }}这个时候，占位类型参数T被用作append方法的item参数和下标的返回类型。Swift 因此可以推断出被用作这个特定容器的ItemType的T的合适类型。扩展一个存在的类型为一指定关联类型在[使用扩展来添加协议兼容性][6]中有描述扩展一个存在的类型添加遵循一个协议。这个类型包含一个关联类型的协议。Swift的Array已经提供append方法，一个count属性和通过下标来查找一个自己的元素。这三个功能都达到Container协议的要求。也就意味着你可以扩展Array去遵循Container协议，只要通过简单声明Array适用于该协议而已。如何实践这样一个空扩展，在[使用扩展来声明协议的采纳][7]中有描述这样一个实现一个空扩展的行为：extension Array: Container {}如同上面的泛型Stack类型一样，Array的append方法和下标保证Swift可以推断出ItemType所使用的适用的类型。定义了这个扩展后，你可以将任何Array当作Container来使用。Where 语句[类型约束][8]中描述的类型约束确保你定义关于类型参数的需求和一泛型函数或类型有关联。对于关联类型的定义需求也是非常有用的。你可以通过这样去定义where语句作为一个类型参数队列的一部分。一个where语句使你能够要求一个关联类型遵循一个特定的协议，以及（或）那个特定的类型参数和关联类型可以是相同的。你可写一个where语句，通过紧随放置where关键字在类型参数队列后面，其后跟着一个或者多个针对关联类型的约束，以及（或）一个或多个类型和关联类型的等于关系。下面的列子定义了一个名为allItemsMatch的泛型函数，用来检查是否两个Container单例包含具有相同顺序的相同元素。如果匹配到所有的元素，那么返回一个为true的Boolean值，反之，则相反。这两个容器可以被检查出是否是相同类型的容器（虽然它们可以是），但他们确实拥有相同类型的元素。这个需求通过一个类型约束和where语句结合来表示：func allItemsMatch&lt;    C1: Container, C2: Container    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;    (someContainer: C1, anotherContainer: C2) -&gt; Bool {        // check that both containers contain the same number of items        if someContainer.count != anotherContainer.count {            return false        }        // check each pair of items to see if they are equivalent        for i in 0..someContainer.count {            if someContainer != anotherContainer {                return false            }        }        // all items match, so return true        return true}这个函数用了两个参数：someContainer和anotherContainer。someContainer参数是类型C1，anotherContainer参数是类型C2。C1和C2是容器的两个占位类型参数，决定了这个函数何时被调用。这个函数的类型参数列紧随在两个类型参数需求的后面：C1必须遵循Container协议 (写作 C1: Container)。C2必须遵循Container协议 (写作 C2: Container)。C1的ItemType同样是C2的ItemType（写作 C1.ItemType == C2.ItemType）。C1的ItemType必须遵循Equatable协议 (写作 C1.ItemType: Equatable)。第三个和第四个要求被定义为一个where语句的一部分，写在关键字where后面，作为函数类型参数链的一部分。这些要求意思是：someContainer是一个C1类型的容器。 anotherContainer是一个C2类型的容器。 someContainer和anotherContainer包含相同的元素类型。 someContainer中的元素可以通过不等于操作(!=)来检查它们是否彼此不同。第三个和第四个要求结合起来的意思是anotherContainer中的元素也可以通过 != 操作来检查，因为他们在someContainer中元素确实是相同的类型。这些要求能够使allItemsMatch函数比较两个容器，即便他们是不同的容器类型。allItemsMatch首先检查两个容器是否拥有同样数目的items，如果他们的元素数目不同，没有办法进行匹配，函数就会false。检查完之后，函数通过for-in循环和半闭区间操作（..）来迭代someContainer中的所有元素。对于每个元素，函数检查是否someContainer中的元素不等于对应的anotherContainer中的元素，如果这两个元素不等，则这两个容器不匹配，返回false。如果循环体结束后未发现没有任何的不匹配，那表明两个容器匹配，函数返回true。这里演示了allItemsMatch函数运算的过程：var stackOfStrings = Stack<string>()stackOfStrings.push(“uno”)stackOfStrings.push(“dos”)stackOfStrings.push(“tres”)var arrayOfStrings = [“uno”, “dos”, “tres”]if allItemsMatch(stackOfStrings, arrayOfStrings) {    println(“All items match.”)} else {    println(“Not all items match.”)}// 输出 “All items match.”上面的例子创建一个Stack单例来存储String，然后压了三个字符串进栈。这个例子也创建了一个Array单例，并初始化包含三个同栈里一样的原始字符串。即便栈和数组否是不同的类型，但他们都遵循Container协议，而且他们都包含同样的类型值。你因此可以调用allItemsMatch函数，用这两个容器作为它的参数。在上面的例子中，allItemsMatch函数正确的显示了所有的这两个容器的items匹配。 </string></t></t></t:></t></t:></string></t></t></t></t></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift高手进阶之协议]]></title>
      <url>/2018/05/16/Swift%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p>#</p>
<p> 转自：<a href="http://codecloud.net/swift-22-1228.html" target="_blank" rel="noopener">http://codecloud.net/swift-22-1228.html</a><br>Protocol(协议)用于统一方法和属性的名称，而不实现任何功能。协议能够被类，枚举，结构体实现，满足协议要求的类，枚举，结构体被称为协议的遵循者。<br>遵循者需要提供协议指定的成员，如属性，方法，操作符，下标等。<br>协议的语法<br>协议的定义与类，结构体，枚举的定义非常相似，如下所示：<br>protocol SomeProtocol {<br>​    // 协议内容<br>}<br>在类，结构体，枚举的名称后加上协议名称，中间以冒号:分隔即可实现协议；实现多个协议时，各协议之间用逗号,分隔，如下所示：<br>struct SomeStructure: FirstProtocol, AnotherProtocol {<br>​    // 结构体内容<br>}</p>
<a id="more"></a>
<p>当某个类含有父类的同时并实现了协议，应当把父类放在所有的协议之前，如下所示：<br>class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {<br>​    // 类的内容<br>}<br>属性要求<br>协议能够要求其遵循者必须含有一些特定名称和类型的实例属性(instance property)或类属性 (type property)，也能够要求属性的(设置权限)settable 和(访问权限)gettable，但它不要求属性是存储型属性(stored property)还是计算型属性(calculate property)。<br>通常前置var关键字将属性声明为变量。在属性声明后写上{ get set }表示属性为可读写的。{ get }用来表示属性为可读的。即使你为可读的属性实现了setter方法，它也不会出错。<br>protocol SomeProtocol {<br>​    var musBeSettable : Int { get set }<br>​    var doesNotNeedToBeSettable: Int { get }<br>}<br>用类来实现协议时，使用class关键字来表示该属性为类成员；用结构体或枚举实现协议时，则使用static关键字来表示：<br>protocol AnotherProtocol {<br>​    class var someTypeProperty: Int { get set }<br>}<br>protocol FullyNamed {<br>​    var fullName: String { get }<br>}<br>FullyNamed协议含有fullName属性。因此其遵循者必须含有一个名为fullName，类型为String的可读属性。<br>struct Person: FullyNamed{<br>​    var fullName: String<br>}<br>let john = Person(fullName: “John Appleseed”)<br>//john.fullName 为 “John Appleseed”<br>Person结构体含有一个名为fullName的存储型属性，完整的遵循了协议。(若协议未被完整遵循，编译时则会报错)。<br>如下所示，Startship类遵循了FullyNamed协议：<br>class Starship: FullyNamed {<br>​    var prefix: String?<br>​    var name: String<br>​    init(name: String, prefix: String? = nil ) {<br>​        self.anme = name<br>​        self.prefix = prefix<br>​    }<br>​    var fullName: String {<br>​    return (prefix ? prefix ! + “ “ : “ “) + name<br>​    }<br>}<br>var ncc1701 = Starship(name: “Enterprise”, prefix: “USS”)<br>// ncc1701.fullName == “USS Enterprise”<br>Starship类将fullName实现为可读的计算型属性。它的每一个实例都有一个名为name的必备属性和一个名为prefix的可选属性。 当prefix存在时，将prefix插入到name之前来为Starship构建fullName。<br>方法要求<br>协议能够要求其遵循者必备某些特定的实例方法和类方法。协议方法的声明与普通方法声明相似，但它不需要方法内容。<br>注意：<br>协议方法支持变长参数(variadic parameter)，不支持默认参数(default parameter)。<br>前置class关键字表示协议中的成员为类成员；当协议用于被枚举或结构体遵循时，则使用static关键字。如下所示：<br>protocol SomeProtocol {<br>​    class func someTypeMethod()<br>}<br>protocol RandomNumberGenerator {<br>​    func random() -&gt; Double<br>}<br>RandomNumberGenerator协议要求其遵循者必须拥有一个名为random， 返回值类型为Double的实例方法。(我们假设随机数在[0，1]区间内)。<br>LinearCongruentialGenerator类遵循了RandomNumberGenerator协议，并提供了一个叫做线性同余生成器(linear congruential generator)的伪随机数算法。<br>class LinearCongruentialGenerator: RandomNumberGenerator {<br>​    var lastRandom = 42.0<br>​    let m = 139968.0<br>​    let a = 3877.0<br>​    let c = 29573.0<br>​    func random() -&gt; Double {<br>​        lastRandom = ((lastRandom <em> a + c) % m)<br>​        return lastRandom / m<br>​    }<br>}<br>let generator = LinearCongruentialGenerator()<br>println(“Here’s a random number: (generator.random())”)<br>// 输出 : “Here’s a random number: 0.37464991998171”<br>println(“And another one: (generator.random())”)<br>// 输出 : “And another one: 0.729023776863283”<br>突变方法要求<br>能在方法或函数内部改变实例类型的方法称为突变方法。在值类型(Value Type)(译者注：特指结构体和枚举)中的的函数前缀加上mutating关键字来表示该函数允许改变该实例和其属性的类型。 这一变换过程在实例方法(Instance Methods)章节中有详细描述。<br>(译者注：类中的成员为引用类型(Reference Type)，可以方便的修改实例及其属性的值而无需改变类型；而结构体和枚举中的成员均为值类型(Value Type)，修改变量的值就相当于修改变量的类型，而Swift默认不允许修改类型，因此需要前置mutating关键字用来表示该函数中能够修改类型)<br>注意：<br>用class实现协议中的mutating方法时，不用写mutating关键字；用结构体，枚举实现协议中的mutating方法时，必须写mutating关键字。<br>如下所示，Togglable协议含有toggle函数。根据函数名称推测，toggle可能用于切换或恢复某个属性的状态。mutating关键字表示它为突变方法：<br>protocol Togglable {<br>​    mutating func toggle()<br>}<br>当使用枚举或结构体来实现Togglabl协议时，必须在toggle方法前加上mutating关键字。<br>如下所示，OnOffSwitch枚举遵循了Togglable协议，On，Off两个成员用于表示当前状态<br>enum OnOffSwitch: Togglable {<br>​    case Off, On<br>​    mutating func toggle() {<br>​        switch self {<br>​        case Off:<br>​            self = On<br>​        case On:<br>​            self = Off<br>​        }<br>​    }<br>}<br>var lightSwitch = OnOffSwitch.Off<br>lightSwitch.toggle()<br>//lightSwitch 现在的值为 .On<br>协议类型<br>协议本身不实现任何功能，但你可以将它当做类型来使用。<br>使用场景：<br>作为函数，方法或构造器中的参数类型，返回值类型<br>作为常量，变量，属性的类型<br>作为数组，字典或其他容器中的元素类型<br>注意：<br>协议类型应与其他类型(Int，Double，String)的写法相同，使用驼峰式<br>class Dice {<br>​    let sides: Int<br>​    let generator: RandomNumberGenerator<br>​    init(sides: Int, generator: RandomNumberGenerator) {<br>​        self.sides = sides<br>​        self.generator = generator<br>​    }<br>​    func roll() -&gt; Int {<br>​        return Int(generator.random() </em> Double(sides)) +1<br>​    }<br>}<br>这里定义了一个名为 Dice的类，用来代表桌游中的N个面的骰子。<br>Dice含有sides和generator两个属性，前者用来表示骰子有几个面，后者为骰子提供一个随机数生成器。由于后者为RandomNumberGenerator的协议类型。所以它能够被赋值为任意遵循该协议的类型。<br>此外，使用构造器(init)来代替之前版本中的setup操作。构造器中含有一个名为generator，类型为RandomNumberGenerator的形参，使得它可以接收任意遵循RandomNumberGenerator协议的类型。<br>roll方法用来模拟骰子的面值。它先使用generator的random方法来创建一个[0-1]区间内的随机数种子，然后加工这个随机数种子生成骰子的面值。<br>如下所示，LinearCongruentialGenerator的实例作为随机数生成器传入Dice的构造器<br>var d6 = Dice(sides: 6,generator: LinearCongruentialGenerator())<br>for _ in 1…5 {<br>​    println(“Random dice roll is (d6.roll())”)<br>}<br>//输出结果<br>//Random dice roll is 3<br>//Random dice roll is 5<br>//Random dice roll is 4<br>//Random dice roll is 5<br>//Random dice roll is 4<br>委托(代理)模式<br>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能交由(委托)给其他的类型。<br>委托模式的实现很简单： 定义协议来封装那些需要被委托的函数和方法， 使其遵循者拥有这些被委托的函数和方法。<br>委托模式可以用来响应特定的动作或接收外部数据源提供的数据，而无需要知道外部数据源的类型。<br>下文是两个基于骰子游戏的协议：<br>protocol DiceGame {<br>​    var dice: Dice { get }<br>​    func play()<br>}<br>protocol DiceGameDelegate {<br>​    func gameDidStart(game: DiceGame)<br>​    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll:Int)<br>​    func gameDidEnd(game: DiceGame)<br>}<br>DiceGame协议可以在任意含有骰子的游戏中实现，DiceGameDelegate协议可以用来追踪DiceGame的游戏过程。<br>如下所示，SnakesAndLadders是Snakes and Ladders(译者注：控制流章节有该游戏的详细介绍)游戏的新版本。新版本使用Dice作为骰子，并且实现了DiceGame和DiceGameDelegate协议<br>class SnakesAndLadders: DiceGame {<br>​    let finalSquare = 25<br>​    let dic = Dice(sides: 6, generator: LinearCongruentialGenerator())<br>​    var square = 0<br>​    var board: Int[]<br>​    init() {<br>​        board = Int<a href="count: finalSquare + 1, repeatedValue: 0" target="_blank" rel="noopener"></a><br>​        board[03] = +08; board[06] = +11; borad[09] = +09; board[10] = +02<br>​        borad[14] = -10; board[19] = -11; borad[22] = -02; board[24] = -08<br>​    }<br>​     var delegate: DiceGameDelegate?<br>​     func play() {<br>​         square = 0<br>​         delegate?.gameDidStart(self)<br>​         gameLoop: while square != finalSquare {<br>​             let diceRoll = dice.roll()<br>​             delegate?.game(self,didStartNewTurnWithDiceRoll: diceRoll)<br>​             switch square + diceRoll {<br>​             case finalSquare:<br>​                 break gameLoop<br>​             case let newSquare where newSquare &gt; finalSquare:<br>​                 continue gameLoop<br>​             default:<br>​             square += diceRoll<br>​             square += board[square]<br>​             }<br>​         }<br>​         delegate?.gameDIdEnd(self)<br>​     }<br>}<br>游戏的初始化设置(setup)被SnakesAndLadders类的构造器(initializer)实现。所有的游戏逻辑被转移到了play方法中。<br>注意：<br>因为delegate并不是该游戏的必备条件，delegate被定义为遵循DiceGameDelegate协议的可选属性<br>DicegameDelegate协议提供了三个方法用来追踪游戏过程。被放置于游戏的逻辑中，即play()方法内。分别在游戏开始时，新一轮开始时，游戏结束时被调用。<br>因为delegate是一个遵循DiceGameDelegate的可选属性，因此在play()方法中使用了可选链来调用委托方法。 若delegate属性为nil， 则委托调用优雅地失效。若delegate不为nil，则委托方法被调用<br>如下所示，DiceGameTracker遵循了DiceGameDelegate协议<br>class DiceGameTracker: DiceGameDelegate {<br>​    var numberOfTurns = 0<br>​    func gameDidStart(game: DiceGame) {<br>​        numberOfTurns = 0<br>​        if game is SnakesAndLadders {<br>​            println(“Started a new game of Snakes and Ladders”)<br>​        }<br>​        println(“The game is using a (game.dice.sides)-sided dice”)<br>​    }<br>​    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {<br>​        ++numberOfTurns<br>​        println(“Rolled a (diceRoll)”)<br>​    }<br>​    func gameDidEnd(game: DiceGame) {<br>​        println(“The game lasted for (numberOfTurns) turns”)<br>​    }<br>}<br>DiceGameTracker实现了DiceGameDelegate协议的方法要求，用来记录游戏已经进行的轮数。 当游戏开始时，numberOfTurns属性被赋值为0；在每新一轮中递加；游戏结束后，输出打印游戏的总轮数。<br>gameDidStart方法从game参数获取游戏信息并输出。game在方法中被当做DiceGame类型而不是SnakeAndLadders类型，所以方法中只能访问DiceGame协议中的成员。<br>DiceGameTracker的运行情况，如下所示：<br>“let tracker = DiceGameTracker()<br>let game = SnakesAndLadders()<br>game.delegate = tracker<br>game.play()<br>// Started a new game of Snakes and Ladders<br>// The game is using a 6-sided dice<br>// Rolled a 3<br>// Rolled a 5<br>// Rolled a 4<br>// Rolled a 5<br>// The game lasted for 4 turns”<br>在扩展中添加协议成员<br>即便无法修改源代码，依然可以通过扩展(Extension)来扩充已存在类型(译者注： 类，结构体，枚举等)。扩展可以为已存在的类型添加属性，方法，下标，协议等成员。详情请在扩展章节中查看。<br>注意：<br>通过扩展为已存在的类型遵循协议时，该类型的所有实例也会随之添加协议中的方法<br>TextRepresentable协议含有一个asText，如下所示：<br>protocol TextRepresentable {<br>​    func asText() -&gt; String<br>}<br>通过扩展为上一节中提到的Dice类遵循TextRepresentable协议<br>extension Dice: TextRepresentable {<br>​    cun asText() -&gt; String {<br>​        return “A (sides)-sided dice”<br>​    }<br>}<br>从现在起，Dice类型的实例可被当作TextRepresentable类型：<br>let d12 = Dice(sides: 12,generator: LinearCongruentialGenerator())<br>println(d12.asText())<br>// 输出 “A 12-sided dice”<br>SnakesAndLadders类也可以通过扩展的方式来遵循协议：<br>extension SnakeAndLadders: TextRepresentable {<br>​    func asText() -&gt; String {<br>​        return “A game of Snakes and Ladders with (finalSquare) squares”<br>​    }<br>}<br>println(game.asText())<br>// 输出 “A game of Snakes and Ladders with 25 squares”<br>通过延展补充协议声明<br>当一个类型已经实现了协议中的所有要求，却没有声明时，可以通过扩展来补充协议声明：<br>struct Hamster {<br>​    var name: String<br>​    func asText() -&gt; String {<br>​        return “A hamster named (name)”<br>​    }<br>}<br>extension Hamster: TextRepresentabl {}<br>从现在起，Hamster的实例可以作为TextRepresentable类型使用<br>let simonTheHamster = Hamster(name: “Simon”)<br>let somethingTextRepresentable: TextRepresentabl = simonTheHamester<br>println(somethingTextRepresentable.asText())<br>// 输出 “A hamster named Simon”<br>注意：<br>即时满足了协议的所有要求，类型也不会自动转变，因此你必须为它做出明显的协议声明<br>集合中的协议类型<br>协议类型可以被集合使用，表示集合中的元素均为协议类型：<br>let things: TextRepresentable[] = [game,d12,simoTheHamster]<br>如下所示，things数组可以被直接遍历，并调用其中元素的asText()函数：<br>for thing in things {<br>​    println(thing.asText())<br>}<br>// A game of Snakes and Ladders with 25 squares<br>// A 12-sided dice<br>// A hamster named Simon<br>thing被当做是TextRepresentable类型而不是Dice，DiceGame，Hamster等类型。因此能且仅能调用asText方法<br>协议的继承<br>协议能够继承一到多个其他协议。语法与类的继承相似，多个协议间用逗号,分隔<br>protocol InheritingProtocol: SomeProtocol, AnotherProtocol {<br>​    // 协议定义<br>}<br>如下所示，PrettyTextRepresentable协议继承了TextRepresentable协议<br>protocol PrettyTextRepresentable: TextRepresentable {<br>​    func asPrettyText() -&gt; String<br>}<br>遵循“PrettyTextRepresentable协议的同时，也需要遵循TextRepresentable<code>协议。
如下所示，用扩展为SnakesAndLadders遵循PrettyTextRepresentable协议：
extension SnakesAndLadders: PrettyTextRepresentable {
​    func asPrettyText() -&gt; String {
​        var output = asText() + &quot;:\n&quot;
​        for index in 1...finalSquare {
​            switch board[index] {
​                case let ladder where ladder &gt; 0:
​                output += &quot;▲ &quot;
​            case let snake where snake &lt; 0:
​                output += &quot;▼ &quot;
​            default:
​                output += &quot;○ &quot;
​            }
​        }
​        return output
​    }
}
在for in中迭代出了board数组中的每一个元素：
当从数组中迭代出的元素的值大于0时，用▲表示
当从数组中迭代出的元素的值小于0时，用▼表示
当从数组中迭代出的元素的值等于0时，用○表示
任意SankesAndLadders的实例都可以使用asPrettyText()方法。
println(game.asPrettyText())
// A game of Snakes and Ladders with 25 squares:
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○
协议合成
一个协议可由多个协议采用protocol&lt;SomeProtocol, AnotherProtocol&gt;这样的格式进行组合，称为协议合成(protocol composition)。
举个例子：
protocol Named {
​    var name: String { get }
}
protocol Aged {
​    var age: Int { get }
}
struct Person: Named, Aged {
​    var name: String
​    var age: Int
}
func wishHappyBirthday(celebrator: protocol&lt;Named, Aged&gt;) {
​    println(&quot;Happy birthday \(celebrator.name) - you&#39;re \(celebrator.age)!&quot;)
}
let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)
wishHappyBirthday(birthdayPerson)
// 输出 &quot;Happy birthday Malcolm - you&#39;re 21!
Named协议包含String类型的name属性；Aged协议包含Int类型的age属性。Person结构体遵循了这两个协议。
wishHappyBirthday函数的形参celebrator的类型为protocol&lt;Named,Aged&gt;。可以传入任意遵循这两个协议的类型的实例
注意：
协议合成并不会生成一个新协议类型，而是将多个协议合成为一个临时的协议，超出范围后立即失效。
检验协议的一致性
使用is检验协议一致性，使用as将协议类型向下转换(downcast)为的其他协议类型。检验与转换的语法和之前相同(详情查看类型检查)：
is操作符用来检查实例是否遵循了某个协议。
as?返回一个可选值，当实例遵循协议时，返回该协议类型；否则返回nil
as用以强制向下转换型。
@objc protocol HasArea {
​    var area: Double { get }
}
注意：
@objc用来表示协议是可选的，也可以用来表示暴露给Objective-C的代码，此外，@objc型协议只对类有效，因此只能在类中检查协议的一致性。详情查看Using Siwft with Cocoa and Objectivei-c。
class Circle: HasArea {
​    let pi = 3.1415927
​    var radius: Double
​    var area:≈radius }
​    init(radius: Double) { self.radius = radius }
}
class Country: HasArea {
​    var area: Double
​    init(area: Double) { self.area = area }
}
Circle和Country都遵循了HasArea协议，前者把area写为计算型属性（computed property），后者则把area写为存储型属性（stored property）。
如下所示，Animal类没有实现任何协议
class Animal {
​    var legs: Int
​    init(legs: Int) { self.legs = legs }
}
Circle,Country,Animal并没有一个相同的基类，所以采用AnyObject类型的数组来装载在他们的实例，如下所示：
let objects: AnyObject[] = [
​    Circle(radius: 2.0),
​    Country(area: 243_610),
​    Animal(legs: 4)
]
如下所示，在迭代时检查object数组的元素是否遵循了HasArea协议：
for object in objects {
​    if let objectWithArea = object as? HasArea {
​        println(&quot;Area is \(objectWithArea.area)&quot;)
​    } else {
​        println(&quot;Something that doesn&#39;t have an area&quot;)
​    }
}
// Area is 12.5663708
// Area is 243610.0
// Something that doesn&#39;t have an area
当数组中的元素遵循HasArea协议时，通过as?操作符将其可选绑定(optional binding)到objectWithArea常量上。
objects数组中元素的类型并不会因为向下转型而改变，当它们被赋值给objectWithArea时只被视为HasArea类型，因此只有area属性能够被访问。
可选协议要求
可选协议含有可选成员，其遵循者可以选择是否实现这些成员。在协议中使用@optional关键字作为前缀来定义可选成员。
可选协议在调用时使用可选链，详细内容在可选链章节中查看。
像someOptionalMethod?(someArgument)一样，你可以在可选方法名称后加上?来检查该方法是否被实现。可选方法和可选属性都会返回一个可选值(optional value)，当其不可访问时，?之后语句不会执行，并返回nil。
注意：
可选协议只能在含有@objc前缀的协议中生效。且@objc的协议只能被类遵循。
Counter类使用CounterDataSource类型的外部数据源来提供增量值(increment amount)，如下所示：
@objc protocol CounterDataSource {
​    @optional func incrementForCount(count: Int) -&gt; Int
​    @optional var fixedIncrement: Int { get }
}
CounterDataSource含有incrementForCount的可选方法和fiexdIncrement的可选属性。
注意：
CounterDataSource中的属性和方法都是可选的，因此可以在类中声明但不实现这些成员，尽管技术上允许这样做，不过最好不要这样写。
Counter类含有CounterDataSource?类型的可选属性dataSource，如下所示：
@objc class Counter {
​    var count = 0
​    var dataSource: CounterDataSource?
​    func increment() {
​        if let amount = dataSource?.incrementForCount?(count) {
​            count += amount
​        } else if let amount = dataSource?.fixedIncrement? {
​            count += amount
​        }
​    }
}
count属性用于存储当前的值，increment方法用来为count赋值。
increment方法通过可选链，尝试从两种可选成员中获取count。
由于dataSource可能为nil，因此在dataSource后边加上了?标记来表明只在dataSource非空时才去调用incrementForCount</code>方法。<br>即使dataSource存在，但是也无法保证其是否实现了incrementForCount方法，因此在incrementForCount方法后边也加有?标记。<br>在调用incrementForCount方法后，Int型可选值通过可选绑定(optional binding)自动拆包并赋值给常量amount。<br>当incrementForCount不能被调用时，尝试使用可选属性“fixedIncrement来代替。<br>ThreeSource实现了CounterDataSource协议，如下所示：<br>class ThreeSource: CounterDataSource {<br>​    let fixedIncrement = 3<br>}<br>使用ThreeSource作为数据源开实例化一个Counter：<br>var counter = Counter()<br>counter.dataSource = ThreeSource()<br>for <em> in 1…4 {<br>​    counter.increment()<br>​    println(counter.count)<br>}<br>// 3<br>// 6<br>// 9<br>// 12<br>TowardsZeroSource实现了CounterDataSource协议中的incrementForCount方法，如下所示：<br>class TowardsZeroSource: CounterDataSource {<br>func incrementForCount(count: Int) -&gt; Int {<br>​        if count == 0 {<br>​            return 0<br>​        } else if count &lt; 0 {<br>​            return 1<br>​        } else {<br>​            return -1<br>​        }<br>​    }<br>}<br>下边是执行的代码：<br>counter.count = -4<br>counter.dataSource = TowardsZeroSource()<br>for </em> in 1…5 {<br>​    counter.increment()<br>​    println(counter.count)<br>}<br>// -3<br>// -2<br>// -1<br>// 0<br>// 0 </p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> 协议 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WKWebView学习笔记]]></title>
      <url>/2018/05/16/WKWebView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>一、简介</p>
<p>webView是我们日常开发中不可缺少的一个组件，通常我们都是使用UIWebView来实现的，不过大多数情况下，UIWebView的表现却不尽如人意（最直观的就是内存消耗严重，特别是有视频的时候，有木有！）<br>iOS8之后苹果推荐使用WKWebView替代UIWebView，其主要的有点有：</p>
<ol>
<li>在性能、稳定性</li>
<li>WKWebView更多的支持HTML5的特性</li>
<li>WKWebView更快，占用内存可能只有UIWebView的1/3 ~ 1/4</li>
<li>WKWebView高达60fps的滚动刷新率和丰富的内置手势</li>
<li>WKWebView具有Safari相同的JavaScript引擎</li>
<li>WKWebView增加了加载进度属性</li>
<li>将UIWebViewDelegate和UIWebView重构成了14个类与3个协议<a href="https://link.jianshu.com/?t=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/WebKit/ObjC_classic/index.html" target="_blank" rel="noopener">官方链接</a><a id="more"></a>
Classes:</li>
</ol>
<blockquote>
<ul>
<li>WKBackForwardList: 之前访问过的 web 页面的列表，可以通过后退和前进动作来访问到。</li>
</ul>
</blockquote>
<ul>
<li>WKBackForwardListItem: webview 中后退列表里的某一个网页。</li>
<li>WKFrameInfo: 包含一个网页的布局信息。</li>
<li>WKNavigation: 包含一个网页的加载进度信息。</li>
<li>WKNavigationAction: 包含可能让网页导航变化的信息，用于判断是否做出导航变化。</li>
<li>WKNavigationResponse: 包含可能让网页导航变化的返回内容信息，用于判断是否做出导航变化。</li>
<li>WKPreferences: 概括一个 webview 的偏好设置。</li>
<li>WKProcessPool: 表示一个 web 内容加载池。</li>
<li>WKUserContentController: 提供使用 JavaScript post 信息和注射 script 的方法。</li>
<li>WKScriptMessage: 包含网页发出的信息。</li>
<li>WKUserScript: 表示可以被网页接受的用户脚本。</li>
<li>WKWebViewConfiguration: 初始化 webview 的设置。</li>
<li>WKWindowFeatures: 指定加载新网页时的窗口属性。</li>
</ul>
<p>Protocols</p>
<blockquote>
<ul>
<li>WKNavigationDelegate: 提供了追踪主窗口网页加载过程和判断主窗口和子窗口是否进行页面加载新页面的相关方法。</li>
</ul>
</blockquote>
<ul>
<li>WKScriptMessageHandler: 提供从网页中收消息的回调方法。</li>
<li>WKUIDelegate: 提供用原生控件显示网页的方法回调。</li>
</ul>
<p>废话了这么多，用一个刚刚测试过的图来展示下内存优化了</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1780316-3b6ef73332b99138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="img"></p>
<p>WKWebView加载视频.png</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1780316-095b192f8eb3e14d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="img"></p>
<p>UIWebView加载视频.png</p>
<p>差距了几倍的内存。下面就聊聊WKWebView的使用。</p>
<h1 id="二、简单使用"><a href="#二、简单使用" class="headerlink" title="二、简单使用"></a>二、简单使用</h1><h4 id="1-首先自然是导入头文件-iOS9之后默认不支持HTTP协议，别忘了在Info-plist里面添加支持"><a href="#1-首先自然是导入头文件-iOS9之后默认不支持HTTP协议，别忘了在Info-plist里面添加支持" class="headerlink" title="1.首先自然是导入头文件(iOS9之后默认不支持HTTP协议，别忘了在Info.plist里面添加支持)"></a>1.首先自然是导入头文件(iOS9之后默认不支持HTTP协议，别忘了在Info.plist里面添加支持)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import&lt;WebKit/WebKit.h&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h4><p><img src="https://upload-images.jianshu.io/upload_images/1780316-69e637f02fc7b376.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>（1）由于WKWebView的父类是UIView，所以可以用我们最常用的方法来初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WKWebView *webView = [[WKWebView alloc]initWithFrame:self.view.frame];</span><br></pre></td></tr></table></figure>
<p>（2）WKWebView自己也具备一个自己的初始化方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration*)configuration</span><br></pre></td></tr></table></figure>
<p>这里面WKWebViewConfiguration就是一个上面讲述的重构了类中的一个，负责的内容是：</p>
<blockquote>
</blockquote>
<p>A WKWebViewConfiguration object is a collection of properties used to initialize a web view.<br>WKWebViewConfiguration 是一个属性的集合 用来初始化web视图。</p>
<p>这个类包含众多的属性，预知详情请见官方文档，这里介绍几个常用的属性(偏好的设置)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//初始化一个WKWebViewConfiguration对象</span><br><span class="line">    WKWebViewConfiguration *config = [WKWebViewConfiguration new];</span><br><span class="line">    //初始化偏好设置属性：preferences</span><br><span class="line">    config.preferences = [WKPreferences new];</span><br><span class="line">    //The minimum font size in points default is 0;</span><br><span class="line">    config.preferences.minimumFontSize = 10;</span><br><span class="line">    //是否支持JavaScript</span><br><span class="line">    config.preferences.javaScriptEnabled = YES;</span><br><span class="line">    //不通过用户交互，是否可以打开窗口</span><br><span class="line">    config.preferences.javaScriptCanOpenWindowsAutomatically = NO;</span><br><span class="line">    </span><br><span class="line">    WKWebView *webView = [[WKWebView alloc]initWithFrame:self.view.frame configuration:config];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:webView];</span><br></pre></td></tr></table></figure>
<h3 id="3-加载网页"><a href="#3-加载网页" class="headerlink" title="3.加载网页"></a>3.加载网页</h3><p>最基础的方法和UIWebView一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString:@&quot;www.jianshu.com&quot;];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">[webView loadRequest:request];</span><br></pre></td></tr></table></figure>
<p>这里有几个加载的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//加载本地URL文件</span><br><span class="line">- (nullable WKNavigation *)loadFileURL:(NSURL *)URL </span><br><span class="line">               allowingReadAccessToURL:(NSURL *)readAccessURL</span><br><span class="line"></span><br><span class="line">//加载本地HTML字符串</span><br><span class="line">- (nullable WKNavigation *)loadHTMLString:(NSString *)string</span><br><span class="line">                                  baseURL:(nullable NSURL *)baseURL;</span><br><span class="line">//加载二进制数据</span><br><span class="line">- (nullable WKNavigation *)loadData:(NSData *)data MIMEType:(NSString *)MIMEType characterEncodingName:(NSString *)characterEncodingName baseURL:(NSURL *)baseURL</span><br></pre></td></tr></table></figure>
<p>每个方法都会返回一个WKNavigation对象，官方介绍是</p>
<blockquote>
<p>一个WKNavigation对象包含信息跟踪加载一个网页的进展。<br>A WKNavigation object contains information for tracking the loading progress of a webpage.</p>
<p>导航web视图加载方法返回的对象,也是传递到导航委托方法来唯一地标识一个网页加载从开始到结束。它没有自己的方法或属性。<br>A navigation object is returned from the web view load methods and is also passed to the navigation delegate methods to uniquely identify a webpage load from start to finish. It has no method or properties of its own.</p>
</blockquote>
<p>然后我创建了两个WKWebView，加载同样的url，打印的结果是不同的地址：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1780316-fc784f84da923071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>这个属性在WKWebView的代理方法里面有用到，我的理解就是用来标记不同的webView的。</p>
<h1 id="三、所有相关的类的API"><a href="#三、所有相关的类的API" class="headerlink" title="三、所有相关的类的API"></a>三、所有相关的类的API</h1><p>这里的东西比较多，想看一些高级使用的直接跳过看下一节，或者直接下载<a href="https://link.jianshu.com/?t=https://github.com/JYSDeveloper/WKWebViewDemo" target="_blank" rel="noopener">Demo</a></p>
<h3 id="1-WKWebView"><a href="#1-WKWebView" class="headerlink" title="1.WKWebView"></a>1.WKWebView</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">//上文介绍过的偏好配置</span><br><span class="line">@property (nonatomic, readonly, copy) WKWebViewConfiguration *configuration;</span><br><span class="line">// 导航代理 </span><br><span class="line">@property (nullable, nonatomic, weak) id &lt;WKNavigationDelegate&gt; navigationDelegate;</span><br><span class="line">// 用户交互代理</span><br><span class="line">@property (nullable, nonatomic, weak) id &lt;WKUIDelegate&gt; UIDelegate;</span><br><span class="line"> </span><br><span class="line">// 页面前进、后退列表</span><br><span class="line">@property (nonatomic, readonly, strong) WKBackForwardList *backForwardList;</span><br><span class="line"> </span><br><span class="line">// 默认构造器</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//加载请求API</span><br><span class="line">- (nullable WKNavigation *)loadRequest:(NSURLRequest *)request;</span><br><span class="line"> </span><br><span class="line">// 加载URL</span><br><span class="line">- (nullable WKNavigation *)loadFileURL:(NSURL *)URL allowingReadAccessToURL:(NSURL *)readAccessURL NS_AVAILABLE(10_11, 9_0);</span><br><span class="line"> </span><br><span class="line">// 直接加载HTML</span><br><span class="line">- (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;</span><br><span class="line"> </span><br><span class="line">// 直接加载data</span><br><span class="line">- (nullable WKNavigation *)loadData:(NSData *)data MIMEType:(NSString *)MIMEType characterEncodingName:(NSString *)characterEncodingName baseURL:(NSURL *)baseURL NS_AVAILABLE(10_11, 9_0);</span><br><span class="line"> </span><br><span class="line">// 前进或者后退到某一页面</span><br><span class="line">- (nullable WKNavigation *)goToBackForwardListItem:(WKBackForwardListItem *)item;</span><br><span class="line"> </span><br><span class="line">// 页面的标题，支持KVO的</span><br><span class="line">@property (nullable, nonatomic, readonly, copy) NSString *title;</span><br><span class="line"> </span><br><span class="line">// 当前请求的URL，支持KVO的</span><br><span class="line">@property (nullable, nonatomic, readonly, copy) NSURL *URL;</span><br><span class="line"> </span><br><span class="line">// 标识当前是否正在加载内容中，支持KVO的</span><br><span class="line">@property (nonatomic, readonly, getter=isLoading) BOOL loading;</span><br><span class="line"> </span><br><span class="line">// 当前加载的进度，范围为[0, 1]</span><br><span class="line">@property (nonatomic, readonly) double estimatedProgress;</span><br><span class="line"> </span><br><span class="line">// 标识页面中的所有资源是否通过安全加密连接来加载，支持KVO的</span><br><span class="line">@property (nonatomic, readonly) BOOL hasOnlySecureContent;</span><br><span class="line"> </span><br><span class="line">// 当前导航的证书链，支持KVO</span><br><span class="line">@property (nonatomic, readonly, copy) NSArray *certificateChain NS_AVAILABLE(10_11, 9_0);</span><br><span class="line"> </span><br><span class="line">// 是否可以招待goback操作，它是支持KVO的</span><br><span class="line">@property (nonatomic, readonly) BOOL canGoBack;</span><br><span class="line"> </span><br><span class="line">// 是否可以执行gofarward操作，支持KVO</span><br><span class="line">@property (nonatomic, readonly) BOOL canGoForward;</span><br><span class="line"> </span><br><span class="line">// 返回上一页面，如果不能返回，则什么也不干</span><br><span class="line">- (nullable WKNavigation *)goBack;</span><br><span class="line"> </span><br><span class="line">// 进入下一页面，如果不能前进，则什么也不干</span><br><span class="line">- (nullable WKNavigation *)goForward;</span><br><span class="line"> </span><br><span class="line">// 重新载入页面</span><br><span class="line">- (nullable WKNavigation *)reload;</span><br><span class="line"> </span><br><span class="line">// 重新从原始URL载入</span><br><span class="line">- (nullable WKNavigation *)reloadFromOrigin;</span><br><span class="line"> </span><br><span class="line">// 停止加载数据</span><br><span class="line">- (void)stopLoading;</span><br><span class="line"> </span><br><span class="line">// 执行JS代码</span><br><span class="line">- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ __nullable)(__nullable id, NSError * __nullable error))completionHandler;</span><br><span class="line"> </span><br><span class="line">// 标识是否支持左、右swipe手势是否可以前进、后退</span><br><span class="line">@property (nonatomic) BOOL allowsBackForwardNavigationGestures;</span><br><span class="line"> </span><br><span class="line">// 自定义user agent，如果没有则为nil</span><br><span class="line">@property (nullable, nonatomic, copy) NSString *customUserAgent NS_AVAILABLE(10_11, 9_0);</span><br><span class="line"> </span><br><span class="line">// 在iOS上默认为NO，标识不允许链接预览</span><br><span class="line">@property (nonatomic) BOOL allowsLinkPreview NS_AVAILABLE(10_11, 9_0);</span><br><span class="line"> </span><br><span class="line">#if TARGET_OS_IPHONE</span><br><span class="line">/*! @abstract The scroll view associated with the web view.</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, readonly, strong) UIScrollView *scrollView;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#if !TARGET_OS_IPHONE</span><br><span class="line">// 标识是否支持放大手势，默认为NO</span><br><span class="line">@property (nonatomic) BOOL allowsMagnification;</span><br><span class="line"> </span><br><span class="line">// 放大因子，默认为1</span><br><span class="line">@property (nonatomic) CGFloat magnification;</span><br><span class="line"> </span><br><span class="line">// 根据设置的缩放因子来缩放页面，并居中显示结果在指定的点</span><br><span class="line">- (void)setMagnification:(CGFloat)magnification centeredAtPoint:(CGPoint)point;</span><br><span class="line"> </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="2-WKPreferences偏好设置"><a href="#2-WKPreferences偏好设置" class="headerlink" title="2. WKPreferences偏好设置"></a>2. WKPreferences偏好设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">// 设置偏好设置</span><br><span class="line">config.preferences = [[WKPreferences alloc] init];</span><br><span class="line">// 默认为0</span><br><span class="line">config.preferences.minimumFontSize = 10;</span><br><span class="line">// 默认认为YES</span><br><span class="line">config.preferences.javaScriptEnabled = YES;</span><br><span class="line">// 在iOS上默认为NO，表示不能自动通过窗口打开</span><br><span class="line">config.preferences.javaScriptCanOpenWindowsAutomatically = NO;</span><br></pre></td></tr></table></figure>
<h3 id="3-WKProcessPool内容处理池"><a href="#3-WKProcessPool内容处理池" class="headerlink" title="3.WKProcessPool内容处理池"></a>3.WKProcessPool内容处理池</h3><p>这个类没有公开的方法和属性，而且也并不需要配置，可以暂时忽略。</p>
<h3 id="4-WKUserContentController内容交互控制器"><a href="#4-WKUserContentController内容交互控制器" class="headerlink" title="4. WKUserContentController内容交互控制器"></a>4. WKUserContentController内容交互控制器</h3><p>我们要通过JS与webview内容交互，就需要到这个类了，它的所有属性及方法说明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 只读属性，所有添加的WKUserScript都在这里可以获取到</span><br><span class="line">@property (nonatomic, readonly, copy) NSArray&lt;WKUserScript *&gt; *userScripts;</span><br><span class="line"> </span><br><span class="line">// 注入JS</span><br><span class="line">- (void)addUserScript:(WKUserScript *)userScript;</span><br><span class="line"> </span><br><span class="line">// 移除所有注入的JS</span><br><span class="line">- (void)removeAllUserScripts;</span><br><span class="line"> </span><br><span class="line">// 添加scriptMessageHandler到所有的frames中，则都可以通过</span><br><span class="line">// window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;)</span><br><span class="line">// 发送消息</span><br><span class="line">// 比如，JS要调用我们原生的方法，就可以通过这种方式了</span><br><span class="line">- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;</span><br><span class="line"> </span><br><span class="line">// 根据name移除所注入的scriptMessageHandler</span><br><span class="line">- (void)removeScriptMessageHandlerForName:(NSString *)name;</span><br></pre></td></tr></table></figure>
<h3 id="5-WKUserScript"><a href="#5-WKUserScript" class="headerlink" title="5. WKUserScript"></a>5. WKUserScript</h3><p>在WKUserContentController中，所有使用到WKUserScript。WKUserContentController是用于与JS交互的类，而所注入的JS是WKUserScript对象。它的所有属性和方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// JS源代码</span><br><span class="line">@property (nonatomic, readonly, copy) NSString *source;</span><br><span class="line"> </span><br><span class="line">// JS注入时间</span><br><span class="line">@property (nonatomic, readonly) WKUserScriptInjectionTime injectionTime;</span><br><span class="line"> </span><br><span class="line">// 只读属性，表示JS是否应该注入到所有的frames中还是只有main frame.</span><br><span class="line">@property (nonatomic, readonly, getter=isForMainFrameOnly) BOOL forMainFrameOnly;</span><br><span class="line"> </span><br><span class="line">// 初始化方法，用于创建WKUserScript对象</span><br><span class="line">// source：JS源代码</span><br><span class="line">// injectionTime：JS注入的时间</span><br><span class="line">// forMainFrameOnly：是否只注入main frame</span><br><span class="line">- (instancetype)initWithSource:(NSString *)source injectionTime:(WKUserScriptInjectionTime)injectionTime forMainFrameOnly:(BOOL)forMainFrameOnly;</span><br></pre></td></tr></table></figure>
<h3 id="6-WKWebsiteDataStore存储的Web内容"><a href="#6-WKWebsiteDataStore存储的Web内容" class="headerlink" title="6.WKWebsiteDataStore存储的Web内容"></a>6.WKWebsiteDataStore存储的Web内容</h3><p><strong>iOS9.0</strong>以后才能使用这个类。是代表webView不同的数据类型，cookies、disk、memory caches、WebSQL、IndexedDB数据库和本地存储。版本适配的化就要放弃了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 默认数据存储</span><br><span class="line">+ (WKWebsiteDataStore *)defaultDataStore;</span><br><span class="line"> </span><br><span class="line">// 返回非持久化存储，数据不会写入文件系统</span><br><span class="line">+ (WKWebsiteDataStore *)nonPersistentDataStore;</span><br><span class="line"> </span><br><span class="line">// 只读属性，表示是否是持久化存储</span><br><span class="line">@property (nonatomic, readonly, getter=isPersistent) BOOL persistent;</span><br><span class="line"> </span><br><span class="line">// 获取所有web内容的数据存储类型集，比如cookies、disk等</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)allWebsiteDataTypes;</span><br><span class="line"> </span><br><span class="line">// 获取某些指定数据存储类型的数据</span><br><span class="line">- (void)fetchDataRecordsOfTypes:(NSSet&lt;NSString *&gt; *)dataTypes completionHandler:(void (^)(NSArray&lt;WKWebsiteDataRecord *&gt; *))completionHandler;</span><br><span class="line"> </span><br><span class="line">// 删除某些指定类型的数据</span><br><span class="line">- (void)removeDataOfTypes:(NSSet&lt;NSString *&gt; *)dataTypes forDataRecords:(NSArray&lt;WKWebsiteDataRecord *&gt; *)dataRecords completionHandler:(void (^)(void))completionHandler;</span><br><span class="line"> </span><br><span class="line">// 删除某些指定类型的数据且修改日期是指定的日期</span><br><span class="line">- (void)removeDataOfTypes:(NSSet&lt;NSString *&gt; *)websiteDataTypes modifiedSince:(NSDate *)date completionHandler:(void (^)(void))completionHandler;</span><br></pre></td></tr></table></figure>
<h3 id="7-WKWebsiteDataRecord"><a href="#7-WKWebsiteDataRecord" class="headerlink" title="7. WKWebsiteDataRecord"></a>7. WKWebsiteDataRecord</h3><p>同样<strong>iOS9.0</strong>之后可以使用，website的数据存储记录类型，它只有两个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 通常是域名</span><br><span class="line">@property (nonatomic, readonly, copy) NSString *displayName;</span><br><span class="line"> </span><br><span class="line">// 存储的数据类型集</span><br><span class="line">@property (nonatomic, readonly, copy) NSSet&lt;NSString *&gt; *dataTypes;</span><br></pre></td></tr></table></figure>
<h3 id="8-WKNavigationDelegate"><a href="#8-WKNavigationDelegate" class="headerlink" title="8. WKNavigationDelegate"></a>8. WKNavigationDelegate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@protocol WKNavigationDelegate &lt;NSObject&gt;</span><br><span class="line"> </span><br><span class="line">@optional</span><br><span class="line"> </span><br><span class="line">// 决定导航的动作，通常用于处理跨域的链接能否导航。WebKit对跨域进行了安全检查限制，不允许跨域，因此我们要对不能跨域的链接</span><br><span class="line">// 单独处理。但是，对于Safari是允许跨域的，不用这么处理。</span><br><span class="line">// 这个是决定是否Request</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler;</span><br><span class="line"> </span><br><span class="line">// 决定是否接收响应</span><br><span class="line">// 这个是决定是否接收response</span><br><span class="line">// 要获取response，通过WKNavigationResponse对象获取</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;</span><br><span class="line"> </span><br><span class="line">// 当main frame的导航开始请求时，会调用此方法</span><br><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation;</span><br><span class="line"> </span><br><span class="line">// 当main frame接收到服务重定向时，会回调此方法</span><br><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation;</span><br><span class="line"> </span><br><span class="line">// 当main frame开始加载数据失败时，会回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error;</span><br><span class="line"> </span><br><span class="line">// 当main frame的web内容开始到达时，会回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation;</span><br><span class="line"> </span><br><span class="line">// 当main frame导航完成时，会回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation;</span><br><span class="line"> </span><br><span class="line">// 当main frame最后下载数据失败时，会回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error;</span><br><span class="line"> </span><br><span class="line">// 这与用于授权验证的API，与AFN、UIWebView的授权验证API是一样的</span><br><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *__nullable credential))completionHandler;</span><br><span class="line"> </span><br><span class="line">// 当web content处理完成时，会回调</span><br><span class="line">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView NS_AVAILABLE(10_11, 9_0);</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="9-WKNavigationResponse"><a href="#9-WKNavigationResponse" class="headerlink" title="9. WKNavigationResponse"></a>9. WKNavigationResponse</h3><p>WKNavigationResponse是导航响应类，通过它可以获取相关响应的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NS_CLASS_AVAILABLE(10_10, 8_0)</span><br><span class="line">@interface WKNavigationResponse : NSObject</span><br><span class="line"> </span><br><span class="line">// 是否是main frame</span><br><span class="line">@property (nonatomic, readonly, getter=isForMainFrame) BOOL forMainFrame;</span><br><span class="line"> </span><br><span class="line">// 获取响应response</span><br><span class="line">@property (nonatomic, readonly, copy) NSURLResponse *response;</span><br><span class="line"> </span><br><span class="line">// 是否显示MIMEType</span><br><span class="line">@property (nonatomic, readonly) BOOL canShowMIMEType;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="10-WKNavigationAction"><a href="#10-WKNavigationAction" class="headerlink" title="10. WKNavigationAction"></a>10. WKNavigationAction</h3><p>WKNavigationAction对象包含关于导航的action的信息，用于make policy decisions。它只有以下几个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 正在请求的导航的frame</span><br><span class="line">@property (nonatomic, readonly, copy) WKFrameInfo *sourceFrame;</span><br><span class="line">// 目标frame，如果这是新的window，它会是nil</span><br><span class="line">@property (nullable, nonatomic, readonly, copy) WKFrameInfo *targetFrame; </span><br><span class="line">// 导航类型，如下面的小标题WKNavigationType</span><br><span class="line">@property (nonatomic, readonly) WKNavigationType navigationType;</span><br><span class="line">// 导航的请求</span><br><span class="line">@property (nonatomic, readonly, copy) NSURLRequest *request;</span><br></pre></td></tr></table></figure>
<h3 id="11-WKUIDelegate"><a href="#11-WKUIDelegate" class="headerlink" title="11. WKUIDelegate"></a>11. WKUIDelegate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@protocol WKUIDelegate &lt;NSObject&gt;</span><br><span class="line"> </span><br><span class="line">@optional</span><br><span class="line"> </span><br><span class="line">// 创建新的webview</span><br><span class="line">// 可以指定配置对象、导航动作对象、window特性</span><br><span class="line">- (nullable WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures;</span><br><span class="line"> </span><br><span class="line">// webview关闭时回调</span><br><span class="line">- (void)webViewDidClose:(WKWebView *)webView NS_AVAILABLE(10_11, 9_0);</span><br><span class="line"> </span><br><span class="line">// 调用JS的alert()方法</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler;</span><br><span class="line"> </span><br><span class="line">// 调用JS的confirm()方法</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler;</span><br><span class="line"> </span><br><span class="line">// 调用JS的prompt()方法</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * __nullable result))completionHandler;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="12-WKBackForwardList"><a href="#12-WKBackForwardList" class="headerlink" title="12. WKBackForwardList"></a>12. WKBackForwardList</h3><p>WKBackForwardList表示webview中可以前进或者后退的页面列表。其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">NS_CLASS_AVAILABLE(10_10, 8_0)</span><br><span class="line">@interface WKBackForwardList : NSObject</span><br><span class="line"> </span><br><span class="line">// 当前正在显示的item（页面）</span><br><span class="line">@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *currentItem;</span><br><span class="line"> </span><br><span class="line">// 后一页，如果没有就是nil</span><br><span class="line">@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *backItem;</span><br><span class="line"> </span><br><span class="line">// 前一页，如果没有就是nil</span><br><span class="line">@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *forwardItem;</span><br><span class="line"> </span><br><span class="line">// 根据下标获取某一个页面的item</span><br><span class="line">- (nullable WKBackForwardListItem *)itemAtIndex:(NSInteger)index;</span><br><span class="line"> </span><br><span class="line">// 可以进行goback操作的页面列表</span><br><span class="line">@property (nonatomic, readonly, copy) NSArray&lt;WKBackForwardListItem *&gt; *backList;</span><br><span class="line"> </span><br><span class="line">// 可以进行goforward操作的页面列表</span><br><span class="line">@property (nonatomic, readonly, copy) NSArray&lt;WKBackForwardListItem *&gt; *forwardList;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="13-WKBackForwardListItem"><a href="#13-WKBackForwardListItem" class="headerlink" title="13. WKBackForwardListItem"></a>13. WKBackForwardListItem</h3><p>页面导航前进、后退列表项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NS_CLASS_AVAILABLE(10_10, 8_0)</span><br><span class="line">@interface WKBackForwardListItem : NSObject</span><br><span class="line"> </span><br><span class="line">// 该页面的URL</span><br><span class="line">@property (readonly, copy) NSURL *URL;</span><br><span class="line"> </span><br><span class="line">// 该页面的title</span><br><span class="line">@property (nullable, readonly, copy) NSString *title;</span><br><span class="line"> </span><br><span class="line">// 初始请求该item的请求的URL</span><br><span class="line">@property (readonly, copy) NSURL *initialURL;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h1 id="四WKWebView与JS实战"><a href="#四WKWebView与JS实战" class="headerlink" title="四WKWebView与JS实战"></a>四WKWebView与JS实战</h1><p>初始化的相关内容在这里不再赘述，提几个常常关注的点</p>
<h3 id="1-添加对WKWebView属性的监听"><a href="#1-添加对WKWebView属性的监听" class="headerlink" title="1.添加对WKWebView属性的监听"></a>1.添加对WKWebView属性的监听</h3><p>这里面处理一下常用的三个：loading、title、estimatedProgress属性，分别用于判断是否正在加载、获取页面标题、当前页面载入进度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 添加KVO监听</span><br><span class="line">    </span><br><span class="line">    [self.webView addObserver:self</span><br><span class="line">                   forKeyPath:@&quot;loading&quot;</span><br><span class="line">                      options:NSKeyValueObservingOptionNew</span><br><span class="line">                      context:nil];</span><br><span class="line">    </span><br><span class="line">    [self.webView addObserver:self</span><br><span class="line">                   forKeyPath:@&quot;title&quot;</span><br><span class="line">                      options:NSKeyValueObservingOptionNew</span><br><span class="line">                      context:nil];</span><br><span class="line">    </span><br><span class="line">    [self.webView addObserver:self</span><br><span class="line">                   forKeyPath:@&quot;estimatedProgress&quot;</span><br><span class="line">                      options:NSKeyValueObservingOptionNew</span><br><span class="line">                      context:nil];</span><br></pre></td></tr></table></figure>
<p>这里不要忘记在界面消失的时候，移除监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[_webView removeObserver:self forKeyPath:@&quot;loading&quot; context:nil];//移除kvo</span><br><span class="line">[_webView removeObserver:self forKeyPath:@&quot;title&quot; context:nil];</span><br><span class="line">[_webView removeObserver:self forKeyPath:@&quot;estimatedProgress&quot; context:nil];</span><br></pre></td></tr></table></figure>
<p>KVO方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(id)object</span><br><span class="line">                        change:(NSDictionary&lt;NSString *,id&gt; *)change</span><br><span class="line">                       context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;loading&quot;])</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;loading&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125; else if ([keyPath isEqualToString:@&quot;title&quot;])</span><br><span class="line">    &#123;</span><br><span class="line">        self.title = self.webView.title;</span><br><span class="line">    &#125; else if ([keyPath isEqualToString:@&quot;estimatedProgress&quot;])</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;progress: %f&quot;, self.webView.estimatedProgress);</span><br><span class="line">        self.progressView.progress = self.webView.estimatedProgress;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 加载完成</span><br><span class="line">    if (!self.webView.loading)</span><br><span class="line">    &#123;</span><br><span class="line">        [UIView animateWithDuration:0.5 animations:^&#123;</span><br><span class="line">            self.progressView.alpha = 0.0;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-配置Js与WebView内容交互"><a href="#2-配置Js与WebView内容交互" class="headerlink" title="2.配置Js与WebView内容交互"></a>2.配置Js与WebView内容交互</h3><p>前面提到了WKUserContentController是用于让Js注入对象的，注入对象后，JS端就可以使用这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;)</span><br></pre></td></tr></table></figure>
<p>用这个方法发送数据给iOS客户端，eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.webkit.messageHandlers.senderModel.postMessage(&#123;body: &apos;sender message&apos;&#125;);</span><br></pre></td></tr></table></figure>
<p>这里面senderModel就是我们要注入的名称，注入之后，就可以在Js端调用了，传数据统一通过body来传递，类型可以随意，但是只支持OC的一些类型（NSNumber, NSString, NSDate, NSArray,NSDictionary, and NSNull类型。）</p>
<p>iOS端的部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">config.userContentController = [[WKUserContentController alloc] init];</span><br><span class="line"> </span><br><span class="line">// 注入JS对象名称senderModel，当JS通过senderModel来调用时，我们可以在WKScriptMessageHandler代理中接收到</span><br><span class="line">[config.userContentController addScriptMessageHandler:self name:@&quot;senderModel&quot;];</span><br><span class="line"></span><br><span class="line">#pragma mark - WKScriptMessageHandler</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController</span><br><span class="line">      didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">  if ([message.name isEqualToString:@&quot;senderModel&quot;]) &#123;</span><br><span class="line">    // 打印所传过来的参数，只支持NSNumber, NSString, NSDate, NSArray,</span><br><span class="line">    // NSDictionary, and NSNull类型</span><br><span class="line">    //do something</span><br><span class="line">    NSLog(@&quot;%@&quot;, message.body);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-WKUIDelegate代理方法"><a href="#3-WKUIDelegate代理方法" class="headerlink" title="3. WKUIDelegate代理方法"></a>3. WKUIDelegate代理方法</h3><p>与JS的alert、confirm、prompt交互，我们希望用自己的原生界面，而不是JS的，就可以使用这个代理类来实现。</p>
<ul>
<li>alert警告框函数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//alert 警告框</span><br><span class="line">-(void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123;</span><br><span class="line">    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;警告&quot; message:@&quot;调用alert提示框&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    [alert addAction:[UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        completionHandler();</span><br><span class="line">    &#125;]];</span><br><span class="line">    [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">    NSLog(@&quot;alert message:%@&quot;,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>confirm确认框函数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//confirm 确认框</span><br><span class="line">-(void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler&#123;</span><br><span class="line">    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;确认框&quot; message:@&quot;调用confirm提示框&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    [alert addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        completionHandler(YES);</span><br><span class="line">    &#125;]];</span><br><span class="line">    [alert addAction:[UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        completionHandler(NO);</span><br><span class="line">    &#125;]];</span><br><span class="line">    [self presentViewController:alert animated:YES completion:NULL];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;confirm message:%@&quot;, message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>prompt 输入框函数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * __nullable result))completionHandler &#123;</span><br><span class="line">    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;输入框&quot; message:@&quot;调用输入框&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    [alert addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123;</span><br><span class="line">        textField.textColor = [UIColor blackColor];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [alert addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        completionHandler([[alert.textFields lastObject] text]);</span><br><span class="line">    &#125;]];</span><br><span class="line">    </span><br><span class="line">    [self presentViewController:alert animated:YES completion:NULL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-WKNavigationDelegate"><a href="#4-WKNavigationDelegate" class="headerlink" title="4.WKNavigationDelegate"></a>4.WKNavigationDelegate</h3><p>代理方法在第三节有提到，这里在重复一下吧</p>
<ul>
<li>用来追踪加载过程的方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//开始加载时调用</span><br><span class="line">-(void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//当内容开始返回时调用</span><br><span class="line">-(void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//页面加载完成之后调用</span><br><span class="line">-(void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">// 页面加载失败时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>页面跳转的代理方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 接收到服务器跳转请求之后调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation;</span><br><span class="line">// 在收到响应后，决定是否跳转</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;</span><br><span class="line">// 在发送请求之前，决定是否跳转</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler;</span><br></pre></td></tr></table></figure>
<p>以上的方法根据实际需求操作即可。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>Demo地址：<a href="https://link.jianshu.com/?t=https://github.com/JYSDeveloper/WKWebViewDemo" target="_blank" rel="noopener">WKWebViewDemo</a><br>参考链接：<a href="https://link.jianshu.com/?t=http://www.brighttj.com/ios/ios-wkwebview-new-features-and-use.html" target="_blank" rel="noopener">WKWebView的新特性与使用</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> WKWebView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为Extension添加存储属性]]></title>
      <url>/2018/05/16/%5BSwift%5D%E4%B8%BAExtension%E6%B7%BB%E5%8A%A0%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>众所周知, 在Swift的扩展(Extension)中只能添加计算属性, 但是有时候, 我们需要添加存储属性的话, 就用到了Runtime的方法.<br>在为Extension添加存储属性的时候, 主要用到了下面两个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public func objc_setAssociatedObject(_ object: Any, _ key: UnsafeRawPointer, _ value: Any?, _ policy: objc_AssociationPolicy)</span><br><span class="line"></span><br><span class="line">public func objc_getAssociatedObject(_ object: Any, _ key: UnsafeRawPointer) -&gt; Any?</span><br></pre></td></tr></table></figure>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><a id="more"></a>
<h5 id="objc-setAssociatedObject-参数"><a href="#objc-setAssociatedObject-参数" class="headerlink" title="objc_setAssociatedObject 参数"></a>objc_setAssociatedObject 参数</h5><p>存储属性</p>
<blockquote>
<p>参数1( object ) : 要添加属性的类<br>参数2( key ): 指定存储的key, 需要使用取址运算符&amp;(参考下面示例)<br>参数3( policy ): 参数属性, 是个枚举, 根据不同的数据类型选择</p>
</blockquote>
<h5 id="objc-getAssociatedObject-参数"><a href="#objc-getAssociatedObject-参数" class="headerlink" title="objc_getAssociatedObject 参数"></a>objc_getAssociatedObject 参数</h5><p>读取属性</p>
<blockquote>
<p>参数1( object ) : 要添加属性的类<br>参数2( key ): 指定存储的key, 需要使用取址运算符&amp;(参考下面示例)</p>
</blockquote>
<h4 id="objc-AssociationPolicy-类型"><a href="#objc-AssociationPolicy-类型" class="headerlink" title="objc_AssociationPolicy 类型"></a>objc_AssociationPolicy 类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public enum objc_AssociationPolicy : UInt &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /**&lt; Specifies a weak reference to the associated object. */</span><br><span class="line">    case OBJC_ASSOCIATION_ASSIGN</span><br><span class="line"></span><br><span class="line">    /**&lt; Specifies a strong reference to the associated object. </span><br><span class="line">     *   The association is not made atomically. */</span><br><span class="line">    case OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /**&lt; Specifies that the associated object is copied. </span><br><span class="line">     *   The association is not made atomically. */</span><br><span class="line">    case OBJC_ASSOCIATION_COPY_NONATOMIC</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /**&lt; Specifies a strong reference to the associated object.</span><br><span class="line">     *   The association is made atomically. */</span><br><span class="line">    case OBJC_ASSOCIATION_RETAIN</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /**&lt; Specifies that the associated object is copied.</span><br><span class="line">     *   The association is made atomically. */</span><br><span class="line">    case OBJC_ASSOCIATION_COPY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><p>以为UIView添加扩展为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">var myNameKey = 100</span><br><span class="line">var myAgeKey = 101</span><br><span class="line">var myOptionKey = 102</span><br><span class="line"></span><br><span class="line">extension UIView &#123;</span><br><span class="line">    </span><br><span class="line">    var myName: String &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            objc_setAssociatedObject(self, &amp;myNameKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        get &#123;</span><br><span class="line">            if let rs = objc_getAssociatedObject(self, &amp;myNameKey) as? String &#123;</span><br><span class="line">                return rs</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var myAge: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            objc_setAssociatedObject(self, &amp;myAgeKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_ASSIGN)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        get &#123;</span><br><span class="line">            if let rs = objc_getAssociatedObject(self, &amp;myAgeKey) as? Int &#123;</span><br><span class="line">                return rs</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return -1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var myOption: UILabel? &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            objc_setAssociatedObject(self, &amp;myOptionKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        get &#123;</span><br><span class="line">            return objc_getAssociatedObject(self, &amp;myOptionKey) as? UILabel</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面为UIView添加了三个不同类型的属性, 在使用的时候, 就可以正常的进行赋值/取值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let view = UIView()</span><br><span class="line">        </span><br><span class="line">        // 赋值</span><br><span class="line">        view.myAge = 100</span><br><span class="line">        view.myName = &quot;扩展的存储属性&quot;</span><br><span class="line">        view.myOption = UILabel()</span><br><span class="line">        </span><br><span class="line">        // 取值</span><br><span class="line">        print(view.myAge)</span><br><span class="line">        print(view.myName)</span><br><span class="line">        print(view.myOption)</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">扩展的存储属性</span><br><span class="line">Optional(&lt;UILabel: 0x7fb863d10bf0; frame = (0 0; 0 0); userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x600000289970&gt;&gt;)</span><br></pre></td></tr></table></figure>
<h1 id="完"><a href="#完" class="headerlink" title="(完)"></a>(完)</h1>]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WKWebView的使用API篇]]></title>
      <url>/2018/05/16/WKWebView%E7%9A%84%E4%BD%BF%E7%94%A8--API%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>WKWebView是苹果在iOS 8之后推出的框架WebKit中的浏览器控件, 其加载速度比UIWebView快了许多, 但内存占用率却下降很多, 也解决了加载网页时的内存泄露问题. 现在的项目大多数只需适配到iOS 8, 所以用WKWebView来替换项目中的UIWebView是很有必要的.</p>
<p>WKWebView的使用主要涉及下面几个类:</p>
<blockquote>
<ul>
<li>WKWebView</li>
<li>WKWebViewConfiguration</li>
<li>WKUserScript</li>
<li>WKUserContentController</li>
<li>WKWebsiteDataStore</li>
</ul>
</blockquote>
<p>以及两个代理:</p>
<blockquote>
<ul>
<li>WKNavigationDelegate</li>
<li>WKUIDelegate</li>
</ul>
</blockquote>
<h2 id="1-WKWebView"><a href="#1-WKWebView" class="headerlink" title="1. WKWebView"></a>1. WKWebView</h2><a id="more"></a>
<h5 id="1-1-常用属性"><a href="#1-1-常用属性" class="headerlink" title="1.1 常用属性"></a>1.1 常用属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 导航代理</span><br><span class="line">@property (nullable, nonatomic, weak) id &lt;WKNavigationDelegate&gt; navigationDelegate;</span><br><span class="line">// UI代理</span><br><span class="line">@property (nullable, nonatomic, weak) id &lt;WKUIDelegate&gt; UIDelegate;</span><br><span class="line"></span><br><span class="line">// 页面标题, 一般使用KVO动态获取</span><br><span class="line">@property (nullable, nonatomic, readonly, copy) NSString *title;</span><br><span class="line">// 页面加载进度, 一般使用KVO动态获取</span><br><span class="line">@property (nonatomic, readonly) double estimatedProgress;</span><br><span class="line"></span><br><span class="line">// 可返回的页面列表, 已打开过的网页, 有点类似于navigationController的viewControllers属性</span><br><span class="line">@property (nonatomic, readonly, strong) WKBackForwardList *backForwardList;</span><br><span class="line"></span><br><span class="line">// 页面url</span><br><span class="line">@property (nullable, nonatomic, readonly, copy) NSURL *URL;</span><br><span class="line">// 页面是否在加载中</span><br><span class="line">@property (nonatomic, readonly, getter=isLoading) BOOL loading;</span><br><span class="line">// 是否可返回</span><br><span class="line">@property (nonatomic, readonly) BOOL canGoBack;</span><br><span class="line">// 是否可向前</span><br><span class="line">@property (nonatomic, readonly) BOOL canGoForward;</span><br><span class="line">// WKWebView继承自UIView, 所以如果想设置scrollView的一些属性, 需要对此属性进行配置</span><br><span class="line">@property (nonatomic, readonly, strong) UIScrollView *scrollView;</span><br><span class="line">// 是否允许手势左滑返回上一级, 类似导航控制的左滑返回</span><br><span class="line">@property (nonatomic) BOOL allowsBackForwardNavigationGestures;</span><br><span class="line"></span><br><span class="line">//自定义UserAgent, 会覆盖默认的值 ,iOS 9之后有效</span><br><span class="line">@property (nullable, nonatomic, copy) NSString *customUserAgent</span><br></pre></td></tr></table></figure>
<h5 id="1-2-一些方法"><a href="#1-2-一些方法" class="headerlink" title="1.2 一些方法:"></a>1.2 一些方法:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 带配置信息的初始化方法</span><br><span class="line">// configuration 配置信息</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration</span><br><span class="line">// 加载请求</span><br><span class="line">- (nullable WKNavigation *)loadRequest:(NSURLRequest *)request;</span><br><span class="line">// 加载HTML</span><br><span class="line">- (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;</span><br><span class="line">// 返回上一级</span><br><span class="line">- (nullable WKNavigation *)goBack;</span><br><span class="line">// 前进下一级, 需要曾经打开过, 才能前进</span><br><span class="line">- (nullable WKNavigation *)goForward;</span><br><span class="line">// 刷新页面</span><br><span class="line">- (nullable WKNavigation *)reload;</span><br><span class="line">// 根据缓存有效期来刷新页面</span><br><span class="line">- (nullable WKNavigation *)reloadFromOrigin;</span><br><span class="line">// 停止加载页面</span><br><span class="line">- (void)stopLoading;</span><br><span class="line">// 执行JavaScript代码</span><br><span class="line">- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id, NSError * _Nullable error))completionHandler;</span><br></pre></td></tr></table></figure>
<h3 id="2-WKWebViewConfiguration"><a href="#2-WKWebViewConfiguration" class="headerlink" title="2. WKWebViewConfiguration"></a>2. WKWebViewConfiguration</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 通过此属性来执行JavaScript代码来修改页面的行为</span><br><span class="line">@property (nonatomic, strong) WKUserContentController *userContentController;</span><br><span class="line"></span><br><span class="line">//***********下面属性一般不需要设置</span><br><span class="line">// 首选项设置,  </span><br><span class="line">//可设置最小字号, 是否允许执行js</span><br><span class="line">//是否通过js自动打开新的窗口</span><br><span class="line">@property (nonatomic, strong) WKPreferences *preferences;</span><br><span class="line">// 是否允许播放媒体文件</span><br><span class="line">@property (nonatomic) BOOL allowsAirPlayForMediaPlayback</span><br><span class="line">// 需要用户来操作才能播放的多媒体类型</span><br><span class="line">@property (nonatomic) WKAudiovisualMediaTypes mediaTypesRequiringUserActionForPlayback</span><br><span class="line">// 是使用h5的视频播放器在线播放, 还是使用原生播放器全屏播放</span><br><span class="line">@property (nonatomic) BOOL allowsInlineMediaPlayback;</span><br></pre></td></tr></table></figure>
<h3 id="3-WKUserContentController"><a href="#3-WKUserContentController" class="headerlink" title="3. WKUserContentController"></a>3. WKUserContentController</h3><p>WKUserContentController 是JavaScript与原生进行交互的桥梁, 主要使用的方法有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 注入JavaScript与原生交互协议</span><br><span class="line">// JS 端可通过 window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 发送消息</span><br><span class="line">- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;</span><br><span class="line">// 移除注入的协议, 在deinit方法中调用</span><br><span class="line">- (void)removeScriptMessageHandlerForName:(NSString *)name;</span><br><span class="line"></span><br><span class="line">// 通过WKUserScript注入需要执行的JavaScript代码</span><br><span class="line">- (void)addUserScript:(WKUserScript *)userScript;</span><br><span class="line">// 移除所有注入的JavaScript代码</span><br><span class="line">- (void)removeAllUserScripts;</span><br></pre></td></tr></table></figure>
<p>使用WKUserContentController注入的交互协议, 需要遵循WKScriptMessageHandler协议, 在其协议方法中获取JavaScript端传递的事件和参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;</span><br></pre></td></tr></table></figure>
<p>WKScriptMessage包含了传递的协议名称及参数, 主要从下面的属性中获取:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 协议名称, 即上面的add方法传递的name</span><br><span class="line">@property (nonatomic, readonly, copy) NSString *name;</span><br><span class="line">// 传递的参数</span><br><span class="line">@property (nonatomic, readonly, copy) id body;</span><br></pre></td></tr></table></figure>
<h3 id="4-WKUserScript"><a href="#4-WKUserScript" class="headerlink" title="4. WKUserScript"></a>4. WKUserScript</h3><p>WKUserScript用于往加载的页面中添加额外需要执行的JavaScript代码, 主要是一个初始化方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">source: 需要执行的JavaScript代码</span><br><span class="line">injectionTime: 加入的位置, 是一个枚举</span><br><span class="line">typedef NS_ENUM(NSInteger, WKUserScriptInjectionTime) &#123;</span><br><span class="line">    WKUserScriptInjectionTimeAtDocumentStart,</span><br><span class="line">    WKUserScriptInjectionTimeAtDocumentEnd</span><br><span class="line">&#125; API_AVAILABLE(macosx(10.10), ios(8.0));</span><br><span class="line"></span><br><span class="line">forMainFrameOnly: 是加入所有框架, 还是只加入主框架</span><br><span class="line">*/</span><br><span class="line">- (instancetype)initWithSource:(NSString *)source injectionTime:(WKUserScriptInjectionTime)injectionTime forMainFrameOnly:(BOOL)forMainFrameOnly;</span><br></pre></td></tr></table></figure>
<h3 id="5-WKUIDelegate"><a href="#5-WKUIDelegate" class="headerlink" title="5. WKUIDelegate"></a>5. WKUIDelegate</h3><p>这个代理方法, 主要是用来处理使用系统的弹框来替换JS中的一些弹框的,比如: 警告框, 选择框, 输入框, 主要使用的是下面三个代理方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> webView中弹出警告框时调用, 只能有一个按钮</span><br><span class="line"></span><br><span class="line"> @param webView webView</span><br><span class="line"> @param message 提示信息</span><br><span class="line"> @param frame 可用于区分哪个窗口调用的</span><br><span class="line"> @param completionHandler 警告框消失的时候调用, 回调给JS</span><br><span class="line"> */</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;警告&quot; message:message preferredStyle:(UIAlertControllerStyleAlert)];</span><br><span class="line">    UIAlertAction *ok = [UIAlertAction actionWithTitle:@&quot;我知道了&quot; style:(UIAlertActionStyleDefault) handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        completionHandler();</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [alert addAction:ok];</span><br><span class="line">    [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 对应js的confirm方法</span><br><span class="line"> webView中弹出选择框时调用, 两个按钮</span><br><span class="line"></span><br><span class="line"> @param webView webView description</span><br><span class="line"> @param message 提示信息</span><br><span class="line"> @param frame 可用于区分哪个窗口调用的</span><br><span class="line"> @param completionHandler 确认框消失的时候调用, 回调给JS, 参数为选择结果: YES or NO</span><br><span class="line"> */</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;请选择&quot; message:message preferredStyle:(UIAlertControllerStyleAlert)];</span><br><span class="line">    UIAlertAction *ok = [UIAlertAction actionWithTitle:@&quot;同意&quot; style:(UIAlertActionStyleDefault) handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        completionHandler(YES);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    UIAlertAction *cancel = [UIAlertAction actionWithTitle:@&quot;不同意&quot; style:(UIAlertActionStyleCancel) handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        completionHandler(NO);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [alert addAction:ok];</span><br><span class="line">    [alert addAction:cancel];</span><br><span class="line">    [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 对应js的prompt方法</span><br><span class="line"> webView中弹出输入框时调用, 两个按钮 和 一个输入框</span><br><span class="line"></span><br><span class="line"> @param webView webView description</span><br><span class="line"> @param prompt 提示信息</span><br><span class="line"> @param defaultText 默认提示文本</span><br><span class="line"> @param frame 可用于区分哪个窗口调用的</span><br><span class="line"> @param completionHandler 输入框消失的时候调用, 回调给JS, 参数为输入的内容</span><br><span class="line"> */</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable result))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;请输入&quot; message:prompt preferredStyle:(UIAlertControllerStyleAlert)];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    [alert addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123;</span><br><span class="line">        textField.placeholder = @&quot;请输入&quot;;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    UIAlertAction *ok = [UIAlertAction actionWithTitle:@&quot;确定&quot; style:(UIAlertActionStyleDefault) handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        </span><br><span class="line">        UITextField *tf = [alert.textFields firstObject];</span><br><span class="line">        </span><br><span class="line">                completionHandler(tf.text);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    UIAlertAction *cancel = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:(UIAlertActionStyleCancel) handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">                completionHandler(defaultText);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [alert addAction:ok];</span><br><span class="line">    [alert addAction:cancel];</span><br><span class="line">    [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-WKNavigationDelegate"><a href="#6-WKNavigationDelegate" class="headerlink" title="6. WKNavigationDelegate"></a>6. WKNavigationDelegate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 决定导航的动作，通常用于处理跨域的链接能否导航。</span><br><span class="line">// WebKit对跨域进行了安全检查限制，不允许跨域，因此我们要对不能跨域的链接单独处理。</span><br><span class="line">// 但是，对于Safari是允许跨域的，不用这么处理。</span><br><span class="line">// 这个是决定是否Request</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123;</span><br><span class="line">    //  在发送请求之前，决定是否跳转</span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 是否接收响应</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler&#123;</span><br><span class="line">    // 在收到响应后，决定是否跳转和发送请求之前那个允许配套使用</span><br><span class="line">    decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用于授权验证的API，与AFN、UIWebView的授权验证API是一样的</span><br><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *__nullable credential))completionHandler&#123;</span><br><span class="line">    </span><br><span class="line">    completionHandler(NSURLSessionAuthChallengePerformDefaultHandling ,nil);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main frame的导航开始请求时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当main frame接收到服务重定向时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation&#123;</span><br><span class="line">    // 接收到服务器跳转请求之后调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当main frame开始加载数据失败时，会回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当内容开始返回时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation&#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当main frame导航完成时，会回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation&#123;</span><br><span class="line">    // 页面加载完成之后调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当main frame最后下载数据失败时，会回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当web content处理完成时，会回调</span><br><span class="line">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-WKWebsiteDataStore"><a href="#7-WKWebsiteDataStore" class="headerlink" title="7. WKWebsiteDataStore"></a>7. WKWebsiteDataStore</h3><p><strong>WKWebsiteDataStore</strong> 提供了网站所能使用的数据类型，包括 cookies，硬盘缓存，内存缓存活在一些WebSQL的数据持久化和本地持久化。可通过 <strong> WKWebViewConfiguration</strong>类的属性 websiteDataStore 进行相关的设置。<strong>WKWebsiteDataStore</strong> 相关的API也比较简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 默认的data store</span><br><span class="line">+ (WKWebsiteDataStore *)defaultDataStore;</span><br><span class="line"></span><br><span class="line">// 如果为webView设置了这个data Store，则不会有数据缓存被写入文件</span><br><span class="line">// 当需要实现隐私浏览的时候，可使用这个</span><br><span class="line">+ (WKWebsiteDataStore *)nonPersistentDataStore;</span><br><span class="line"></span><br><span class="line">// 是否是可缓存数据的，只读</span><br><span class="line">@property (nonatomic, readonly, getter=isPersistent) BOOL persistent;</span><br><span class="line"></span><br><span class="line">// 获取所有可使用的数据类型</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)allWebsiteDataTypes;</span><br><span class="line"></span><br><span class="line">// 查找指定类型的缓存数据</span><br><span class="line">// 回调的值是WKWebsiteDataRecord的集合</span><br><span class="line">- (void)fetchDataRecordsOfTypes:(NSSet&lt;NSString *&gt; *)dataTypes completionHandler:(void (^)(NSArray&lt;WKWebsiteDataRecord *&gt; *))completionHandler;</span><br><span class="line"></span><br><span class="line">// 删除指定的纪录</span><br><span class="line">// 这里的参数是通过上面的方法查找到的WKWebsiteDataRecord实例获取的</span><br><span class="line">- (void)removeDataOfTypes:(NSSet&lt;NSString *&gt; *)dataTypes forDataRecords:(NSArray&lt;WKWebsiteDataRecord *&gt; *)dataRecords completionHandler:(void (^)(void))completionHandler;</span><br><span class="line"></span><br><span class="line">// 删除某时间后修改的某类型的数据</span><br><span class="line">- (void)removeDataOfTypes:(NSSet&lt;NSString *&gt; *)websiteDataTypes modifiedSince:(NSDate *)date completionHandler:(void (^)(void))completionHandler;</span><br><span class="line"></span><br><span class="line">// 保存的HTTP cookies</span><br><span class="line">@property (nonatomic, readonly) WKHTTPCookieStore *httpCookieStore</span><br></pre></td></tr></table></figure>
<h5 id="dataTyle"><a href="#dataTyle" class="headerlink" title="dataTyle"></a>dataTyle</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 硬盘缓存</span><br><span class="line">WKWebsiteDataTypeDiskCache,</span><br><span class="line"></span><br><span class="line">// HTML离线web应用程序缓存</span><br><span class="line">WKWebsiteDataTypeOfflineWebApplicationCache,</span><br><span class="line"></span><br><span class="line">// 内存缓存</span><br><span class="line">WKWebsiteDataTypeMemoryCache,</span><br><span class="line"></span><br><span class="line">// 本地缓存</span><br><span class="line">WKWebsiteDataTypeLocalStorage,</span><br><span class="line"></span><br><span class="line">// cookies</span><br><span class="line">WKWebsiteDataTypeCookies,</span><br><span class="line"></span><br><span class="line">// HTML会话存储</span><br><span class="line">WKWebsiteDataTypeSessionStorage,</span><br><span class="line"></span><br><span class="line">//  IndexedDB 数据库</span><br><span class="line">WKWebsiteDataTypeIndexedDBDatabases,</span><br><span class="line"></span><br><span class="line">// WebSQL 数据库</span><br><span class="line">WKWebsiteDataTypeWebSQLDatabases</span><br></pre></td></tr></table></figure>
<h5 id="WKWebsiteDataRecord"><a href="#WKWebsiteDataRecord" class="headerlink" title="WKWebsiteDataRecord"></a>WKWebsiteDataRecord</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 展示名称, 通常是域名</span><br><span class="line">@property (nonatomic, readonly, copy) NSString *displayName;</span><br><span class="line"></span><br><span class="line">// 包含的数据类型</span><br><span class="line">@property (nonatomic, readonly, copy) NSSet&lt;NSString *&gt; *dataTypes;</span><br></pre></td></tr></table></figure>
<h5 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h5><p>删除指定时间的所有类型数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSSet *websiteDataTypes = [WKWebsiteDataStore allWebsiteDataTypes];</span><br><span class="line">    NSDate *dateFrom = [NSDate dateWithTimeIntervalSince1970:0];</span><br><span class="line">    [[WKWebsiteDataStore defaultDataStore] removeDataOfTypes:websiteDataTypes modifiedSince:dateFrom completionHandler:^&#123;</span><br><span class="line">        // Done</span><br><span class="line">        NSLog(@&quot;释放&quot;);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>查找删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WKWebsiteDataStore *dataStore = [WKWebsiteDataStore defaultDataStore];</span><br><span class="line">    [dataStore fetchDataRecordsOfTypes:[WKWebsiteDataStore allWebsiteDataTypes] completionHandler:^(NSArray&lt;WKWebsiteDataRecord *&gt; * _Nonnull records) &#123;</span><br><span class="line">        for (WKWebsiteDataRecord *record in records) &#123;</span><br><span class="line">            [dataStore removeDataOfTypes:record.dataTypes forDataRecords:@[record] completionHandler:^&#123;</span><br><span class="line">                // done</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>查找删除特定的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WKWebsiteDataStore *dataStore = [WKWebsiteDataStore defaultDataStore];</span><br><span class="line">    [dataStore fetchDataRecordsOfTypes:[WKWebsiteDataStore allWebsiteDataTypes] completionHandler:^(NSArray&lt;WKWebsiteDataRecord *&gt; * _Nonnull records) &#123;</span><br><span class="line">        for (WKWebsiteDataRecord *record in records) &#123;</span><br><span class="line">            if ([record.displayName isEqualToString:@&quot;baidu&quot;]) &#123;</span><br><span class="line">                [dataStore removeDataOfTypes:record.dataTypes forDataRecords:@[record] completionHandler:^&#123;</span><br><span class="line">                    // done</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> WKWebView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS UIApplication.h]]></title>
      <url>/2018/05/15/UIApplication/</url>
      <content type="html"><![CDATA[<p>import Foundation</p>
<p>import UIKit</p>
<p>import _SwiftUIKitOverlayShims</p>
<p>//</p>
<p>//  UIApplication.h</p>
<p>//  UIKit</p>
<p>//</p>
<p>//  Copyright (c) 2005-2017 Apple Inc. All rights reserved.</p>
<p>//<br><a id="more"></a><br>public enum UIStatusBarStyle : Int {</p>
<p>​    </p>
<p>​    case <code>default</code> // Dark content, for use on light backgrounds</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    case lightContent // Light content, for use on dark backgrounds</p>
<p>}</p>
<p>public enum UIStatusBarAnimation : Int {</p>
<p>​    </p>
<p>​    case none</p>
<p>​    @available(iOS 3.2, *)</p>
<p>​    case fade</p>
<p>​    @available(iOS 3.2, *)</p>
<p>​    case slide</p>
<p>}</p>
<p>// Note that UIInterfaceOrientationLandscapeLeft is equal to UIDeviceOrientationLandscapeRight (and vice versa).</p>
<p>// This is because rotating the device to the left requires rotating the content to the right.</p>
<p>public enum UIInterfaceOrientation : Int {</p>
<p>​    </p>
<p>​    case unknown</p>
<p>​    case portrait</p>
<p>​    case portraitUpsideDown</p>
<p>​    case landscapeLeft</p>
<p>​    case landscapeRight</p>
<p>}</p>
<p>extension UIInterfaceOrientation {</p>
<p>​    public var isLandscape: Bool { get }</p>
<p>​    public var isPortrait: Bool { get }</p>
<p>}</p>
<p>extension NSExceptionName {</p>
<p>​    </p>
<p>​    /* This exception is raised if supportedInterfaceOrientations returns 0, or if preferredInterfaceOrientationForPresentation</p>
<p>​       returns an orientation that is not supported.</p>
<p>​    */</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let UIApplicationInvalidInterfaceOrientationException: NSExceptionName</p>
<p>}</p>
<p>public struct UIInterfaceOrientationMask : OptionSet {</p>
<p>​    public init(rawValue: UInt)</p>
<p>​    </p>
<p>​    public static var portrait: UIInterfaceOrientationMask { get }</p>
<p>​    public static var landscapeLeft: UIInterfaceOrientationMask { get }</p>
<p>​    public static var landscapeRight: UIInterfaceOrientationMask { get }</p>
<p>​    public static var portraitUpsideDown: UIInterfaceOrientationMask { get }</p>
<p>​    public static var landscape: UIInterfaceOrientationMask { get }</p>
<p>​    public static var all: UIInterfaceOrientationMask { get }</p>
<p>​    public static var allButUpsideDown: UIInterfaceOrientationMask { get }</p>
<p>}</p>
<p>public func UIInterfaceOrientationIsPortrait(_ orientation: UIInterfaceOrientation) -&gt; Bool</p>
<p>public func UIInterfaceOrientationIsLandscape(_ orientation: UIInterfaceOrientation) -&gt; Bool</p>
<p>@available(iOS, introduced: 3.0, deprecated: 8.0, message: “Use UserNotifications Framework’s UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead.”)</p>
<p>public struct UIRemoteNotificationType : OptionSet {</p>
<p>​    public init(rawValue: UInt)</p>
<p>​    </p>
<p>​    public static var badge: UIRemoteNotificationType { get }</p>
<p>​    public static var sound: UIRemoteNotificationType { get }</p>
<p>​    public static var alert: UIRemoteNotificationType { get }</p>
<p>​    public static var newsstandContentAvailability: UIRemoteNotificationType { get }</p>
<p>}</p>
<p>@available(iOS 7.0, *)</p>
<p>public enum UIBackgroundFetchResult : UInt {</p>
<p>​    </p>
<p>​    case newData</p>
<p>​    case noData</p>
<p>​    case failed</p>
<p>}</p>
<p>@available(iOS 7.0, *)</p>
<p>public enum UIBackgroundRefreshStatus : Int {</p>
<p>​    </p>
<p>​    case restricted //&lt; unavailable on this system due to device configuration; the user cannot enable the feature</p>
<p>​    case denied //&lt; explicitly disabled by the user for this application</p>
<p>​    case available //&lt; enabled for this application</p>
<p>}</p>
<p>@available(iOS 4.0, *)</p>
<p>public enum UIApplicationState : Int {</p>
<p>​    </p>
<p>​    case active</p>
<p>​    case inactive</p>
<p>​    case background</p>
<p>}</p>
<p>public typealias UIBackgroundTaskIdentifier = Int</p>
<p>@available(iOS 4.0, *)</p>
<p>public let UIBackgroundTaskInvalid: UIBackgroundTaskIdentifier</p>
<p>@available(iOS 4.0, *)</p>
<p>public let UIMinimumKeepAliveTimeout: TimeInterval</p>
<p>@available(iOS 7.0, *)</p>
<p>public let UIApplicationBackgroundFetchIntervalMinimum: TimeInterval</p>
<p>@available(iOS 7.0, *)</p>
<p>public let UIApplicationBackgroundFetchIntervalNever: TimeInterval</p>
<p>@available(iOS 2.0, *)</p>
<p>open class UIApplication : UIResponder {</p>
<p>​    </p>
<p>​    open class var shared: UIApplication { get }</p>
<p>​    </p>
<p>​    unowned(unsafe) open var delegate: UIApplicationDelegate?</p>
<p>​    </p>
<p>​    open func beginIgnoringInteractionEvents() // nested. set should be set during animations &amp; transitions to ignore touch and other events</p>
<p>​    open func endIgnoringInteractionEvents()</p>
<p>​    </p>
<p>​    open var isIgnoringInteractionEvents: Bool { get } // returns YES if we are at least one deep in ignoring events</p>
<p>​    </p>
<p>​    // returns YES if we are at least one deep in ignoring events</p>
<p>​    </p>
<p>​    open var isIdleTimerDisabled: Bool // default is NO</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 2.0, deprecated: 10.0, message: “Please use openURL:options:completionHandler: instead”)</p>
<p>​    open func openURL(_ url: URL) -&gt; Bool</p>
<p>​    @available(iOS 3.0, *)</p>
<p>​    open func canOpenURL(_ url: URL) -&gt; Bool</p>
<p>​    </p>
<p>​    // Options are specified in the section below for openURL options. An empty options dictionary will result in the same</p>
<p>​    // behavior as the older openURL call, aside from the fact that this is asynchronous and calls the completion handler rather</p>
<p>​    // than returning a result.</p>
<p>​    // The completion handler is called on the main queue.</p>
<p>​    @available(iOS 10.0, *)</p>
<p>​    open func open(_ url: URL, options: [String : Any] = [:], completionHandler completion: ((Bool) -&gt; Swift.Void)? = nil)</p>
<p>​    </p>
<p>​    open func sendEvent(_ event: UIEvent)</p>
<p>​    </p>
<p>​    open var keyWindow: UIWindow? { get }</p>
<p>​    open var windows: [UIWindow] { get }</p>
<p>​    </p>
<p>​    open func sendAction(_ action: Selector, to target: Any?, from sender: Any?, for event: UIEvent?) -&gt; Bool</p>
<p>​    </p>
<p>​    open var isNetworkActivityIndicatorVisible: Bool // showing network spinning gear in status bar. default is NO</p>
<p>​    </p>
<p>​    open var statusBarStyle: UIStatusBarStyle { get } // default is UIStatusBarStyleDefault</p>
<p>​    </p>
<p>​    open var isStatusBarHidden: Bool { get }</p>
<p>​    </p>
<p>​    open var statusBarOrientation: UIInterfaceOrientation { get }</p>
<p>​    </p>
<p>​    // The system only calls this method if the application delegate has not</p>
<p>​    // implemented the delegate equivalent. It returns the orientations specified by</p>
<p>​    // the application’s info.plist. If no supported interface orientations were</p>
<p>​    // specified it will return UIInterfaceOrientationMaskAll on an iPad and</p>
<p>​    // UIInterfaceOrientationMaskAllButUpsideDown on a phone.  The return value</p>
<p>​    // should be one of the UIInterfaceOrientationMask values which indicates the</p>
<p>​    // orientations supported by this application.</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    open func supportedInterfaceOrientations(for window: UIWindow?) -&gt; UIInterfaceOrientationMask</p>
<p>​    </p>
<p>​    open var statusBarOrientationAnimationDuration: TimeInterval { get } // Returns the animation duration for the status bar during a 90 degree orientation change.  It should be doubled for a 180 degree orientation change.</p>
<p>​    open var statusBarFrame: CGRect { get } // returns CGRectZero if the status bar is hidden</p>
<p>​    </p>
<p>​    open var applicationIconBadgeNumber: Int // set to 0 to hide. default is 0. In iOS 8.0 and later, your application must register for user notifications using -[UIApplication registerUserNotificationSettings:] before being able to set the icon badge.</p>
<p>​    </p>
<p>​    @available(iOS 3.0, *)</p>
<p>​    open var applicationSupportsShakeToEdit: Bool</p>
<p>​    </p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    open var applicationState: UIApplicationState { get }</p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    open var backgroundTimeRemaining: TimeInterval { get }</p>
<p>​    </p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    open func beginBackgroundTask(expirationHandler handler: (() -&gt; Swift.Void)? = nil) -&gt; UIBackgroundTaskIdentifier</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    open func beginBackgroundTask(withName taskName: String?, expirationHandler handler: (() -&gt; Swift.Void)? = nil) -&gt; UIBackgroundTaskIdentifier</p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    open func endBackgroundTask(_ identifier: UIBackgroundTaskIdentifier)</p>
<p>​    </p>
<p>​    /*! The system guarantees that it will not wake up your application for a background fetch more</p>
<p>​        frequently than the interval provided. Set to UIApplicationBackgroundFetchIntervalMinimum to be</p>
<p>​        woken as frequently as the system desires, or to UIApplicationBackgroundFetchIntervalNever (the</p>
<p>​        default) to never be woken for a background fetch.</p>
<p>​     </p>
<p>​        This setter will have no effect unless your application has the “fetch” </p>
<p>​        UIBackgroundMode. See the UIApplicationDelegate method</p>
<p>​        <code>application:performFetchWithCompletionHandler:</code> for more. */</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    open func setMinimumBackgroundFetchInterval(_ minimumBackgroundFetchInterval: TimeInterval)</p>
<p>​    </p>
<p>​    /*! When background refresh is available for an application, it may launched or resumed in the background to handle significant</p>
<p>​        location changes, remote notifications, background fetches, etc. Observe UIApplicationBackgroundRefreshStatusDidChangeNotification to</p>
<p>​        be notified of changes. */</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    open var backgroundRefreshStatus: UIBackgroundRefreshStatus { get }</p>
<p>​    </p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    open var isProtectedDataAvailable: Bool { get }</p>
<p>​    </p>
<p>​    @available(iOS 5.0, *)</p>
<p>​    open var userInterfaceLayoutDirection: UIUserInterfaceLayoutDirection { get }</p>
<p>​    </p>
<p>​    // Return the size category</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    open var preferredContentSizeCategory: UIContentSizeCategory { get }</p>
<p>}</p>
<p>extension UIApplication {</p>
<p>​    </p>
<p>​    // Calling this will result in either application:didRegisterForRemoteNotificationsWithDeviceToken: or application:didFailToRegisterForRemoteNotificationsWithError: to be called on the application delegate. Note: these callbacks will be made only if the application has successfully registered for user notifications with registerUserNotificationSettings:, or if it is enabled for Background App Refresh.</p>
<p>​    @available(iOS 8.0, *)</p>
<p>​    open func registerForRemoteNotifications()</p>
<p>​    </p>
<p>​    @available(iOS 3.0, *)</p>
<p>​    open func unregisterForRemoteNotifications()</p>
<p>​    </p>
<p>​    // Returns YES if the application is currently registered for remote notifications, taking into account any systemwide settings; doesn’t relate to connectivity.</p>
<p>​    </p>
<p>​    @available(iOS 8.0, *)</p>
<p>​    open var isRegisteredForRemoteNotifications: Bool { get }</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 3.0, deprecated: 8.0, message: “Use -[UIApplication registerForRemoteNotifications] and UserNotifications Framework’s -[UNUserNotificationCenter requestAuthorizationWithOptions:completionHandler:]”)</p>
<p>​    open func registerForRemoteNotifications(matching types: UIRemoteNotificationType)</p>
<p>​    </p>
<p>​    // Returns the enabled types, also taking into account any systemwide settings; doesn’t relate to connectivity.</p>
<p>​    @available(iOS, introduced: 3.0, deprecated: 8.0, message: “Use -[UIApplication isRegisteredForRemoteNotifications] and UserNotifications Framework’s -[UNUserNotificationCenter getNotificationSettingsWithCompletionHandler:] to retrieve user-enabled remote notification and user notification settings”)</p>
<p>​    open func enabledRemoteNotificationTypes() -&gt; UIRemoteNotificationType</p>
<p>}</p>
<p>// In iOS 8.0 and later, your application must register for user notifications using -[UIApplication registerUserNotificationSettings:] before being able to schedule and present UILocalNotifications</p>
<p>extension UIApplication {</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 4.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenter addNotificationRequest:withCompletionHandler:]”)</p>
<p>​    open func presentLocalNotificationNow(_ notification: UILocalNotification)</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 4.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenter addNotificationRequest:withCompletionHandler:]”)</p>
<p>​    open func scheduleLocalNotification(_ notification: UILocalNotification) // copies notification</p>
<p>​    @available(iOS, introduced: 4.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenter removePendingNotificationRequestsWithIdentifiers:]”)</p>
<p>​    open func cancelLocalNotification(_ notification: UILocalNotification)</p>
<p>​    @available(iOS, introduced: 4.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenter removeAllPendingNotificationRequests]”)</p>
<p>​    open func cancelAllLocalNotifications()</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 4.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenter getPendingNotificationRequestsWithCompletionHandler:]”)</p>
<p>​    open var scheduledLocalNotifications: [UILocalNotification]?</p>
<p>}</p>
<p>extension UIApplication {</p>
<p>​    </p>
<p>​    // Registering UIUserNotificationSettings more than once results in previous settings being overwritten.</p>
<p>​    @available(iOS, introduced: 8.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenter requestAuthorizationWithOptions:completionHandler:] and -[UNUserNotificationCenter setNotificationCategories:]”)</p>
<p>​    open func registerUserNotificationSettings(_ notificationSettings: UIUserNotificationSettings)</p>
<p>​    </p>
<p>​    // Returns the enabled user notification settings, also taking into account any systemwide settings.</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 8.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenter getNotificationSettingsWithCompletionHandler:] and -[UNUserNotificationCenter getNotificationCategoriesWithCompletionHandler:]”)</p>
<p>​    open var currentUserNotificationSettings: UIUserNotificationSettings? { get }</p>
<p>}</p>
<p>extension UIApplication {</p>
<p>​    </p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    open func beginReceivingRemoteControlEvents()</p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    open func endReceivingRemoteControlEvents()</p>
<p>}</p>
<p>extension UIApplication {</p>
<p>​    @available(iOS, introduced: 5.0, deprecated: 9.0, message: “Newsstand apps now behave like normal apps on SpringBoard”)</p>
<p>​    open func setNewsstandIconImage(_ image: UIImage?)</p>
<p>}</p>
<p>extension UIApplication {</p>
<p>​    // Register shortcuts to display on the home screen, or retrieve currently registered shortcuts.</p>
<p>​    @available(iOS 9.0, *)</p>
<p>​    open var shortcutItems: [UIApplicationShortcutItem]?</p>
<p>}</p>
<p>extension UIApplication {</p>
<p>​    // If false, alternate icons are not supported for the current process.</p>
<p>​    @available(iOS 10.3, *)</p>
<p>​    open var supportsAlternateIcons: Bool { get }</p>
<p>​    </p>
<p>​    // Pass <code>nil</code> to use the primary application icon. The completion handler will be invoked asynchronously on an arbitrary background queue; be sure to dispatch back to the main queue before doing any further UI work.</p>
<p>​    @available(iOS 10.3, *)</p>
<p>​    open func setAlternateIconName(_ alternateIconName: String?, completionHandler: ((Error?) -&gt; Swift.Void)? = nil)</p>
<p>​    </p>
<p>​    // If <code>nil</code>, the primary application icon is being used.</p>
<p>​    @available(iOS 10.3, *)</p>
<p>​    open var alternateIconName: String? { get }</p>
<p>}</p>
<p>extension UIApplication {</p>
<p>​    // These methods are used to inform the system that state restoration is occuring asynchronously after the application</p>
<p>​    // has processed its restoration archive on launch. In the even of a crash, the system will be able to detect that it may</p>
<p>​    // have been caused by a bad restoration archive and arrange to ignore it on a subsequent application launch.</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    open func extendStateRestoration()</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    open func completeStateRestoration()</p>
<p>​    </p>
<p>​    // Indicate the application should not use the snapshot on next launch, even if there is a valid state restoration archive.</p>
<p>​    // This should only be called from methods invoked from State Preservation, else it is ignored.</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    open func ignoreSnapshotOnNextApplicationLaunch()</p>
<p>​    </p>
<p>​    // Register non-View/ViewController objects for state restoration so other objects can reference them within state restoration archives.</p>
<p>​    // If the object implements encode/decode, those methods will be called during save/restore.</p>
<p>​    // Obj and identifier must not be nil, or will raise UIRestorationObjectRegistrationException.</p>
<p>​    // Objects do not need to be unregistered when they are deleted, the State Restoration system will notice and stop tracking the object.</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    open class func registerObject(forStateRestoration object: UIStateRestoring, restorationIdentifier: String)</p>
<p>}</p>
<p>public struct UIApplicationLaunchOptionsKey : RawRepresentable, Equatable, Hashable {</p>
<p>​    public init(_ rawValue: String)</p>
<p>​    public init(rawValue: String)</p>
<p>}</p>
<p>public protocol UIApplicationDelegate : NSObjectProtocol {</p>
<p>​    </p>
<p>​    @available(iOS 2.0, *)</p>
<p>​    optional public func applicationDidFinishLaunching(_ application: UIApplication)</p>
<p>​    </p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, willFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool</p>
<p>​    @available(iOS 3.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool</p>
<p>​    </p>
<p>​    @available(iOS 2.0, *)</p>
<p>​    optional public func applicationDidBecomeActive(_ application: UIApplication)</p>
<p>​    @available(iOS 2.0, *)</p>
<p>​    optional public func applicationWillResignActive(_ application: UIApplication)</p>
<p>​    @available(iOS, introduced: 2.0, deprecated: 9.0, message: “Please use application:openURL:options:”)</p>
<p>​    optional public func application(_ application: UIApplication, handleOpen url: URL) -&gt; Bool</p>
<p>​    @available(iOS, introduced: 4.2, deprecated: 9.0, message: “Please use application:openURL:options:”)</p>
<p>​    optional public func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -&gt; Bool</p>
<p>​    </p>
<p>​    @available(iOS 9.0, *)</p>
<p>​    optional public func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -&gt; Bool // no equiv. notification. return NO if the application can’t open for some reason</p>
<p>​    </p>
<p>​    @available(iOS 2.0, *)</p>
<p>​    optional public func applicationDidReceiveMemoryWarning(_ application: UIApplication) // try to clean up as much memory as possible. next step is to terminate app</p>
<p>​    @available(iOS 2.0, *)</p>
<p>​    optional public func applicationWillTerminate(_ application: UIApplication)</p>
<p>​    @available(iOS 2.0, *)</p>
<p>​    optional public func applicationSignificantTimeChange(_ application: UIApplication) // midnight, carrier time update, daylight savings time change</p>
<p>​    </p>
<p>​    @available(iOS 2.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, willChangeStatusBarOrientation newStatusBarOrientation: UIInterfaceOrientation, duration: TimeInterval)</p>
<p>​    @available(iOS 2.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, didChangeStatusBarOrientation oldStatusBarOrientation: UIInterfaceOrientation)</p>
<p>​    </p>
<p>​    @available(iOS 2.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, willChangeStatusBarFrame newStatusBarFrame: CGRect) // in screen coordinates</p>
<p>​    @available(iOS 2.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, didChangeStatusBarFrame oldStatusBarFrame: CGRect)</p>
<p>​    </p>
<p>​    // This callback will be made upon calling -[UIApplication registerUserNotificationSettings:]. The settings the user has granted to the application will be passed in as the second argument.</p>
<p>​    @available(iOS, introduced: 8.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenter requestAuthorizationWithOptions:completionHandler:]”)</p>
<p>​    optional public func application(_ application: UIApplication, didRegister notificationSettings: UIUserNotificationSettings)</p>
<p>​    </p>
<p>​    @available(iOS 3.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</p>
<p>​    </p>
<p>​    @available(iOS 3.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error)</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 3.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenterDelegate willPresentNotification:withCompletionHandler:] or -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:] for user visible notifications and -[UIApplicationDelegate application:didReceiveRemoteNotification:fetchCompletionHandler:] for silent remote notifications”)</p>
<p>​    optional public func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any])</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 4.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenterDelegate willPresentNotification:withCompletionHandler:] or -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]”)</p>
<p>​    optional public func application(_ application: UIApplication, didReceive notification: UILocalNotification)</p>
<p>​    </p>
<p>​    // Called when your app has been activated by the user selecting an action from a local notification.</p>
<p>​    // A nil action identifier indicates the default action.</p>
<p>​    // You should call the completion handler as soon as you’ve finished handling the action.</p>
<p>​    @available(iOS, introduced: 8.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]”)</p>
<p>​    optional public func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, for notification: UILocalNotification, completionHandler: @escaping () -&gt; Swift.Void)</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 9.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]”)</p>
<p>​    optional public func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [AnyHashable : Any], withResponseInfo responseInfo: [AnyHashable : Any], completionHandler: @escaping () -&gt; Swift.Void)</p>
<p>​    </p>
<p>​    // Called when your app has been activated by the user selecting an action from a remote notification.</p>
<p>​    // A nil action identifier indicates the default action.</p>
<p>​    // You should call the completion handler as soon as you’ve finished handling the action.</p>
<p>​    @available(iOS, introduced: 8.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]”)</p>
<p>​    optional public func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [AnyHashable : Any], completionHandler: @escaping () -&gt; Swift.Void)</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 9.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]”)</p>
<p>​    optional public func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, for notification: UILocalNotification, withResponseInfo responseInfo: [AnyHashable : Any], completionHandler: @escaping () -&gt; Swift.Void)</p>
<p>​    </p>
<p>​    /*! This delegate method offers an opportunity for applications with the “remote-notification” background mode to fetch appropriate new data in response to an incoming remote notification. You should call the fetchCompletionHandler as soon as you’re finished performing that operation, so the system can accurately estimate its power and data cost.</p>
<p>​     </p>
<p>​     This method will be invoked even if the application was launched or resumed because of the remote notification. The respective delegate methods will be invoked first. Note that this behavior is in contrast to application:didReceiveRemoteNotification:, which is not called in those cases, and which will not be invoked if this method is implemented. !*/</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Swift.Void)</p>
<p>​    </p>
<p>​    /// Applications with the “fetch” background mode may be given opportunities to fetch updated content in the background or when it is convenient for the system. This method will be called in these situations. You should call the fetchCompletionHandler as soon as you’re finished performing that operation, so the system can accurately estimate its power and data cost.</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Swift.Void)</p>
<p>​    </p>
<p>​    // Called when the user activates your application by selecting a shortcut on the home screen,</p>
<p>​    // except when -application:willFinishLaunchingWithOptions: or -application:didFinishLaunchingWithOptions returns NO.</p>
<p>​    @available(iOS 9.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Swift.Void)</p>
<p>​    </p>
<p>​    // Applications using an NSURLSession with a background configuration may be launched or resumed in the background in order to handle the</p>
<p>​    // completion of tasks in that session, or to handle authentication. This method will be called with the identifier of the session needing</p>
<p>​    // attention. Once a session has been created from a configuration object with that identifier, the session’s delegate will begin receiving</p>
<p>​    // callbacks. If such a session has already been created (if the app is being resumed, for instance), then the delegate will start receiving</p>
<p>​    // callbacks without any action by the application. You should call the completionHandler as soon as you’re finished handling the callbacks.</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -&gt; Swift.Void)</p>
<p>​    </p>
<p>​    @available(iOS 8.2, *)</p>
<p>​    optional public func application(_ application: UIApplication, handleWatchKitExtensionRequest userInfo: [AnyHashable : Any]?, reply: @escaping ([AnyHashable : Any]?) -&gt; Swift.Void)</p>
<p>​    </p>
<p>​    @available(iOS 9.0, *)</p>
<p>​    optional public func applicationShouldRequestHealthAuthorization(_ application: UIApplication)</p>
<p>​    </p>
<p>​    @available(iOS 11.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, handle intent: INIntent, completionHandler: @escaping (INIntentResponse) -&gt; Swift.Void)</p>
<p>​    </p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    optional public func applicationDidEnterBackground(_ application: UIApplication)</p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    optional public func applicationWillEnterForeground(_ application: UIApplication)</p>
<p>​    </p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    optional public func applicationProtectedDataWillBecomeUnavailable(_ application: UIApplication)</p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    optional public func applicationProtectedDataDidBecomeAvailable(_ application: UIApplication)</p>
<p>​    </p>
<p>​    @available(iOS 5.0, *)</p>
<p>​    optional public var window: UIWindow? { get set }</p>
<p>​    </p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask</p>
<p>​    </p>
<p>​    // Applications may reject specific types of extensions based on the extension point identifier.</p>
<p>​    // Constants representing common extension point identifiers are provided further down.</p>
<p>​    // If unimplemented, the default behavior is to allow the extension point identifier.</p>
<p>​    @available(iOS 8.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, shouldAllowExtensionPointIdentifier extensionPointIdentifier: UIApplicationExtensionPointIdentifier) -&gt; Bool</p>
<p>​    </p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, viewControllerWithRestorationIdentifierPath identifierComponents: [Any], coder: NSCoder) -&gt; UIViewController?</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, shouldSaveApplicationState coder: NSCoder) -&gt; Bool</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, shouldRestoreApplicationState coder: NSCoder) -&gt; Bool</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, willEncodeRestorableStateWith coder: NSCoder)</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, didDecodeRestorableStateWith coder: NSCoder)</p>
<p>​    </p>
<p>​    // Called on the main thread as soon as the user indicates they want to continue an activity in your application. The NSUserActivity object may not be available instantly,</p>
<p>​    // so use this as an opportunity to show the user that an activity will be continued shortly.</p>
<p>​    // For each application:willContinueUserActivityWithType: invocation, you are guaranteed to get exactly one invocation of application:continueUserActivity: on success,</p>
<p>​    // or application:didFailToContinueUserActivityWithType:error: if an error was encountered.</p>
<p>​    @available(iOS 8.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, willContinueUserActivityWithType userActivityType: String) -&gt; Bool</p>
<p>​    </p>
<p>​    // Called on the main thread after the NSUserActivity object is available. Use the data you stored in the NSUserActivity object to re-create what the user was doing.</p>
<p>​    // You can create/fetch any restorable objects associated with the user activity, and pass them to the restorationHandler. They will then have the UIResponder restoreUserActivityState: method</p>
<p>​    // invoked with the user activity. Invoking the restorationHandler is optional. It may be copied and invoked later, and it will bounce to the main thread to complete its work and call</p>
<p>​    // restoreUserActivityState on all objects.</p>
<p>​    @available(iOS 8.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -&gt; Swift.Void) -&gt; Bool</p>
<p>​    </p>
<p>​    // If the user activity cannot be fetched after willContinueUserActivityWithType is called, this will be called on the main thread when implemented.</p>
<p>​    @available(iOS 8.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, didFailToContinueUserActivityWithType userActivityType: String, error: Error)</p>
<p>​    </p>
<p>​    // This is called on the main thread when a user activity managed by UIKit has been updated. You can use this as a last chance to add additional data to the userActivity.</p>
<p>​    @available(iOS 8.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, didUpdate userActivity: NSUserActivity)</p>
<p>​    </p>
<p>​    // This will be called on the main thread after the user indicates they want to accept a CloudKit sharing invitation in your application.</p>
<p>​    // You should use the CKShareMetadata object’s shareURL and containerIdentifier to schedule a CKAcceptSharesOperation, then start using</p>
<p>​    // the resulting CKShare and its associated record(s), which will appear in the CKContainer’s shared database in a zone matching that of the record’s owner.</p>
<p>​    @available(iOS 10.0, *)</p>
<p>​    optional public func application(_ application: UIApplication, userDidAcceptCloudKitShareWith cloudKitShareMetadata: CKShareMetadata)</p>
<p>}</p>
<p>public struct UIApplicationOpenURLOptionsKey : RawRepresentable, Equatable, Hashable {</p>
<p>​    public init(_ rawValue: String)</p>
<p>​    public init(rawValue: String)</p>
<p>}</p>
<p>public struct UIApplicationExtensionPointIdentifier : RawRepresentable, Equatable, Hashable {</p>
<p>​    public init(_ rawValue: String)</p>
<p>​    public init(rawValue: String)</p>
<p>}</p>
<p>extension UIApplication {</p>
<p>​    </p>
<p>​    // Explicit setting of the status bar orientation is more limited in iOS 6.0 and later.</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 2.0, deprecated: 9.0, message: “Explicit setting of the status bar orientation is more limited in iOS 6.0 and later”)</p>
<p>​    open func setStatusBarOrientation(_ interfaceOrientation: UIInterfaceOrientation, animated: Bool)</p>
<p>​    </p>
<p>​    // Setting the statusBarStyle does nothing if your application is using the default UIViewController-based status bar system.</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 2.0, deprecated: 9.0, message: “Use -[UIViewController preferredStatusBarStyle]”)</p>
<p>​    open func setStatusBarStyle(_ statusBarStyle: UIStatusBarStyle, animated: Bool)</p>
<p>​    </p>
<p>​    // Setting statusBarHidden does nothing if your application is using the default UIViewController-based status bar system.</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 3.2, deprecated: 9.0, message: “Use -[UIViewController prefersStatusBarHidden]”)</p>
<p>​    open func setStatusBarHidden(_ hidden: Bool, with animation: UIStatusBarAnimation)</p>
<p>​    </p>
<p>​    @available(iOS, introduced: 4.0, deprecated: 9.0, message: “Please use PushKit for VoIP applications instead of calling this method”)</p>
<p>​    open func setKeepAliveTimeout(_ timeout: TimeInterval, handler keepAliveHandler: (() -&gt; Swift.Void)? = nil) -&gt; Bool</p>
<p>​    @available(iOS, introduced: 4.0, deprecated: 9.0, message: “Please use PushKit for VoIP applications instead of calling this method”)</p>
<p>​    open func clearKeepAliveTimeout()</p>
<p>}</p>
<p>// If nil is specified for principalClassName, the value for NSPrincipalClass from the Info.plist is used. If there is no</p>
<p>// NSPrincipalClass key specified, the UIApplication class is used. The delegate class will be instantiated using init.</p>
<p>public func UIApplicationMain(<em> argc: Int32, </em> argv: UnsafeMutablePointer&lt;UnsafeMutablePointer<int8>&gt;!, <em> principalClassName: String?, </em> delegateClassName: String?) -&gt; Int32</int8></p>
<p>extension RunLoopMode {</p>
<p>​    </p>
<p>​    public static let UITrackingRunLoopMode: RunLoopMode</p>
<p>}</p>
<p>extension NSNotification.Name {</p>
<p>​    </p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    public static let UIApplicationDidEnterBackground: NSNotification.Name</p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    public static let UIApplicationWillEnterForeground: NSNotification.Name</p>
<p>​    public static let UIApplicationDidFinishLaunching: NSNotification.Name</p>
<p>​    public static let UIApplicationDidBecomeActive: NSNotification.Name</p>
<p>​    public static let UIApplicationWillResignActive: NSNotification.Name</p>
<p>​    public static let UIApplicationDidReceiveMemoryWarning: NSNotification.Name</p>
<p>​    public static let UIApplicationWillTerminate: NSNotification.Name</p>
<p>​    public static let UIApplicationSignificantTimeChange: NSNotification.Name</p>
<p>​    public static let UIApplicationWillChangeStatusBarOrientation: NSNotification.Name // userInfo contains NSNumber with new orientation</p>
<p>​    public static let UIApplicationDidChangeStatusBarOrientation: NSNotification.Name // userInfo contains NSNumber with old orientation</p>
<p>​    // userInfo dictionary key for status bar orientation</p>
<p>​    public static let UIApplicationWillChangeStatusBarFrame: NSNotification.Name // userInfo contains NSValue with new frame</p>
<p>​    public static let UIApplicationDidChangeStatusBarFrame: NSNotification.Name // userInfo contains NSValue with old frame</p>
<p>​    // userInfo dictionary key for status bar frame</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let UIApplicationBackgroundRefreshStatusDidChange: NSNotification.Name</p>
<p>​    </p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    public static let UIApplicationProtectedDataWillBecomeUnavailable: NSNotification.Name</p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    public static let UIApplicationProtectedDataDidBecomeAvailable: NSNotification.Name</p>
<p>​    </p>
<p>​    // userInfo contains NSURL with launch URL</p>
<p>​    // userInfo contains NSString with launch app bundle ID</p>
<p>​    // userInfo contains NSDictionary with payload</p>
<p>​    // userInfo contains a UILocalNotification</p>
<p>​    // userInfo contains object with annotation property list</p>
<p>​    // app was launched in response to a CoreLocation event.</p>
<p>​    // userInfo contains an NSArray of NKAssetDownload identifiers</p>
<p>​    // userInfo contains an NSArray of CBCentralManager restore identifiers</p>
<p>​    // userInfo contains an NSArray of CBPeripheralManager restore identifiers</p>
<p>​    // userInfo contains the UIApplicationShortcutItem used to launch the app.</p>
<p>​    </p>
<p>​    // Key in options dict passed to application:[will | did]FinishLaunchingWithOptions and info for UIApplicationDidFinishLaunchingNotification</p>
<p>​    // Sub-Dictionary present in launch options when user activity is present</p>
<p>​    // Key in user activity dictionary for the activity type</p>
<p>​    // The presence of this key indicates that the app was launched in order to handle a CloudKit sharing invitation. The value of this key is a CKShareMetadata object.</p>
<p>​    </p>
<p>​    // userInfo contains NSURL with launch URL</p>
<p>​    // userInfo contains NSString with launch app bundle ID</p>
<p>​    // userInfo contains NSDictionary with payload</p>
<p>​    // userInfo contains a UILocalNotification</p>
<p>​    // userInfo contains object with annotation property list</p>
<p>​    // app was launched in response to a CoreLocation event.</p>
<p>​    // userInfo contains an NSArray of NKAssetDownload identifiers</p>
<p>​    // userInfo contains an NSArray of CBCentralManager restore identifiers</p>
<p>​    // userInfo contains an NSArray of CBPeripheralManager restore identifiers</p>
<p>​    // userInfo contains the UIApplicationShortcutItem used to launch the app.</p>
<p>​    // Key in options dict passed to application:[will | did]FinishLaunchingWithOptions and info for UIApplicationDidFinishLaunchingNotification</p>
<p>​    // Sub-Dictionary present in launch options when user activity is present</p>
<p>​    // Key in user activity dictionary for the activity type</p>
<p>​    // The presence of this key indicates that the app was launched in order to handle a CloudKit sharing invitation. The value of this key is a CKShareMetadata object.</p>
<p>​    </p>
<p>​    // Keys for application:openURL:options:</p>
<p>​    </p>
<p>​    // value is an NSString containing the bundle ID of the originating application</p>
<p>​    // value is a property-list typed object corresponding to what the originating application passed in UIDocumentInteractionController’s annotation property</p>
<p>​    // value is a bool NSNumber. Copy the file before use if this value is NO, or is not present.</p>
<p>​    </p>
<p>​    // value is an NSString containing the bundle ID of the originating application</p>
<p>​    // value is a property-list typed object corresponding to what the originating application passed in UIDocumentInteractionController’s annotation property</p>
<p>​    // value is a bool NSNumber, set to YES if the file needs to be copied before use</p>
<p>​    </p>
<p>​    // This notification is posted after the user takes a screenshot (for example by pressing both the home and lock screen buttons)</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let UIApplicationUserDidTakeScreenshot: NSNotification.Name</p>
<p>}</p>
<p>public let UIApplicationStatusBarOrientationUserInfoKey: String</p>
<p>public let UIApplicationStatusBarFrameUserInfoKey: String</p>
<p>extension UIApplicationLaunchOptionsKey {</p>
<p>​    @available(iOS 3.0, *)</p>
<p>​    public static let url: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS 3.0, *)</p>
<p>​    public static let sourceApplication: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS 3.0, *)</p>
<p>​    public static let remoteNotification: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS, introduced: 4.0, deprecated: 10.0, message: “Use UserNotifications Framework’s -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]”)</p>
<p>​    public static let localNotification: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS 3.2, *)</p>
<p>​    public static let annotation: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS 4.0, *)</p>
<p>​    public static let location: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS 5.0, *)</p>
<p>​    public static let newsstandDownloads: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let bluetoothCentrals: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let bluetoothPeripherals: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS 9.0, *)</p>
<p>​    public static let shortcutItem: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS 8.0, *)</p>
<p>​    public static let userActivityDictionary: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS 8.0, *)</p>
<p>​    public static let userActivityType: UIApplicationLaunchOptionsKey</p>
<p>​    @available(iOS 10.0, *)</p>
<p>​    public static let cloudKitShareMetadata: UIApplicationLaunchOptionsKey</p>
<p>}</p>
<p>@available(iOS 8.0, *)</p>
<p>public let UIApplicationOpenSettingsURLString: String</p>
<p>extension UIApplicationOpenURLOptionsKey {</p>
<p>​    @available(iOS 9.0, *)</p>
<p>​    public static let sourceApplication: UIApplicationOpenURLOptionsKey</p>
<p>​    @available(iOS 9.0, *)</p>
<p>​    public static let annotation: UIApplicationOpenURLOptionsKey</p>
<p>​    @available(iOS 9.0, *)</p>
<p>​    public static let openInPlace: UIApplicationOpenURLOptionsKey</p>
<p>}</p>
<p>extension UIApplicationExtensionPointIdentifier {</p>
<p>​    </p>
<p>​    @available(iOS 8.0, *)</p>
<p>​    public static let keyboard: UIApplicationExtensionPointIdentifier</p>
<p>}</p>
<p>// Option for openURL:options:CompletionHandler: only open URL if it is a valid universal link with an application configured to open it</p>
<p>// If there is no application configured, or the user disabled using it to open the link, completion handler called with NO</p>
<p>@available(iOS 10.0, *)</p>
<p>public let UIApplicationOpenURLOptionUniversalLinksOnly: String</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Apple </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS10之前/之后系统访问权限以及跳转到系统界面]]></title>
      <url>/2018/05/15/iOS10%E4%B9%8B%E5%89%8D%E4%B9%8B%E5%90%8E%E7%B3%BB%E7%BB%9F%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BB%A5%E5%8F%8A%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%B3%BB%E7%BB%9F%E7%95%8C%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>iOS10以后字段有所改变</p>
<p>iOS10后：”App-Prefs:root=INTERNET_TETHERING”</p>
<p>iOS10前：”prefs:root=INTERNET_TETHERING”</p>
<p>跳转到自已app设置里及权限设置 ：let settingUrl = NSURL(string:UIApplicationOpenSettingsURLString)!</p>
<a id="more"></a>
<p>if #available(iOS 10.0, *) {</p>
<p>​        //                        let settingUrl = NSURL(string:”App-Prefs:root=INTERNET_TETHERING”)!</p>
<p>​        //                        if UIApplication.shared.canOpenURL(settingUrl as URL) {</p>
<p>​        //                            UIApplication.shared.open(settingUrl as URL, options: [UIApplicationOpenURLOptionUniversalLinksOnly : “”], completionHandler:{ (true) in</p>
<p>​        //</p>
<p>​        //</p>
<p>​        //                            })</p>
<p>​        //</p>
<p>​        //                        } else {</p>
<p>​        //                            let settingUrl = NSURL(string:”prefs:root=INTERNET_TETHERING”)!</p>
<p>​        //                            if UIApplication.shared.canOpenURL(settingUrl as URL)</p>
<p>​        //                            {</p>
<p>​        //                                UIApplication.shared.openURL(settingUrl as URL)</p>
<p>​        //</p>
<p>​        //                            }</p>
<p>​        //                        }</p>
<p>​        //                    }</p>
<p>About — prefs:root=General&amp;path=About</p>
<p>Accessibility — prefs:root=General&amp;path=ACCESSIBILITY</p>
<p>Airplane Mode On — prefs:root=AIRPLANE_MODE</p>
<p>Auto-Lock — prefs:root=General&amp;path=AUTOLOCK</p>
<p>Brightness — prefs:root=Brightness</p>
<p>Bluetooth — prefs:root=General&amp;path=Bluetooth</p>
<p>Date &amp; Time — prefs:root=General&amp;path=DATE_AND_TIME</p>
<p>FaceTime — prefs:root=FACETIME</p>
<p>General — prefs:root=General</p>
<p>Keyboard — prefs:root=General&amp;path=Keyboard</p>
<p>iCloud — prefs:root=CASTLE</p>
<p>iCloud Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP</p>
<p>International — prefs:root=General&amp;path=INTERNATIONAL</p>
<p>Location Services — prefs:root=LOCATION_SERVICES</p>
<p>Music — prefs:root=MUSIC</p>
<p>Music Equalizer — prefs:root=MUSIC&amp;path=EQ</p>
<p>Music Volume Limit — prefs:root=MUSIC&amp;path=VolumeLimit</p>
<p>Network — prefs:root=General&amp;path=Network</p>
<p>Nike + iPod — prefs:root=NIKE_PLUS_IPOD</p>
<p>Notes — prefs:root=NOTES</p>
<p>Notification — prefs:root=NOTIFICATIONS_ID</p>
<p>Phone — prefs:root=Phone</p>
<p>Photos — prefs:root=Photos</p>
<p>Profile — prefs:root=General&amp;path=ManagedConfigurationList</p>
<p>Reset — prefs:root=General&amp;path=Reset</p>
<p>Safari — prefs:root=Safari</p>
<p>Siri — prefs:root=General&amp;path=Assistant</p>
<p>Sounds — prefs:root=Sounds</p>
<p>Software Update — prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK</p>
<p>Store — prefs:root=STORE</p>
<p>Twitter — prefs:root=TWITTER</p>
<p>Usage — prefs:root=General&amp;path=USAGE</p>
<p>VPN — prefs:root=General&amp;path=Network/VPN</p>
<p>Wallpaper — prefs:root=Wallpaper</p>
<p>Wi-Fi — prefs:root=WIFI</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift App状态恢复－State Restoration]]></title>
      <url>/2018/05/14/Swift%20App%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%EF%BC%8DState%20Restoration/</url>
      <content type="html"><![CDATA[<h6 id="Swift-App状态恢复－State-Restoration"><a href="#Swift-App状态恢复－State-Restoration" class="headerlink" title="Swift App状态恢复－State Restoration"></a>Swift App状态恢复－State Restoration</h6><p>原创Blog，转载请注明出处<br><a href="https://blog.csdn.net/hello_hwc/article/details/blog.csdn.net/hello_hwc" target="_blank" rel="noopener">blog.csdn.net/hello_hwc</a></p>
<hr>
<a id="more"></a>
<p>前言：<br>对于一个app来说，没有办法保证每次都是用户正常关闭（双击home，然后关闭）。有可能是用户把app切换到后台，然后由于内存的原因，IOS系统选择关闭掉应用。这时候，就是状态恢复使用的场景。App应当做到的是，用户没有察觉到App在后台被IOS Kill掉了。</p>
<p>本文主要讲诉如何用Storyboard进行状态恢复，下一篇更新如何实现代码State Restoration。</p>
<p>注意：<br>状态恢复不是持久化存储，换句话说，用户正常关闭App的时候，状态恢复是不会起到任何作用的，因为用户正常关闭App，理所应当这次操作的状态都应该清除。</p>
<hr>
<h2 id="一-什么是状态相关的信息？"><a href="#一-什么是状态相关的信息？" class="headerlink" title="一 什么是状态相关的信息？"></a>一 什么是状态相关的信息？</h2><p>就是那些不容易被重新创建的信息，比如一个tableview，当前选择的是哪行？比如用户的first responser是什么？比如tabController当前选择是哪个页面。</p>
<hr>
<h2 id="二-如何实现保存状态信息"><a href="#二-如何实现保存状态信息" class="headerlink" title="二 如何实现保存状态信息"></a>二 如何实现保存状态信息</h2><ol>
<li>(必须) app 代理的两个代理方法，要实现。通常直接返回YES即可，当然，也可以判断状态来决定是否保存和恢复。<br><code>application:shouldSaveApplicationState: application:shouldRestoreApplicationState:</code></li>
<li>(必须)每个想要保存的视图控制器一定要有一个唯一的恢复表示符（restoration identifiers）。如果是用Storyboard上创建的，则在storyboard上设置。如果是代码创建的，使用属性restorationIdentifier 。</li>
<li>(必须)对于storyboard上创建的视图控制器，不需要设置restoration classes。对于那些由代码动态创建的视图控制器，要设置restoration classes来实现保存和恢复。否则，统一在appDelegate的代理方法中实现。后一种方式不推荐。</li>
<li>(推荐)实现两个方法来保存/恢复状态信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encodeRestorableStateWithCoder: </span><br><span class="line">decodeRestorableStateWithCoder: 12</span><br></pre></td></tr></table></figure>
<p>另外，可以使用App 代理来存储版本等额外信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application:willEncodeRestorableStateWithCoder: and application:didDecodeRestorableStateWithCoder:1</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三-State-Restoration的流程"><a href="#三-State-Restoration的流程" class="headerlink" title="三 State Restoration的流程"></a>三 State Restoration的流程</h2><p>保存状态的流程图<br><img src="https://img-blog.csdn.net/20150420221747930" alt="这里写图片描述"></p>
<p>恢复状态的流程图<br><img src="https://img-blog.csdn.net/20150420221941505" alt="这里写图片描述"></p>
<hr>
<p>从视图控制器的生命周期来看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awakeFromNib</span><br><span class="line">viewDidLoad</span><br><span class="line">decodeRestorableStateWithCoder:</span><br><span class="line">viewWillAppear</span><br><span class="line">viewDidAppear12345</span><br></pre></td></tr></table></figure>
<p>如果是用代码实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+viewControllerWithRestorationIdentifierPath:coder:</span><br><span class="line">awakeFromNib</span><br><span class="line">viewDidLoad</span><br><span class="line">decodeRestorableStateWithCoder:</span><br><span class="line">viewWillAppear</span><br><span class="line">viewDidAppear123456</span><br></pre></td></tr></table></figure>
<p>注意：比如v3-&gt;v2-&gt;v1,是层次结构，如果v2没有标识符，那么底层的v3即便有标识符也没办法恢复。一组层次结构要保存，一定要都有restorationIdentifier</p>
<hr>
<h2 id="四-Demo"><a href="#四-Demo" class="headerlink" title="四 Demo"></a>四 Demo</h2><hr>
<p>项目链接<br><!--~~<~~https://github.com/wenchenhuang/StateRestorationStoryboard~~>~~--></p>
<!---->~~~~<a href="https://github.com/shagedorn/StateRestorationDemo" target="_blank" rel="noopener">https://github.com/shagedorn/StateRestorationDemo</a><br><br>——<br><br>如何测试<br>在XCode中运行，然后Command+Shift+H进入后台，然后点击Stop的方框，然后再运行，会发现恢复了上次的状态<br><br>——<br><br>首先，在AppDelegate中实现两个代理函数<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, shouldRestoreApplicationState coder: NSCoder) -&gt; Bool &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line">func application(application: UIApplication, shouldSaveApplicationState coder: NSCoder) -&gt; Bool &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;123456</span><br></pre></td></tr></table></figure>
<hr>
<p>然后，看一下我的Storyboad上的架构<br><img src="https://img-blog.csdn.net/20150422123336437" alt="这里写图片描述"><br>一个tabbarController，包括两个子Controller，然后第二个子Controller又包含一个ChildController</p>
<hr>
<p>对每一个Storyboard上的vc都设置restoration identifiers，如图<br><img src="https://img-blog.csdn.net/20150422123401834" alt="这里写图片描述"></p>
<hr>
<p>对Tabbar当前选择哪个VC进行保存恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let KTABBARSELECTINDEX = &quot;SelectIndex&quot;</span><br><span class="line"></span><br><span class="line">class MainTabbarController:UITabBarController&#123;</span><br><span class="line">    override func encodeRestorableStateWithCoder(coder: NSCoder) &#123;</span><br><span class="line">        let selectindex = self.selectedIndex;</span><br><span class="line">        coder.encodeInteger(selectedIndex, forKey: KTABBARSELECTINDEX)</span><br><span class="line"></span><br><span class="line">        //Do not forget to call super</span><br><span class="line">        super.encodeRestorableStateWithCoder(coder)</span><br><span class="line">    &#125;</span><br><span class="line">    override func decodeRestorableStateWithCoder(coder: NSCoder) &#123;</span><br><span class="line">        let selectindex = coder.decodeIntegerForKey(KTABBARSELECTINDEX)</span><br><span class="line">        self.selectedIndex = selectindex</span><br><span class="line">        //Do not  forget to call super</span><br><span class="line">        super.decodeRestorableStateWithCoder(coder)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;123456789101112131415161718</span><br></pre></td></tr></table></figure>
<hr>
<p>对FirstViewController的TextField内容进行保存/恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let KSECONDVCTEXTFIELD = &quot;secondvctextField&quot;</span><br><span class="line"></span><br><span class="line">class FirstViewController:UIViewController,UITextFieldDelegate&#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var textfield: UITextField!</span><br><span class="line">    override func encodeRestorableStateWithCoder(coder: NSCoder) &#123;</span><br><span class="line">        coder.encodeObject(textfield.text, forKey: KSECONDVCTEXTFIELD)</span><br><span class="line">        super.encodeRestorableStateWithCoder(coder)</span><br><span class="line">    &#125;</span><br><span class="line">    override func decodeRestorableStateWithCoder(coder: NSCoder) &#123;</span><br><span class="line">        if let text = coder.decodeObjectForKey(KSECONDVCTEXTFIELD) as? String&#123;</span><br><span class="line">            textfield.text = text</span><br><span class="line">        &#125;</span><br><span class="line">        super.decodeRestorableStateWithCoder(coder)</span><br><span class="line">    &#125;</span><br><span class="line">    func textFieldShouldReturn(textField: UITextField) -&gt; Bool &#123;</span><br><span class="line">        textfield.resignFirstResponder()</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;1234567891011121314151617181920</span><br></pre></td></tr></table></figure>
<hr>
<p>对SecondViewController进行Textfield和ChildVC进行保存/恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let KFIRSTVCTEXTFIELD = &quot;firstvctextField&quot;</span><br><span class="line"></span><br><span class="line">class SecondViewController:UIViewController,UITextFieldDelegate</span><br><span class="line">&#123;</span><br><span class="line">    @IBOutlet weak var textfield: UITextField!</span><br><span class="line">    override func encodeRestorableStateWithCoder(coder: NSCoder) &#123;</span><br><span class="line">        coder.encodeObject(textfield.text, forKey: KFIRSTVCTEXTFIELD)</span><br><span class="line">        //Parent vc should encode child vc,so that child vc can encode itself</span><br><span class="line">        let childVC = self.childViewControllers.first as! UINavigationController</span><br><span class="line">        coder.encodeObject(childVC, forKey: &quot;childVC&quot;)</span><br><span class="line">        super.encodeRestorableStateWithCoder(coder)</span><br><span class="line">    &#125;</span><br><span class="line">    override func decodeRestorableStateWithCoder(coder: NSCoder) &#123;</span><br><span class="line">        if let text = coder.decodeObjectForKey(KFIRSTVCTEXTFIELD) as? String&#123;</span><br><span class="line">            textfield.text = text</span><br><span class="line">        &#125;</span><br><span class="line">        super.decodeRestorableStateWithCoder(coder)</span><br><span class="line">    &#125;</span><br><span class="line">    func textFieldShouldReturn(textField: UITextField) -&gt; Bool &#123;</span><br><span class="line">        textfield.resignFirstResponder()</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>
<hr>
<p>对嵌入式的TableViwController进行当前选择的行进行保存/恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let KTALBLESELECTEDINDEX = &quot;selectIndex&quot;</span><br><span class="line"></span><br><span class="line">class EmbedTableviewController:UITableViewController&#123;</span><br><span class="line"></span><br><span class="line">    override func encodeRestorableStateWithCoder(coder: NSCoder) &#123;</span><br><span class="line">        if let selectedIndexs = self.tableView.indexPathsForSelectedRows()&#123;</span><br><span class="line">            //Encode select index</span><br><span class="line">            var data = NSKeyedArchiver.archivedDataWithRootObject(selectedIndexs)</span><br><span class="line">            coder.encodeObject(data, forKey:KTALBLESELECTEDINDEX)</span><br><span class="line">        &#125;</span><br><span class="line">        super.encodeRestorableStateWithCoder(coder)</span><br><span class="line">    &#125;</span><br><span class="line">    override func decodeRestorableStateWithCoder(coder: NSCoder) &#123;</span><br><span class="line"></span><br><span class="line">        var data = coder.decodeObjectForKey(KTALBLESELECTEDINDEX) as? NSData</span><br><span class="line">        if data != nil&#123;</span><br><span class="line">            //Decode select index</span><br><span class="line">            if let selectedIndexs = NSKeyedUnarchiver.unarchiveObjectWithData(data!) as? NSArray&#123;</span><br><span class="line">                for var i = 0;i &lt; selectedIndexs.count;i++ &#123;</span><br><span class="line">                    let oneIndex = selectedIndexs[i] as! NSIndexPath</span><br><span class="line">                    self.tableView.selectRowAtIndexPath(oneIndex, animated:false, scrollPosition: UITableViewScrollPosition.None)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        super.decodeRestorableStateWithCoder(coder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;123456789101112131415161718192021222324252627</span><br></pre></td></tr></table></figure>
<hr>
<p>版权声明：本文为博主原创文章，如需转载请注明出处    <a href="https://blog.csdn.net/Hello_Hwc/article/details/45146305" target="_blank" rel="noopener">https://blog.csdn.net/Hello_Hwc/article/details/45146305</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS允许用户删除专辑，以及撤销上次的删除操作]]></title>
      <url>/2018/05/14/%E5%85%81%E8%AE%B8%E7%94%A8%E6%88%B7%E5%88%A0%E9%99%A4%E4%B8%93%E8%BE%91%E4%BB%A5%E5%8F%8A%E6%92%A4%E9%94%80%E4%B8%8A%E6%AC%A1%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="最后的润色"><a href="#最后的润色" class="headerlink" title="最后的润色"></a>最后的润色</h1><p>现在我们将添加最后一个功能：允许用户删除专辑，以及撤销上次的删除操作。</p>
<p>在 <code>ViewController</code> 里添加如下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 为了实现撤销功能，我们用数组作为一个栈来 push 和 pop 用户的操作</span><br><span class="line">var undoStack: [(Album, Int)] = []</span><br></pre></td></tr></table></figure>
<p>然后在 <code>viewDidLoad</code> 的 <code>reloadScroller()</code> 后面添加如下代码：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let undoButton = UIBarButtonItem(barButtonSystemItem: .Undo, target: self, action:&quot;undoAction&quot;)</span><br><span class="line">undoButton.enabled = false;</span><br><span class="line">let space = UIBarButtonItem(barButtonSystemItem: .FlexibleSpace, target:nil, action:nil)</span><br><span class="line">let trashButton = UIBarButtonItem(barButtonSystemItem: .Trash, target:self, action:&quot;deleteAlbum&quot;)</span><br><span class="line">let toolbarButtonItems = [undoButton, space, trashButton]</span><br><span class="line">toolbar.setItems(toolbarButtonItems, animated: true)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码创建了一个 <code>toolbar</code> ，上面有两个按钮，在 <code>undoStack</code> 为空的情况下， <code>undo</code> 的按钮是不可用的。注意 <code>toolbar</code> 已经在 <code>storyboard</code> 里了，我们需要做的只是配置上面的按钮。</p>
<p>我们需要在 <code>ViewController.swift</code> 里添加三个方法，用来处理专辑的编辑事件：增加，删除，撤销。</p>
<p>先写添加的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func addAlbumAtIndex(album: Album,index: Int) &#123;</span><br><span class="line">    LibraryAPI.sharedInstance.addAlbum(album, index: index)</span><br><span class="line">    currentAlbumIndex = index</span><br><span class="line">    reloadScroller()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了三件事：添加专辑，设为当前的索引，重新加载滚动条。</p>
<p>接下来是删除方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func deleteAlbum() &#123;</span><br><span class="line">    //1</span><br><span class="line">    var deletedAlbum : Album = allAlbums[currentAlbumIndex]</span><br><span class="line">    //2</span><br><span class="line">    var undoAction = (deletedAlbum, currentAlbumIndex)</span><br><span class="line">    undoStack.insert(undoAction, atIndex: 0)</span><br><span class="line">    //3</span><br><span class="line">    LibraryAPI.sharedInstance.deleteAlbum(currentAlbumIndex)</span><br><span class="line">    reloadScroller()</span><br><span class="line">    //4</span><br><span class="line">    let barButtonItems = toolbar.items as [UIBarButtonItem]</span><br><span class="line">    var undoButton : UIBarButtonItem = barButtonItems[0]</span><br><span class="line">    undoButton.enabled = true</span><br><span class="line">    //5</span><br><span class="line">    if (allAlbums.count == 0) &#123;</span><br><span class="line">        var trashButton : UIBarButtonItem = barButtonItems[2]</span><br><span class="line">        trashButton.enabled = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>挨个看一下各个部分：</p>
<ul>
<li>获取要删除的专辑。</li>
<li>创建一个 <code>undoAction</code> 对象，用元组存储 <code>Album</code> 对象和它的索引值。然后把这个元组加到了栈里。</li>
<li>使用 <code>LibraryAPI</code> 删除专辑数据，然后重新加载滚动条。</li>
<li>既然撤销栈里已经有了数据，那么我们需要设置撤销按钮为可用。</li>
<li>检查一下是不是还剩专辑，如果没有专辑了那就设置删除按钮为不可用。</li>
</ul>
<p>最后添加撤销按钮：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func undoAction() &#123;</span><br><span class="line">    let barButtonItems = toolbar.items as [UIBarButtonItem]</span><br><span class="line">    //1       </span><br><span class="line">    if undoStack.count &gt; 0 &#123;</span><br><span class="line">        let (deletedAlbum, index) = undoStack.removeAtIndex(0)</span><br><span class="line">        addAlbumAtIndex(deletedAlbum, index: index)</span><br><span class="line">    &#125;</span><br><span class="line">    //2       </span><br><span class="line">    if undoStack.count == 0 &#123;</span><br><span class="line">        var undoButton : UIBarButtonItem = barButtonItems[0]</span><br><span class="line">        undoButton.enabled = false</span><br><span class="line">    &#125;</span><br><span class="line">    //3       </span><br><span class="line">    let trashButton : UIBarButtonItem = barButtonItems[2]</span><br><span class="line">    trashButton.enabled = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>照着备注的三个步骤再看一下撤销方法里的代码：</p>
<ul>
<li>首先从栈里 <code>pop</code> 出一个对象，这个对象就是我们当初塞进去的元祖，存有删除的 <code>Album</code> 对象和它的索引位置。然后我们把取出来的对象放回了数据源里。</li>
<li>因为我们从栈里删除了一个对象，所以需要检查一下看看栈是不是空了。如果空了那就设置撤销按钮不可用。</li>
<li>既然我们已经撤消了一个专辑，那删除按钮肯定是可用的。所以把它设置为 <code>enabled</code> 。</li>
</ul>
<p>这时再运行应用，试试删除和插销功能，似乎一切正常了：</p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/13.png" alt="img"></p>
<p>我们也可以趁机测试一下，看看是否及时存储了专辑数据的变化。比如删除一个专辑，然后切到后台，强关应用，再重新开启，看看是不是删除操作成功保存了。</p>
<p>如果想要恢复所有数据，删除应用然后重新安装即可。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> other </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS备忘录模式 - Memento]]></title>
      <url>/2018/05/14/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>备忘录模式捕捉并且具象化一个对象的内在状态。换句话说，它把你的对象存在了某个地方，然后在以后的某个时间再把它恢复出来，而不会打破它本身的封装性，私有数据依旧是私有数据。</p>
<h3 id="如何使用备忘录模式"><a href="#如何使用备忘录模式" class="headerlink" title="如何使用备忘录模式"></a>如何使用备忘录模式</h3><p>在 <code>ViewController.swift</code> 里加上下面两个方法：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//MARK: Memento Pattern</span><br><span class="line">func saveCurrentState() &#123;</span><br><span class="line">    // When the user leaves the app and then comes back again, he wants it to be in the exact same state</span><br><span class="line">    // he left it. In order to do this we need to save the currently displayed album.</span><br><span class="line">    // Since it&apos;s only one piece of information we can use NSUserDefaults.</span><br><span class="line">    NSUserDefaults.standardUserDefaults().setInteger(currentAlbumIndex, forKey: &quot;currentAlbumIndex&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func loadPreviousState() &#123;</span><br><span class="line">    currentAlbumIndex = NSUserDefaults.standardUserDefaults().integerForKey(&quot;currentAlbumIndex&quot;)</span><br><span class="line">    showDataForAlbum(currentAlbumIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>saveCurrentState</code> 把当前相册的索引值存到 <code>NSUserDefaults</code> 里。<code>NSUserDefaults</code> 是 iOS 提供的一个标准存储方案，用于保存应用的配置信息和数据。</p>
<p><code>loadPreviousState</code> 方法加载上次存储的索引值。这并不是备忘录模式的完整实现，但是已经离目标不远了。</p>
<p>接下来在 <code>viewDidLoad</code> 的 <code>scroller.delegate = self</code> 前面调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadPreviousState()</span><br></pre></td></tr></table></figure>
<p>这样在刚初始化的时候就加载了上次存储的状态。但是什么时候存储当前状态呢？这个时候我们可以用通知来做。在应用进入到后台的时候， iOS 会发送一个 <code>UIApplicationDidEnterBackgroundNotification</code> 的通知，我们可以在这个通知里调用 <code>saveCurrentState</code> 这个方法。是不是很方便？</p>
<p>在 <code>viewDidLoad</code> 的最后加上如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSNotificationCenter.defaultCenter().addObserver(self, selector:&quot;saveCurrentState&quot;, name: UIApplicationDidEnterBackgroundNotification, object: nil)</span><br></pre></td></tr></table></figure>
<p>现在，当应用即将进入后台的时候，<code>ViewController</code> 会调用 <code>saveCurrentState</code> 方法自动存储当前状态。</p>
<p>当然也别忘了取消监听通知，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">    NSNotificationCenter.defaultCenter().removeObserver(self)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就确保在 <code>ViewController</code> 销毁的时候取消监听通知。</p>
<p>这时再运行程序，随意移到某个专辑上，然后按下 Home 键把应用切换到后台，再在 Xcode 上把 App 关闭。重新启动，会看见上次记录的专辑已经存了下来并成功还原了：</p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/11.png" alt="img"></p>
<p>看起来专辑数据好像是对了，但是上面的滚动条似乎出了问题，没有居中啊！</p>
<p>这时 <code>initialViewIndex</code> 方法就派上用场了。由于在委托里 (也就是 <code>ViewController</code> ) 还没实现这个方法，所以初始化的结果总是第一张专辑。</p>
<p>为了修复这个问题，我们可以在 <code>ViewController.swift</code> 里添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func initialViewIndex(scroller: HorizontalScroller) -&gt; Int &#123;</span><br><span class="line">    return currentAlbumIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>HorizontalScroller</code> 可以根据 <code>currentAlbumIndex</code> 自动滑到相应的索引位置了。</p>
<p>再次重复上次的步骤，切到后台，关闭应用，重启，一切顺利：</p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/12.png" alt="img"></p>
<p>回头看看 <code>PersistencyManager</code> 的 <code>init</code> 方法，你会发现专辑数据是我们硬编码写进去的，而且每次创建 <code>PersistencyManager</code> 的时候都会再创建一次专辑数据。而实际上一个比较好的方案是只创建一次，然后把专辑数据存到本地文件里。我们如何把专辑数据存到文件里呢？</p>
<p>一种方案是遍历 <code>Album</code> 的属性然后把它们写到一个 <code>plist</code> 文件里，然后如果需要的时候再重新创建 <code>Album</code> 对象。这并不是最好的选择，因为数据和属性不同，你的代码也就要相应的产生变化。举个例子，如果我们以后想添加 <code>Movie</code> 对象，它有着完全不同的属性，那么存储和读取数据又需要重写新的代码。</p>
<p>况且你也无法存储这些对象的私有属性，因为其他类是没有访问权限的。这也就是为什么 Apple 提供了 归档 的机制。</p>
<h3 id="归档-Archiving"><a href="#归档-Archiving" class="headerlink" title="归档 - Archiving"></a>归档 - Archiving</h3><p>苹果通过归档的方法来实现备忘录模式。它把对象转化成了流然后在不暴露内部属性的情况下存储数据。你可以读一读 《iOS 6 by Tutorials》 这本书的第 16 章，或者看下[苹果的归档和序列化文档][14]。</p>
<h4 id="如何使用归档"><a href="#如何使用归档" class="headerlink" title="如何使用归档"></a>如何使用归档</h4><p>首先，我们需要让 <code>Album</code> 实现 <code>NSCoding</code> 协议，声明这个类是可被归档的。打开 <code>Album.swift</code> 在 <code>class</code> 那行后面加上 <code>NSCoding</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Album: NSObject, NSCoding &#123;</span><br></pre></td></tr></table></figure>
<p>然后添加如下的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">required init(coder decoder: NSCoder) &#123;</span><br><span class="line">    super.init()</span><br><span class="line">    self.title = decoder.decodeObjectForKey(&quot;title&quot;) as String?</span><br><span class="line">    self.artist = decoder.decodeObjectForKey(&quot;artist&quot;) as String?</span><br><span class="line">    self.genre = decoder.decodeObjectForKey(&quot;genre&quot;) as String?</span><br><span class="line">    self.coverUrl = decoder.decodeObjectForKey(&quot;cover_url&quot;) as String?</span><br><span class="line">    self.year = decoder.decodeObjectForKey(&quot;year&quot;) as String?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func encodeWithCoder(aCoder: NSCoder) &#123;</span><br><span class="line">    aCoder.encodeObject(title, forKey: &quot;title&quot;)</span><br><span class="line">    aCoder.encodeObject(artist, forKey: &quot;artist&quot;)</span><br><span class="line">    aCoder.encodeObject(genre, forKey: &quot;genre&quot;)</span><br><span class="line">    aCoder.encodeObject(coverUrl, forKey: &quot;cover_url&quot;)</span><br><span class="line">    aCoder.encodeObject(year, forKey: &quot;year&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>encodeWithCoder</code> 方法是 <code>NSCoding</code> 的一部分，在被归档的时候调用。相对的， <code>init(coder:)</code> 方法则是用来解档的。很简单，很强大。</p>
<p>现在 <code>Album</code> 对象可以被归档了，添加一些代码来存储和加载 <code>Album</code> 数据。</p>
<p>在 <code>PersistencyManager.swift</code> 里添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func saveAlbums() &#123;</span><br><span class="line">    var filename = NSHomeDirectory().stringByAppendingString(&quot;/Documents/albums.bin&quot;)</span><br><span class="line">    let data = NSKeyedArchiver.archivedDataWithRootObject(albums)</span><br><span class="line">    data.writeToFile(filename, atomically: true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可以用来存储专辑。 <code>NSKeyedArchiver</code> 把专辑数组归档到了 <code>albums.bin</code> 这个文件里。</p>
<p>当我们归档一个包含子对象的对象时，系统会自动递归的归档子对象，然后是子对象的子对象，这样一层层递归下去。在我们的例子里，我们归档的是 <code>albums</code> 因为 <code>Array</code> 和 <code>Album</code> 都是实现 <code>NSCopying</code> 接口的，所以数组里的对象都可以自动归档。</p>
<p>用下面的代码取代 <code>PersistencyManager</code> 中的 <code>init</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">override init() &#123;</span><br><span class="line">    super.init()</span><br><span class="line">    if let data = NSData(contentsOfFile: NSHomeDirectory().stringByAppendingString(&quot;/Documents/albums.bin&quot;)) &#123;</span><br><span class="line">        let unarchiveAlbums = NSKeyedUnarchiver.unarchiveObjectWithData(data) as [Album]?</span><br><span class="line">        if let unwrappedAlbum = unarchiveAlbums &#123;</span><br><span class="line">            albums = unwrappedAlbum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        createPlaceholderAlbum()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createPlaceholderAlbum() &#123;</span><br><span class="line">    //Dummy list of albums</span><br><span class="line">    let album1 = Album(title: &quot;Best of Bowie&quot;,</span><br><span class="line">             artist: &quot;David Bowie&quot;,</span><br><span class="line">             genre: &quot;Pop&quot;,</span><br><span class="line">             coverUrl: &quot;http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png&quot;,</span><br><span class="line">             year: &quot;1992&quot;)</span><br><span class="line"></span><br><span class="line">    let album2 = Album(title: &quot;It&apos;s My Life&quot;,</span><br><span class="line">           artist: &quot;No Doubt&quot;,</span><br><span class="line">           genre: &quot;Pop&quot;,</span><br><span class="line">           coverUrl: &quot;http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png&quot;,</span><br><span class="line">           year: &quot;2003&quot;)</span><br><span class="line"></span><br><span class="line">    let album3 = Album(title: &quot;Nothing Like The Sun&quot;,</span><br><span class="line">               artist: &quot;Sting&quot;,</span><br><span class="line">           genre: &quot;Pop&quot;,</span><br><span class="line">           coverUrl: &quot;http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png&quot;,</span><br><span class="line">           year: &quot;1999&quot;)</span><br><span class="line"></span><br><span class="line">    let album4 = Album(title: &quot;Staring at the Sun&quot;,</span><br><span class="line">           artist: &quot;U2&quot;,</span><br><span class="line">           genre: &quot;Pop&quot;,</span><br><span class="line">           coverUrl: &quot;http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png&quot;,</span><br><span class="line">           year: &quot;2000&quot;)</span><br><span class="line"></span><br><span class="line">    let album5 = Album(title: &quot;American Pie&quot;,</span><br><span class="line">           artist: &quot;Madonna&quot;,</span><br><span class="line">           genre: &quot;Pop&quot;,</span><br><span class="line">           coverUrl: &quot;http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png&quot;,</span><br><span class="line">           year: &quot;2000&quot;)</span><br><span class="line">    albums = [album1, album2, album3, album4, album5]</span><br><span class="line">    saveAlbums()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把创建专辑数据的方法放到了 <code>createPlaceholderAlbum</code> 里，这样代码可读性更高。在新的代码里，如果存在归档文件， <code>NSKeyedUnarchiver</code> 从归档文件加载数据；否则就创建归档文件，这样下次程序启动的时候可以读取本地文件加载数据。</p>
<p>我们还想在每次程序进入后台的时候存储专辑数据。看起来现在这个功能并不是必须的，但是如果以后我们加了编辑功能，这样做还是很有必要的，那时我们肯定希望确保新的数据会同步到本地的归档文件。</p>
<p>因为我们的程序通过 <code>LibraryAPI</code> 来访问所有服务，所以我们需要通过 <code>LibraryAPI</code> 来通知 <code>PersistencyManager</code> 存储专辑数据。</p>
<p>在 <code>LibraryAPI</code> 里添加存储专辑数据的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func saveAlbums() &#123;</span><br><span class="line">    persistencyManager.saveAlbums()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单，就是把 <code>LibraryAPI</code> 的 <code>saveAlbums</code> 方法传递给了 <code>persistencyManager</code> 的 <code>saveAlbums</code> 方法。</p>
<p>然后在 <code>ViewController.swift</code> 的 <code>saveCurrentState</code> 方法的最后加上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LibraryAPI.sharedInstance.saveAlbums()</span><br></pre></td></tr></table></figure>
<p>在 <code>ViewController</code> 需要存储状态的时候，上面的代码通过 <code>LibraryAPI</code> 归档当前的专辑数据。</p>
<p>运行一下程序，检查一下没有编译错误。</p>
<p>不幸的是似乎没什么简单的方法来检查归档是否正确完成。你可以检查一下 <code>Documents</code> 目录，看下是否存在归档文件。如果要查看其他数据变化的话，还需要添加编辑专辑数据的功能。</p>
<p>不过和编辑数据相比，似乎加个删除专辑的功能更好一点，如果不想要这张专辑直接删除即可。再进一步，万一误删了话，是不是还可以再加个撤销按钮？</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[列举 ENUM 类型]]></title>
      <url>/2018/05/11/%E5%88%97%E4%B8%BE%20ENUM%20%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>由 <strong>王巍 (@ONEVCAT)</strong> 发布于 2016-04-13</p>
<p><a href="http://swifter.tips/enum-enumerate/" target="_blank" rel="noopener">http://swifter.tips/enum-enumerate/</a></p>
<p>设想我们有这样一个需求，通过对于一副扑克牌的花色和牌面大小的 <code>enum</code> 类型，凑出一套不含大小王的扑克牌的数组。<br><a id="more"></a><br>扑克牌花色和牌面大小分别由下面两个 <code>enum</code> 来定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">enum Suit: String &#123;</span><br><span class="line">    case Spades = &quot;黑桃&quot;</span><br><span class="line">    case Hearts = &quot;红桃&quot;</span><br><span class="line">    case Clubs = &quot;草花&quot;</span><br><span class="line">    case Diamonds = &quot;方片&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Rank: Int, Printable &#123;</span><br><span class="line">    case Ace = 1</span><br><span class="line">    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten</span><br><span class="line">    case Jack, Queen, King</span><br><span class="line">    var description: String &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Ace:</span><br><span class="line">            return &quot;A&quot;</span><br><span class="line">        case .Jack:</span><br><span class="line">            return &quot;J&quot;</span><br><span class="line">        case .Queen:</span><br><span class="line">            return &quot;Q&quot;</span><br><span class="line">        case .King:</span><br><span class="line">            return &quot;K&quot;</span><br><span class="line">        default:</span><br><span class="line">            return String(self.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最容易想到的方式当然不外乎对两个 <code>enum</code> 进行两次循环，先循环取出 <code>Suit</code> 中的四种花色，然后在其中循环 <code>Rank</code> 类型取出数字后，就可以配合得到 52 张牌了。</p>
<p>在其他很多语言中，我们可以对 <code>enum</code> 类型或者其某个类似 <code>values</code> 的属性直接进行枚举，写出来的话，可能会是类似这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for suit in Suit.values &#123;</span><br><span class="line">    for rank in Rank.values &#123;</span><br><span class="line">        // ...</span><br><span class="line">        // 处理数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在 Swift 中，由于在 <code>enum</code> 中的某一个 case 中我们是可以添加具体值的 (就是 <code>case Some(T)</code>这样的情况)，因此直接使用 <code>for...in</code> 的方式在语义上是无法表达出所有情况的。不过因为在我们这个特定的情况中并没有带有参数的枚举类型，所以我们可以利用 static 的属性来获取一个可以进行循环的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protocol EnumeratableEnumType &#123;</span><br><span class="line">    static var allValues: [Self] &#123;get&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Suit: EnumeratableEnumType &#123;</span><br><span class="line">    static var allValues: [Suit] &#123;</span><br><span class="line">        return [.Spades, .Hearts, .Clubs, .Diamonds]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Rank: EnumeratableEnumType &#123;</span><br><span class="line">    static var allValues: [Rank] &#123;</span><br><span class="line">        return [.Ace, .Two, .Three,</span><br><span class="line">            .Four, .Five, .Six,</span><br><span class="line">            .Seven, .Eight, .Nine,</span><br><span class="line">            .Ten, .Jack, .Queen, .King]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们使用了一个接口来更好地定义适用的接口。关于其中的 <code>class</code> 和 <code>static</code> 的使用情景，可以参看<a href="http://swifter.tips/static-class/" target="_blank" rel="noopener">这一篇总结</a>。在实现了 <code>allValues</code> 后，我们就可以按照上面的思路写出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for suit in Suit.allValues &#123;</span><br><span class="line">    for rank in Rank.allValues &#123;</span><br><span class="line">        print(&quot;\(suit.rawValue)\(rank)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// 黑桃A</span><br><span class="line">// 黑桃2</span><br><span class="line">// 黑桃3</span><br><span class="line">// ...</span><br><span class="line">// 方片K</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[swift enum高级用法]]></title>
      <url>/2018/05/11/swift%20enum%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>swift enum高级用法</p>
<p>2017年08月31日 16:40:00</p>
<p>阅读数：2770</p>
<p>本文是一篇详细且具有实战意义的教程，涵盖几乎所有枚举(<code>Enum</code>)知识点，为你解答<code>Swift</code>中枚举的应用场合以及使用方法。</p>
<p>和<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="noopener">switch语句</a>类似，<code>Swift</code>中的枚举乍看之下更像是<code>C</code>语言中枚举的进阶版本，即允许你定义一种类型，用于表示普通事情中某种用例。不过深入挖掘之后，凭借<code>Swift</code>背后特别的设计理念，相比较<code>C</code>语言枚举来说其在实际场景中的应用更为广泛。特别是作为强大的工具，<code>Swift</code>中的枚举能够清晰表达代码的意图。<br><a id="more"></a><br>本文中，我们将首先了解基础语法和使用枚举的可能性，接着通过实战教你如何以及何时使用枚举。最后我们还会大致了解下<code>Swift</code>标准库中枚举是如何被使用的。</p>
<p>正式开始学习之前，先给出枚举的定义。之后我们将回过头再来讨论它。</p>
<blockquote>
<p>枚举声明的类型是囊括可能状态的有限集，且可以具有附加值。通过内嵌(<em>nesting</em>),方法(<em>method</em>),关联值(<em>associated values</em>)和模式匹配(<em>pattern matching</em>),枚举可以分层次地定义任何有组织的数据。</p>
</blockquote>
<h2 id="深入理解-Diving-In"><a href="#深入理解-Diving-In" class="headerlink" title="深入理解(Diving In)"></a>深入理解(Diving In)</h2><p>简要概述如何定义和使用枚举。</p>
<h3 id="定义基本的枚举类型-Defining-Basic-Enums"><a href="#定义基本的枚举类型-Defining-Basic-Enums" class="headerlink" title="定义基本的枚举类型(Defining Basic Enums)"></a>定义基本的枚举类型(Defining Basic Enums)</h3><p>试想我们正在开发一款游戏，玩家能够朝四个方向移动。所以喽，玩家的运动轨迹受到了限制。显然，我们能够使用枚举来表述这一情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Movement&#123;</span><br><span class="line">    case Left</span><br><span class="line">    case Right</span><br><span class="line">    case Top</span><br><span class="line">    case Bottom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，你可以使用<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="noopener">多种模式匹配结构</a>获取到<code>Movement</code>的枚举值，或者按照特定情况执行操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let aMovement = Movement.Left</span><br><span class="line"></span><br><span class="line">// switch 分情况处理</span><br><span class="line">switch aMovement&#123;</span><br><span class="line">case .Left: print(&quot;left&quot;)</span><br><span class="line">default:()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 明确的case情况</span><br><span class="line">if case .Left = aMovement&#123;</span><br><span class="line">    print(&quot;left&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if aMovement == .Left &#123; print(&quot;left&quot;) &#125;</span><br></pre></td></tr></table></figure>
<p>案例中，我们无须明确指出<code>enum</code>的实际名称(即<code>case Move.Left:print(&quot;Left&quot;)</code>)。因为类型检查器能够自动为此进行类型推算。这对于那些<strong>UIKit</strong>以及<strong>AppKit</strong>中错综复杂的枚举是灰常有用的。</p>
<h3 id="枚举值-Enum-Values"><a href="#枚举值-Enum-Values" class="headerlink" title="枚举值(Enum Values)"></a>枚举值(Enum Values)</h3><p>当然，你可能想要为<code>enum</code>中每个<code>case</code>分配一个值。这相当有用，比如枚举自身实际与某事或某物挂钩时，往往这些东西又需要使用不同类型来表述。在<code>C</code>语言中，你只能为枚举<code>case</code>分配整型值，而<code>Swift</code>则提供了更多的灵活性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 映射到整型</span><br><span class="line">enum Movement: Int &#123;</span><br><span class="line">    case Left = 0</span><br><span class="line">    case Right = 1</span><br><span class="line">    case Top = 2</span><br><span class="line">    case Bottom = 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同样你可以与字符串一一对应</span><br><span class="line">enum House: String &#123;</span><br><span class="line">    case Baratheon = &quot;Ours is the Fury&quot;</span><br><span class="line">    case Greyjoy = &quot;We Do Not Sow&quot;</span><br><span class="line">    case Martell = &quot;Unbowed, Unbent, Unbroken&quot;</span><br><span class="line">    case Stark = &quot;Winter is Coming&quot;</span><br><span class="line">    case Tully = &quot;Family, Duty, Honor&quot;</span><br><span class="line">    case Tyrell = &quot;Growing Strong&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者float double都可以(同时注意枚举中的花式unicode)</span><br><span class="line">enum Constants: Double &#123;</span><br><span class="line">    case π = 3.14159</span><br><span class="line">    case e = 2.71828</span><br><span class="line">    case φ = 1.61803398874</span><br><span class="line">    case λ = 1.30357</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>String</code>和<code>Int</code>类型来说，你甚至可以忽略为枚举中的<code>case</code>赋值，<code>Swift</code>编译器也能正常工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Mercury = 1, Venus = 2, ... Neptune = 8</span><br><span class="line">enum Planet: Int &#123;</span><br><span class="line">    case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// North = &quot;North&quot;, ... West = &quot;West&quot;</span><br><span class="line">// 译者注: 这个是swift2.0新增语法</span><br><span class="line">enum CompassPoint: String &#123;</span><br><span class="line">    case North, South, East, West</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Swift</code>枚举中支持以下四种关联值类型:</p>
<ul>
<li>整型(Integer)</li>
<li>浮点数(Float Point)</li>
<li>字符串(String)</li>
<li>布尔类型(Boolean)</li>
</ul>
<p>因此你无法<a href="https://blog.csdn.net/itchosen/article/details/77749152#c1" target="_blank" rel="noopener">1</a>为枚举分配诸如<code>CGPoint</code>类型的值。</p>
<p>倘若你想要读取枚举的值，可以通过<code>rawValue</code>属性来实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let bestHouse = House.Stark</span><br><span class="line">print(bestHouse.rawValue)</span><br><span class="line">// prints &quot;Winter is coming&quot;</span><br></pre></td></tr></table></figure>
<p>不过某种情形下，你可能想要通过一个已有的<code>raw value</code>来创建一个<code>enum case</code>。这种情况下，枚举提供了一个指定构造方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Movement: Int &#123;</span><br><span class="line">    case Left = 0</span><br><span class="line">    case Right = 1</span><br><span class="line">    case Top = 2</span><br><span class="line">    case Bottom = 3</span><br><span class="line">&#125;</span><br><span class="line">// 创建一个movement.Right 用例,其raw value值为1</span><br><span class="line">let rightMovement = Movement(rawValue: 1)</span><br></pre></td></tr></table></figure>
<p>倘若使用<code>rawValue</code>构造器，切记它是一个可失败构造器(<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID376" target="_blank" rel="noopener">failable initializer</a>)。换言之，构造方法返回值为<a href="http://appventure.me/2014/06/13/swift-optionals-made-simple/" target="_blank" rel="noopener">可选类型值</a>,因为有时候传入的值可能与任意一个<code>case</code>都不匹配。比如<code>Movement(rawValue:42)</code>。</p>
<p>如果你想要以底层 C 二进制编码形式呈现某物或某事，使得更具可读性，这是一个非常有用的功能。例如，可以看一下<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/kqueue.2.html" target="_blank" rel="noopener">BSD kqeue library</a>中的<strong>VNode Flags</strong>标志位的编码方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum VNodeFlags : UInt32 &#123;</span><br><span class="line">    case Delete = 0x00000001</span><br><span class="line">    case Write = 0x00000002</span><br><span class="line">    case Extended = 0x00000004</span><br><span class="line">    case Attrib = 0x00000008</span><br><span class="line">    case Link = 0x00000010</span><br><span class="line">    case Rename = 0x00000020</span><br><span class="line">    case Revoke = 0x00000040</span><br><span class="line">    case None = 0x00000080</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此便可以使你的<strong>Delete</strong>或<strong>Write</strong>用例声明一目了然，稍后一旦需要，只需将<strong>raw value</strong>传入 C 函数中即可。</p>
<h3 id="嵌套枚举-Nesting-Enums"><a href="#嵌套枚举-Nesting-Enums" class="headerlink" title="嵌套枚举(Nesting Enums)"></a>嵌套枚举(Nesting Enums)</h3><p>如果你有特定子类型的需求，可以对<code>enum</code>进行嵌套。这样就允许你为实际的<code>enum</code>中包含其他明确信息的<code>enum</code>。以<strong>RPG</strong>游戏中的每个角色为例，每个角色能够拥有武器，因此所有角色都可以获取同一个武器集合。而游戏中的其他实例则无法获取这些武器(比如食人魔,它们仅使用棍棒)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum Character &#123;</span><br><span class="line">  enum Weapon &#123;</span><br><span class="line">    case Bow</span><br><span class="line">    case Sword</span><br><span class="line">    case Lance</span><br><span class="line">    case Dagger</span><br><span class="line">  &#125;</span><br><span class="line">  enum Helmet &#123;</span><br><span class="line">    case Wooden</span><br><span class="line">    case Iron</span><br><span class="line">    case Diamond</span><br><span class="line">  &#125;</span><br><span class="line">  case Thief</span><br><span class="line">  case Warrior</span><br><span class="line">  case Knight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你可以通过层级结构来描述角色允许访问的项目条。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let character = Character.Thief</span><br><span class="line">let weapon = Character.Weapon.Bow</span><br><span class="line">let helmet = Character.Helmet.Iron</span><br></pre></td></tr></table></figure>
<h3 id="包含枚举-Containing-Enums"><a href="#包含枚举-Containing-Enums" class="headerlink" title="包含枚举(Containing Enums)"></a>包含枚举(Containing Enums)</h3><p>同样地，你也能够在<code>structs</code>或<code>classes</code>中内嵌枚举。接着上面的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct Character &#123;</span><br><span class="line">   enum CharacterType &#123;</span><br><span class="line">    case Thief</span><br><span class="line">    case Warrior</span><br><span class="line">    case Knight</span><br><span class="line">  &#125;</span><br><span class="line">  enum Weapon &#123;</span><br><span class="line">    case Bow</span><br><span class="line">    case Sword</span><br><span class="line">    case Lance</span><br><span class="line">    case Dagger</span><br><span class="line">  &#125;</span><br><span class="line">  let type: CharacterType</span><br><span class="line">  let weapon: Weapon</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let warrior = Character(type: .Warrior, weapon: .Sword)</span><br></pre></td></tr></table></figure>
<p>同样地，这也将有助于我们将相关的信息集中在一个位置。</p>
<h3 id="关联值-Associated-Value"><a href="#关联值-Associated-Value" class="headerlink" title="关联值(Associated Value)"></a>关联值(Associated Value)</h3><p>关联值是将额外信息附加到<code>enum case</code>中的一种极好的方式。打个比方，你正在开发一款交易引擎，可能存在<strong>买</strong>和<strong>卖</strong>两种不同的交易类型。除此之外每手交易还要制定明确的股票名称和交易数量:</p>
<h4 id="简单例程-Simple-Example"><a href="#简单例程-Simple-Example" class="headerlink" title="简单例程(Simple Example)"></a>简单例程(Simple Example)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Trade &#123;</span><br><span class="line">    case Buy</span><br><span class="line">    case Sell</span><br><span class="line">&#125;</span><br><span class="line">func trade(tradeType: Trade, stock: String, amount: Int) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然而股票的价值和数量显然从属于交易，让他们作为独立的参数显得模棱两可。你可能已经想到要往<code>struct</code>中内嵌一个枚举了，不过关联值提供了一种更清爽的解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Trade &#123;</span><br><span class="line">    case Buy(stock: String, amount: Int)</span><br><span class="line">    case Sell(stock: String, amount: Int)</span><br><span class="line">&#125;</span><br><span class="line">func trade(type: Trade) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模式匹配-Pattern-Mathching"><a href="#模式匹配-Pattern-Mathching" class="headerlink" title="模式匹配(Pattern Mathching)"></a>模式匹配(Pattern Mathching)</h4><p>如果你想要访问这些值，<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="noopener">模式匹配</a>再次救场:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let trade = Trade.Buy(stock: &quot;APPL&quot;, amount: 500)</span><br><span class="line">if case let Trade.Buy(stock, amount) = trade &#123;</span><br><span class="line">    print(&quot;buy \(amount) of \(stock)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标签-Labels"><a href="#标签-Labels" class="headerlink" title="标签(Labels)"></a>标签(Labels)</h4><p>关联值不需要附加标签的声明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Trade &#123;</span><br><span class="line">   case Buy(String, Int)</span><br><span class="line">   case Sell(String, Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倘若你添加了，那么，每当创建枚举用例时，你都需要将这些标签标示出来。</p>
<h4 id="元组参数-Tuple-as-Arguments"><a href="#元组参数-Tuple-as-Arguments" class="headerlink" title="(元组参数)Tuple as Arguments"></a>(元组参数)Tuple as Arguments</h4><p>更重要的是,<code>Swift</code>内部相关信息其实是一个元组,所以你可以像下面这样做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let tp = (stock: &quot;TSLA&quot;, amount: 100)</span><br><span class="line">let trade = Trade.Sell(tp)</span><br><span class="line"></span><br><span class="line">if case let Trade.Sell(stock, amount) = trade &#123;</span><br><span class="line">    print(&quot;buy \(amount) of \(stock)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// Prints: &quot;buy 100 of TSLA&quot;</span><br></pre></td></tr></table></figure>
<p>语法允许您将元组当作一个简单的数据结构,稍后元组将自动转换到高级类型，就比如<code>enum case</code>。想象一个应用程序可以让用户来配置电脑:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typealias Config = (RAM: Int, CPU: String, GPU: String)</span><br><span class="line"></span><br><span class="line">// Each of these takes a config and returns an updated config</span><br><span class="line">func selectRAM(_ config: Config) -&gt; Config &#123;return (RAM: 32, CPU: config.CPU, GPU: config.GPU)&#125;</span><br><span class="line">func selectCPU(_ config: Config) -&gt; Config &#123;return (RAM: config.RAM, CPU: &quot;3.2GHZ&quot;, GPU: config.GPU)&#125;</span><br><span class="line">func selectGPU(_ config: Config) -&gt; Config &#123;return (RAM: config.RAM, CPU: &quot;3.2GHZ&quot;, GPU: &quot;NVidia&quot;)&#125;</span><br><span class="line"></span><br><span class="line">enum Desktop &#123;</span><br><span class="line">   case Cube(Config)</span><br><span class="line">   case Tower(Config)</span><br><span class="line">   case Rack(Config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let aTower = Desktop.Tower(selectGPU(selectCPU(selectRAM((0, &quot;&quot;, &quot;&quot;) as Config))))</span><br></pre></td></tr></table></figure>
<p>配置的每个步骤均通过递交元组到<code>enum</code>中进行内容更新。倘若我们从<strong>函数式编程</strong><a href="https://blog.csdn.net/itchosen/article/details/77749152#c2" target="_blank" rel="noopener">2</a>中获得启发，这将变得更好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">infix operator &lt;^&gt; &#123; associativity left &#125;</span><br><span class="line"></span><br><span class="line">func &lt;^&gt;(a: Config, f: (Config) -&gt; Config) -&gt; Config &#123; </span><br><span class="line">    return f(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以将不同配置步骤串联起来。这在配置步骤繁多的情况下相当有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let config = (0, &quot;&quot;, &quot;&quot;) &lt;^&gt; selectRAM  &lt;^&gt; selectCPU &lt;^&gt; selectGPU</span><br><span class="line">let aCube = Desktop.Cube(config)</span><br></pre></td></tr></table></figure>
<h4 id="使用案例-Use-Case-Example"><a href="#使用案例-Use-Case-Example" class="headerlink" title="使用案例(Use Case Example)"></a>使用案例(Use Case Example)</h4><p>关联值可以以多种方式使用。常言道：一码胜千言, 下面就上几段简单的示例代码，这几段代码没有特定的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 拥有不同值的用例</span><br><span class="line">enum UserAction &#123;</span><br><span class="line">  case OpenURL(url: NSURL)</span><br><span class="line">  case SwitchProcess(processId: UInt32)</span><br><span class="line">  case Restart(time: NSDate?, intoCommandLine: Bool)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 假设你在实现一个功能强大的编辑器，这个编辑器允许多重选择，</span><br><span class="line">// 正如 Sublime Text : https://www.youtube.com/watch?v=i2SVJa2EGIw</span><br><span class="line">enum Selection &#123;</span><br><span class="line">  case None</span><br><span class="line">  case Single(Range&lt;Int&gt;)</span><br><span class="line">  case Multiple([Range&lt;Int&gt;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者映射不同的标识码</span><br><span class="line">enum Barcode &#123;</span><br><span class="line">    case UPCA(numberSystem: Int, manufacturer: Int, product: Int, check: Int)</span><br><span class="line">    case QRCode(productCode: String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 又或者假设你在封装一个 C 语言库，正如 Kqeue BSD/Darwin 通知系统:</span><br><span class="line">// https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2</span><br><span class="line">enum KqueueEvent &#123;</span><br><span class="line">    case UserEvent(identifier: UInt, fflags: [UInt32], data: Int)</span><br><span class="line">    case ReadFD(fd: UInt, data: Int)</span><br><span class="line">    case WriteFD(fd: UInt, data: Int)</span><br><span class="line">    case VnodeFD(fd: UInt, fflags: [UInt32], data: Int)</span><br><span class="line">    case ErrorEvent(code: UInt, message: String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最后, 一个 RPG 游戏中的所有可穿戴装备可以使用一个枚举来进行映射，</span><br><span class="line">// 可以为一个装备增加重量和持久两个属性</span><br><span class="line">// 现在可以仅用一行代码来增加一个&quot;钻石&quot;属性，如此一来我们便可以增加几件新的镶嵌钻石的可穿戴装备</span><br><span class="line">enum Wearable &#123;</span><br><span class="line">    enum Weight: Int &#123;</span><br><span class="line">    case Light = 1</span><br><span class="line">    case Mid = 4</span><br><span class="line">    case Heavy = 10</span><br><span class="line">    &#125;</span><br><span class="line">    enum Armor: Int &#123;</span><br><span class="line">    case Light = 2</span><br><span class="line">    case Strong = 8</span><br><span class="line">    case Heavy = 20</span><br><span class="line">    &#125;</span><br><span class="line">    case Helmet(weight: Weight, armor: Armor)</span><br><span class="line">    case Breastplate(weight: Weight, armor: Armor)</span><br><span class="line">    case Shield(weight: Weight, armor: Armor)</span><br><span class="line">&#125;</span><br><span class="line">let woodenHelmet = Wearable.Helmet(weight: .Light, armor: .Light)</span><br></pre></td></tr></table></figure>
<h3 id="方法和属性-Methods-and-properties"><a href="#方法和属性-Methods-and-properties" class="headerlink" title="方法和属性(Methods and properties)"></a>方法和属性(Methods and properties)</h3><p>你也可以在<code>enum</code>中像这样定义方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum Wearable &#123;</span><br><span class="line">    enum Weight: Int &#123;</span><br><span class="line">        case Light = 1</span><br><span class="line">    &#125;</span><br><span class="line">    enum Armor: Int &#123;</span><br><span class="line">        case Light = 2</span><br><span class="line">    &#125;</span><br><span class="line">    case Helmet(weight: Weight, armor: Armor)</span><br><span class="line">        func attributes() -&gt; (weight: Int, armor: Int) &#123;</span><br><span class="line">       switch self &#123;</span><br><span class="line">             case .Helmet(let w, let a): return (weight: w.rawValue * 2, armor: w.rawValue * 4)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let woodenHelmetProps = Wearable.Helmet(weight: .Light, armor: .Light).attributes()</span><br><span class="line">print (woodenHelmetProps)</span><br><span class="line">// prints &quot;(2, 4)&quot;</span><br></pre></td></tr></table></figure>
<p>枚举中的方法为每一个<code>enum case</code>而“生”。所以倘若想要在特定情况执行特定代码的话，你需要分支处理或采用<code>switch</code>语句来明确正确的代码路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum Device &#123; </span><br><span class="line">    case iPad, iPhone, AppleTV, AppleWatch </span><br><span class="line">    func introduced() -&gt; String &#123;</span><br><span class="line">       switch self &#123;</span><br><span class="line">         case AppleTV: return &quot;\(self) was introduced 2006&quot;</span><br><span class="line">         case iPhone: return &quot;\(self) was introduced 2007&quot;</span><br><span class="line">         case iPad: return &quot;\(self) was introduced 2010&quot;</span><br><span class="line">         case AppleWatch: return &quot;\(self) was introduced 2014&quot;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print (Device.iPhone.introduced())</span><br><span class="line">// prints: &quot;iPhone was introduced 2007&quot;</span><br></pre></td></tr></table></figure>
<h4 id="属性-Properties"><a href="#属性-Properties" class="headerlink" title="属性(Properties)"></a>属性(Properties)</h4><p>尽管增加一个存储属性到枚举中不被允许，但你依然能够创建计算属性。当然，计算属性的内容都是建立在枚举值下或者枚举关联值得到的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum Device &#123;</span><br><span class="line">  case iPad, iPhone</span><br><span class="line">  var year: Int &#123;</span><br><span class="line">    switch self &#123;</span><br><span class="line">        case iPhone: return 2007</span><br><span class="line">        case iPad: return 2010</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态方法-Static-Methods"><a href="#静态方法-Static-Methods" class="headerlink" title="静态方法(Static Methods)"></a>静态方法(Static Methods)</h4><p>你也能够为枚举创建一些静态方法(<code>static methods</code>)。换言之通过一个非枚举类型来创建一个枚举。在这个示例中,我们需要考虑用户有时将苹果设备叫错的情况(比如AppleWatch叫成iWatch)，需要返回一个合适的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Device &#123; </span><br><span class="line">    case AppleWatch </span><br><span class="line">    static func fromSlang(term: String) -&gt; Device? &#123;</span><br><span class="line">      if term == &quot;iWatch&quot; &#123;</span><br><span class="line">      return .AppleWatch</span><br><span class="line">      &#125;</span><br><span class="line">      return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print (Device.fromSlang(&quot;iWatch&quot;))</span><br></pre></td></tr></table></figure>
<h4 id="可变方法-Mutating-Methods"><a href="#可变方法-Mutating-Methods" class="headerlink" title="可变方法(Mutating Methods)"></a>可变方法(Mutating Methods)</h4><p>方法可以声明为<code>mutating</code>。这样就允许改变隐藏参数<code>self</code>的<code>case</code>值了<a href="https://blog.csdn.net/itchosen/article/details/77749152#c3" target="_blank" rel="noopener">3</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum TriStateSwitch &#123;</span><br><span class="line">    case Off, Low, High</span><br><span class="line">    mutating func next() &#123;</span><br><span class="line">    switch self &#123;</span><br><span class="line">    case Off:</span><br><span class="line">        self = Low</span><br><span class="line">    case Low:</span><br><span class="line">        self = High</span><br><span class="line">    case High:</span><br><span class="line">        self = Off</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var ovenLight = TriStateSwitch.Low</span><br><span class="line">ovenLight.next()</span><br><span class="line">// ovenLight 现在等于.On</span><br><span class="line">ovenLight.next()</span><br><span class="line">// ovenLight 现在等于.Off</span><br></pre></td></tr></table></figure>
<h3 id="小结-To-Recap"><a href="#小结-To-Recap" class="headerlink" title="小结(To Recap)"></a>小结(To Recap)</h3><p>至此，我们已经大致了解了Swift中枚举语法的基本用例。在开始迈向进阶之路之前，让我们重新审视文章开篇给出的定义，看看现在是否变得更清晰了。</p>
<blockquote>
<p>枚举声明的类型是囊括可能状态的有限集，且可以具有附加值。通过内嵌(<em>nesting</em>),方法(<em>method</em>),关联值(<em>associated values</em>)和模式匹配(<em>pattern matching</em>),枚举可以分层次地定义任何有组织的数据。</p>
</blockquote>
<p>现在我们已经对这个定义更加清晰了。确实，如果我们添加关联值和嵌套，<code>enum</code>就看起来就像一个封闭的、简化的<code>struct</code>。相比较<code>struct</code>，前者优势体现在能够为分类与层次结构编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Struct Example</span><br><span class="line">struct Point &#123; let x: Int, let y: Int &#125;</span><br><span class="line">struct Rect &#123; let x: Int, let y: Int, let width: Int, let height: Int &#125;</span><br><span class="line"></span><br><span class="line">// Enum Example</span><br><span class="line">enum GeometricEntity &#123;</span><br><span class="line">   case Point(x: Int, y: Int)</span><br><span class="line">   case Rect(x: Int, y: Int, width: Int, height: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法和静态方法的添加允许我们为<code>enum</code>附加功能，这意味着无须依靠额外函数就能实现<a href="https://blog.csdn.net/itchosen/article/details/77749152#c4" target="_blank" rel="noopener">4</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// C-Like example</span><br><span class="line">enum Trade &#123;</span><br><span class="line">   case Buy</span><br><span class="line">   case Sell</span><br><span class="line">&#125;</span><br><span class="line">func order(trade: Trade)</span><br><span class="line"></span><br><span class="line">// Swift Enum example</span><br><span class="line">enum Trade &#123;</span><br><span class="line">   case Buy</span><br><span class="line">   case Sell</span><br><span class="line">   func order()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举进阶-Advanced-Enum-Usage）"><a href="#枚举进阶-Advanced-Enum-Usage）" class="headerlink" title="枚举进阶(Advanced Enum Usage）"></a>枚举进阶(Advanced Enum Usage）</h2><h3 id="协议-Protocols"><a href="#协议-Protocols" class="headerlink" title="协议(Protocols)"></a>协议(Protocols)</h3><p>我已经提及了<code>structs</code>和<code>enums</code>之间的相似性。除了附加方法的能力之外，<code>Swift</code>也允许你在枚举中使用<strong>协议(Protocols)</strong>和<strong>协议扩展(Protocol Extension)</strong>。</p>
<p><code>Swift</code>协议定义一个接口或类型以供其他数据结构来遵循。<code>enum</code>当然也不例外。我们先从<code>Swift</code>标准库中的一个例子开始.</p>
<p><code>CustomStringConvertible</code>是一个以打印为目的的自定义格式化输出的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol CustomStringConvertible &#123;</span><br><span class="line">  var description: String &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该协议只有一个要求，即一个只读(<code>getter</code>)类型的字符串(<code>String</code>类型)。我们可以很容易为<code>enum</code>实现这个协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum Trade: CustomStringConvertible &#123;</span><br><span class="line">   case Buy, Sell</span><br><span class="line">   var description: String &#123;</span><br><span class="line">       switch self &#123;</span><br><span class="line">       case Buy: return &quot;We&apos;re buying something&quot;</span><br><span class="line">       case Sell: return &quot;We&apos;re selling something&quot;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let action = Trade.Buy</span><br><span class="line">print(&quot;this action is \(action)&quot;)</span><br><span class="line">// prints: this action is We&apos;re buying something</span><br></pre></td></tr></table></figure>
<p>一些协议的实现可能需要根据内部状态来相应处理要求。例如定义一个管理银行账号的协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol AccountCompatible &#123;</span><br><span class="line">  var remainingFunds: Int &#123; get &#125;</span><br><span class="line">  mutating func addFunds(amount: Int) throws</span><br><span class="line">  mutating func removeFunds(amount: Int) throws</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也许会简单地拿<code>struct</code>实现这个协议，但是考虑应用的上下文，<code>enum</code>是一个更明智的处理方法。不过你无法添加一个存储属性到<code>enum</code>中，就像<code>var remainingFuns:Int</code>。那么你会如何构造呢？答案灰常简单，你可以使用关联值完美解决:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Account &#123;</span><br><span class="line">  case Empty</span><br><span class="line">  case Funds(remaining: Int)</span><br><span class="line"></span><br><span class="line">  enum Error: ErrorType &#123;</span><br><span class="line">    case Overdraft(amount: Int)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var remainingFunds: Int &#123;</span><br><span class="line">    switch self &#123;</span><br><span class="line">    case Empty: return 0</span><br><span class="line">    case Funds(let remaining): return remaining</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保持代码清爽，我们可以在<code>enum</code>的协议扩展(<code>protocl extension</code>)中定义必须的协议函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">extension Account: AccountCompatible &#123;</span><br><span class="line"></span><br><span class="line">  mutating func addFunds(amount: Int) throws &#123;</span><br><span class="line">    var newAmount = amount</span><br><span class="line">    if case let .Funds(remaining) = self &#123;</span><br><span class="line">      newAmount += remaining</span><br><span class="line">    &#125;</span><br><span class="line">    if newAmount &lt; 0 &#123;</span><br><span class="line">      throw Error.Overdraft(amount: -newAmount)</span><br><span class="line">    &#125; else if newAmount == 0 &#123;</span><br><span class="line">      self = .Empty</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      self = .Funds(remaining: newAmount)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutating func removeFunds(amount: Int) throws &#123;</span><br><span class="line">    try self.addFunds(amount * -1)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var account = Account.Funds(remaining: 20)</span><br><span class="line">print(&quot;add: &quot;, try? account.addFunds(10))</span><br><span class="line">print (&quot;remove 1: &quot;, try? account.removeFunds(15))</span><br><span class="line">print (&quot;remove 2: &quot;, try? account.removeFunds(55))</span><br><span class="line">// prints:</span><br><span class="line">// : add:  Optional(())</span><br><span class="line">// : remove 1:  Optional(())</span><br><span class="line">// : remove 2:  nil</span><br></pre></td></tr></table></figure>
<p>正如你所看见的，我们通过将值存储到<code>enum cases</code>中实现了协议所有要求项。如此做法还有一个妙不可言的地方:现在整个代码基础上你只需要一个模式匹配就能测试空账号输入的情况。你不需要关心剩余资金是否等于零。</p>
<p>同时，我们也在<strong>账号(Accout)</strong>中内嵌了一个遵循<code>ErrorType</code>协议的枚举，这样我们就可以使用<code>Swift2.0</code>语法来进行错误处理了。这里给出更详细的<a href="http://appventure.me/2015/10/17/advanced-practical-enum-examples/#errortype" target="_blank" rel="noopener">使用案例</a>教程。</p>
<h3 id="扩展-Extensions"><a href="#扩展-Extensions" class="headerlink" title="扩展(Extensions)"></a>扩展(Extensions)</h3><p>正如刚才所见，枚举也可以进行扩展。最明显的用例就是将枚举的<code>case</code>和<code>method</code>分离，这样阅读你的代码能够简单快速地消化掉<code>enum</code>内容，紧接着转移到方法定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Entities &#123;</span><br><span class="line">    case Soldier(x: Int, y: Int)</span><br><span class="line">    case Tank(x: Int, y: Int)</span><br><span class="line">    case Player(x: Int, y: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们为<code>enum</code>扩展方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension Entities &#123;</span><br><span class="line">   mutating func move(dist: CGVector) &#123;&#125;</span><br><span class="line">   mutating func attack() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你同样可以通过写一个扩展来遵循一个特定的协议:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension Entities: CustomStringConvertible &#123;</span><br><span class="line">  var description: String &#123;</span><br><span class="line">    switch self &#123;</span><br><span class="line">       case let .Soldier(x, y): return &quot;\(x), \(y)&quot;</span><br><span class="line">       case let .Tank(x, y): return &quot;\(x), \(y)&quot;</span><br><span class="line">       case let .Player(x, y): return &quot;\(x), \(y)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举泛型-Generic-Enums"><a href="#枚举泛型-Generic-Enums" class="headerlink" title="枚举泛型(Generic Enums)"></a>枚举泛型(Generic Enums)</h3><p>枚举也支持泛型参数定义。你可以使用它们以适应枚举中的关联值。就拿直接来自<code>Swift</code>标准库中的简单例子来说，即<code>Optional</code>类型。你主要可能通过以下几种方式使用它:可选链(<code>optional chaining(?)</code>)、<code>if-let</code>可选绑定、<code>guard let</code>、或<code>switch</code>，但是从语法角度来说你也可以这么使用<code>Optional</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let aValue = Optional&lt;Int&gt;.Some(5)</span><br><span class="line">let noValue = Optional&lt;Int&gt;.None</span><br><span class="line">if noValue == Optional.None &#123; print(&quot;No value&quot;) &#125;</span><br></pre></td></tr></table></figure>
<p>这是<code>Optional</code>最直接的用例，并未使用任何语法糖，但是不可否认<code>Swift</code>中语法糖的加入使得你的工作更简单。如果你观察上面的实例代码，你恐怕已经猜到<code>Optional</code>内部实现是这样的<a href="https://blog.csdn.net/itchosen/article/details/77749152#c5" target="_blank" rel="noopener">5</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Simplified implementation of Swift&apos;s Optional</span><br><span class="line">enum MyOptional&lt;T&gt; &#123;</span><br><span class="line">  case Some(T)</span><br><span class="line">  case None</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有啥特别呢？注意枚举的关联值采用泛型参数<code>T</code>作为自身类型，这样可选类型构造任何你想要的返回值。</p>
<p>枚举可以拥有多个泛型参数。就拿熟知的<code>Either</code>类为例，它并非是<code>Swift</code>标准库中的一部分，而是实现于众多开源库以及<br>其他函数式编程语言，比如<strong>Haskell</strong>或<strong>F#</strong>。设计想法是这样的:相比较仅仅返回一个值或没有值(née Optional)，你更期望返回一个成功值或者一些反馈信息(比如错误值)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// The well-known either type is, of course, an enum that allows you to return either</span><br><span class="line">// value one (say, a successful value) or value two (say an error) from a function</span><br><span class="line">enum Either&lt;T1, T2&gt; &#123;</span><br><span class="line">  case Left(T1)</span><br><span class="line">  case Right(T2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，<code>Swift</code>中所有在<code>class</code>和<code>struct</code>中奏效的类型约束，在<code>enum</code>中同样适用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Totally nonsensical example. A bag that is either full (has an array with contents)</span><br><span class="line">// or empty.</span><br><span class="line">enum Bag&lt;T: SequenceType where T.Generator.Element==Equatable&gt; &#123;</span><br><span class="line">  case Empty</span><br><span class="line">  case Full(contents: T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归-间接-Indirect-类型"><a href="#递归-间接-Indirect-类型" class="headerlink" title="递归 / 间接(Indirect)类型"></a>递归 / 间接(Indirect)类型</h3><p>间接类型是 Swift 2.0 新增的一个类型。 它们允许将枚举中一个 case 的关联值再次定义为枚举。举个例子，假设我们想定义一个文件系统，用来表示文件以及包含文件的目录。如果将<em>文件</em>和<em>目录</em>定义为枚举的 case，则<em>目录</em> case 的关联值应该再包含一个<em>文件</em>的数组作为它的关联值。因为这是一个递归的操作，编译器需要对此进行一个特殊的准备。Swift 文档中是这么写的：</p>
<blockquote>
<p>枚举和 case 可以被标记为间接的(indrect)，这意味它们的关联值是被间接保存的，这允许我们定义递归的数据结构。</p>
</blockquote>
<p>所以，如果我们要定义 <code>FileNode</code> 的枚举，它应该会是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum FileNode &#123;</span><br><span class="line">  case File(name: String)</span><br><span class="line">  indirect case Folder(name: String, files: [FileNode])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的 <code>indrect</code> 关键字告诉编译器间接地处理这个枚举的 case。也可以对整个枚举类型使用这个关键字。<a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/" target="_blank" rel="noopener">作为例子，我们来定义一个二叉树</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">indirect enum Tree&lt;Element: Comparable&gt; &#123;</span><br><span class="line">    case Empty</span><br><span class="line">    case Node(Tree&lt;Element&gt;,Element,Tree&lt;Element&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个很强大的特性，可以让我们用非常简洁的方式来定义一个有着复杂关联的数据结构。</p>
<h3 id="使用自定义类型作为枚举的值"><a href="#使用自定义类型作为枚举的值" class="headerlink" title="使用自定义类型作为枚举的值"></a>使用自定义类型作为枚举的值</h3><p>如果我们忽略关联值，则枚举的值就只能是整型，浮点型，字符串和布尔类型。如果想要支持别的类型，则可以通过实现 <code>StringLiteralConvertible</code> 协议来完成，这可以让我们通过对字符串的序列化和反序列化来使枚举支持自定义类型。</p>
<p>作为一个例子，假设我们要定义一个枚举来保存不同的 iOS 设备的屏幕尺寸：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Devices: CGSize &#123;</span><br><span class="line">   case iPhone3GS = CGSize(width: 320, height: 480)</span><br><span class="line">   case iPhone5 = CGSize(width: 320, height: 568)</span><br><span class="line">   case iPhone6 = CGSize(width: 375, height: 667)</span><br><span class="line">   case iPhone6Plus = CGSize(width: 414, height: 736)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这段代码不能通过编译。因为 CGPoint 并不是一个常量，不能用来定义枚举的值。我们需要为想要支持的自定义类型增加一个扩展，让其实现 <code>StringLiteralConvertible</code> 协议。这个协议要求我们实现三个<em>构造方法</em>，这三个方法都需要使用一个<code>String</code>类型的参数，并且我们需要将这个字符串转换成我们需要的类型(此处是<code>CGSize</code>)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extension CGSize: StringLiteralConvertible &#123;</span><br><span class="line">    public init(stringLiteral value: String) &#123;</span><br><span class="line">    let size = CGSizeFromString(value)</span><br><span class="line">    self.init(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public init(extendedGraphemeClusterLiteral value: String) &#123;</span><br><span class="line">    let size = CGSizeFromString(value)</span><br><span class="line">    self.init(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public init(unicodeScalarLiteral value: String) &#123;</span><br><span class="line">    let size = CGSizeFromString(value)</span><br><span class="line">    self.init(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就可以来实现我们需要的枚举了，不过这里有一个缺点：初始化的值必须写成字符串形式，因为这就是我们定义的枚举需要接受的类型(记住，我们实现了 StringLiteralConvertible，因此<strong>String</strong>可以转化成<code>CGSize</code>类型)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Devices: CGSize &#123;</span><br><span class="line">   case iPhone3GS = &quot;&#123;320, 480&#125;&quot;</span><br><span class="line">   case iPhone5 = &quot;&#123;320, 568&#125;&quot;</span><br><span class="line">   case iPhone6 = &quot;&#123;375, 667&#125;&quot;</span><br><span class="line">   case iPhone6Plus = &quot;&#123;414, 736&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于，我们可以使用 CGPoint 类型的枚举了。需要注意的是，当要获取真实的 CGPoint 的值的时候，我们需要访问枚举的是 <code>rawValue</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = Devices.iPhone5</span><br><span class="line">let b = a.rawValue</span><br><span class="line">print(&quot;the phone size string is \(a), width is \(b.width), height is \(b.height)&quot;)</span><br><span class="line">// prints : the phone size string is iPhone5, width is 320.0, height is 568.0</span><br></pre></td></tr></table></figure>
<p>使用字符串序列化的形式，会让使用自定义类型的枚举比较困难，然而在某些特定的情况下，这也会给我们增加不少便利(比较使用<strong>NSColor</strong> / <strong>UIColor</strong>的时候)。不仅如此，我们完全可以对自己定义的类型使用这个方法。</p>
<h3 id="对枚举的关联值进行比较"><a href="#对枚举的关联值进行比较" class="headerlink" title="对枚举的关联值进行比较"></a>对枚举的关联值进行比较</h3><p>在通常情况下，枚举是很容易进行相等性判断的。一个简单的 <code>enum T { case a, b }</code> 实现默认支持相等性判断 <code>T.a == T.b, T.b != T.a</code></p>
<p>然而，一旦我们为枚举增加了关联值，Swift 就没有办法正确地为两个枚举进行相等性判断，需要我们自己实现 <code>==</code> 运行符。这并不是很困难：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Trade &#123;</span><br><span class="line">    case Buy(stock: String, amount: Int)</span><br><span class="line">    case Sell(stock: String, amount: Int)</span><br><span class="line">&#125;</span><br><span class="line">func ==(lhs: Trade, rhs: Trade) -&gt; Bool &#123;</span><br><span class="line">   switch (lhs, rhs) &#123;</span><br><span class="line">     case let (.Buy(stock1, amount1), .Buy(stock2, amount2))</span><br><span class="line">       where stock1 == stock2 &amp;&amp; amount1 == amount2:</span><br><span class="line">       return true</span><br><span class="line">     case let (.Sell(stock1, amount1), .Sell(stock2, amount2))</span><br><span class="line">       where stock1 == stock2 &amp;&amp; amount1 == amount2:</span><br><span class="line">       return true</span><br><span class="line">     default: return false</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们所见，我们通过 switch 语句对两个枚举的 case 进行判断，并且只有当它们的 case 是匹配的时候(比如 Buy 和 Buy)才对它们的真实关联值进行判断。</p>
<h3 id="自定义构造方法"><a href="#自定义构造方法" class="headerlink" title="自定义构造方法"></a>自定义构造方法</h3><p>在 <strong>静态方法</strong> 一节当中我们已经提到它们可以作为从不同数据构造枚举的方便形式。在之前的例子里也展示过，对出版社经常误用的苹果设备名返回正确的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum Device &#123; </span><br><span class="line">    case AppleWatch </span><br><span class="line">    static func fromSlang(term: String) -&gt; Device? &#123;</span><br><span class="line">      if term == &quot;iWatch&quot; &#123;</span><br><span class="line">      return .AppleWatch</span><br><span class="line">      &#125;</span><br><span class="line">      return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用自定义构造方法来替换静态方法。枚举与结构体和类的构造方法最大的不同在于，枚举的构造方法需要将隐式的 <code>self</code> 属性设置为正确的 case。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum Device &#123; </span><br><span class="line">    case AppleWatch </span><br><span class="line">    init?(term: String) &#123;</span><br><span class="line">      if term == &quot;iWatch&quot; &#123;</span><br><span class="line">      self = .AppleWatch</span><br><span class="line">      &#125;</span><br><span class="line">      return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用了可失败(failable)的构造方法。但是，普通的构造方法也可以工作得很好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum NumberCategory &#123;</span><br><span class="line">   case Small</span><br><span class="line">   case Medium</span><br><span class="line">   case Big</span><br><span class="line">   case Huge</span><br><span class="line">   init(number n: Int) &#123;</span><br><span class="line">    if n &lt; 10000 &#123; self = .Small &#125;</span><br><span class="line">    else if n &lt; 1000000 &#123; self = .Medium &#125;</span><br><span class="line">    else if n &lt; 100000000 &#123; self = .Big &#125;</span><br><span class="line">    else &#123; self = .Huge &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">let aNumber = NumberCategory(number: 100)</span><br><span class="line">print(aNumber)</span><br><span class="line">// prints: &quot;Small&quot;</span><br></pre></td></tr></table></figure>
<h3 id="对枚举的-case-进行迭代"><a href="#对枚举的-case-进行迭代" class="headerlink" title="对枚举的 case 进行迭代"></a>对枚举的 case 进行迭代</h3><p>一个特别经常被问到的问题就是如何对枚举中的 case 进行迭代。可惜的是，枚举并没有遵守<code>SequenceType</code>协议，因此没有一个官方的做法来对其进行迭代。取决于枚举的类型，对其进行迭代可能也简单，也有可能很困难。在<a href="http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type" target="_blank" rel="noopener">StackOverflow</a>上有一个很好的讨论贴。贴子里面讨论到的不同情况太多了，如果只在这里摘取一些会有片面性，而如果将全部情况都列出来，则会太多。</p>
<h3 id="对-Objective-C-的支持"><a href="#对-Objective-C-的支持" class="headerlink" title="对 Objective-C 的支持"></a>对 Objective-C 的支持</h3><p>基于整型的枚举，如 <code>enum Bit: Int { case Zero = 0; case One = 1 }</code> 可以通过 <code>@objc</code> 标识来将其桥接到 Objective-C 当中。然而，一旦使用整型之外的类型(如 <code>String</code>)或者开始使用<strong>关联值</strong>，我们就无法在 Objective-C 当中使用这些枚举了。</p>
<p>有一个名为<a href="http://nshint.io/blog/2015/10/07/easy-cast-with-_ObjectiveCBridgeable/?utm_campaign=Swift+Sandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_11" target="_blank" rel="noopener">_ObjectiveCBridgeable的隐藏协议</a>，可以让规范我们以定义合适的方法，如此一来，Swift 便可以正确地将枚举转成 Objective-C 类型，但我猜这个协议被隐藏起来一定是有原因的。然而，从理论上来讲，这个协议还是允许我们将枚举(包括其实枚举值)正确地桥接到 Objective-C 当中。</p>
<p>但是，我们并不一定非要使用上面提到的这个方法。为枚举添加两个方法，使用 <code>@objc</code> 定义一个替代类型，如此一来我们便可以自由地将枚举进行转换了，并且这种方式不需要遵守私有协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">enum Trade &#123;</span><br><span class="line">    case Buy(stock: String, amount: Int)</span><br><span class="line">    case Sell(stock: String, amount: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这个类型也可以定义在 Objective-C 的代码中</span><br><span class="line">@objc class OTrade: NSObject &#123;</span><br><span class="line">    var type: Int</span><br><span class="line">    var stock: String</span><br><span class="line">    var amount: Int</span><br><span class="line">    init(type: Int, stock: String, amount: Int) &#123;</span><br><span class="line">    self.type = type</span><br><span class="line">    self.stock = stock</span><br><span class="line">    self.amount = amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Trade  &#123;</span><br><span class="line"></span><br><span class="line">    func toObjc() -&gt; OTrade &#123;</span><br><span class="line">    switch self &#123;</span><br><span class="line">    case let .Buy(stock, amount):</span><br><span class="line">        return OTrade(type: 0, stock: stock, amount: amount)</span><br><span class="line">    case let .Sell(stock, amount):</span><br><span class="line">        return OTrade(type: 1, stock: stock, amount: amount)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static func fromObjc(source: OTrade) -&gt; Trade? &#123;</span><br><span class="line">    switch (source.type) &#123;</span><br><span class="line">    case 0: return Trade.Buy(stock: source.stock, amount: source.amount)</span><br><span class="line">    case 1: return Trade.Sell(stock: source.stock, amount: source.amount)</span><br><span class="line">    default: return nil</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有一个的缺点，我们需要将枚举映射为 Objective-C 中的 <code>NSObject</code> 基础类型(我们也可以直接使用 <code>NSDictionary</code>)，但是，当我们碰到一些确实<strong>需要</strong>在 Objective-C 当中获取有关联值的枚举时，这是一个可以使用的方法。</p>
<h3 id="枚举底层"><a href="#枚举底层" class="headerlink" title="枚举底层"></a>枚举底层</h3><p>Erica Sadun 写过一篇很流弊的<a href="http://ericasadun.com/2015/07/12/swift-enumerations-or-how-to-annoy-tom/" target="_blank" rel="noopener">关于枚举底层的博客</a>，涉及到枚举底层的方方面面。在生产代码中绝不应该使用到这些东西，但是学习一下还是相当有趣的。在这里，我准备只提到那篇博客中一条，如果想了解更多，请移步到原文：</p>
<blockquote>
<p>枚举通常都是一个字节长度。[…]如果你真的很傻很天真，你当然可以定义一个有成百上千个 case 的枚举，在这种情况下，取决于最少所需要的比特数，枚举可能占据两个字节或者更多。</p>
</blockquote>
<h2 id="Swift-标准库中的枚举"><a href="#Swift-标准库中的枚举" class="headerlink" title="Swift 标准库中的枚举"></a>Swift 标准库中的枚举</h2><p>在我们准备继续探索枚举在项目中的不同用例之前，先看一下在 Swift 标准库当中是如何使用枚举可能会更诱人，所以现在让我们先来看看。</p>
<p><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Bit_Enumeration/index.html#//apple_ref/swift/enum/s:OSs3Bit" target="_blank" rel="noopener">Bit</a> 这个枚举有两个值，<strong>One</strong> 和 <strong>Zero</strong>。它被作为 <code>CollectionOfOne&lt;T&gt;</code> 中的 <code>Index</code> 类型。</p>
<p><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_FloatingPointClassification_Enumeration/index.html#//apple_ref/swift/enumelt/FloatingPointClassification/s:FOSs27FloatingPointClassification12SignalingNaNFMS_S_" target="_blank" rel="noopener">FloatingPointClassification</a> 这个枚举定义了一系列 IEEE 754 可能的类别，比如 <code>NegativeInfinity</code>, <code>PositiveZero</code> 或 <code>SignalingNaN</code>。</p>
<p><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-AncestorRepresentation_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror22AncestorRepresentation" target="_blank" rel="noopener">Mirror.AncestorRepresentation</a> 和 <a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-DisplayStyle_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror12DisplayStyle" target="_blank" rel="noopener">Mirror.DisplayStyle</a> 这两个枚举被用在 Swift 反射 API 的上下文当中。</p>
<p><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Optional_Enumeration/index.html#//apple_ref/swift/enum/s:Sq" target="_blank" rel="noopener">Optional</a> 这个就不用多说了</p>
<p><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Process_Enumeration/index.html#//apple_ref/swift/enum/s:OSs7Process" target="_blank" rel="noopener">Process</a> 这个枚举包含了当前进程的命令行参数(<code>Process.argc</code>, <code>Process.arguments</code>)。这是一个相当有趣的枚举类型，因为在 Swift 1.0 当中，它是被作为一个结构体来实现的。</p>
<h2 id="实践用例"><a href="#实践用例" class="headerlink" title="实践用例"></a>实践用例</h2><p>我们已经在前面几个小节当中看过了许多有用的枚举类型。包括 <code>Optional</code>，<code>Either</code>, <code>FileNode</code> 还有二叉树。然而，还存在很多场合，使用枚举要胜过使用结构体和类。一般来讲，如果问题可以被分解为有限的不同类别，则使用枚举应该就是正确的选择。即使只有两种 case，这也是一个使用枚举的完美场景，正如 Optional 和 Either 类型所展示的。</p>
<p>以下列举了一些枚举类型在实战中的使用示例，可以用来点燃你的创造力。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>说到枚举的实践使用，当然少不了在 Swift 2.0 当中新推出的错误处理。标记为可抛出的函数可以抛出任何遵守了 <code>ErrorType</code> 空协议的类型。正如 Swift 官方文档中所写的：</p>
<blockquote>
<p>Swift 的枚举特别适用于构建一组相关的错误状态，可以通过关联值来为其增加额外的附加信息。</p>
</blockquote>
<p>作为一个示例，我们来看下流行的<a href="https://github.com/thoughtbot/Argo" target="_blank" rel="noopener">JSON解析框架 Argo</a>。当 JSON 解析失败的时候，它有可能是以下两种主要原因：</p>
<ol>
<li>JSON 数据缺少某些最终模型所需要的键(比如你的模型有一个 <code>username</code> 的属性，但是 JSON 中缺少了)</li>
<li>存在类型不匹配，比如说 <code>username</code> 需要的是 String 类型，而 JSON 中包含的是 <code>NSNull</code><a href="https://blog.csdn.net/itchosen/article/details/77749152#c6" target="_blank" rel="noopener">6</a>。</li>
</ol>
<p>除此之外，Argo 还为不包含在上述两个类别中的错误提供了自定义错误。它们的 <code>ErrorType</code> 枚举是类似这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum DecodeError: ErrorType &#123;</span><br><span class="line">  case TypeMismatch(expected: String, actual: String)</span><br><span class="line">  case MissingKey(String)</span><br><span class="line">  case Custom(String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 case 都有一个关联值用来包含关于错误的附加信息。</p>
<p>一个更加通用的用于完整 HTTP / REST API 错误处理的<code>ErrorType</code>应该是类似这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum APIError : ErrorType &#123;</span><br><span class="line">    // Can&apos;t connect to the server (maybe offline?)</span><br><span class="line">    case ConnectionError(error: NSError)</span><br><span class="line">    // The server responded with a non 200 status code</span><br><span class="line">    case ServerError(statusCode: Int, error: NSError)</span><br><span class="line">    // We got no data (0 bytes) back from the server</span><br><span class="line">    case NoDataError</span><br><span class="line">    // The server response can&apos;t be converted from JSON to a Dictionary</span><br><span class="line">    case JSONSerializationError(error: ErrorType)</span><br><span class="line">    // The Argo decoding Failed</span><br><span class="line">    case JSONMappingError(converstionError: DecodeError)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>ErrorType</code> 实现了完整的 REST 程序栈解析有可能出现的错误，包含了所有在解析结构体与类时会出现的错误。</p>
<p>如果你看得够仔细，会发现在<code>JSONMappingError</code>中，我们将<strong>Argo</strong>中的<code>DecodeError</code>封装到了我们的<code>APIError</code>类型当中，因为我们会用 Argo 来作实际的 JSON 解析。</p>
<p>更多关于<code>ErrorType</code>以及此种枚举类型的示例可以参看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>在 Swift 当中，有许多方法来构建观察模式。如果使用 <code>@objc</code> 兼容标记，则我们可以使用 <code>NSNotificationCenter</code> 或者 <strong>KVO</strong>。即使不用这个标记，<code>didSet</code>语法也可以很容易地实现简单的观察模式。在这里可以使用枚举，它可以使被观察者的变化更加清晰明了。设想我们要对一个集合进行观察。如果我们稍微思考一下就会发现这只有几种可能的情况：一个或多个项被插入，一个或多个项被删除，一个或多个项被更新。这听起来就是枚举可以完成的工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Change &#123;</span><br><span class="line">     case Insertion(items: [Item])</span><br><span class="line">     case Deletion(items: [Item])</span><br><span class="line">     case Update(items: [Item])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，观察对象就可以使用一个很简洁的方式来获取已经发生的事情的详细信息。这也可以通过为其增加 <strong>oldValue</strong> 和 <strong>newValue</strong> 的简单方法来扩展它的功能。</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>如果我们正在使用一个外部系统，而这个系统使用了状态码(或者错误码)来传递错误信息，类似 HTTP 状态码，这种情况下枚举就是一种很明显并且很好的方式来对信息进行封装<a href="https://blog.csdn.net/itchosen/article/details/77749152#c7" target="_blank" rel="noopener">7</a> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum HttpError: String &#123;</span><br><span class="line">  case Code400 = &quot;Bad Request&quot;</span><br><span class="line">  case Code401 = &quot;Unauthorized&quot;</span><br><span class="line">  case Code402 = &quot;Payment Required&quot;</span><br><span class="line">  case Code403 = &quot;Forbidden&quot;</span><br><span class="line">  case Code404 = &quot;Not Found&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果类型映射-Map-Result-Types"><a href="#结果类型映射-Map-Result-Types" class="headerlink" title="结果类型映射(Map Result Types)"></a>结果类型映射(Map Result Types)</h3><p>枚举也经常被用于将 JSON 解析后的结果映射成 Swift 的原生类型。这里有一个简短的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum JSON &#123;</span><br><span class="line">    case JSONString(Swift.String)</span><br><span class="line">    case JSONNumber(Double)</span><br><span class="line">    case JSONObject([String : JSONValue])</span><br><span class="line">    case JSONArray([JSONValue])</span><br><span class="line">    case JSONBool(Bool)</span><br><span class="line">    case JSONNull</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，如果我们解析了其它的东西，也可以使用这种方式将解析结果转化我们 Swift 的类型。</p>
<h3 id="UIKit-标识"><a href="#UIKit-标识" class="headerlink" title="UIKit 标识"></a>UIKit 标识</h3><p>枚举可以用来将字符串类型的重用标识或者 storyboard 标识映射为类型系统可以进行检查的类型。假设我们有一个拥有很多原型 Cell 的 UITableView：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum CellType: String &#123;</span><br><span class="line">    case ButtonValueCell = &quot;ButtonValueCell&quot;</span><br><span class="line">    case UnitEditCell = &quot;UnitEditCell&quot;</span><br><span class="line">    case LabelCell = &quot;LabelCell&quot;</span><br><span class="line">    case ResultLabelCell = &quot;ResultLabelCell&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><p>单位以及单位转换是另一个使用枚举的绝佳场合。可以将单位及其对应的转换率映射起来，然后添加方法来对单位进行自动的转换。以下是一个相当简单的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum Liquid: Float &#123;</span><br><span class="line">  case ml = 1.0</span><br><span class="line">  case l = 1000.0</span><br><span class="line">  func convert(amount amount: Float, to: Liquid) -&gt; Float &#123;</span><br><span class="line">      if self.rawValue &lt; to.rawValue &#123;</span><br><span class="line">     return (self.rawValue / to.rawValue) * amount</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">     return (self.rawValue * to.rawValue) * amount</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Convert liters to milliliters</span><br><span class="line">print (Liquid.l.convert(amount: 5, to: Liquid.ml))</span><br></pre></td></tr></table></figure>
<p>另一个示例是货币的转换。以及数学符号(比如角度与弧度)也可以从中受益。</p>
<h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>游戏也是枚举中的另一个相当好的用例，屏幕上的大多数实体都属于一个特定种族的类型(敌人，障碍，纹理，…)。相对于本地的 iOS 或者 Mac 应用，游戏更像是一个白板。即开发游戏我们可以使用全新的对象以及全新的关联创造一个全新的世界，而 iOS 或者 OSX 需要使用预定义的 UIButtons，UITableViews，UITableViewCells 或者 NSStackView.</p>
<p>不仅如此，由于枚举可以遵守协议，我们可以利用协议扩展和基于协议的编程为不同为游戏定义的枚举增加功能。这里是一个用来展示这种层级的的简短示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum FlyingBeast &#123; case Dragon, Hippogriff, Gargoyle &#125;</span><br><span class="line">enum Horde &#123; case Ork, Troll &#125;</span><br><span class="line">enum Player &#123; case Mage, Warrior, Barbarian &#125;</span><br><span class="line">enum NPC &#123; case Vendor, Blacksmith &#125;</span><br><span class="line">enum Element &#123; case Tree, Fence, Stone &#125;</span><br><span class="line"></span><br><span class="line">protocol Hurtable &#123;&#125;</span><br><span class="line">protocol Killable &#123;&#125;</span><br><span class="line">protocol Flying &#123;&#125;</span><br><span class="line">protocol Attacking &#123;&#125;</span><br><span class="line">protocol Obstacle &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension FlyingBeast: Hurtable, Killable, Flying, Attacking &#123;&#125;</span><br><span class="line">extension Horde: Hurtable, Killable, Attacking &#123;&#125;</span><br><span class="line">extension Player: Hurtable, Obstacle &#123;&#125;</span><br><span class="line">extension NPC: Hurtable &#123;&#125;</span><br><span class="line">extension Element: Obstacle &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串类型化"><a href="#字符串类型化" class="headerlink" title="字符串类型化"></a>字符串类型化</h3><p>在一个稍微大一点的 Xcode 项目中，我们很快就会有一大堆通过字符串来访问的资源。在前面的小节中，我们已经提过重用标识和 storyboard 的标识，但是除了这两样，还存在很多资源：图像，Segues，Nibs，字体以及其它资源。通常情况下，这些资源都可以分成不同的集合。如果是这样的话，一个类型化的字符串会是一个让编译器帮我们进行类型检查的好方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum DetailViewImages: String &#123;</span><br><span class="line">  case Background = &quot;bg1.png&quot;</span><br><span class="line">  case Sidebar = &quot;sbg.png&quot;</span><br><span class="line">  case ActionButton1 = &quot;btn1_1.png&quot;</span><br><span class="line">  case ActionButton2 = &quot;btn2_1.png&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 iOS 开发者，<a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a>这个第三方库可以为以上提到的情况自动生成结构体。但是有些时候你可能需要有更多的控制(或者你可能是一个Mac开发者<a href="https://blog.csdn.net/itchosen/article/details/77749152#c8" target="_blank" rel="noopener">8</a>)。</p>
<h3 id="API-端点"><a href="#API-端点" class="headerlink" title="API 端点"></a>API 端点</h3><p>Rest API 是枚举的绝佳用例。它们都是分组的，它们都是有限的 API 集合，并且它们也可能会有附加的查询或者命名的参数，而这可以使用关联值来实现。</p>
<p>这里有个 <a href="https://instagram.com/developer/endpoints/media/" target="_blank" rel="noopener">Instagram API</a> 的简化版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum Instagram &#123;</span><br><span class="line">  enum Media &#123;</span><br><span class="line">    case Popular</span><br><span class="line">    case Shortcode(id: String)</span><br><span class="line">    case Search(lat: Float, min_timestamp: Int, lng: Float, max_timestamp: Int, distance: Int)</span><br><span class="line">  &#125;</span><br><span class="line">  enum Users &#123;</span><br><span class="line">    case User(id: String)</span><br><span class="line">    case Feed</span><br><span class="line">    case Recent(id: String)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Ash Furrow的<strong>Moya</strong>框架</a>就是基本这个思想，使用枚举对 rest 端点进行映射。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>Airspeed Velocity有一篇<a href="http://airspeedvelocity.net/tag/swift/" target="_blank" rel="noopener">极好的文章</a>说明了如何使用枚举来实现一个链表。那篇文章中的大多数代码都超出了枚举的知识，并涉及到了大量其它有趣的主题<a href="https://blog.csdn.net/itchosen/article/details/77749152#c9" target="_blank" rel="noopener">9</a>，但是，链表最基本的定义是类似这样的(我对其进行了一些简化)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum List &#123;</span><br><span class="line">    case End</span><br><span class="line">    indirect case Node(Int, next: List)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个节点(Node) case 都指向了下一个 case， 通过使用枚举而非其它类型，我们可以避免使用一个可选的 next 类型以用来表示链表的结束。</p>
<p>Airspeed Velocity 还写过一篇超赞的博客，关于如何使用 Swift 的间接枚举类型来实现红黑树，所以如果你已经阅读过关于链表的博客，你可能想继续阅读<a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/" target="_blank" rel="noopener">这篇关于红黑树的博客</a>。</p>
<h3 id="设置字典-Setting-Dictionaries"><a href="#设置字典-Setting-Dictionaries" class="headerlink" title="设置字典(Setting Dictionaries)"></a>设置字典(Setting Dictionaries)</h3><p>这是 Erica Sadun 提出的<a href="http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign=Swift+Sandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12" target="_blank" rel="noopener">非常非常机智的解决方案</a>。简单来讲，就是任何我们需要用一个属性的字典来对一个项进行设置的时候，都应该使用一系列有关联值的枚举来替代。使用这方法，类型检查系统可以确保配置的值都是正确的类型。</p>
<p><a href="http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign=Swift+Sandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12" target="_blank" rel="noopener">关于更多的细节，以及合适的例子，可以阅读下她的文章</a>。</p>
<h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p>与之前类似，我将会用一系列枚举的局限性来结束本篇文章。</p>
<h3 id="提取关联值"><a href="#提取关联值" class="headerlink" title="提取关联值"></a>提取关联值</h3><p>David Owens写过一篇<a href="http://owensd.io/2015/09/15/associated-enum-cases-as-types.html" target="_blank" rel="noopener">文章</a>，他觉得当前的关联值提取方式是很笨重的。我墙裂推荐你去看一下他的原文，在这里我对它的要旨进行下说明：为了从一个枚举中获取关联值，我们必须使用模式匹配。然而，关联值就是关联在特定枚举 case 的高效元组。而元组是可以使用更简单的方式来获取它内部值，即 <code>.keyword 或者 .0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Enums</span><br><span class="line">enum Ex &#123; case Mode(ab: Int, cd: Int) &#125;</span><br><span class="line">if case Ex.Mode(let ab, let cd) = Ex.Mode(ab: 4, cd: 5) &#123;</span><br><span class="line">    print(ab)</span><br><span class="line">&#125;</span><br><span class="line">// vs tuples:</span><br><span class="line">let tp = (ab: 4, cd: 5)</span><br><span class="line">print(tp.ab)</span><br></pre></td></tr></table></figure>
<p>如果你也同样觉得我们应该使用相同的方法来对枚举进行解构(deconstruct)，这里有个 rdar: <a href="http://openradar.me/22704262" target="_blank" rel="noopener">rdar://22704262</a> (译者注：一开始我不明白 rdar 是啥意思，后来我 google 了下，如果你也有兴趣，也可以自己去搜索一下)</p>
<h3 id="相等性"><a href="#相等性" class="headerlink" title="相等性"></a>相等性</h3><p>拥有关联值的枚举没有遵守 <code>equatable</code> 协议。这是一个遗憾，因为它为很多事情增加了不必要的复杂和麻烦。深层的原因可能是因为关联值的底层使用是使用了元组，而元组并没有遵守 <code>equatable</code> 协议。然而，对于限定的 case 子集，如果这些关联值的类型都遵守了 <code>equatable</code> 类型，我认为编译器应该默认为其生成 <code>equatable</code> 扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Int 和 String 是可判等的, 所以 Mode 应该也是可判等的</span><br><span class="line">enum Ex &#123; case Mode(ab: Int, cd: String) &#125;</span><br><span class="line"></span><br><span class="line">// Swift 应该能够自动生成这个函数</span><br><span class="line">func == (lhs: Ex.Mode, rhs: Ex.Mode) -&gt; Bool &#123;</span><br><span class="line">    switch (lhs, rhs) &#123;</span><br><span class="line">       case (.Mode(let a, let b), .Mode(let c, let d)):</span><br><span class="line">       return a == c &amp;&amp; b == d</span><br><span class="line">       default:</span><br><span class="line">       return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元组-Tuples"><a href="#元组-Tuples" class="headerlink" title="元组(Tuples)"></a>元组(Tuples)</h3><p>最大的问题就是对<a href="http://appventure.me/2015/07/19/tuples-swift-advanced-usage-best-practices/" target="_blank" rel="noopener">元组的支持</a>。我喜欢使用元组，它们可以使很多事情变得更简单，但是他们目前还处于无文档状态并且在很多场合都无法使用。在枚举当中，我们无法使用元组作为枚举的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Devices: (intro: Int, name: String) &#123;</span><br><span class="line">  case iPhone = (intro: 2007, name: &quot;iPhone&quot;)</span><br><span class="line">  case AppleTV = (intro: 2006, name: &quot;Apple TV&quot;)</span><br><span class="line">  case AppleWatch = (intro: 2014, name: &quot;Apple Watch&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这似乎看起来并不是一个最好的示例，但是我们一旦开始使用枚举，就会经常陷入到需要用到类似上面这个示例的情形中。</p>
<h3 id="迭代枚举的所有case"><a href="#迭代枚举的所有case" class="headerlink" title="迭代枚举的所有case"></a>迭代枚举的所有case</h3><p>这个我们已经在前面讨论过了。目前还没有一个很好的方法来获得枚举中的所有 case 的集合以使我们可以对其进行迭代。</p>
<h3 id="默认关联值"><a href="#默认关联值" class="headerlink" title="默认关联值"></a>默认关联值</h3><p>另一个会碰到的事是枚举的关联值总是类型，但是我们却无法为这些类型指定默认值。假设有这样一种情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Characters &#123;</span><br><span class="line">  case Mage(health: Int = 70, magic: Int = 100, strength: Int = 30)</span><br><span class="line">  case Warrior(health: Int = 100, magic: Int = 0, strength: Int = 100)</span><br><span class="line">  case Neophyte(health: Int = 50, magic: Int = 20, strength: Int = 80)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们依然可以使用不同的值创建新的 case，但是角色的默认设置依然会被映射。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift 编程中的尾递归和蹦床]]></title>
      <url>/2018/05/11/Swift%20%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92%E5%92%8C%E8%B9%A6%E5%BA%8A/</url>
      <content type="html"><![CDATA[<h1 id="Swift-编程中的尾递归和蹦床【译】"><a href="#Swift-编程中的尾递归和蹦床【译】" class="headerlink" title="Swift 编程中的尾递归和蹦床【译】"></a><a href="http://www.cnblogs.com/ftchen/p/5542149.html" target="_blank" rel="noopener">Swift 编程中的尾递归和蹦床【译】</a></h1><p><img src="https://segmentfault.com/image?src=https://www.uraimo.com/imgs/trampoline.png&amp;objectId=1190000005364643&amp;token=3102852c142958cf6206be586fc4f7f5" alt="img"></p>
<p>通过递归来实现算法往往比<a href="http://c2.com/cgi/wiki?RecursionVsLoop" target="_blank" rel="noopener">基于循环</a>的实现来得更加清晰，但递归的实现会因为每次方法调用的时候都需要分配和管理<a href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch10s07.html" target="_blank" rel="noopener">栈帧</a>而导致额外的开销，这会导致递归的实现很慢而且有可能很快就耗尽了栈空间(也就是栈溢出)。<br><a id="more"></a><br>为了避免栈溢出，一个推荐的做法是把程序重写成<em>尾递归</em>的形式来利用一些编译器的尾递归优化的功能来避免溢出。</p>
<p>但我们不仅会想，普通递归和尾递归的区别到底是什么？编译器的尾递归优化到底是做了怎样的事情？</p>
<p>尾递归和普通的递归不同之处在于，尾递归函数的返回值是简单的递归调用，没有任何额外的运算。实际运算的过程是通过一个累加器变量一路传递到后继的调用中，直到递归执行完毕。</p>
<p>上面的定义可能不太好懂，下一节会有一个例子来提供更清晰的解释。现在你唯一需要知道的就是，有一种特殊的递归可以被编译器优化成更高效的基于循环的实现，不会受到栈大小的影响。</p>
<p>但是在 Swift 里，<em>我们不能指望</em>编译器会在所有情况下都<a href="https://twitter.com/jl_hfl/status/551168151497748480" target="_blank" rel="noopener">执行尾递归优化</a>。</p>
<p>这个缺陷之前已经在 <a href="https://www.natashatherobot.com/functional-swift-tail-recursion/" target="_blank" rel="noopener">Natasha 的博客</a> 被讨论过，现在已经有人为此做了一些工作并提交了一份<a href="https://github.com/apple/swift-evolution/pull/103/files" target="_blank" rel="noopener">提案</a>。提案主要提出了添加一些属性来让优化器的行为更加可验证，并允许明确地指定哪些尾递归是可以被优化的(如果没有被优化，则应该抛出异常。)</p>
<p>这篇文章我们会讲解如何使用蹦床 (trampolines) 机制来解决 Swift 尾递归优化方面的不足，同时会给出一些递归的替代方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">译者注：为什么叫做蹦床呢？是因为蹦床机制本质上就是把递归调用转化为循环调用。递归会先连续的压栈(递归调用)，返回的时候再连续地出栈。而蹦床的话，每次执行调用压栈一次(函数调用),然后马上出栈(函数返回)。循环往复这个过程。如果把栈比作蹦床的话，这个过程就像在跳蹦床一样。落下就是压栈，弹起就是出栈。交替进行。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>可以到 GitHub 或者这里获得本文所使用的 playground 文件</em></p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title="                                                                                                                                                                                                                                                                                                                 "></a><a href="http://blogcn.bzgpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzzpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzzpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpbt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpbt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzspt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzspt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpct.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpct.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpgt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpgt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpft.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpft.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpht.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpht.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpkt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpkt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpmt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpmt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzptt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzptt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpst.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpst.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpdt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpdt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpxt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpxt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzwpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzwpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzypt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzypt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpwt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpwt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bzpyt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bzpyt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfdpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfdpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfgpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfgpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bffpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bffpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfmpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfmpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfspt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfspt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfwpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfwpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfypt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfypt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfxpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfxpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfzpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfzpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfjpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfjpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpbt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpbt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpct.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpct.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bftpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bftpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpdt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpdt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpft.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpft.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfkpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfkpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpmt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpmt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfptt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfptt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpgt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpgt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpht.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpht.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpyt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpyt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpxt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpxt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpst.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpst.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfppt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfppt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgdpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgdpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpkt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpkt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgfpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgfpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgcpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgcpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bghpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bghpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bggpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bggpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpwt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpwt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgspt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgspt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bfpzt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bfpzt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgkpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgkpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgzpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgzpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgtpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgtpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgpbt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgpbt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgxpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgxpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgwpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgwpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgpct.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgpct.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgpdt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgpdt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgmpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgmpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgpgt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgpgt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgpht.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgpht.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgpft.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgpft.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgpkt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgpkt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgpst.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgpst.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgpyt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgpyt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgptt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgptt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgppt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgppt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgpmt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgpmt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bhbpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bhbpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bgpwt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bgpwt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bhcpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bhcpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bhgpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bhgpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bhdpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bhdpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bhhpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bhhpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bhjpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bhjpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://bhkpt.cn/ft.html" target="_blank" rel="noopener"> </a> <a href="http://blogcn.bhkpt.cn/ft.html" target="_blank" rel="noopener"> </a></h2><h2 id="用递归计算三角数"><a href="#用递归计算三角数" class="headerlink" title="用递归计算三角数"></a>用递归计算三角数</h2><p>让我们来看一个用递归的方式来计算第 n 个<a href="https://en.wikipedia.org/wiki/Triangular_number" target="_blank" rel="noopener">三角形数</a>的算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func tri(n:Int)-&gt;Int&#123;</span><br><span class="line">    if n &lt;= 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    return n+tri(n-1)</span><br><span class="line">&#125;</span><br><span class="line">tri(300) //45150</span><br></pre></td></tr></table></figure>
<p>在这个简单的递归的例子中，递归调用的执行结果和参数相加就是结果。我们最初的 <code>tri(300)</code> 的结果就是对所有这样的数，通过递归链式地求和。</p>
<p>把上述代码改为尾递归的形式，我们添加一个累加器变量来把累加值传递到下一层调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func ttri(n:Int, acc:Int=0)-&gt;Int &#123;</span><br><span class="line">    if n&lt;1 &#123;</span><br><span class="line">        return acc</span><br><span class="line">    &#125;</span><br><span class="line">    return ttri(n-1,acc:acc+n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ttri(300) //45150</span><br></pre></td></tr></table></figure>
<p>注意上述算法中结果是如何通过累加器实现的，最后一步就是简单的返回累加值来完整整个计算过程。</p>
<p>但是当输入参数很大时，上面两个方案都会 crash。我们来看一下如何用蹦床算法来解决这个问题。</p>
<h2 id="蹦床"><a href="#蹦床" class="headerlink" title="蹦床"></a>蹦床</h2><p>蹦床背后的原理其实很简单。</p>
<p>蹦床形式的基本定义是循环的执行一个函数，这个函数要么返回的是一个用于下一次执行函数(以 <a href="https://en.wikipedia.org/wiki/Thunk" target="_blank" rel="noopener">thunk</a> 或者“连续”的形式，具体说就是一个数据结构，其中包含用于某次方法调用所必须的信息)， 要么返回的是一个其他类型的值(在这个例子中就是累加值)来标识迭代的结束。</p>
<p>如果我们要用蹦床来顺序的执行我们的尾递归函数，我们需要对其进行一些简单的修改，修改成<a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="_blank" rel="noopener">连续传递的形式 (continuation-passing style)</a>.</p>
<blockquote>
<p>更新</p>
<p>像 <a href="https://twitter.com/oisdk" target="_blank" rel="noopener">oisdk</a> 所说，我们在下面修改后的函数只是有一点点像真正的 CPS(译注：也就是上面提到的连续传递形式)。</p>
<p>在这里，闭包可以让你通过模拟延迟计算 (Lazy Evaluation) 来实现一种伪尾递归优化。<em>在连续传递形式中，你将“连续”以函数的额外参数的形式传到递归函数中，“连续”定义了函数主体执行完毕以后该做什么（译注：本质上来说，“连续”也是一个函数）。简单的说，先执行函数主体，然后执行“连续”的部分，通常在最开始，你传入的是一个元函数。这个机制可以让你把普通递归函数变换为尾递归函数。但显然，Swift 并不保证进行尾递归优化，所以其实这个机制也没什么用处。</em></p>
<p>先不管这些。下面是三角数计算的 CPS 形式：</p>
<p>func triCont(n: Int, cont: Int -&gt; Int) -&gt; Int {<br>return n &lt;= 1 ? cont(1) : triCont(n-1) { r in cont(r+n) }<br>}</p>
<p>func id&lt;A&gt;(x: A) -&gt; A { return x }</p>
<p>triCont(10, cont: id) // 55</p>
<p>感谢棒棒哒的解释。</p>
</blockquote>
<p>和直接执行递归调用不同的是，我们的 <code>ttri</code> 函数将会返回一个封装了<em>真实的调用</em>的对象，并且一旦到达执行应该结束的点，我们会返回一个包含累加结果的哨兵值，来标识执行结束。</p>
<p>我们从定义一个 <code>Result</code> 枚举来表示我们修改后的递归函数可能返回的值：<code>.Done</code> 表示递归执行完毕，并且其中包含最后的累加值。<code>.Call</code> 会包含下一步要执行的方法的闭包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;A&gt;&#123;</span><br><span class="line">    case Done(A)</span><br><span class="line">    case Call(()-&gt;Result&lt;A&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们就可以来定义新的函数，包括一个修改版的 <code>ttri</code> 以及一些实现蹦床机制的代码。最后一个部分一般放在单独的函数中。但是在本例里把都放到一起，为了更加可读：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func tritr(n:Int)-&gt;Int &#123;</span><br><span class="line">    func ttri(n:Int, acc:Int=0)-&gt;Result&lt;Int&gt; &#123;</span><br><span class="line">        if n&lt;1 &#123;</span><br><span class="line">            return .Done(acc)</span><br><span class="line">        &#125;</span><br><span class="line">        return .Call(&#123;</span><br><span class="line">            ()-&gt;Result&lt;Int&gt; in</span><br><span class="line">            return ttri(n-1,acc: acc+n)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Trampoline section</span><br><span class="line">    let acc = 0</span><br><span class="line">    var res = ttri(n,acc:acc)</span><br><span class="line">    </span><br><span class="line">    while true &#123;</span><br><span class="line">        switch res &#123;</span><br><span class="line">        case let .Done(accu):</span><br><span class="line">            return accu</span><br><span class="line">        case let .Call(f):</span><br><span class="line">            res = f()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tritr(300)</span><br></pre></td></tr></table></figure>
<p>仔细想一下上面的步骤，实现蹦床的部分也就不难理解了。</p>
<p>在初始调用 <code>ttri</code> 方法启动蹦床之后，<code>.Call</code> 枚举中包含的函数就被顺序的执行，累加值也在每一步中被更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return .Call(&#123;</span><br><span class="line">    ()-&gt;Result&lt;Int&gt; in</span><br><span class="line">    return ttri(n-1,acc: acc+n)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>虽然代码不一样了，但是行为仍然和我们最开始的递归版本是一样的。</p>
<p>一旦计算完成，<code>ttri</code> 函数就返回一个包含最终结果的 <code>.Done</code> 枚举。</p>
<p>虽然这个实现比最开始的版本要慢，因为所有代码都需要操作蹦床。但这个版本已经解决了栈溢出这个最大的问题，我们现在已经可以计算任意大小三角数了，直到超过整数的限制。</p>
<p>建议说。<code>ttri</code>函数的实现可以通过一个快被遗忘的属性修饰符 <code>@autoclosure</code> 来简化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func call&lt;A&gt;(@autoclosure(escaping) c: () -&gt; Result&lt;A&gt;) -&gt; Result&lt;A&gt; &#123;</span><br><span class="line">    return .Call(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ttri(n: Int, acc:Int=1) -&gt; Result&lt;Int&gt; &#123;</span><br><span class="line">    return n &lt;= 1 ? .Done(acc) : call(tri(n-1, acc: acc+n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们继续之前，再多说一点例子的问题。把代码包在 <code>while true</code> 中并不是一个好习惯，一个更好的循环检查应该是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while case .Call(_) = res &#123;</span><br><span class="line">    switch res &#123;</span><br><span class="line">    case let .Done(accu):</span><br><span class="line">        return accu</span><br><span class="line">    case let .Call(f):</span><br><span class="line">        res = f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">if case let .Done(ac) = res &#123;</span><br><span class="line">    return ac</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">return -1</span><br></pre></td></tr></table></figure>
<p>当然还有更好的做法，因为我们用枚举来关联值，我们应该针对该枚举实现一个比较运算符并在循环的开头来检查是否完成。</p>
<p>现在，蹦床的基本原理已经解释了，我们现在可以构建一个通用的函数来实现：给定一个返回 <code>.Result</code> 枚举的函数，返回一个闭包来在蹦床中执行原始函数。用该函数可以将执行细节封装起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func withTrampoline&lt;V,A&gt;(f:(V,A)-&gt;Result&lt;A&gt;) -&gt; ((V,A)-&gt;A)&#123;</span><br><span class="line">    return &#123; (value:V,accumulator:A)-&gt;A in</span><br><span class="line">        var res = f(value,accumulator)</span><br><span class="line">        </span><br><span class="line">        while true &#123;</span><br><span class="line">            switch res &#123;</span><br><span class="line">            case let .Done(accu):</span><br><span class="line">                return accu</span><br><span class="line">            case let .Call(f):</span><br><span class="line">                res = f()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们返回的闭包的主体基本上就是我们在之前例子中的蹦床部分，<code>withTrampoline</code> 函数接收一个类型为 <code>(V,A)-&gt;Result&lt;A&gt;</code> 函数作为参数。这个函数之前我们已经实现了。还有一点和之前的版本显著的不同的地方是，我们不能初始化泛型累加器 <code>A</code> 因为我们并不知道它具体的类型，所以我们将它暴露为我们返回的函数的参数，这里算一点小瑕疵。</p>
<p>下面就用一下我们刚才定义的通用函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fin: (n:Int, a:Int) -&gt; Result&lt;Int&gt; = &#123;_,_ in .Done(0)&#125;</span><br><span class="line">fin = &#123; (n:Int, a:Int) -&gt; Result&lt;Int&gt; in</span><br><span class="line">    if n&lt;1 &#123;</span><br><span class="line">        return .Done(a)</span><br><span class="line">    &#125;</span><br><span class="line">    return .Call(&#123;</span><br><span class="line">        ()-&gt;Result&lt;Int&gt; in</span><br><span class="line">        return fin(n: n-1,a: a+n)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let f = withTrampoline(fin)</span><br><span class="line"></span><br><span class="line">f(30,0)</span><br></pre></td></tr></table></figure>
<p>这代码可能比你想象的要长一点。</p>
<p>因为我们在闭包内部需要使用当前的函数，所以我们必须在定义真正的闭包之前先定义一个该闭包类型的傀儡实现，来使得在闭包实现中对自身的引用合法化。</p>
<p>如果不用傀儡实现，而是直接声明 <code>fin</code> 闭包，会得到一个<em>变量在它初始化过程中被使用的错误</em>。 如果你喜欢冒险，可以尝试使用 <a href="https://stackoverflow.com/questions/24717460/cant-make-weak-reference-to-closure-in-swift" target="_blank" rel="noopener">Z 组合子</a> 来替换这个丑陋的解决办法。</p>
<p>但是如果去掉传统的蹦床设计，我们可以简化 <code>Result</code> 枚举并且在蹦床内部来跟踪函数的执行，而不是把函数当做值存在枚举中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">enum Result2&lt;V,A&gt;&#123;</span><br><span class="line">    case Done(A)</span><br><span class="line">    case Call(V, A)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func withTrampoline2&lt;V,A&gt;(f:(V,A)-&gt;Result2&lt;V,A&gt;) -&gt; ((V,A)-&gt;A)&#123;</span><br><span class="line">    return &#123; (value:V,accumulator:A)-&gt;A in</span><br><span class="line">        var res = f(value,accumulator)</span><br><span class="line">        </span><br><span class="line">        while true &#123;</span><br><span class="line">            switch res &#123;</span><br><span class="line">            case let .Done(accu):</span><br><span class="line">                return accu</span><br><span class="line">            case let .Call(num, accu):</span><br><span class="line">                res = f(num,accu)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let f2 = withTrampoline2 &#123; (n:Int, a:Int) -&gt; Result2&lt;Int, Int&gt; in</span><br><span class="line">    if n&lt;1 &#123;</span><br><span class="line">        return .Done(a)</span><br><span class="line">    &#125;</span><br><span class="line">    return .Call(n-1,a+n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2(30,0)</span><br></pre></td></tr></table></figure>
<p>这样看起来更清晰，更紧凑。</p>
<blockquote>
<p><em>可以到 Github 或者这里获得本文所使用的 playground 文件</em></p>
</blockquote>
<h2 id="Swift-中递归的替代方案"><a href="#Swift-中递归的替代方案" class="headerlink" title="Swift 中递归的替代方案"></a>Swift 中递归的替代方案</h2><p>如果你有阅读过一些关于 <a href="https://www.uraimo.com/category/functional" target="_blank" rel="noopener">Swift 函数式编程的文章</a>的话那你应该知道 Swift 提供了一些有用的特性来替代递归来解决一些一般会使用递归来解决的问题。</p>
<p>比如，三角形数可以通过<a href="https://www.uraimo.com/2016/01/06/10-Swift-One-Liners-To-Impress-Your-Friends/" target="_blank" rel="noopener">一行简单的函数式代码</a>计算出来，使用 reduce:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1...30).reduce(0,combine:+) //465</span><br></pre></td></tr></table></figure>
<p>或者我们可以创建一个 <a href="https://www.uraimo.com/2015/11/12/experimenting-with-swift-2-sequencetype-generatortype/" target="_blank" rel="noopener">Sequence 或 Generator</a> 来生成所有可能的三角形数的序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TriangularSequence :SequenceType &#123;</span><br><span class="line">    func generate() -&gt; AnyGenerator&lt;Int&gt; &#123;</span><br><span class="line">        var i = 0</span><br><span class="line">        var acc = 0</span><br><span class="line">        return AnyGenerator(body:&#123;</span><br><span class="line">            print(&quot;# Returning &quot;+String(i))</span><br><span class="line">            i=i+1</span><br><span class="line">            acc = acc + i</span><br><span class="line">            return acc</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fs = TriangularSequence().generate()</span><br><span class="line"></span><br><span class="line">for i in 1...30 &#123;</span><br><span class="line">    print(fs.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是我们可以用 Swift 实现的两种可能的替代方案。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之责任链模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">// 责任链模式</span><br><span class="line">// 百度百科：在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</span><br><span class="line">// 设计模式分类：行为型模式</span><br><span class="line"></span><br><span class="line">/// 钱堆</span><br><span class="line">class MoneyPile &#123;</span><br><span class="line">    /// 价值</span><br><span class="line">    let value: Int</span><br><span class="line">    /// 数量</span><br><span class="line">    var quantity: Int</span><br><span class="line">    /// 下一堆</span><br><span class="line">    var nextPile: MoneyPile?</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     初始化</span><br><span class="line">     </span><br><span class="line">     - parameter value:    价值</span><br><span class="line">     - parameter quantity: 数量</span><br><span class="line">     - parameter nextPile: 下一堆</span><br><span class="line">     </span><br><span class="line">     - returns: 堆对象</span><br><span class="line">     */</span><br><span class="line">    init(value: Int, quantity: Int, nextPile: MoneyPile?) &#123;</span><br><span class="line">        self.value = value</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.nextPile = nextPile</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     判断是否可以提取</span><br><span class="line">     </span><br><span class="line">     - parameter value: 提取值</span><br><span class="line">     </span><br><span class="line">     - returns: true 可以， false 不行</span><br><span class="line">     */</span><br><span class="line">    func canWithdraw(value: Int) -&gt; Bool &#123;</span><br><span class="line">        </span><br><span class="line">        var v = value</span><br><span class="line">        </span><br><span class="line">        func canTakeSomeBill(want: Int) -&gt; Bool &#123;</span><br><span class="line">            return (want / self.value) &gt; 0</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        var q = self.quantity</span><br><span class="line">        </span><br><span class="line">        while canTakeSomeBill(v) &#123;</span><br><span class="line">            </span><br><span class="line">            if q == 0 &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            v -= self.value</span><br><span class="line">            q -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if v == 0 &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125; else if let next = self.nextPile &#123;</span><br><span class="line">            return next.canWithdraw(v)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// ATM取款机</span><br><span class="line">class ATM &#123;</span><br><span class="line">        /// 100元堆</span><br><span class="line">    private var hundred: MoneyPile</span><br><span class="line">        /// 50元堆</span><br><span class="line">    private var fifty: MoneyPile</span><br><span class="line">        /// 20元堆</span><br><span class="line">    private var twenty: MoneyPile</span><br><span class="line">        /// 10元堆</span><br><span class="line">    private var ten: MoneyPile</span><br><span class="line">    </span><br><span class="line">    private var startPile: MoneyPile &#123;</span><br><span class="line">        return self.hundred</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     初始化</span><br><span class="line">     </span><br><span class="line">     - parameter hundred: 100元堆</span><br><span class="line">     - parameter fifty:   50元堆</span><br><span class="line">     - parameter twenty:  20元堆</span><br><span class="line">     - parameter ten:     10元堆</span><br><span class="line">     </span><br><span class="line">     - returns: atm对象</span><br><span class="line">     */</span><br><span class="line">    init(hundred: MoneyPile,</span><br><span class="line">         fifty: MoneyPile,</span><br><span class="line">         twenty: MoneyPile,</span><br><span class="line">         ten: MoneyPile) &#123;</span><br><span class="line">        </span><br><span class="line">        self.hundred = hundred</span><br><span class="line">        self.fifty = fifty</span><br><span class="line">        self.twenty = twenty</span><br><span class="line">        self.ten = ten</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     判断是否可以提取</span><br><span class="line">     </span><br><span class="line">     - parameter value: 提取值</span><br><span class="line">     </span><br><span class="line">     - returns: true 可以， false 不行</span><br><span class="line">     */</span><br><span class="line">    func canWithdraw(value: Int) -&gt; String &#123;</span><br><span class="line">        return &quot;Can withdraw: \(self.startPile.canWithdraw(value))&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一些钱堆， 并将它们链接在一起</span><br><span class="line">let ten = MoneyPile(value: 10, quantity: 6, nextPile: nil)</span><br><span class="line">let twenty = MoneyPile(value: 20, quantity: 2, nextPile: ten)</span><br><span class="line">let fifty = MoneyPile(value: 50, quantity: 2, nextPile: twenty)</span><br><span class="line">let hundred = MoneyPile(value: 100, quantity: 1, nextPile: fifty)</span><br><span class="line"></span><br><span class="line">// 创建atm对象</span><br><span class="line">var atm = ATM(hundred: hundred, fifty: fifty, twenty: twenty, ten: ten)</span><br><span class="line"></span><br><span class="line">atm.canWithdraw(310) // false atm只有300</span><br><span class="line">atm.canWithdraw(100) // true 100*1</span><br><span class="line">atm.canWithdraw(165) // false atm没有面值5</span><br><span class="line">atm.canWithdraw(30)  // true 20*1 + 10*1</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之命令模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 命令模式</span><br><span class="line">// 百度百科：一组行为抽象为对象，实现二者之间的松耦合</span><br><span class="line">// 设计模式分类：行为型模式</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  命令接口</span><br><span class="line"> */</span><br><span class="line">protocol LightCommand &#123;</span><br><span class="line">    /**</span><br><span class="line">     执行命令</span><br><span class="line">     </span><br><span class="line">     - returns: 结果</span><br><span class="line">     */</span><br><span class="line">    func execute() -&gt; String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 打开命令</span><br><span class="line">class OpenCommand : LightCommand &#123;</span><br><span class="line">    let light:String</span><br><span class="line">    </span><br><span class="line">    required init(light: String) &#123;</span><br><span class="line">        self.light = light</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func execute() -&gt; String &#123;</span><br><span class="line">        return &quot;Opened \(light)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 关闭命令</span><br><span class="line">class CloseCommand : LightCommand &#123;</span><br><span class="line">    let light:String</span><br><span class="line">    </span><br><span class="line">    required init(light: String) &#123;</span><br><span class="line">        self.light = light</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func execute() -&gt; String &#123;</span><br><span class="line">        return &quot;Closed \(light)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 台灯类</span><br><span class="line">class TableLamp &#123;</span><br><span class="line">    let openCommand: LightCommand</span><br><span class="line">    let closeCommand: LightCommand</span><br><span class="line">    </span><br><span class="line">    init(light: String) &#123;</span><br><span class="line">        self.openCommand = OpenCommand(light:light)</span><br><span class="line">        self.closeCommand = CloseCommand(light:light)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func close() -&gt; String &#123;</span><br><span class="line">        return closeCommand.execute()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func open() -&gt; String &#123;</span><br><span class="line">        return openCommand.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let lightName = &quot;名叫[hello world!]的台灯&quot;</span><br><span class="line">let myTableLamp = TableLamp(light:lightName)</span><br><span class="line"></span><br><span class="line">myTableLamp.open()</span><br><span class="line">myTableLamp.close()</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之解释器模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">// 解释器模式</span><br><span class="line">// 百度百科：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</span><br><span class="line">// 设计模式分类：行为型模式</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  表达式接口</span><br><span class="line"> */</span><br><span class="line">protocol IntegerExp &#123;</span><br><span class="line">    /**</span><br><span class="line">     取值</span><br><span class="line">     </span><br><span class="line">     - parameter context: 上下文</span><br><span class="line">     </span><br><span class="line">     - returns: 值</span><br><span class="line">     */</span><br><span class="line">    func evaluate(context: IntegerContext) -&gt; Int</span><br><span class="line">    /**</span><br><span class="line">     替换</span><br><span class="line">     </span><br><span class="line">     - parameter character:  字符</span><br><span class="line">     - parameter integerExp: 表达式</span><br><span class="line">     </span><br><span class="line">     - returns: &lt;#return value description#&gt;</span><br><span class="line">     */</span><br><span class="line">    func replace(character: Character, integerExp: IntegerExp) -&gt; IntegerExp</span><br><span class="line">    /**</span><br><span class="line">     复制</span><br><span class="line">     </span><br><span class="line">     - returns: 表达式</span><br><span class="line">     */</span><br><span class="line">    func copy() -&gt; IntegerExp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 上下文</span><br><span class="line">class IntegerContext &#123;</span><br><span class="line">    /// 数据字典</span><br><span class="line">    private var data: [Character:Int] = [:]</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     查找</span><br><span class="line">     </span><br><span class="line">     - parameter name: 字符</span><br><span class="line">     </span><br><span class="line">     - returns: 字符代表的值</span><br><span class="line">     */</span><br><span class="line">    func lookup(name: Character) -&gt; Int &#123;</span><br><span class="line">        return self.data[name]!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     分配值</span><br><span class="line">     </span><br><span class="line">     - parameter integerVarExp: 变量表达式</span><br><span class="line">     - parameter value:         值</span><br><span class="line">     */</span><br><span class="line">    func assign(integerVarExp: IntegerVarExp, value: Int) &#123;</span><br><span class="line">        self.data[integerVarExp.name] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 变量表达式</span><br><span class="line">class IntegerVarExp: IntegerExp &#123;</span><br><span class="line">    let name: Character</span><br><span class="line">    </span><br><span class="line">    init(name: Character) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func evaluate(context: IntegerContext) -&gt; Int &#123;</span><br><span class="line">        return context.lookup(self.name)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func replace(name: Character, integerExp: IntegerExp) -&gt; IntegerExp &#123;</span><br><span class="line">        if name == self.name &#123;</span><br><span class="line">            return integerExp.copy()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return IntegerVarExp(name: self.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func copy() -&gt; IntegerExp &#123;</span><br><span class="line">        return IntegerVarExp(name: self.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 加表达式</span><br><span class="line">class AddExp: IntegerExp &#123;</span><br><span class="line">        /// 操作数1</span><br><span class="line">    private var operand1: IntegerExp</span><br><span class="line">        /// 操作数2</span><br><span class="line">    private var operand2: IntegerExp</span><br><span class="line">    </span><br><span class="line">    init(op1: IntegerExp, op2: IntegerExp) &#123;</span><br><span class="line">        self.operand1 = op1</span><br><span class="line">        self.operand2 = op2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func evaluate(context: IntegerContext) -&gt; Int &#123;</span><br><span class="line">        return self.operand1.evaluate(context) + self.operand2.evaluate(context)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func replace(character: Character, integerExp: IntegerExp) -&gt; IntegerExp &#123;</span><br><span class="line">        return AddExp(op1: operand1.replace(character, integerExp: integerExp),</span><br><span class="line">                      op2: operand2.replace(character, integerExp: integerExp))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func copy() -&gt; IntegerExp &#123;</span><br><span class="line">        return AddExp(op1: self.operand1, op2: self.operand2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 减表达式</span><br><span class="line">class SubtractExp: IntegerExp &#123;</span><br><span class="line">    /// 操作数1</span><br><span class="line">    private var operand1: IntegerExp</span><br><span class="line">    /// 操作数2</span><br><span class="line">    private var operand2: IntegerExp</span><br><span class="line">    </span><br><span class="line">    init(op1: IntegerExp, op2: IntegerExp) &#123;</span><br><span class="line">        self.operand1 = op1</span><br><span class="line">        self.operand2 = op2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func evaluate(context: IntegerContext) -&gt; Int &#123;</span><br><span class="line">        return self.operand1.evaluate(context) - self.operand2.evaluate(context)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func replace(character: Character, integerExp: IntegerExp) -&gt; IntegerExp &#123;</span><br><span class="line">        return AddExp(op1: operand1.replace(character, integerExp: integerExp),</span><br><span class="line">                      op2: operand2.replace(character, integerExp: integerExp))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func copy() -&gt; IntegerExp &#123;</span><br><span class="line">        return AddExp(op1: self.operand1, op2: self.operand2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = IntegerVarExp(name: &quot;A&quot;)</span><br><span class="line">var b = IntegerVarExp(name: &quot;B&quot;)</span><br><span class="line">var c = IntegerVarExp(name: &quot;C&quot;)</span><br><span class="line"></span><br><span class="line">// 创建一个表达式 a - (b + c)</span><br><span class="line">var expression: IntegerExp = SubtractExp(op1: a, op2: AddExp(op1: b, op2: c)) // a - (b + c)</span><br><span class="line"></span><br><span class="line">// 创建一个上下文</span><br><span class="line">var intContext = IntegerContext()</span><br><span class="line">intContext.assign(a, value: 2) // a = 2</span><br><span class="line">intContext.assign(b, value: 1) // b = 1</span><br><span class="line">intContext.assign(c, value: 3) // c = 3</span><br><span class="line"></span><br><span class="line">// 在上下文环境中执行表达式</span><br><span class="line">var result = expression.evaluate(intContext) // 2 - (1 + 3) = -2</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之迭代器模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 迭代器模式</span><br><span class="line">// 百度百科：提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示</span><br><span class="line">// 设计模式分类：行为型模式</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  小说集类</span><br><span class="line"> */</span><br><span class="line">struct NovellasCollection&lt;T&gt; &#123;</span><br><span class="line">    let novellas: [T]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现SequenceType接口</span><br><span class="line">extension NovellasCollection: SequenceType &#123;</span><br><span class="line">    typealias Generator = AnyGenerator&lt;T&gt;</span><br><span class="line">    </span><br><span class="line">    func generate() -&gt; AnyGenerator&lt;T&gt; &#123;</span><br><span class="line">        var i = 0</span><br><span class="line">        return AnyGenerator&#123;</span><br><span class="line">            if i &gt;= self.novellas.count &#123;</span><br><span class="line">                return nil</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                let r = self.novellas[i]</span><br><span class="line">                i += 1</span><br><span class="line">                return r</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greatNovellas = NovellasCollection(novellas:[&quot;三国演义&quot;, &quot;水浒&quot;, &quot;红楼梦&quot;, &quot;西游记&quot;])</span><br><span class="line"></span><br><span class="line">// 可以迭代</span><br><span class="line">for novella in greatNovellas &#123;</span><br><span class="line">    print(&quot;I&apos;ve read: \(novella)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之中介者模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 中介者模式</span><br><span class="line">// 来自网络：类之间的交互行为被统一放在Mediator的对象中，对象通过Mediator对象同其他对象交互，Mediator对象起着控制器的作用</span><br><span class="line">// 设计模式分类：行为型模式</span><br><span class="line"></span><br><span class="line">/// 对象抽象</span><br><span class="line">class Colleague &#123;</span><br><span class="line">    let name: String</span><br><span class="line">    let mediator: Mediator</span><br><span class="line">    </span><br><span class="line">    init(name: String, mediator: Mediator) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.mediator = mediator</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     发送消息</span><br><span class="line">     </span><br><span class="line">     - parameter message: 消息</span><br><span class="line">     */</span><br><span class="line">    func send(message: String) &#123;</span><br><span class="line">        print(&quot;Colleague \(name) send: \(message)&quot;)</span><br><span class="line">        mediator.send(message, colleague: self)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     接收消息</span><br><span class="line">     </span><br><span class="line">     - parameter message: 消息</span><br><span class="line">     */</span><br><span class="line">    func receive(message: String) &#123;</span><br><span class="line">        assert(false, &quot;Method should be overriden&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  中介者接口</span><br><span class="line"> */</span><br><span class="line">protocol Mediator &#123;</span><br><span class="line">    /**</span><br><span class="line">     发送消息</span><br><span class="line">     </span><br><span class="line">     - parameter message:   消息</span><br><span class="line">     - parameter colleague: 发送者</span><br><span class="line">     */</span><br><span class="line">    func send(message: String, colleague: Colleague)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 具体中介者</span><br><span class="line">class MessageMediator: Mediator &#123;</span><br><span class="line">    private var colleagues: [Colleague] = []</span><br><span class="line">    </span><br><span class="line">    func addColleague(colleague: Colleague) &#123;</span><br><span class="line">        colleagues.append(colleague)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func send(message: String, colleague: Colleague) &#123;</span><br><span class="line">        for c in colleagues &#123;</span><br><span class="line">            if c !== colleague &#123; //for simplicity we compare object references</span><br><span class="line">                c.receive(message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 具体对象</span><br><span class="line">class ConcreteColleague: Colleague &#123;</span><br><span class="line">    override func receive(message: String) &#123;</span><br><span class="line">        print(&quot;Colleague \(name) received: \(message)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let messagesMediator = MessageMediator()</span><br><span class="line">let user0 = ConcreteColleague(name: &quot;张三&quot;, mediator: messagesMediator)</span><br><span class="line">let user1 = ConcreteColleague(name: &quot;李四&quot;, mediator: messagesMediator)</span><br><span class="line">let user2 = ConcreteColleague(name: &quot;王五&quot;, mediator: messagesMediator)</span><br><span class="line">messagesMediator.addColleague(user0)</span><br><span class="line">messagesMediator.addColleague(user1)</span><br><span class="line">messagesMediator.addColleague(user2)</span><br><span class="line"></span><br><span class="line">user0.send(&quot;Hello&quot;) // user1 receives message</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之备忘录模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">// 备忘录模式</span><br><span class="line">// 百度百科：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</span><br><span class="line">// 设计模式分类：行为型模式</span><br><span class="line"></span><br><span class="line">import Foundation</span><br><span class="line">typealias Memento = Dictionary&lt;NSObject, AnyObject&gt;</span><br><span class="line"></span><br><span class="line">let DPMementoKeyChapter = &quot;com.valve.halflife.chapter&quot;</span><br><span class="line">let DPMementoKeyWeapon = &quot;com.valve.halflife.weapon&quot;</span><br><span class="line">let DPMementoGameState = &quot;com.valve.halflife.state&quot;</span><br><span class="line"></span><br><span class="line">/// 游戏状态</span><br><span class="line">class GameState &#123;</span><br><span class="line">    var chapter: String = &quot;&quot;</span><br><span class="line">    var weapon: String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     生成游戏存档</span><br><span class="line">     </span><br><span class="line">     - returns: 存档</span><br><span class="line">     */</span><br><span class="line">    func toMemento() -&gt; Memento &#123;</span><br><span class="line">        return [ DPMementoKeyChapter:chapter, DPMementoKeyWeapon:weapon ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     恢复游戏存档</span><br><span class="line">     </span><br><span class="line">     - parameter memento: 存档</span><br><span class="line">     */</span><br><span class="line">    func restoreFromMemento(memento: Memento) &#123;</span><br><span class="line">        chapter = memento[DPMementoKeyChapter] as? String ?? &quot;n/a&quot;</span><br><span class="line">        weapon = memento[DPMementoKeyWeapon] as? String ?? &quot;n/a&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 存档点</span><br><span class="line"> */</span><br><span class="line">enum CheckPoint &#123;</span><br><span class="line">    /**</span><br><span class="line">     保存存档</span><br><span class="line">     </span><br><span class="line">     - parameter memento: 存档</span><br><span class="line">     - parameter keyName: 存档名</span><br><span class="line">     */</span><br><span class="line">    static func saveState(memento: Memento, keyName: String = DPMementoGameState) &#123;</span><br><span class="line">//        let defaults = NSUserDefaults.standardUserDefaults()</span><br><span class="line">//        defaults.setObject(memento, forKey: keyName)</span><br><span class="line">//        defaults.synchronize()</span><br><span class="line">        </span><br><span class="line">        DB.set(keyName, obj: memento)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     读取存档</span><br><span class="line">     </span><br><span class="line">     - parameter keyName: 存档名</span><br><span class="line">     </span><br><span class="line">     - returns: 存档</span><br><span class="line">     */</span><br><span class="line">    static func restorePreviousState(keyName keyName: String = DPMementoGameState) -&gt; Memento &#123;</span><br><span class="line">//        let defaults = NSUserDefaults.standardUserDefaults()</span><br><span class="line">//        </span><br><span class="line">//        return defaults.objectForKey(keyName) as? Memento ?? Memento()</span><br><span class="line">        </span><br><span class="line">        let m = DB.get(keyName)</span><br><span class="line">        return m as? Memento ?? Memento()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DB &#123;</span><br><span class="line">    static var dict:Dictionary&lt;String, AnyObject&gt; = [:]</span><br><span class="line">    </span><br><span class="line">    class func set(key: String, obj: AnyObject) &#123;</span><br><span class="line">        dict[key] = obj</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class func get(key: String) -&gt; AnyObject? &#123;</span><br><span class="line">        return dict[key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printGameStateInfo(state: GameState) -&gt; Void &#123;</span><br><span class="line">    print(&quot;当前游戏状态：[chapter = \(state.chapter), weapon = \(state.weapon)]&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gameState = GameState()</span><br><span class="line">gameState.restoreFromMemento(CheckPoint.restorePreviousState()) // 新游戏</span><br><span class="line"></span><br><span class="line">printGameStateInfo(gameState)</span><br><span class="line"></span><br><span class="line">gameState.chapter = &quot;第一章 新手上路&quot;</span><br><span class="line">gameState.weapon = &quot;木剑&quot;</span><br><span class="line">CheckPoint.saveState(gameState.toMemento()) // 第一个存档</span><br><span class="line"></span><br><span class="line">printGameStateInfo(gameState)</span><br><span class="line"></span><br><span class="line">gameState.chapter = &quot;第二章 冒险开始&quot;</span><br><span class="line">gameState.weapon = &quot;铜剑&quot;</span><br><span class="line">gameState.restoreFromMemento(CheckPoint.restorePreviousState()) // 恢复存档</span><br><span class="line"></span><br><span class="line">printGameStateInfo(gameState)</span><br><span class="line"></span><br><span class="line">gameState.chapter = &quot;第三章 挑战魔龙&quot;</span><br><span class="line">gameState.weapon = &quot;铁剑&quot;</span><br><span class="line">CheckPoint.saveState(gameState.toMemento(), keyName: &quot;gameState2&quot;) // 第二个存档</span><br><span class="line"></span><br><span class="line">printGameStateInfo(gameState)</span><br><span class="line"></span><br><span class="line">gameState.chapter = &quot;最后章 最终之战&quot;</span><br><span class="line">gameState.weapon = &quot;圣剑&quot;</span><br><span class="line">CheckPoint.saveState(gameState.toMemento()) // 覆盖第一个存档</span><br><span class="line"></span><br><span class="line">printGameStateInfo(gameState)</span><br><span class="line"></span><br><span class="line">gameState.restoreFromMemento(CheckPoint.restorePreviousState(keyName: &quot;gameState2&quot;)) // 加载第二个存档</span><br><span class="line"></span><br><span class="line">printGameStateInfo(gameState)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之状态模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 状态模式</span><br><span class="line">// 百度百科：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类</span><br><span class="line">// 设计模式分类：行为型模式</span><br><span class="line"></span><br><span class="line">/// 持有状态的对象</span><br><span class="line">class Context &#123;</span><br><span class="line">    private var state: State = UnauthorizedState()</span><br><span class="line">    </span><br><span class="line">    var isAuthorized: Bool &#123;</span><br><span class="line">        get &#123; return state.isAuthorized(self) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var userId: String? &#123;</span><br><span class="line">        get &#123; return state.userId(self) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func changeStateToAuthorized(userId userId: String) &#123;</span><br><span class="line">        state = AuthorizedState(userId: userId)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func changeStateToUnauthorized() &#123;</span><br><span class="line">        state = UnauthorizedState()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  状态接口</span><br><span class="line"> */</span><br><span class="line">protocol State &#123;</span><br><span class="line">    func isAuthorized(context: Context) -&gt; Bool</span><br><span class="line">    func userId(context: Context) -&gt; String?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 未认证状态</span><br><span class="line">class UnauthorizedState: State &#123;</span><br><span class="line">    func isAuthorized(context: Context) -&gt; Bool &#123; return false &#125;</span><br><span class="line">    </span><br><span class="line">    func userId(context: Context) -&gt; String? &#123; return nil &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 认证状态</span><br><span class="line">class AuthorizedState: State &#123;</span><br><span class="line">    let userId: String</span><br><span class="line">    </span><br><span class="line">    init(userId: String) &#123; self.userId = userId &#125;</span><br><span class="line">    </span><br><span class="line">    func isAuthorized(context: Context) -&gt; Bool &#123; return true &#125;</span><br><span class="line">    </span><br><span class="line">    func userId(context: Context) -&gt; String? &#123; return userId &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let context = Context()</span><br><span class="line">(context.isAuthorized, context.userId)</span><br><span class="line">context.changeStateToAuthorized(userId: &quot;admin&quot;)</span><br><span class="line">(context.isAuthorized, context.userId) // now logged in as &quot;admin&quot;</span><br><span class="line">context.changeStateToUnauthorized()</span><br><span class="line">(context.isAuthorized, context.userId)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之策略模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 策略模式</span><br><span class="line">// 策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化</span><br><span class="line">// 设计模式分类：行为型模式</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  打印策略接口</span><br><span class="line"> */</span><br><span class="line">protocol PrintStrategy &#123;</span><br><span class="line">    func printString(string: String) -&gt; String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 打印机类</span><br><span class="line">class Printer &#123;</span><br><span class="line">    </span><br><span class="line">    let strategy: PrintStrategy</span><br><span class="line">    </span><br><span class="line">    func printString(string: String) -&gt; String &#123;</span><br><span class="line">        return self.strategy.printString(string)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(strategy: PrintStrategy) &#123;</span><br><span class="line">        self.strategy = strategy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 大写打印策略</span><br><span class="line">class UpperCaseStrategy : PrintStrategy &#123;</span><br><span class="line">    func printString(string:String) -&gt; String &#123;</span><br><span class="line">        return string.uppercaseString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 小写打印策略</span><br><span class="line">class LowerCaseStrategy : PrintStrategy &#123;</span><br><span class="line">    func printString(string:String) -&gt; String &#123;</span><br><span class="line">        return string.lowercaseString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var lower = Printer(strategy:LowerCaseStrategy())</span><br><span class="line">lower.printString(&quot;O tempora, o mores!&quot;)</span><br><span class="line"></span><br><span class="line">var upper = Printer(strategy:UpperCaseStrategy())</span><br><span class="line">upper.printString(&quot;O tempora, o mores!&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之访问者模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 访问者模式</span><br><span class="line">// 百度百科：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作</span><br><span class="line">// 设计模式分类：行为型模式</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  星球访问者接口</span><br><span class="line"> */</span><br><span class="line">protocol PlanetVisitor &#123;</span><br><span class="line">    func visit(planet: Earth)</span><br><span class="line">    func visit(planet: Mars)</span><br><span class="line">    func visit(planet: Venus)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  行星类</span><br><span class="line"> */</span><br><span class="line">protocol Planet &#123;</span><br><span class="line">    func accept(visitor: PlanetVisitor)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 地球</span><br><span class="line">class Earth: Planet &#123;</span><br><span class="line">    func accept(visitor: PlanetVisitor) &#123; visitor.visit(self) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 火星</span><br><span class="line">class Mars: Planet &#123;</span><br><span class="line">    func accept(visitor: PlanetVisitor) &#123; visitor.visit(self) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 金星</span><br><span class="line">class Venus: Planet &#123;</span><br><span class="line">    func accept(visitor: PlanetVisitor) &#123; visitor.visit(self) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 具体访问者类</span><br><span class="line">class NameVisitor: PlanetVisitor &#123;</span><br><span class="line">    var name = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    func visit(planet: Earth)  &#123; name = &quot;Earth&quot; &#125;</span><br><span class="line">    func visit(planet: Mars) &#123; name = &quot;Mars&quot; &#125;</span><br><span class="line">    func visit(planet: Venus)  &#123; name = &quot;Venus&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let planets: [Planet] = [Earth(), Mars(), Venus()]</span><br><span class="line"></span><br><span class="line">let names = planets.map &#123; (planet: Planet) -&gt; String in</span><br><span class="line">    let visitor = NameVisitor()</span><br><span class="line">    planet.accept(visitor)</span><br><span class="line">    return visitor.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之抽象工厂模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// 抽象工厂模式</span><br><span class="line">// 百度百科：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类</span><br><span class="line">// 设计模式分类：创建型模式</span><br><span class="line"></span><br><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  抽象工厂</span><br><span class="line"> */</span><br><span class="line">protocol Decimal &#123;</span><br><span class="line">    func stringValue() -&gt; String</span><br><span class="line">    // 工厂方法</span><br><span class="line">    static func make(string : String) -&gt; Decimal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typealias NumberFactory = (String) -&gt; Decimal</span><br><span class="line"></span><br><span class="line">// Number implementations with factory methods</span><br><span class="line">/**</span><br><span class="line"> *  具体工厂</span><br><span class="line"> */</span><br><span class="line">struct NextStepNumber : Decimal &#123;</span><br><span class="line">    private var nextStepNumber : NSNumber</span><br><span class="line">    </span><br><span class="line">    func stringValue() -&gt; String &#123; return nextStepNumber.stringValue &#125;</span><br><span class="line">    </span><br><span class="line">    // 工厂方法</span><br><span class="line">    static func make(string : String) -&gt; Decimal &#123;</span><br><span class="line">        return NextStepNumber(nextStepNumber:NSNumber(longLong:(string as NSString).longLongValue))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  具体工厂</span><br><span class="line"> */</span><br><span class="line">struct SwiftNumber : Decimal &#123;</span><br><span class="line">    private var swiftInt : Int</span><br><span class="line">    </span><br><span class="line">    func stringValue() -&gt; String &#123; return &quot;\(swiftInt)&quot; &#125;</span><br><span class="line">    </span><br><span class="line">    // 工厂方法</span><br><span class="line">    static func make(string : String) -&gt; Decimal &#123;</span><br><span class="line">        return SwiftNumber(swiftInt:(string as NSString).integerValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum NumberType &#123;</span><br><span class="line">    case NextStep, Swift</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum NumberHelper &#123;</span><br><span class="line">    static func factoryFor(type : NumberType) -&gt; NumberFactory &#123;</span><br><span class="line">        switch type &#123;</span><br><span class="line">        case .NextStep:</span><br><span class="line">            return NextStepNumber.make</span><br><span class="line">        case .Swift:</span><br><span class="line">            return SwiftNumber.make</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let factoryOne = NumberHelper.factoryFor(.NextStep)</span><br><span class="line">let numberOne = factoryOne(&quot;1&quot;)</span><br><span class="line">numberOne.stringValue()</span><br><span class="line"></span><br><span class="line">let factoryTwo = NumberHelper.factoryFor(.Swift)</span><br><span class="line">let numberTwo = factoryTwo(&quot;2&quot;)</span><br><span class="line">numberTwo.stringValue()</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之创建者模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 创建者模式</span><br><span class="line">// 百度百科：其核心思想是将一个“复杂对象的构建算法”与它的“部件及组装方式”分离，使得构件算法和组装方式可以独立应对变化；复用同样的构建算法可以创建不同的表示，不同的构建过程可以复用相同的部件组装方式</span><br><span class="line">// 设计模式分类：创建型模式</span><br><span class="line"></span><br><span class="line">/// 创建者</span><br><span class="line">class DeathStarBuilder &#123;</span><br><span class="line">    </span><br><span class="line">    var x: Double?</span><br><span class="line">    var y: Double?</span><br><span class="line">    var z: Double?</span><br><span class="line">    </span><br><span class="line">        /// 创建者闭包</span><br><span class="line">    typealias BuilderClosure = (DeathStarBuilder) -&gt; ()</span><br><span class="line">    </span><br><span class="line">    init(buildClosure: BuilderClosure) &#123;</span><br><span class="line">        buildClosure(self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  创建对象</span><br><span class="line"> */</span><br><span class="line">struct DeathStar : CustomStringConvertible &#123;</span><br><span class="line">    </span><br><span class="line">    let x: Double</span><br><span class="line">    let y: Double</span><br><span class="line">    let z: Double</span><br><span class="line">    </span><br><span class="line">    init?(builder: DeathStarBuilder) &#123;</span><br><span class="line">        </span><br><span class="line">        if let x = builder.x, y = builder.y, z = builder.z &#123;</span><br><span class="line">            self.x = x</span><br><span class="line">            self.y = y</span><br><span class="line">            self.z = z</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var description:String &#123;</span><br><span class="line">        return &quot;Death Star at (x:\(x) y:\(y) z:\(z))&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let empire = DeathStarBuilder &#123; builder in</span><br><span class="line">    builder.x = 0.1</span><br><span class="line">    builder.y = 0.2</span><br><span class="line">    builder.z = 0.3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let deathStar = DeathStar(builder:empire)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之工厂方法模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// 工厂方法模式</span><br><span class="line">// 百度百科：是一种常用的对象创建型设计模式,此模式的核心精神是封装类中不变的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。它的核心结构有四个角色，分别是抽象工厂；具体工厂；抽象产品；具体产品</span><br><span class="line">// 设计模式分类：创建型模式</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  抽象产品（货币）</span><br><span class="line"> */</span><br><span class="line">protocol Currency &#123;</span><br><span class="line">    func symbol() -&gt; String</span><br><span class="line">    func code() -&gt; String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 具体产品（欧元）</span><br><span class="line">class Euro : Currency &#123;</span><br><span class="line">    func symbol() -&gt; String &#123;</span><br><span class="line">        return &quot;€&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func code() -&gt; String &#123;</span><br><span class="line">        return &quot;EUR&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 具体产品（美元）</span><br><span class="line">class UnitedStatesDolar : Currency &#123;</span><br><span class="line">    func symbol() -&gt; String &#123;</span><br><span class="line">        return &quot;$&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func code() -&gt; String &#123;</span><br><span class="line">        return &quot;USD&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 国家</span><br><span class="line"> </span><br><span class="line"> - UnitedStates: 美国</span><br><span class="line"> - Spain:        西班牙</span><br><span class="line"> - UK:           英国</span><br><span class="line"> - Greece:       希腊</span><br><span class="line"> */</span><br><span class="line">enum Country &#123;</span><br><span class="line">    case UnitedStates, Spain, UK, Greece</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 具体工厂</span><br><span class="line"> */</span><br><span class="line">enum CurrencyFactory &#123;</span><br><span class="line">    static func currencyForCountry(country:Country) -&gt; Currency? &#123;</span><br><span class="line">        </span><br><span class="line">        switch country &#123;</span><br><span class="line">        case .Spain, .Greece :</span><br><span class="line">            return Euro()</span><br><span class="line">        case .UnitedStates :</span><br><span class="line">            return UnitedStatesDolar()</span><br><span class="line">        default:</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let noCurrencyCode = &quot;No Currency Code Available&quot;</span><br><span class="line"></span><br><span class="line">CurrencyFactory.currencyForCountry(.Greece)?.code() ?? noCurrencyCode</span><br><span class="line">CurrencyFactory.currencyForCountry(.Spain)?.code() ?? noCurrencyCode</span><br><span class="line">CurrencyFactory.currencyForCountry(.UnitedStates)?.code() ?? noCurrencyCode</span><br><span class="line">CurrencyFactory.currencyForCountry(.UK)?.code() ?? noCurrencyCode</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之原型模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 原型模式</span><br><span class="line">// 百度百科：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</span><br><span class="line">// 设计模式分类：创建型模式</span><br><span class="line"></span><br><span class="line">class ChungasRevengeDisplay &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    let font: String</span><br><span class="line">    </span><br><span class="line">    init(font: String) &#123;</span><br><span class="line">        self.font = font</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func clone() -&gt; ChungasRevengeDisplay &#123;</span><br><span class="line">        return ChungasRevengeDisplay(font:self.font)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Prototype = ChungasRevengeDisplay(font:&quot;GotanProject&quot;)</span><br><span class="line"></span><br><span class="line">let Philippe = Prototype.clone()</span><br><span class="line">Philippe.name = &quot;Philippe&quot;</span><br><span class="line"></span><br><span class="line">let Christoph = Prototype.clone()</span><br><span class="line">Christoph.name = &quot;Christoph&quot;</span><br><span class="line"></span><br><span class="line">let Eduardo = Prototype.clone()</span><br><span class="line">Eduardo.name = &quot;Eduardo&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之单例模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 单例模式</span><br><span class="line">// 百度百科：单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例</span><br><span class="line">// 设计模式分类：创建型模式</span><br><span class="line"></span><br><span class="line">class DeathStarSuperlaser &#123;</span><br><span class="line">    static let sharedInstance = DeathStarSuperlaser()</span><br><span class="line">    </span><br><span class="line">    private init() &#123;</span><br><span class="line">        // 私有化构造函数来保证只有一个实例</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let laser = DeathStarSuperlaser.sharedInstance</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之适配器模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 适配器模式</span><br><span class="line">// 百度百科：适配器模式（有时候也称包装样式或者包装）将一个类的接口适配成用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中</span><br><span class="line">// 设计模式分类：结构型模式</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  两针插座接口</span><br><span class="line"> */</span><br><span class="line">protocol TwoPinPlugProtocol &#123;</span><br><span class="line">    var pin1: String &#123; get &#125;</span><br><span class="line">    var pin2: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 现在有一个三针插座</span><br><span class="line">class ThreePinPlug &#123;</span><br><span class="line">    var pin1: String &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return &quot;pin1 of ThreePinPlug&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var pin2: String &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return &quot;pin2 of ThreePinPlug&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var pin3: String &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return &quot;pin3 of ThreePinPlug&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 这是一个适配器， 将三针插座转化为两针插座</span><br><span class="line">class TwoPinPlugAdapter: TwoPinPlugProtocol &#123;</span><br><span class="line">    let threePinPlug: ThreePinPlug!</span><br><span class="line">    </span><br><span class="line">    init(plug: ThreePinPlug) &#123;</span><br><span class="line">        self.threePinPlug = plug</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var pin1: String &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return threePinPlug.pin1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var pin2: String &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return threePinPlug.pin2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 打印两针插座信息（不可以接收三针插座）</span><br><span class="line"> </span><br><span class="line"> - parameter plug: 两针插座</span><br><span class="line"> */</span><br><span class="line">func printTwoPinPlugInfo(plug: TwoPinPlugProtocol) -&gt; Void &#123;</span><br><span class="line">    print(&quot;two pin plug info: [pin1 = \(plug.pin1), pin2 = \(plug.pin2)]&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let threePinPlug = ThreePinPlug() // 目前有一个三针插座</span><br><span class="line">let twoPinPlugAdapter = TwoPinPlugAdapter(plug: threePinPlug) // 用适配器来包装</span><br><span class="line"></span><br><span class="line">printTwoPinPlugInfo(twoPinPlugAdapter) // 包装后可以将三针插座放入只接收两针插座的接口中</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之桥梁模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 桥梁模式</span><br><span class="line">// 百度百科：继承或实现的类通过不同的实现方式来完成抽象类或接口的变化 , 也就是实现过程的变化 , 但可能会有这样的情况 , 抽象过程同样需要进行变化 , 也就是抽象类或者接口需要变化 , 这样就会造成原有的继承或实现关系复杂 , 关系混乱 .桥梁模式利用将抽象层和实现层进行解耦 , 使两者不再像继承或实现这样的较强的关系 , 从而使抽象和实现层更加独立的完成变化的过程 . 使系统更加清晰</span><br><span class="line">// 设计模式分类：结构型模式</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  开关接口</span><br><span class="line"> */</span><br><span class="line">protocol Switch &#123;</span><br><span class="line">    var appliance: Appliance &#123;get set&#125;</span><br><span class="line">    func turnOn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  电器接口</span><br><span class="line"> */</span><br><span class="line">protocol Appliance &#123;</span><br><span class="line">    func run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 开关实现</span><br><span class="line">class RemoteControl: Switch &#123;</span><br><span class="line">    var appliance: Appliance</span><br><span class="line">    </span><br><span class="line">    func turnOn() &#123;</span><br><span class="line">        self.appliance.run()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(appliance: Appliance) &#123;</span><br><span class="line">        self.appliance = appliance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 电器实现，电视</span><br><span class="line">class TV: Appliance &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;tv turned on&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 电器实现，吸尘器</span><br><span class="line">class VacuumCleaner: Appliance &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;vacuum cleaner turned on&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var tvRemoteControl = RemoteControl(appliance: TV())</span><br><span class="line">tvRemoteControl.turnOn()</span><br><span class="line"></span><br><span class="line">var fancyVacuumCleanerRemoteControl = RemoteControl(appliance: VacuumCleaner())</span><br><span class="line">fancyVacuumCleanerRemoteControl.turnOn()</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之组合模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 桥梁模式</span><br><span class="line">// 百度百科：继承或实现的类通过不同的实现方式来完成抽象类或接口的变化 , 也就是实现过程的变化 , 但可能会有这样的情况 , 抽象过程同样需要进行变化 , 也就是抽象类或者接口需要变化 , 这样就会造成原有的继承或实现关系复杂 , 关系混乱 .桥梁模式利用将抽象层和实现层进行解耦 , 使两者不再像继承或实现这样的较强的关系 , 从而使抽象和实现层更加独立的完成变化的过程 . 使系统更加清晰</span><br><span class="line">// 设计模式分类：创建型模式</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  开关接口</span><br><span class="line"> */</span><br><span class="line">protocol Switch &#123;</span><br><span class="line">    var appliance: Appliance &#123;get set&#125;</span><br><span class="line">    func turnOn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  电器接口</span><br><span class="line"> */</span><br><span class="line">protocol Appliance &#123;</span><br><span class="line">    func run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 开关实现</span><br><span class="line">class RemoteControl: Switch &#123;</span><br><span class="line">    var appliance: Appliance</span><br><span class="line">    </span><br><span class="line">    func turnOn() &#123;</span><br><span class="line">        self.appliance.run()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(appliance: Appliance) &#123;</span><br><span class="line">        self.appliance = appliance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 电器实现，电视</span><br><span class="line">class TV: Appliance &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;tv turned on&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 电器实现，吸尘器</span><br><span class="line">class VacuumCleaner: Appliance &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;vacuum cleaner turned on&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var tvRemoteControl = RemoteControl(appliance: TV())</span><br><span class="line">tvRemoteControl.turnOn()</span><br><span class="line"></span><br><span class="line">var fancyVacuumCleanerRemoteControl = RemoteControl(appliance: VacuumCleaner())</span><br><span class="line">fancyVacuumCleanerRemoteControl.turnOn()</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之装饰模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">// 装饰模式</span><br><span class="line">// 百度百科：在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象</span><br><span class="line">// 设计模式分类：结构型模式</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  咖啡接口</span><br><span class="line"> */</span><br><span class="line">protocol Coffee &#123;</span><br><span class="line">    /**</span><br><span class="line">     价格</span><br><span class="line">     </span><br><span class="line">     - returns: 价格</span><br><span class="line">     */</span><br><span class="line">    func getCost() -&gt; Double</span><br><span class="line">    /**</span><br><span class="line">     原料</span><br><span class="line">     </span><br><span class="line">     - returns: 原料</span><br><span class="line">     */</span><br><span class="line">    func getIngredients() -&gt; String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 简单咖啡实现</span><br><span class="line">class SimpleCoffee: Coffee &#123;</span><br><span class="line">    func getCost() -&gt; Double &#123;</span><br><span class="line">        return 1.0</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func getIngredients() -&gt; String &#123;</span><br><span class="line">        return &quot;Coffee&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 咖啡装饰接口</span><br><span class="line">class CoffeeDecorator: Coffee &#123;</span><br><span class="line">    private let decoratedCoffee: Coffee</span><br><span class="line">    private let ingredientSeparator: String = &quot;, &quot;</span><br><span class="line">    </span><br><span class="line">    required init(decoratedCoffee: Coffee) &#123;</span><br><span class="line">        self.decoratedCoffee = decoratedCoffee</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func getCost() -&gt; Double &#123;</span><br><span class="line">        return decoratedCoffee.getCost()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func getIngredients() -&gt; String &#123;</span><br><span class="line">        return decoratedCoffee.getIngredients()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 牛奶装饰实现</span><br><span class="line">class Milk: CoffeeDecorator &#123;</span><br><span class="line">    required init(decoratedCoffee: Coffee) &#123;</span><br><span class="line">        super.init(decoratedCoffee: decoratedCoffee)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func getCost() -&gt; Double &#123;</span><br><span class="line">        return super.getCost() + 0.5</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func getIngredients() -&gt; String &#123;</span><br><span class="line">        return super.getIngredients() + ingredientSeparator + &quot;Milk&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// whip装饰实现</span><br><span class="line">class WhipCoffee: CoffeeDecorator &#123;</span><br><span class="line">    required init(decoratedCoffee: Coffee) &#123;</span><br><span class="line">        super.init(decoratedCoffee: decoratedCoffee)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func getCost() -&gt; Double &#123;</span><br><span class="line">        return super.getCost() + 0.7</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func getIngredients() -&gt; String &#123;</span><br><span class="line">        return super.getIngredients() + ingredientSeparator + &quot;Whip&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var someCoffee: Coffee = SimpleCoffee() // 简单咖啡</span><br><span class="line">print(&quot;Cost : \(someCoffee.getCost()); Ingredients: \(someCoffee.getIngredients())&quot;)</span><br><span class="line"></span><br><span class="line">var milkCoffee = Milk(decoratedCoffee: someCoffee) // 装饰了牛奶的咖啡</span><br><span class="line">print(&quot;Cost : \(milkCoffee.getCost()); Ingredients: \(milkCoffee.getIngredients())&quot;)</span><br><span class="line"></span><br><span class="line">var whipCoffee = WhipCoffee(decoratedCoffee: milkCoffee) // 装饰了whip和牛奶的咖啡</span><br><span class="line">print(&quot;Cost : \(whipCoffee.getCost()); Ingredients: \(whipCoffee.getIngredients())&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之外观模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 外观模式</span><br><span class="line">// 百度百科：为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用</span><br><span class="line">// 设计模式分类：结构型模式</span><br><span class="line"></span><br><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">enum Eternal &#123;</span><br><span class="line">    </span><br><span class="line">    static func setObj(value: AnyObject!, forKey defaultName: String!) &#123;</span><br><span class="line">        let defaults:NSUserDefaults = NSUserDefaults.standardUserDefaults()</span><br><span class="line">        defaults.setObject(value, forKey:defaultName)</span><br><span class="line">        defaults.synchronize()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static func getObj(defaultName: String!) -&gt; AnyObject! &#123;</span><br><span class="line">        let defaults:NSUserDefaults = NSUserDefaults.standardUserDefaults()</span><br><span class="line">        </span><br><span class="line">        return defaults.objectForKey(defaultName)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// *** 注意， 在playground中NSUserDefaults无法使用， 请在普通项目中测试</span><br><span class="line">Eternal.setObj(&quot;Disconnect me. I’d rather be nothing&quot;, forKey:&quot;Bishop&quot;)</span><br><span class="line">Eternal.getObj(&quot;Bishop&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之保护代理模式]]></title>
      <url>/2018/05/11/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BF%9D%E6%8A%A4%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 保护代理模式</span><br><span class="line">// 百度百科：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用</span><br><span class="line">// 设计模式分类：结构型模式</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  电脑接口</span><br><span class="line"> */</span><br><span class="line">protocol PC &#123;</span><br><span class="line">    func connect(ip: String) -&gt; Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 电脑实现</span><br><span class="line">class MyPC: PC &#123;</span><br><span class="line">    func connect(ip: String) -&gt; Bool &#123;</span><br><span class="line">        print(&quot;connect to \(ip)&quot;)</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 代理实现</span><br><span class="line">class MyProxy: PC &#123;</span><br><span class="line">    </span><br><span class="line">    var pc: MyPC!</span><br><span class="line">    </span><br><span class="line">    init(pc: MyPC) &#123;</span><br><span class="line">        self.pc = pc</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func connect(ip: String) -&gt; Bool &#123;</span><br><span class="line">        if ip == &quot;10.10.10.10&quot; &#123;</span><br><span class="line">            print(&quot;\(ip) has been limited&quot;)</span><br><span class="line">            return false</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pc.connect(ip)</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let pc = MyPC()</span><br><span class="line">let proxy = MyProxy(pc: pc)</span><br><span class="line"></span><br><span class="line">proxy.connect(&quot;1.2.3.4&quot;)</span><br><span class="line">proxy.connect(&quot;10.10.10.10&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift中自定义Log]]></title>
      <url>/2018/05/11/Swift%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89Log/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>Swift中自定义Log：依次是<strong>类名.方法名.行号.内容</strong>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func LTLog&lt;T&gt;(funcName: String = #function,_ message: T,file: String = #file, line: Int = #line) &#123;</span><br><span class="line"></span><br><span class="line">    #if DEBUG</span><br><span class="line">    let files = (file as NSString).lastPathComponent.replacingOccurrences(of: &quot;.swift&quot;, with: &quot;&quot;)</span><br><span class="line">        print(&quot;\(files) --&gt; \(funcName) --&gt;  \(line) --&gt; \(message) &quot;)</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还要配置以下宏</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1067182-c319525049a240a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>假如我在一个函数中打印这个”我是靓仔”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">       LTLog(&quot;撒大大的&quot;)</span><br><span class="line">       return true</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最终会输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppDelegate.application(_:didFinishLaunchingWithOptions:)[23]:撒大大的</span><br></pre></td></tr></table></figure>
<p>注:依次是<strong>类名.方法名.行号.内容</strong>.</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift设计模式之观察者模式]]></title>
      <url>/2018/05/10/Swift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#</p>
<p><strong>转自</strong></p>
<ul>
<li><a href="http://qefee.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Swift设计模式</a></li>
</ul>
<p><strong>原文</strong></p>
<ul>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift#behavioral" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 观察者模式</span><br><span class="line">// 一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统</span><br><span class="line">// 设计模式分类：行为型模式</span><br><span class="line"></span><br><span class="line">/// 观察者接口</span><br><span class="line">protocol PropertyObserver : class &#123;</span><br><span class="line">    /**</span><br><span class="line">     属性即将改变监听方法</span><br><span class="line">     </span><br><span class="line">     - parameter propertyName:     属性名</span><br><span class="line">     - parameter newPropertyValue: 新的值</span><br><span class="line">     */</span><br><span class="line">    func willChangePropertyName(propertyName:String, newPropertyValue:Int)</span><br><span class="line">    /**</span><br><span class="line">     属性已经改变监听方法</span><br><span class="line">     </span><br><span class="line">     - parameter propertyName:     属性名</span><br><span class="line">     - parameter oldPropertyValue: 原来的值</span><br><span class="line">     */</span><br><span class="line">    func didChangePropertyName(propertyName:String, oldPropertyValue:Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 观察对象</span><br><span class="line">class TestChambers &#123;</span><br><span class="line">    </span><br><span class="line">    weak var observer:PropertyObserver?</span><br><span class="line">    </span><br><span class="line">    var testChamberNumber: Int = 0 &#123;</span><br><span class="line">        willSet(newValue) &#123;</span><br><span class="line">            observer?.willChangePropertyName(&quot;testChamberNumber&quot;, newPropertyValue:newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            observer?.didChangePropertyName(&quot;testChamberNumber&quot;, oldPropertyValue:oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 具体观察者</span><br><span class="line">class Observer : PropertyObserver &#123;</span><br><span class="line">    func willChangePropertyName(propertyName: String, newPropertyValue: Int) &#123;</span><br><span class="line">        print(&quot;\(propertyName)的值将要改变为\(newPropertyValue)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func didChangePropertyName(propertyName: String, oldPropertyValue: Int) &#123;</span><br><span class="line">        print(&quot;\(propertyName)的值已经改变,原来的值为\(oldPropertyValue)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerInstance = Observer()</span><br><span class="line">var testChambers = TestChambers()</span><br><span class="line">testChambers.observer = observerInstance</span><br><span class="line">testChambers.testChamberNumber += 1</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Swift设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift 4 域名解析 DNS]]></title>
      <url>/2018/05/08/Swift%204%20%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%20DNS/</url>
      <content type="html"><![CDATA[<blockquote>
<p>引用于GitHub：<a href="https://github.com/xiaoxiaocainiao/HostToIP/blob/master/HostToIP/ViewController.swift" target="_blank" rel="noopener">https://github.com/xiaoxiaocainiao/HostToIP/blob/master/HostToIP/ViewController.swift</a><br>这里又根据自己需要做了少许改动，在此感谢下作者的无私提供。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        getIPAddress(&quot;www.baidu.com&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override func didReceiveMemoryWarning() &#123;</span><br><span class="line">        super.didReceiveMemoryWarning()</span><br><span class="line">        // Dispose of any resources that can be recreated.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 域名解析</span><br><span class="line">    func getIPAddress(domainName: String) -&gt; String &#123;</span><br><span class="line">    var result = &quot;&quot;</span><br><span class="line">        let host = CFHostCreateWithName(nil,domainName as CFString).takeRetainedValue()</span><br><span class="line">        CFHostStartInfoResolution(host, .addresses, nil)</span><br><span class="line">        var success: DarwinBoolean = false</span><br><span class="line">        if let addresses = CFHostGetAddressing(host, &amp;success)?.takeUnretainedValue() as NSArray?,</span><br><span class="line">            let theAddress = addresses.firstObject as? NSData &#123;</span><br><span class="line">            var hostname = [CChar](repeating: 0, count: Int(NI_MAXHOST))</span><br><span class="line">            if getnameinfo(theAddress.bytes.assumingMemoryBound(to: sockaddr.self), socklen_t(theAddress.length),</span><br><span class="line">                           &amp;hostname, socklen_t(hostname.count), nil, 0, NI_NUMERICHOST) == 0 &#123;</span><br><span class="line">                let numAddress = String(cString: hostname)</span><br><span class="line">                result = numAddress</span><br><span class="line">                print(numAddress)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> tips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UIAlertController]]></title>
      <url>/2018/05/07/%E8%87%AA%E5%AE%9A%E4%B9%89UIAlertController/</url>
      <content type="html"><![CDATA[<p>自定义UIAlertController</p>
<p>1:显示alert，点击过到指定时间，dissMiss Alert</p>
<p>2:显示alert，点击过到指定时间，dissMiss Alert 后，继续执行block内容</p>
<p>class Utils :NSObject{</p>
<p>​    static var alert: UIAlertController!</p>
<p>​      // 消息提示框</p>
<p>​    public static func notifyUser(title: String, message: String, timeToDissapear: Int) -&gt; Void</p>
<p>​    {<br><a id="more"></a><br>​        alert = UIAlertController(title: title,</p>
<p>​                                  message: message,</p>
<p>​                                  preferredStyle: UIAlertControllerStyle.alert)</p>
<p>​        </p>
<p>​        let cancelAction = UIAlertAction(title: “确定”,</p>
<p>​                                         style: .cancel, handler: {</p>
<p>​                                            action in</p>
<p>​                                            return</p>
<p>​                                                })</p>
<p>​        </p>
<p>​        alert.addAction(cancelAction)</p>
<p>​        </p>
<p>​        UIApplication.shared.keyWindow?.rootViewController!</p>
<p>​            .present(alert, animated: true,completion: nil)</p>
<p>​        </p>
<p>​        //定时关闭</p>
<p>​        _ = Timer.scheduledTimer(timeInterval: Double(timeToDissapear), target: self, selector: #selector(Utils.dismissAlert), userInfo: nil, repeats: false)</p>
<p>​    }</p>
<p>​    </p>
<p>​    @objc static func dismissAlert()</p>
<p>​    {</p>
<p>​        // Dismiss the alert from here</p>
<p>​        alert.dismiss(animated: true, completion: nil)</p>
<p>​    }</p>
<p>​    typealias ZZWandBlock = (() -&gt; Void)</p>
<p>​    var andBlock : ZZWandBlock?</p>
<p>​    // 消息提示框</p>
<p>​    func notifyUserB(title: String, message: String, timeToDissapear: Int,_ block: @escaping (() -&gt; Void)) -&gt; Void</p>
<p>​    {</p>
<p>​        andBlock = block</p>
<p>​        </p>
<p>​        Utils.alert = UIAlertController(title: title,</p>
<p>​                                        message: message,</p>
<p>​                                        preferredStyle: UIAlertControllerStyle.alert)</p>
<p>​        </p>
<p>​        let cancelAction = UIAlertAction(title: NSLocalizedString(“BUTTON_OK”, comment: “确定”),</p>
<p>​                                         style: .cancel, handler: {</p>
<p>​                                            action in</p>
<p>​                                            block()</p>
<p>​                                            return</p>
<p>​        })</p>
<p>​        Utils.alert.addAction(cancelAction)</p>
<p>​        </p>
<p>​        UIApplication.shared.keyWindow?.rootViewController!</p>
<p>​            .present(Utils.alert, animated: true,completion: nil)</p>
<p>​        //        self.present(alert, animated: true) {</p>
<p>​        //</p>
<p>​        //        }</p>
<p>​        </p>
<p>​        //定时关闭</p>
<p>​        _ = Timer.scheduledTimer(timeInterval: Double(timeToDissapear), target: self, selector: #selector(Utils.dismissAlertB), userInfo: nil, repeats: false)</p>
<p>​    }</p>
<p>​    </p>
<p>​    @objc func dismissAlertB()</p>
<p>​    {</p>
<p>​        // Dismiss the alert from here</p>
<p>​        if Utils.alert.isBeingDismissed {</p>
<p>​            </p>
<p>​        }else{</p>
<p>​            Utils.alert.dismiss(animated: true){</p>
<p>​                self.andBlock!()</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>用法：Utils.notifyUser(title: “tips”, message: “请连接”, timeToDissapear: 3)</p>
<p>Utils().notifyUserB(title: “信息”, message: “状态”, timeToDissapear: 3, {</p>
<p>​               print(“jbcdksbck”)</p>
<p>​            })</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> UIAlertController </tag>
            
            <tag> UI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[类和结构struct]]></title>
      <url>/2018/05/07/%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="类和结构"><a href="#类和结构" class="headerlink" title="类和结构"></a>类和结构</h2><p><em>类</em>和<em>结构</em>是通用的，灵活的构造，它们成为程序代码的构建块。您可以使用与常量，变量和函数完全相同的语法来定义属性和方法，从而为您的类和结构添加功能。</p>
<p>与其他编程语言不同，Swift不要求您为自定义类和结构创建单独的接口和实现文件。在Swift中，您可以在单个文件中定义一个类或结构，并且该类或结构的外部接口会自动提供给其他代码使用。</p>
<p>注意传统上将<em>类</em>的实例称为<em>对象</em>。然而，斯威夫特类和结构在功能上比其他语言更接近，而很多本章介绍了可以应用到的实例功能，<em>无论是</em>类或结构类型。因此，使用更一般的术语<em>实例</em>。<br><a id="more"></a></p>
<h3 id="比较类和结构"><a href="#比较类和结构" class="headerlink" title="比较类和结构"></a>比较类和结构</h3><p>Swift中的类和结构有许多共同之处。两者都可以：</p>
<ul>
<li>定义属性以存储值</li>
<li>定义提供功能的方法</li>
<li>使用下标语法定义下标以提供对其值的访问</li>
<li>定义初始化程序以设置其初始状态</li>
<li>扩展到超出默认实现范围的功能</li>
<li>符合协议以提供某种标准功能</li>
</ul>
<p>有关更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254" target="_blank" rel="noopener">属性</a>，<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234" target="_blank" rel="noopener">方法</a>，下<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Subscripts.html#//apple_ref/doc/uid/TP40014097-CH16-ID305" target="_blank" rel="noopener">标</a>，<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" target="_blank" rel="noopener">初始化</a>，<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" target="_blank" rel="noopener">扩展</a>和<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="noopener">协议</a>。</p>
<p>类具有结构不具有的其他功能：</p>
<ul>
<li>继承使一个类能够继承另一个类的特性。</li>
<li>类型转换使您能够在运行时检查和解释类实例的类型。</li>
<li>去初始化器使类的一个实例释放它分配的任何资源。</li>
<li>引用计数允许对一个类实例的多个引用。</li>
</ul>
<p>有关更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-ID193" target="_blank" rel="noopener">继承</a>，<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22-ID338" target="_blank" rel="noopener">类型转换</a>，<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Deinitialization.html#//apple_ref/doc/uid/TP40014097-CH19-ID142" target="_blank" rel="noopener">取消初始化</a>和<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID48" target="_blank" rel="noopener">自动引用计数</a>。</p>
<p>注意结构在代码中传递时总是被复制，并且不使用引用计数。</p>
<h3 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h3><p>类和结构具有类似的定义语法。您可以使用<code>class</code>关键字引入具有关键字和结构的类<code>struct</code>。两者都将其整个定义放在一对大括号内：</p>
<ol>
<li><code>class SomeClass {</code></li>
<li><code>// class definition goes here</code></li>
<li><code>}</code></li>
<li><code>struct SomeStructure {</code></li>
<li><code>// structure definition goes here</code></li>
<li><code>}</code></li>
</ol>
<p>注意每当你定义一个新的类或结构时，你都可以有效地定义一个全新的Swift类型。给出类型<code>UpperCamelCase</code>名称（如<code>SomeClass</code>和<code>SomeStructure</code>这里）来匹配标准斯威夫特类型的资本（如<code>String</code>，<code>Int</code>和<code>Bool</code>）。相反，总是给属性和方法<code>lowerCamelCase</code>名称（如<code>frameRate</code>和<code>incrementCount</code>）来区分它们和类型名称。</p>
<p>下面是一个结构定义和类定义的例子：</p>
<ol>
<li><code>struct Resolution {</code></li>
<li><code>var width = 0</code></li>
<li><code>var height = 0</code></li>
<li><code>}</code></li>
<li><code>class VideoMode {</code></li>
<li><code>var resolution = Resolution()</code></li>
<li><code>var interlaced = false</code></li>
<li><code>var frameRate = 0.0</code></li>
<li><code>var name: String?</code></li>
<li><code>}</code></li>
</ol>
<p>上面的例子定义了一个称为的新结构<code>Resolution</code>来描述基于像素的显示分辨率。这个结构有两个存储的属性，称为<code>width</code>和<code>height</code>。存储属性是常量或变量，它们被捆绑并存储为类或结构的一部分。通过将这两个属性<code>Int</code>设置为初始整数值，可以将这两个属性推断为类型<code>0</code>。</p>
<p>上面的例子还定义了一个新类<code>VideoMode</code>，用于描述视频显示的特定视频模式。这个类有四个变量存储的属性。第一个，<code>resolution</code>是用一个新的<code>Resolution</code>结构实例初始化的，它推断出一个属性类型<code>Resolution</code>。对于其他三个属性，<code>VideoMode</code>将使用（意思是“非隔行视频”）<code>interlaced</code>设置来初始化新实例<code>false</code>，播放帧速率为<code>0.0</code>，以及可选<code>String</code>值为<code>name</code>。该<code>name</code>属性会自动给出默认值<code>nil</code>或“无<code>name</code>值”，因为它是可选类型。</p>
<h3 id="类和结构实例"><a href="#类和结构实例" class="headerlink" title="类和结构实例"></a>类和结构实例</h3><p>该<code>Resolution</code>结构定义和<code>VideoMode</code>类定义只说明什么<code>Resolution</code>或<code>VideoMode</code>看起来像。他们自己没有描述特定的分辨率或视频模式。要做到这一点，你需要创建一个结构或类的实例。</p>
<p>创建实例的语法对于结构和类都非常相似：</p>
<ol>
<li><code>let someResolution = Resolution()</code></li>
<li><code>let someVideoMode = VideoMode()</code></li>
</ol>
<p>结构和类都为新实例使用初始化语法。最简单的初始化语法形式使用类或名称的结构，后跟空括号，如<code>Resolution()</code>或<code>VideoMode()</code>。这将创建类或结构的新实例，并将任何属性初始化为默认值。类和结构初始化在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" target="_blank" rel="noopener">初始化</a>中有更详细的描述。</p>
<h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>您可以使用<em>点语法</em>访问实例的属性。在点语法中，可以在实例名称后面立即写入属性名称，并用句点（<code>.</code>）分隔，但不带任何空格：</p>
<ol>
<li><code>print(&quot;The width of someResolution is \(someResolution.width)&quot;)</code></li>
<li><code>// Prints &quot;The width of someResolution is 0&quot;</code></li>
</ol>
<p>在这个例子中，<code>someResolution.width</code>指的是<code>width</code>属性<code>someResolution</code>，并返回它的默认初始值<code>0</code>。</p>
<p>您可以深入查看子属性，例如a <code>width</code>属性中的<code>resolution</code>属性<code>VideoMode</code>：</p>
<ol>
<li><code>print(&quot;The width of someVideoMode is \(someVideoMode.resolution.width)&quot;)</code></li>
<li><code>// Prints &quot;The width of someVideoMode is 0&quot;</code></li>
</ol>
<p>您也可以使用点语法为变量属性指定一个新值：</p>
<ol>
<li><code>someVideoMode.resolution.width = 1280</code></li>
<li><code>print(&quot;The width of someVideoMode is now \(someVideoMode.resolution.width)&quot;)</code></li>
<li><code>// Prints &quot;The width of someVideoMode is now 1280&quot;</code></li>
</ol>
<p>注意与Objective-C不同的是，Swift使您能够直接设置结构属性的子属性。在上面的最后一个例子中，<code>width</code>属性<code>resolution</code>property <code>someVideoMode</code>是直接设置的，不需要将整个<code>resolution</code>属性设置为新值。</p>
<h3 id="结构类型的成员初始化程序"><a href="#结构类型的成员初始化程序" class="headerlink" title="结构类型的成员初始化程序"></a>结构类型的成员初始化程序</h3><p>所有结构都有一个自动生成的<em>成员初始化程序</em>，您可以使用它初始化新结构实例的成员属性。新实例属性的初始值可以按名称传递给成员初始值设定项：</p>
<ol>
<li><code>let vga = Resolution(width: 640, height: 480)</code></li>
</ol>
<p>与结构不同，类实例不会接收默认的成员初始值设定项。初始化中更详细地描述在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" target="_blank" rel="noopener">初始化</a>。</p>
<h3 id="结构和枚举是值类型"><a href="#结构和枚举是值类型" class="headerlink" title="结构和枚举是值类型"></a>结构和枚举是值类型</h3><p>甲<em>值类型</em>是一个类型，其值被<em>拷贝</em>时，它被分配给一个变量或常数，或当它被传递给函数。</p>
<p>在前面的章节中，您实际上已经广泛使用了值类型。事实上，Swift整数，浮点数，布尔值，字符串，数组和字典中的所有基本类型都是值类型，并在后台实现为结构。</p>
<p>所有结构和枚举都是Swift中的值类型。这意味着您创建的任何结构和枚举实例以及它们作为属性的任何值类型在您的代码中传递时总是被复制。</p>
<p>考虑这个例子，它使用<code>Resolution</code>了前面例子中的结构：</p>
<ol>
<li><code>let hd = Resolution(width: 1920, height: 1080)</code></li>
<li><code>var cinema = hd</code></li>
</ol>
<p>此示例声明了一个常量<code>hd</code>，并将其设置为使用<code>Resolution</code>全高清视频的宽度和高度（<code>1920</code>像素宽<code>1080</code>高像素）初始化的实例。</p>
<p>然后它声明一个变量<code>cinema</code>，并将其设置为当前值<code>hd</code>。因为<code>Resolution</code>是一个结构，现有实例的一个<em>副本</em>被创建，并且这个新副本被分配给<code>cinema</code>。虽然<code>hd</code>和<code>cinema</code>现在有相同的宽度和高度，他们是幕后两种完全不同的情况。</p>
<p>接下来，将<code>width</code>属性<code>cinema</code>修改为用于数字电影投影的宽度稍宽的2K标准（<code>2048</code>像素宽和<code>1080</code>像素高）：</p>
<ol>
<li><code>cinema.width = 2048</code></li>
</ol>
<p>检查<code>width</code>属性<code>cinema</code>显示它确实已更改为<code>2048</code>：</p>
<ol>
<li><code>print(&quot;cinema is now \(cinema.width) pixels wide&quot;)</code></li>
<li><code>// Prints &quot;cinema is now 2048 pixels wide&quot;</code></li>
</ol>
<p>但是，<code>width</code>原始<code>hd</code>实例的属性仍具有以下旧值<code>1920</code>：</p>
<ol>
<li><code>print(&quot;hd is still \(hd.width) pixels wide&quot;)</code></li>
<li><code>// Prints &quot;hd is still 1920 pixels wide&quot;</code></li>
</ol>
<p>当<code>cinema</code>给出当前值时<code>hd</code>，存储在其中的<em>值</em><code>hd</code>被复制到新<code>cinema</code>实例中。最终结果是两个完全分离的实例，它们恰好包含相同的数值。由于它们是单独的实例，因此设置宽度<code>cinema</code>以<code>2048</code>不影响存储的宽度<code>hd</code>。</p>
<p>相同的行为适用于枚举：</p>
<ol>
<li><code>enum CompassPoint {</code></li>
<li><code>case north, south, east, west</code></li>
<li><code>}</code></li>
<li><code>var currentDirection = CompassPoint.west</code></li>
<li><code>let rememberedDirection = currentDirection</code></li>
<li><code>currentDirection = .east</code></li>
<li><code>if rememberedDirection == .west {</code></li>
<li><code>print(&quot;The remembered direction is still .west&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;The remembered direction is still .west&quot;</code></li>
</ol>
<p>当<code>rememberedDirection</code>赋值的时候<code>currentDirection</code>，它实际上被设置为该值的一个副本。<code>currentDirection</code>此后更改此值不会影响存储在其中的原始值的副本<code>rememberedDirection</code>。</p>
<h3 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h3><p>与值类型不同，<em>引用类型</em>在分配给变量或常量时，或者传递给函数时<em>不会被</em>复制。而不是副本，而是使用对相同现有实例的引用。</p>
<p>下面是一个使用<code>VideoMode</code>上面定义的类的示例：</p>
<ol>
<li><code>let tenEighty = VideoMode()</code></li>
<li><code>tenEighty.resolution = hd</code></li>
<li><code>tenEighty.interlaced = true</code></li>
<li><code>tenEighty.name = &quot;1080i&quot;</code></li>
<li><code>tenEighty.frameRate = 25.0</code></li>
</ol>
<p>本示例声明了一个新的常量<code>tenEighty</code>，并将其设置为引用<code>VideoMode</code>该类的新实例。视频模式被分配的HD分辨率的副本，<code>1920</code>通过<code>1080</code>从之前。它被设置为隔行扫描，并被命名为<code>&quot;1080i&quot;</code>。最后，它被设置为<code>25.0</code>每秒帧数的帧速率。</p>
<p>接下来，<code>tenEighty</code>将其分配给一个新的常量，并调用<code>alsoTenEighty</code>帧速率<code>alsoTenEighty</code>：</p>
<ol>
<li><code>let alsoTenEighty = tenEighty</code></li>
<li><code>alsoTenEighty.frameRate = 30.0</code></li>
</ol>
<p>因为类是引用类型，<code>tenEighty</code>并且<code>alsoTenEighty</code>实际上都引用<em>同一个</em> <code>VideoMode</code>实例。实际上，它们只是同一个实例的两个不同名称。</p>
<p>检查<code>frameRate</code>属性<code>tenEighty</code>显示它正确报告<code>30.0</code>来自底层<code>VideoMode</code>实例的新帧速率：</p>
<ol>
<li><code>print(&quot;The frameRate property of tenEighty is now \(tenEighty.frameRate)&quot;)</code></li>
<li><code>// Prints &quot;The frameRate property of tenEighty is now 30.0&quot;</code></li>
</ol>
<p>请注意，<code>tenEighty</code>并<code>alsoTenEighty</code>声明为<em>常量</em>，而不是变量。但是，你仍然可以改变<code>tenEighty.frameRate</code>，<code>alsoTenEighty.frameRate</code>因为常量<code>tenEighty</code>和<code>alsoTenEighty</code>常量的值本身并没有改变。<code>tenEighty</code>并且<code>alsoTenEighty</code>它们自己不“存储” <code>VideoMode</code>实例 - 相反，它们都<em>指向</em><code>VideoMode</code>幕后的实例。它是<code>frameRate</code>底层的属性<code>VideoMode</code>被更改，而不是常量引用的值<code>VideoMode</code>。</p>
<h3 id="身份运营商"><a href="#身份运营商" class="headerlink" title="身份运营商"></a>身份运营商</h3><p>因为类是引用类型，所以多个常量和变量可以在幕后引用同一个类的单个实例。（结构和枚举也是如此，因为它们在分配给常量或变量或传递给函数时总是被复制。）</p>
<p>找出两个常量或变量是否指向一个类的完全相同的实例有时会很有用。为了实现这一点，Swift提供了两个身份运算符：</p>
<ul>
<li>与（<code>===</code>） 相同</li>
<li>与（<code>!==</code>） 不相同</li>
</ul>
<p>使用这些运算符来检查两个常量或变量是否引用同一个单一实例：</p>
<ol>
<li><code>if tenEighty === alsoTenEighty {</code></li>
<li><code>print(&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</code></li>
</ol>
<p>请注意，“与……相同”（用三个等号表示，或者<code>===</code>）并不等同于“等于”（用两个等号表示<code>==</code>）：</p>
<ul>
<li>“与……相同”表示类型的两个常量或变量指向完全相同的类实例。</li>
<li>“等于”意味着两个实例在值中被认为是“相等的”或“等价的”，对于类型的设计者定义的“相等”的某些适当的含义。</li>
</ul>
<p>当您定义自己的自定义类和结构时，您有责任决定两个“平等”实例的合格性。在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID45" target="_blank" rel="noopener">等价运算</a>符中描述定义您自己的“等于”和“不等于”运算<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID45" target="_blank" rel="noopener">符的实现的过程</a>。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>如果您有使用C，C ++或Objective-C的经验，您可能会知道这些语言使用<em>指针</em>来引用内存中的地址。引用某个引用类型的实例的Swift常量或变量类似于C中的指针，但不是指向内存中某个地址的直接指针，也不需要写一个asterisk（<code>*</code>）来指示您是创造一个参考。相反，这些引用是像Swift中的其他常量或变量一样定义的。</p>
<h3 id="选择类和结构"><a href="#选择类和结构" class="headerlink" title="选择类和结构"></a>选择类和结构</h3><p>您可以使用类和结构来定义自定义数据类型，以用作程序代码的构建块。</p>
<p>但是，结构实例总是按<em>值</em>传递，而类实例总是按<em>引用</em>传递。这意味着它们适合于不同类型的任务。在考虑项目所需的数据结构和功能时，请确定每个数据结构是应该定义为类还是结构。</p>
<p>作为一般指导原则，考虑在适用以下一个或多个条件时创建一个结构：</p>
<ul>
<li>该结构的主要目的是封装一些相对简单的数据值。</li>
<li>当您分配或传递该结构的实例时，期望封装值将被复制而不是引用是合理的。</li>
<li>结构存储的任何属性都是它们自己的值类型，也可能被复制而不是引用。</li>
<li>该结构不需要继承其他现有类型的属性或行为。</li>
</ul>
<p>良好的结构候选人的例子包括：</p>
<ul>
<li>几何形状的大小，也许封装一个<code>width</code>属性和一个<code>height</code>属性，都是类型<code>Double</code>。</li>
<li>一种引用一系列范围内的范围的方法，也许封装一个<code>start</code>属性和一个<code>length</code>属性，两者都是类型<code>Int</code>。</li>
<li>3D坐标系中的一个点，可能是封装<code>x</code>，<code>y</code>以及<code>z</code>每个类型的属性<code>Double</code>。</li>
</ul>
<p>在所有其他情况下，定义一个类，并创建该类的实例，以便通过引用进行管理和传递。实际上，这意味着大多数自定义数据结构应该是类而不是结构。</p>
<h3 id="字符串，数组和字典的赋值和复制行为"><a href="#字符串，数组和字典的赋值和复制行为" class="headerlink" title="字符串，数组和字典的赋值和复制行为"></a>字符串，数组和字典的赋值和复制行为</h3><p>在夫特，许多基本的数据类型，如<code>String</code>，<code>Array</code>以及<code>Dictionary</code>被实现为结构。这意味着如果将字符串，数组和字典等数据分配给新的常量或变量，或者将它们传递给函数或方法时，它们将被复制。</p>
<p>此行为是不同的基金：<code>NSString</code>，<code>NSArray</code>，和<code>NSDictionary</code>为类，而不是结构来实现。基金会中的字符串，数组和字典始终作为对现有实例的引用进行分配和传递，而不是作为副本。</p>
<p>注意上面的描述涉及字符串，数组和字典的“复制”。您在代码中看到的行为将始终像发生副本一样。但是，当绝对必要时，Swift仅在幕后执行<em>实际的</em>副本。Swift管理所有值复制以确保最佳性能，并且您不应该避免分配尝试抢占此优化。</p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145" target="_blank" rel="noopener">枚举</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254" target="_blank" rel="noopener">属性</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> apple </tag>
            
            <tag> struct </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[枚举enum]]></title>
      <url>/2018/05/07/%E6%9E%9A%E4%B8%BEenum/</url>
      <content type="html"><![CDATA[<p>##</p>
<p>一个<em>枚举</em>定义了一个通用型的一组相关的值，使你在你的代码中的一个类型安全的方式这些值来工作。</p>
<p>如果您熟悉C，您将知道C枚举将相关名称分配给一组整数值。Swift中的枚举更加灵活，并且不必为枚举的每种情况提供值。如果一个值（被称为“原始”的值）<em>被</em>提供给每个枚举的情况下，该值可以是一个字符串，一个字符，或任何整数的值或者浮点型。</p>
<p>或者，枚举案例可以指定与每个不同案例值一起存储的<em>任何</em>类型的关联值，这与联合会或变体在其他语言中的做法非常相似。您可以将一组相关案例定义为一个枚举的一部分，其中每个案例都有一组与其相关的适当类型的值。</p>
<p>Swift中的枚举本身就是一流的类型。它们采用了传统上仅由类支持的许多功能，例如计算属性以提供有关枚举的当前值的附加信息，以及提供与枚举所代表的值相关的功能的实例方法。枚举还可以定义初始化器以提供初始案例值; 可以扩展到超出其原始实现范围的功能; 并且可以符合协议以提供标准功能。<br><a id="more"></a><br>有关这些功能的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254" target="_blank" rel="noopener">属性</a>，<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234" target="_blank" rel="noopener">方法</a>，<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" target="_blank" rel="noopener">初始化</a>，<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" target="_blank" rel="noopener">扩展</a>和<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="noopener">协议</a>。</p>
<h3 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h3><p>您可以使用<code>enum</code>关键字引入枚举并将其整个定义放在一对大括号中：</p>
<ol>
<li><code>enum SomeEnumeration {</code></li>
<li><code>// enumeration definition goes here</code></li>
<li><code>}</code></li>
</ol>
<p>以下是一个指南针四个要点的例子：</p>
<ol>
<li><code>enum CompassPoint {</code></li>
<li><code>case north</code></li>
<li><code>case south</code></li>
<li><code>case east</code></li>
<li><code>case west</code></li>
<li><code>}</code></li>
</ol>
<p>在枚举定义的值（例如<code>north</code>，<code>south</code>，<code>east</code>，和<code>west</code>）是其<em>枚举的情况下</em>。您使用<code>case</code>关键字来引入新的枚举案例。</p>
<p>注意与C和Objective-C不同，Swift枚举案例在创建时未被赋予默认的整数值。在<code>CompassPoint</code>上面的例子，<code>north</code>，<code>south</code>，<code>east</code>和<code>west</code>不等于隐式<code>0</code>，<code>1</code>，<code>2</code>和<code>3</code>。相反，不同的枚举案例本身就是完全成熟的值，具有明确定义的类型<code>CompassPoint</code>。</p>
<p>多个案例可以在一行中出现，用逗号分隔：</p>
<ol>
<li><code>enum Planet {</code></li>
<li><code>case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune</code></li>
<li><code>}</code></li>
</ol>
<p>每个枚举定义都定义了一种全新的类型。像Swift中的其他类型一样，它们的名称（例如<code>CompassPoint</code>和<code>Planet</code>）应该以大写字母开头。给枚举类型单数而不是复数名称，以便他们阅读不言自明：</p>
<ol>
<li><code>var directionToHead = CompassPoint.west</code></li>
</ol>
<p><code>directionToHead</code>使用其中一个可能值进行初始化时 ，会推断出该类型<code>CompassPoint</code>。一旦<code>directionToHead</code>声明为a <code>CompassPoint</code>，您可以<code>CompassPoint</code>使用较短的点语法将其设置为不同的值：</p>
<ol>
<li><code>directionToHead = .east</code></li>
</ol>
<p>类型<code>directionToHead</code>是已知的，因此您可以在设置其值时删除该类型。这使得在使用显式类型的枚举值时具有高度可读的代码。</p>
<h3 id="用枚举语句匹配枚举值"><a href="#用枚举语句匹配枚举值" class="headerlink" title="用枚举语句匹配枚举值"></a>用枚举语句匹配枚举值</h3><p>您可以将单个枚举值与一个<code>switch</code>语句进行匹配：</p>
<ol>
<li><code>directionToHead = .south</code></li>
<li><code>switch directionToHead {</code></li>
<li><code>case .north:</code></li>
<li><code>print(&quot;Lots of planets have a north&quot;)</code></li>
<li><code>case .south:</code></li>
<li><code>print(&quot;Watch out for penguins&quot;)</code></li>
<li><code>case .east:</code></li>
<li><code>print(&quot;Where the sun rises&quot;)</code></li>
<li><code>case .west:</code></li>
<li><code>print(&quot;Where the skies are blue&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;Watch out for penguins&quot;</code></li>
</ol>
<p>你可以阅读这段代码：</p>
<p>“考虑价值<code>directionToHead</code>。在它相等的情况下<code>.north</code>，打印<code>&quot;Lots of planets have a north&quot;</code>。在它相等的情况下<code>.south</code>，打印<code>&quot;Watch out for penguins&quot;</code>。“</p>
<p>…等等。</p>
<p>如<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" target="_blank" rel="noopener">控制流程中所述</a>，<code>switch</code>在考虑枚举的情况下，声明必须是详尽的。如果省略了<code>case</code>for <code>.west</code>，则此代码不会编译，因为它不考虑完整的<code>CompassPoint</code>案例列表。要求详尽无遗确保枚举案件不会被意外省略。</p>
<p>如果不适合<code>case</code>为每个枚举案例提供一个案例，则可以提供一个<code>default</code>案例来涵盖任何未明确解决的案例：</p>
<ol>
<li><code>let somePlanet = Planet.earth</code></li>
<li><code>switch somePlanet {</code></li>
<li><code>case .earth:</code></li>
<li><code>print(&quot;Mostly harmless&quot;)</code></li>
<li><code>default:</code></li>
<li><code>print(&quot;Not a safe place for humans&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;Mostly harmless&quot;</code></li>
</ol>
<h3 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h3><p>上一节中的示例显示了枚举的情况是如何定义（和键入）的值。您可以设置一个常量或变量<code>Planet.earth</code>，并在稍后检查该值。但是，能够在这些案例值旁边存储其他类型的<em>关联值</em>有时很有用。这使您可以将额外的自定义信息与案例值一起存储，并且每次在代码中使用该案例时都会允许此信息发生变化。</p>
<p>您可以定义Swift枚举来存储任何给定类型的关联值，并且如果需要，值类型对于枚举的每种情况都可以不同。与这些枚举类似的枚举被称为<em>区分联合</em>，<em>标记联合</em>或其他编程语言的<em>变体</em>。</p>
<p>例如，假设库存跟踪系统需要通过两种不同类型的条形码跟踪产品。某些产品以UPC格式标记有一维条形码，该格式使用数字<code>0</code>来表示<code>9</code>。每个条形码都有一个“数字系统”数字，随后是五个“制造商代码”数字和五个“产品代码”数字。这些后面跟着一个“检查”数字以验证代码已被正确扫描：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png" alt="图片：../Art/barcode_UPC_2x.png"></p>
<p>其他产品采用QR码格式的二维条码进行标注，可以使用任何ISO 8859-1字符，并且可以编码长达2,953个字符的字符串：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png" alt="image：../Art/barcode_QR_2x.png"></p>
<p>库存跟踪系统可以方便地将UPC条形码存储为四个整数的元组，并将QR码条形码存储为任意长度的字符串。</p>
<p>在Swift中，用于定义任一类型的产品条形码的枚举可能如下所示：</p>
<ol>
<li><code>enum Barcode {</code></li>
<li><code>case upc(Int, Int, Int, Int)</code></li>
<li><code>case qrCode(String)</code></li>
<li><code>}</code></li>
</ol>
<p>这可以理解为：</p>
<p>“定义称为枚举类型<code>Barcode</code>，它可以采取任何的值<code>upc</code>与式（的相关值<code>Int</code>，<code>Int</code>，<code>Int</code>，<code>Int</code>），或的值<code>qrCode</code>与类型的相关联的值<code>String</code>。”</p>
<p>该定义不提供任何实际值<code>Int</code>或<code>String</code>值 - 它只是定义常量和变量在等于或时可以存储的关联值的<em>类型</em>。<code>Barcode``Barcode.upc``Barcode.qrCode</code></p>
<p>然后可以使用以下任一类型创建新的条形码：</p>
<ol>
<li><code>var productBarcode = Barcode.upc(8, 85909, 51226, 3)</code></li>
</ol>
<p>这个例子创建一个新的变量，<code>productBarcode</code>并为它赋值<code>Barcode.upc</code>一个关联的元组值<code>(8, 85909, 51226, 3)</code>。</p>
<p>相同的产品可以分配不同类型的条形码：</p>
<ol>
<li><code>productBarcode = .qrCode(&quot;ABCDEFGHIJKLMNOP&quot;)</code></li>
</ol>
<p>此时，原始<code>Barcode.upc</code>值及其整数值将由新<code>Barcode.qrCode</code>值及其字符串值替换。类型的常量和变量<code>Barcode</code>可以存储a <code>.upc</code>或a <code>.qrCode</code>（以及它们的关联值），但是它们只能在任何给定时间存储其中的一个。</p>
<p>像以前一样，可以使用switch语句检查不同的条形码类型。但是，这次可以将关联的值作为switch语句的一部分提取出来。您可以将每个关联值提取为一个常量（带<code>let</code>前缀）或一个变量（带<code>var</code>前缀）以便在<code>switch</code>案例正文中使用：</p>
<ol>
<li><code>switch productBarcode {</code></li>
<li><code>case .upc(let numberSystem, let manufacturer, let product, let check):</code></li>
<li><code>print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)</code></li>
<li><code>case .qrCode(let productCode):</code></li>
<li><code>print(&quot;QR code: \(productCode).&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;QR code: ABCDEFGHIJKLMNOP.&quot;</code></li>
</ol>
<p>如果枚举案例的所有关联值都被提取为常量，或者全部提取为变量，则为简洁起见，您可以在案例名称之前放置一个<code>var</code>或<code>let</code>注释。</p>
<ol>
<li><code>switch productBarcode {</code></li>
<li><code>case let .upc(numberSystem, manufacturer, product, check):</code></li>
<li><code>print(&quot;UPC : \(numberSystem), \(manufacturer), \(product), \(check).&quot;)</code></li>
<li><code>case let .qrCode(productCode):</code></li>
<li><code>print(&quot;QR code: \(productCode).&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;QR code: ABCDEFGHIJKLMNOP.&quot;</code></li>
</ol>
<h3 id="原始价值"><a href="#原始价值" class="headerlink" title="原始价值"></a>原始价值</h3><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID148" target="_blank" rel="noopener">关联值</a>中 的条形码示例显示枚举的案例如何声明它们存储不同类型的关联值。作为关联值的替代，枚举案例可以预先填充所有相同类型的默认值（称为<em>原始值</em>）。</p>
<p>下面是一个例子，它将原始ASCII值与名为枚举的情况一起存储：</p>
<ol>
<li><code>enum ASCIIControlCharacter: Character {</code></li>
<li><code>case tab = &quot;\t&quot;</code></li>
<li><code>case lineFeed = &quot;\n&quot;</code></li>
<li><code>case carriageReturn = &quot;\r&quot;</code></li>
<li><code>}</code></li>
</ol>
<p>这里，调用的枚举的原始值<code>ASCIIControlCharacter</code>被定义为类型<code>Character</code>，并被设置为一些更常见的ASCII控制字符。<code>Character</code>值在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285" target="_blank" rel="noopener">字符串和字符</a>中描述。</p>
<p>原始值可以是字符串，字符或任何整数或浮点数类型。每个原始值在其枚举声明中必须是唯一的。</p>
<p>注意原始值是<em>不</em>一样的关联值。当您首先在您的代码中定义枚举时，将原始值设置为预填充值，如上面的三个ASCII代码。特定枚举个案的原始值始终相同。当您根据某个枚举的情况创建新的常量或变量时，会设置关联值，并且每次执行此操作时都会有所不同。</p>
<h3 id="隐式分配的原始值"><a href="#隐式分配的原始值" class="headerlink" title="隐式分配的原始值"></a>隐式分配的原始值</h3><p>当您使用存储整数或字符串原始值的枚举时，不必为每个个案明确分配一个原始值。当你不这样做时，Swift会自动为你分配值。</p>
<p>例如，当整数用于原始值时，每种情况的隐含值比前一种情况多一个。如果第一个案例没有设置值，则其值为<code>0</code>。</p>
<p>下面的枚举是前面<code>Planet</code>枚举的一个改进，用整数原始值来表示每个行星从太阳的顺序：</p>
<ol>
<li><code>enum Planet: Int {</code></li>
<li><code>case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune</code></li>
<li><code>}</code></li>
</ol>
<p>在上面的例子中，<code>Planet.mercury</code>有一个明确的原始值<code>1</code>，<code>Planet.venus</code>有一个隐含的原始值<code>2</code>，等等。</p>
<p>当字符串用于原始值时，每个案例的隐含值是该案例名称的文本。</p>
<p>下面的枚举是对前面<code>CompassPoint</code>枚举的改进，用字符串原始值来表示每个方向的名称：</p>
<ol>
<li><code>enum CompassPoint: String {</code></li>
<li><code>case north, south, east, west</code></li>
<li><code>}</code></li>
</ol>
<p>在上面的例子中，<code>CompassPoint.south</code>有一个隐含的原始值<code>&quot;south&quot;</code>，等等。</p>
<p>您可以使用其<code>rawValue</code>属性访问枚举个案的原始值：</p>
<ol>
<li><code>let earthsOrder = Planet.earth.rawValue</code></li>
<li><code>// earthsOrder is 3</code></li>
<li><code></code></li>
<li><code>let sunsetDirection = CompassPoint.west.rawValue</code></li>
<li><code>// sunsetDirection is &quot;west&quot;</code></li>
</ol>
<h3 id="从原始值初始化"><a href="#从原始值初始化" class="headerlink" title="从原始值初始化"></a>从原始值初始化</h3><p>如果使用原始值类型定义枚举，则枚举将自动接收一个初始值设定项，该初始值设定项将采用原始值类型的值（作为参数调用<code>rawValue</code>）并返回枚举大小写或<code>nil</code>。您可以使用此初始化程序尝试创建枚举的新实例。</p>
<p>这个例子确定了天王星的原始价值<code>7</code>：</p>
<ol>
<li><code>let possiblePlanet = Planet(rawValue: 7)</code></li>
<li><code>// possiblePlanet is of type Planet? and equals Planet.uranus</code></li>
</ol>
<p>但是，并非所有可能的<code>Int</code>值都会找到匹配的行星。因此，原始值初始值设定项始终返回一个<em>可选的</em>枚举大小写。在上面的例子中，<code>possiblePlanet</code>是类型的<code>Planet?</code>，或者是“可选的” <code>Planet</code>。</p>
<p>注意原始值初始化器是一个可分解的初始化器，因为不是每个原始值都会返回一个枚举大小写。有关更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID376" target="_blank" rel="noopener">Failable Initializers</a>。</p>
<p>如果您尝试找到位置为的行星，则由原始值初始值设定项返回<code>11</code>的可选<code>Planet</code>值将为<code>nil</code>：</p>
<ol>
<li><code>let positionToFind = 11</code></li>
<li><code>if let somePlanet = Planet(rawValue: positionToFind) {</code></li>
<li><code>switch somePlanet {</code></li>
<li><code>case .earth:</code></li>
<li><code>print(&quot;Mostly harmless&quot;)</code></li>
<li><code>default:</code></li>
<li><code>print(&quot;Not a safe place for humans&quot;)</code></li>
<li><code>}</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;There isn&#39;t a planet at position \(positionToFind)&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;There isn&#39;t a planet at position 11&quot;</code></li>
</ol>
<p>该示例使用可选绑定来尝试访问原始值为的行星<code>11</code>。该语句<code>if let somePlanet = Planet(rawValue: 11)</code>创建一个可选项<code>Planet</code>，如果可以检索<code>somePlanet</code>，<code>Planet</code>则设置为该可选项的值。在这种情况下，这是不可能检索星球的位置<code>11</code>，因此<code>else</code>，转而执行分支。</p>
<h3 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h3><p>甲<em>递归枚举</em>是具有枚举作为一个或一个以上的枚举案件相关联的值的另一个实例的枚举。您通过<code>indirect</code>在它之前写入来指示枚举案例是递归的，这会告诉编译器插入必要的间接层。</p>
<p>例如，下面是一个存储简单算术表达式的枚举：</p>
<ol>
<li><code>enum ArithmeticExpression {</code></li>
<li><code>case number(Int)</code></li>
<li><code>indirect case addition(ArithmeticExpression, ArithmeticExpression)</code></li>
<li><code>indirect case multiplication(ArithmeticExpression, ArithmeticExpression)</code></li>
<li><code>}</code></li>
</ol>
<p>您也可以<code>indirect</code>在枚举开始之前写入，以启用所有枚举的具有关联值的情况的间接寻址：</p>
<ol>
<li><code>indirect enum ArithmeticExpression {</code></li>
<li><code>case number(Int)</code></li>
<li><code>case addition(ArithmeticExpression, ArithmeticExpression)</code></li>
<li><code>case multiplication(ArithmeticExpression, ArithmeticExpression)</code></li>
<li><code>}</code></li>
</ol>
<p>该枚举可以存储三种算术表达式：一个普通数，两个表达式的相加，以及两个表达式的相乘。这些<code>addition</code>和<code>multiplication</code>关联的值具有相关的值，这些值也是算术表达式 - 这些关联值可以嵌套表达式。例如，表达式<code>(5 + 4) * 2</code>在乘法的右侧有一个数字，在乘法的左侧有另一个表达式。因为数据是嵌套的，所以用于存储数据的枚举也需要支持嵌套 - 这意味着枚举需要递归。下面的代码显示了为以下内容<code>ArithmeticExpression</code>创建的递归枚举<code>(5 + 4) * 2</code>：</p>
<ol>
<li><code>let five = ArithmeticExpression.number(5)</code></li>
<li><code>let four = ArithmeticExpression.number(4)</code></li>
<li><code>let sum = ArithmeticExpression.addition(five, four)</code></li>
<li><code>let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))</code></li>
</ol>
<p>递归函数是处理具有递归结构的数据的直接方式。例如，以下是一个评估算术表达式的函数：</p>
<ol>
<li><code>func evaluate(_ expression: ArithmeticExpression) -&gt; Int {</code></li>
<li><code>switch expression {</code></li>
<li><code>case let .number(value):</code></li>
<li><code>return value</code></li>
<li><code>case let .addition(left, right):</code></li>
<li><code>return evaluate(left) + evaluate(right)</code></li>
<li><code>case let .multiplication(left, right):</code></li>
<li><code>return evaluate(left) * evaluate(right)</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>print(evaluate(product))</code></li>
<li><code>// Prints &quot;18&quot;</code></li>
</ol>
<p>该函数通过简单地返回关联值来评估普通数字。它通过评估左侧的表达式，评估右侧的表达式，然后添加它们或将它们相乘来评估加法或乘法。</p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94" target="_blank" rel="noopener">关闭</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82" target="_blank" rel="noopener">类和结构</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> apple </tag>
            
            <tag> enum </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Closures闭包]]></title>
      <url>/2018/05/07/Closures%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>##</p>
<p><em>闭包</em>是自包含的功能块，可以在代码中传递和使用。Swift中的闭包与C和Objective-C中的块以及其他编程语言中的lambda类似。</p>
<p>闭包可以从定义的上下文中捕获和存储对任何常量和变量的引用。这被称为<em>关闭</em>那些常量和变量。Swift处理所有为你捕获的内存管理。</p>
<p>注意如果您不熟悉捕捉概念，请不要担心。它在下面的<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID103" target="_blank" rel="noopener">捕获值</a>中有详细的解释。</p>
<p>在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158" target="_blank" rel="noopener">函数中</a>引入的全局函数和嵌套函数实际上是闭包的特例。闭包采取以下三种形式之一：<br><a id="more"></a></p>
<ul>
<li>全局函数是具有名称并且不捕获任何值的闭包。</li>
<li>嵌套函数是具有名称的闭包，可以从其封闭函数中捕获值。</li>
<li>Closure表达式是以轻量级语法编写的未命名的闭包，可以捕获周围环境中的值。</li>
</ul>
<p>Swift的闭包表达式具有干净清晰的风格，优化可以在常见场景中促进简洁，无混乱的语法。这些优化包括：</p>
<ul>
<li>从上下文中推断参数和返回值类型</li>
<li>来自单表达式闭包的隐式返回</li>
<li>速记参数名称</li>
<li>尾随闭包语法</li>
</ul>
<h3 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h3><p>嵌套函数中引入的<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID178" target="_blank" rel="noopener">嵌套函数</a>是一种方便的方式，可以将自包含的代码块作为更大函数的一部分进行命名和定义。但是，编写较短版本的类似功能的结构（没有完整的声明和名称）有时很有用。当您使用将函数作为一个或多个参数的函数或方法时，尤其如此。</p>
<p><em>Closure表达式</em>是一种用简短的聚焦语法编写内联闭包的方法。闭包表达式提供了几种语法优化，用于以缩写形式编写闭包，而不会损失清晰度或意图。下面的闭包表达式示例通过<code>sorted(by:)</code>在几次迭代中完善该方法的单个示例来说明这些优化，每个迭代都以更简洁的方式表达相同的功能。</p>
<h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><p>Swift的标准库提供了一种称为的方法<code>sorted(by:)</code>，该方法根据您提供的排序闭包的输出对已知类型的值数组进行排序。一旦完成排序过程，该<code>sorted(by:)</code>方法将返回一个与旧的相同类型和大小的新数组，其元素按正确的排序顺序排列。原始数组不被该<code>sorted(by:)</code>方法修改。</p>
<p>下面的闭包表达式示例使用该<code>sorted(by:)</code>方法以<code>String</code>反向字母顺序对值数组进行排序。这是要排序的初始数组：</p>
<ol>
<li><code>let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</code></li>
</ol>
<p>该<code>sorted(by:)</code>方法接受一个闭包，该闭包接受与数组内容相同类型的两个参数，并返回一个<code>Bool</code>值，表示在排序值后第一个值应该出现在第二个值之前还是之后。<code>true</code>如果第一个值应该出现<em>在</em>第二个值<em>之前</em>，则排序闭包需要返回，<code>false</code>否则。</p>
<p>这个例子是排序<code>String</code>值的数组，因此排序闭包需要是类型的函数<code>(String, String) -&gt; Bool</code>。</p>
<p>提供排序闭包的一种方法是编写正确类型的正常函数，并将其作为参数传递给<code>sorted(by:)</code>方法：</p>
<ol>
<li><code>func backward(_ s1: String, _ s2: String) -&gt; Bool {</code></li>
<li><code>return s1 &gt; s2</code></li>
<li><code>}</code></li>
<li><code>var reversedNames = names.sorted(by: backward)</code></li>
<li><code>// reversedNames is equal to [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</code></li>
</ol>
<p>如果第一个字符串（<code>s1</code>）大于第二个字符串（<code>s2</code>），则该<code>backward(_:_:)</code>函数将返回<code>true</code>，指示<code>s1</code>应<code>s2</code>在排序数组之前出现。对于字符串中的字符，“大于”意味着“字母后面出现比”。这意味着该字母<code>&quot;B&quot;</code>“大于”该字母<code>&quot;A&quot;</code>，并且该字符串<code>&quot;Tom&quot;</code>大于该字符串<code>&quot;Tim&quot;</code>。这给出了一个反向字母排序，<code>&quot;Barry&quot;</code>放在之前<code>&quot;Alex&quot;</code>，等等。</p>
<p>然而，这是写一个基本上是单表达式函数（<code>a &gt; b</code>）的相当冗长的方法。在这个例子中，最好使用闭包表达式语法来内联编写排序闭包。</p>
<h3 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h3><p>Closure表达式语法具有以下一般形式：</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;（参数） - &gt; 返回类型 在</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该<em>参数</em>在封闭表达式语法可以在输出参数，但是他们不能有一个默认值。如果命名可变参数，可以使用变量参数。元组也可以用作参数类型和返回类型。</p>
<p>下面的例子显示了<code>backward(_:_:)</code>上面函数的闭包表达式版本：</p>
<ol>
<li><code>reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in</code></li>
<li><code>return s1 &gt; s2</code></li>
<li><code>})</code></li>
</ol>
<p>请注意，此内联关闭的参数声明和返回类型与<code>backward(_:_:)</code>函数声明相同。在这两种情况下，它都被写为<code>(s1: String, s2: String) -&gt; Bool</code>。但是，对于内联闭包表达式，参数和返回类型写<em>在</em>花括号内，而不是外部。</p>
<p><code>in</code>关键字 引入了封闭体的开始。这个关键字表示闭包的参数和返回类型的定义已经完成，闭包的主体即将开始。</p>
<p>由于封闭体的体积非常短，所以它甚至可以写在一行上：</p>
<ol>
<li><code>reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )</code></li>
</ol>
<p>这说明对该方法的整体调用<code>sorted(by:)</code>保持不变。一对圆括号仍然包含了该方法的整个参数。但是，这个论点现在是一个内联关闭。</p>
<h3 id="从上下文推断类型"><a href="#从上下文推断类型" class="headerlink" title="从上下文推断类型"></a>从上下文推断类型</h3><p>因为排序闭包作为参数传递给方法，所以Swift可以推断它的参数类型和它返回的值的类型。该<code>sorted(by:)</code>方法在一个字符串数组上被调用，所以它的参数必须是一个类型的函数<code>(String, String) -&gt; Bool</code>。这意味着<code>(String, String)</code>和<code>Bool</code>类型不需要被写为闭包表达式定义的一部分。由于可以推断所有类型，<code>-&gt;</code>因此也可以省略返回箭头（）和参数名称周围的括号。</p>
<ol>
<li><code>reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )</code></li>
</ol>
<p>在将闭包作为内联闭包表达式传递给函数或方法时，始终可以推断参数类型和返回类型。因此，当闭包用作函数或方法参数时，您绝不需要以最充分的形式编写内联闭包。</p>
<p>尽管如此，如果您愿意的话，仍然可以明确类型，如果避免代码读者含糊不清，那么可以这样做。在该<code>sorted(by:)</code>方法的情况下，封闭的目的从排序发生的事实中清晰可见，并且读者认为封闭可能与<code>String</code>值一起工作是安全的，因为它正在协助排序的字符串数组。</p>
<h3 id="来自单表达式闭包的隐式返回"><a href="#来自单表达式闭包的隐式返回" class="headerlink" title="来自单表达式闭包的隐式返回"></a>来自单表达式闭包的隐式返回</h3><p>单个表达式闭包可以通过<code>return</code>从声明中省略关键字来隐式地返回单个表达式的结果，就像前面示例的这个版本一样：</p>
<ol>
<li><code>reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )</code></li>
</ol>
<p>在这里，<code>sorted(by:)</code>方法参数的函数类型清楚地表明一个<code>Bool</code>值必须由闭包返回。因为闭包的主体包含一个<code>s1 &gt; s2</code>返回<code>Bool</code>值的单个表达式（），所以没有歧义，<code>return</code>关键字可以省略。</p>
<h3 id="速记参数名称"><a href="#速记参数名称" class="headerlink" title="速记参数名称"></a>速记参数名称</h3><p>雨燕自动提供速记参数名内联闭包，它可以使用的名称，指的是关闭的参数值<code>$0</code>，<code>$1</code>，<code>$2</code>，等等。</p>
<p>如果在闭包表达式中使用这些简写参数名称，则可以从其定义中省略闭包的参数列表，并且将从预期的函数类型中推断简写参数名称的数量和类型。的<code>in</code>关键字也可以被省略，因为封闭件表达是由完全其身体的：</p>
<ol>
<li><code>reversedNames = names.sorted(by: { $0 &gt; $1 } )</code></li>
</ol>
<p>在这里，<code>$0</code>并<code>$1</code>请参阅关闭的第一和第二个<code>String</code>参数。</p>
<h3 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h3><p>实际上有一个更<em>短的</em>方法来编写上面的闭包表达式。Swift的<code>String</code>类型定义了它<code>&gt;</code>作为具有两个类型参数的方法的大于运算符（）的字符串特定实现<code>String</code>，并返回一个类型值<code>Bool</code>。这与该方法所需的方法类型完全匹配<code>sorted(by:)</code>。因此，你可以简单地传入大于运算符，Swift会推断你想使用它的字符串特定实现：</p>
<ol>
<li><code>reversedNames = names.sorted(by: &gt;)</code></li>
</ol>
<p>欲了解更多有关操作方法，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID42" target="_blank" rel="noopener">操作方法</a>。</p>
<h3 id="追踪关闭"><a href="#追踪关闭" class="headerlink" title="追踪关闭"></a>追踪关闭</h3><p>如果需要将闭包表达式作为函数的最终参数传递给函数，并且闭包表达式很长，那么将其作为<em>尾部闭包</em>编写可能会很有用。尾随闭包在函数调用的括号后面写入，尽管它仍然是该函数的参数。在使用尾随闭包语法时，不要将闭包的参数标签作为函数调用的一部分写入。</p>
<ol>
<li><code>func someFunctionThatTakesAClosure(closure: () -&gt; Void) {</code></li>
<li><code>// function body goes here</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>// Here&#39;s how you call this function without using a trailing closure:</code></li>
<li><code></code></li>
<li><code>someFunctionThatTakesAClosure(closure: {</code></li>
<li><code>// closure&#39;s body goes here</code></li>
<li><code>})</code></li>
<li><code></code></li>
<li><code>// Here&#39;s how you call this function with a trailing closure instead:</code></li>
<li><code></code></li>
<li><code>someFunctionThatTakesAClosure() {</code></li>
<li><code>// trailing closure&#39;s body goes here</code></li>
<li><code>}</code></li>
</ol>
<p>上面 的<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID97" target="_blank" rel="noopener">Closure Expression Syntax</a>部分的字符串排序闭<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID97" target="_blank" rel="noopener">包</a>可以在<code>sorted(by:)</code>方法的括号之外写为尾部闭包：</p>
<ol>
<li><code>reversedNames = names.sorted() { $0 &gt; $1 }</code></li>
</ol>
<p>如果将闭包表达式作为函数或方法的唯一参数提供，并且将该表达式作为尾随闭包提供，那么<code>()</code>在调用该函数时，无需在函数或方法名称后面编写一对括号。</p>
<ol>
<li><code>reversedNames = names.sorted { $0 &gt; $1 }</code></li>
</ol>
<p>当封闭足够长以至于不可能将它写在一行上时，尾随封闭非常有用。作为一个例子，Swift的<code>Array</code>类型有一个<code>map(_:)</code>方法，它将一个闭包表达式作为其单个参数。对于数组中的每个项目都调用一次闭包，并为该项目返回一个替代映射值（可能是某种其他类型）。映射的性质和返回值的类型留给闭包来指定。</p>
<p>将提供的闭包应用于每个数组元素后，该<code>map(_:)</code>方法返回一个包含所有新映射值的新数组，其顺序与原始数组中的相应值相同。</p>
<p>以下是如何使用<code>map(_:)</code>具有尾随闭包的方法将<code>Int</code>值数组转换为值数组<code>String</code>。该数组<code>[16, 58, 510]</code>用于创建新数组<code>[&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code>：</p>
<ol>
<li><code>let digitNames = [</code></li>
<li><code>0: &quot;Zero&quot;, 1: &quot;One&quot;, 2: &quot;Two&quot;,   3: &quot;Three&quot;, 4: &quot;Four&quot;,</code></li>
<li><code>5: &quot;Five&quot;, 6: &quot;Six&quot;, 7: &quot;Seven&quot;, 8: &quot;Eight&quot;, 9: &quot;Nine&quot;</code></li>
<li><code>]</code></li>
<li><code>let numbers = [16, 58, 510]</code></li>
</ol>
<p>上面的代码创建了一个整数数字和英文版名称之间映射的字典。它还定义了一个整数数组，可以将其转换为字符串。</p>
<p>您现在可以使用该<code>numbers</code>数组创建一个<code>String</code>值数组，方法是将闭包表达式<code>map(_:)</code>作为尾部闭包传递给数组的方法：</p>
<ol>
<li><code>let strings = numbers.map { (number) -&gt; String in</code></li>
<li><code>var number = number</code></li>
<li><code>var output = &quot;&quot;</code></li>
<li><code>repeat {</code></li>
<li><code>output = digitNames[number % 10]! + output</code></li>
<li><code>number /= 10</code></li>
<li><code>} while number &gt; 0</code></li>
<li><code>return output</code></li>
<li><code>}</code></li>
<li><code>// strings is inferred to be of type [String]</code></li>
<li><code>// its value is [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code></li>
</ol>
<p>该<code>map(_:)</code>方法为数组中的每个项调用闭包表达式一次。您不需要指定闭包的输入参数<code>number</code>的类型，因为可以从要映射的数组中的值中推断出该类型。</p>
<p>在这个例子中，变量<code>number</code>是用闭包<code>number</code>参数的值初始化的，这样就可以在闭包体中修改该值。（函数和闭包的参数始终是常量。）闭包表达式还指定返回类型<code>String</code>，以指示将存储在映射的输出数组中的类型。</p>
<p>闭包表达式会在<code>output</code>每次调用时创建一个字符串。它<code>number</code>使用余数运算符（<code>number % 10</code>）计算最后一位数字，并使用此数字在<code>digitNames</code>字典中查找适当的字符串。闭包可以用来创建任何大于零的整数的字符串表示。</p>
<p>注意对<code>digitNames</code>字典下标的调用后面跟着一个感叹号（<code>!</code>），因为字典下标返回一个可选值，表示如果该键不存在，字典查找可能会失败。在上面的例子中，保证字典<code>number % 10</code>总是一个有效的下标键<code>digitNames</code>，因此使用感叹号来强制解开<code>String</code>存储在下标可选返回值中的值。</p>
<p>从检索到的字符串<code>digitNames</code>辞典被添加到<em>前面</em>的<code>output</code>，有效地建立反向一数目的字符串版本。（该表达式<code>number % 10</code>给出了<code>6</code>for <code>16</code>，<code>8</code>for <code>58</code>和<code>0</code>for的值<code>510</code>。）</p>
<p><code>number</code>然后 这个变量除以<code>10</code>。因为它是一个整数，它在划分期间被舍入，所以<code>16</code>变成<code>1</code>，<code>58</code>变成<code>5</code>，<code>510</code>变成<code>51</code>。</p>
<p>重复该过程直至<code>number</code>等于<code>0</code>，此时<code>output</code>字符串由闭包返回，并通过该<code>map(_:)</code>方法添加到输出数组中。</p>
<p>在上面的例子中，使用尾部闭包语法在闭包支持的函数后立即封闭闭包的功能，而不需要将整个闭包封装在<code>map(_:)</code>方法的外部圆括号内。</p>
<h3 id="捕捉价值观"><a href="#捕捉价值观" class="headerlink" title="捕捉价值观"></a>捕捉价值观</h3><p>闭包可以<em>捕获</em>定义它的周围环境中的常量和变量。即使定义常量和变量的原始范围不再存在，闭包也可以引用并修改其正文中的那些常量和变量的值。</p>
<p>在Swift中，可以捕获值的闭包的最简单形式是嵌套函数，写在另一个函数的主体中。嵌套函数可以捕获任何外部函数的参数，也可以捕获外部函数中定义的任何常量和变量。</p>
<p>这是一个叫做函数的例子<code>makeIncrementer</code>，它包含一个叫做嵌套函数<code>incrementer</code>。嵌套<code>incrementer()</code>函数捕获两个值，<code>runningTotal</code>并<code>amount</code>从其周围的上下文中捕获。在捕获这些值后，作为闭包<code>incrementer</code>返回，每次调用时都会<code>makeIncrementer</code>递增。 <code>runningTotal``amount</code></p>
<ol>
<li><code>func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {</code></li>
<li><code>var runningTotal = 0</code></li>
<li><code>func incrementer() -&gt; Int {</code></li>
<li><code>runningTotal += amount</code></li>
<li><code>return runningTotal</code></li>
<li><code>}</code></li>
<li><code>return incrementer</code></li>
<li><code>}</code></li>
</ol>
<p>返回类型<code>makeIncrementer</code>是<code>() -&gt; Int</code>。这意味着它返回一个<em>函数</em>，而不是一个简单的值。它返回的函数没有参数，<code>Int</code>每次调用时都会返回一个值。要了解函数如何返回其他函数，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID177" target="_blank" rel="noopener">函数类型作为返回类型</a>。</p>
<p>该<code>makeIncrementer(forIncrement:)</code>函数定义了一个称为的整数变量<code>runningTotal</code>，用于存储将返回的增量器的当前运行总数。该变量的初始值为<code>0</code>。</p>
<p>该<code>makeIncrementer(forIncrement:)</code>函数具有单个<code>Int</code>参数，参数标签为<code>forIncrement</code>，参数名称为<code>amount</code>。传递给此参数的参数值指定<code>runningTotal</code>每次调用返回的增量函数时应递增多少。该<code>makeIncrementer</code>函数定义一个名为的嵌套函数<code>incrementer</code>，它执行实际递增。该功能仅添加<code>amount</code>到<code>runningTotal</code>，并返回结果。</p>
<p>当单独考虑时，嵌套<code>incrementer()</code>函数可能看起来很不寻常：</p>
<ol>
<li><code>func incrementer() -&gt; Int {</code></li>
<li><code>runningTotal += amount</code></li>
<li><code>return runningTotal</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>incrementer()</code>函数没有任何参数，但它指的是<code>runningTotal</code>和<code>amount</code>其函数体内。它通过捕获做到这一点<em>参考</em>，以<code>runningTotal</code>和<code>amount</code>从周围的功能和其自身的函数体中使用它们。通过参考捕捉保证<code>runningTotal</code>和<code>amount</code>不消失的时候调用<code>makeIncrementer</code>结束，而且也保证了<code>runningTotal</code>可用下一次<code>incrementer</code>函数被调用。</p>
<p>注意作为一个优化，Swift可以取而代之地捕获并存储一个值的<em>副本</em>，如果该值没有被闭包变异，并且该值在闭包创建后没有变异。Swift还处理所有涉及处理变量时不再需要的内存管理。</p>
<p>以下是一个实例<code>makeIncrementer</code>：</p>
<ol>
<li><code>let incrementByTen = makeIncrementer(forIncrement: 10)</code></li>
</ol>
<p>本实施例中设置了一个称为恒定<code>incrementByTen</code>来指代将一个增量器功能<code>10</code>到其<code>runningTotal</code>每次被调用时的变量。多次调用该函数会显示这种行为：</p>
<ol>
<li><code>incrementByTen()</code></li>
<li><code>// returns a value of 10</code></li>
<li><code>incrementByTen()</code></li>
<li><code>// returns a value of 20</code></li>
<li><code>incrementByTen()</code></li>
<li><code>// returns a value of 30</code></li>
</ol>
<p>如果您创建了第二个增量器，它将拥有自己的对新的单独<code>runningTotal</code>变量的存储引用：</p>
<ol>
<li><code>let incrementBySeven = makeIncrementer(forIncrement: 7)</code></li>
<li><code>incrementBySeven()</code></li>
<li><code>// returns a value of 7</code></li>
</ol>
<p><code>incrementByTen</code>再次 调用原始增量（）再继续递增其自己的<code>runningTotal</code>变量，并且不影响通过<code>incrementBySeven</code>以下方式捕获的变量：</p>
<ol>
<li><code>incrementByTen()</code></li>
<li><code>// returns a value of 40</code></li>
</ol>
<p>注意如果将闭包分配给类实例的属性，并且闭包通过引用实例或其成员来捕获该实例，则将在闭包和实例之间创建一个强引用循环。Swift使用<em>捕获列表</em>来打破这些强大的参考周期。有关更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID56" target="_blank" rel="noopener">闭环的强参考周期</a>。</p>
<h3 id="闭包是参考类型"><a href="#闭包是参考类型" class="headerlink" title="闭包是参考类型"></a>闭包是参考类型</h3><p>在上面的例子中，<code>incrementBySeven</code>和<code>incrementByTen</code>是常量，但是这些常量指的是封闭仍然能够递增<code>runningTotal</code>，他们已抓获的变量。这是因为函数和闭包是<em>引用类型</em>。</p>
<p>无论何时将函数或闭包分配给常量或变量，实际上都是将该常量或变量设置为对函数或闭包的<em>引用</em>。在上面的例子中，闭包的选择是<code>incrementByTen</code> <em>指</em>常量，而不是闭包本身的内容。</p>
<p>这也意味着，如果将一个闭包分配给两个不同的常量或变量，那么这两个常量或变量都会引用相同的闭包：</p>
<ol>
<li><code>let alsoIncrementByTen = incrementByTen</code></li>
<li><code>alsoIncrementByTen()</code></li>
<li><code>// returns a value of 50</code></li>
</ol>
<h3 id="逃逸关闭"><a href="#逃逸关闭" class="headerlink" title="逃逸关闭"></a>逃逸关闭</h3><p>闭包是说<em>逃避</em>当封盖作为参数传递给函数，但在函数返回之后被调用的函数。当你声明一个将闭包作为其参数的函数时，你可以<code>@escaping</code>在参数的类型之前写入，以表示允许闭包被转义。</p>
<p>闭包可以逃脱的一种方式是存储在函数外部定义的变量中。作为例子，许多启动异步操作的函数都将闭包参数作为完成处理程序。该函数在开始操作后返回，但在操作完成之前不会调用闭包 - 闭包需要转义，稍后调用。例如：</p>
<ol>
<li><code>var completionHandlers: [() -&gt; Void] = []</code></li>
<li><code>func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {</code></li>
<li><code>completionHandlers.append(completionHandler)</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>someFunctionWithEscapingClosure(_:)</code>函数将闭包作为参数，并将其添加到在函数外声明的数组。如果你没有标记这个函数的参数<code>@escaping</code>，你会得到一个编译时错误。</p>
<p>标记闭包<code>@escaping</code>意味着你必须<code>self</code>在闭包中明确提及。例如，在下面的代码中，传递给的闭包<code>someFunctionWithEscapingClosure(_:)</code>是一个转义闭包，这意味着它需要<code>self</code>明确引用。相比之下，传递给<code>someFunctionWithNonescapingClosure(_:)</code>它的闭包是一个nonescaping闭包，这意味着它可以<code>self</code>隐式引用。</p>
<ol>
<li><code>func someFunctionWithNonescapingClosure(closure: () -&gt; Void) {</code></li>
<li><code>closure()</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>class SomeClass {</code></li>
<li><code>var x = 10</code></li>
<li><code>func doSomething() {</code></li>
<li><code>someFunctionWithEscapingClosure { self.x = 100 }</code></li>
<li><code>someFunctionWithNonescapingClosure { x = 200 }</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>let instance = SomeClass()</code></li>
<li><code>instance.doSomething()</code></li>
<li><code>print(instance.x)</code></li>
<li><code>// Prints &quot;200&quot;</code></li>
<li><code></code></li>
<li><code>completionHandlers.first?()</code></li>
<li><code>print(instance.x)</code></li>
<li><code>// Prints &quot;100&quot;</code></li>
</ol>
<h3 id="Autoclosures"><a href="#Autoclosures" class="headerlink" title="Autoclosures"></a>Autoclosures</h3><p>一个<em>autoclosure</em>是自动创建来包装被真实作为参数传递给函数的表达式的封闭件。它不需要任何参数，当它被调用时，它会返回包装在其中的表达式的值。这种语法上的便利可以让你通过写一个普通的表达式而不是显式的闭包来省略函数参数的大括号。</p>
<p>通常<em>调用</em>采用自动屏蔽的函数，但<em>实现</em>这种功能并不常见。例如，该<code>assert(condition:message:file:line:)</code>函数为其参数<code>condition</code>和<code>message</code>参数进行autoclosure ; 它<code>condition</code>仅在调试参数进行评估，并建立其<code>message</code>仅在参数评估<code>condition</code>是<code>false</code>。</p>
<p>autoclosure让你延迟评估，因为在你调用闭包之前，里面的代码不会运行。延迟评估对于有副作用或计算成本较高的代码非常有用，因为它可以让您控制代码的评估时间。下面的代码显示了封闭延迟评估的方式。</p>
<ol>
<li><code>var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</code></li>
<li><code>print(customersInLine.count)</code></li>
<li><code>// Prints &quot;5&quot;</code></li>
<li><code></code></li>
<li><code>let customerProvider = { customersInLine.remove(at: 0) }</code></li>
<li><code>print(customersInLine.count)</code></li>
<li><code>// Prints &quot;5&quot;</code></li>
<li><code></code></li>
<li><code>print(&quot;Now serving \(customerProvider())!&quot;)</code></li>
<li><code>// Prints &quot;Now serving Chris!&quot;</code></li>
<li><code>print(customersInLine.count)</code></li>
<li><code>// Prints &quot;4&quot;</code></li>
</ol>
<p>即使<code>customersInLine</code>数组的第一个元素被闭包中的代码删除，数组元素也不会被删除，直到实际调用闭包为止。如果闭包永远不会被调用，闭包内的表达式永远不会被计算，这意味着数组元素永远不会被移除。请注意，类型<code>customerProvider</code>是不是<code>String</code>，但<code>() -&gt; String</code>不带任何参数，返回一个字符串-a功能。</p>
<p>当您将闭包作为参数传递给函数时，您会得到延迟评估的相同行为。</p>
<ol>
<li><code>// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</code></li>
<li><code>func serve(customer customerProvider: () -&gt; String) {</code></li>
<li><code>print(&quot;Now serving \(customerProvider())!&quot;)</code></li>
<li><code>}</code></li>
<li><code>serve(customer: { customersInLine.remove(at: 0) } )</code></li>
<li><code>// Prints &quot;Now serving Alex!&quot;</code></li>
</ol>
<p><code>serve(customer:)</code>上面列表中 的函数使用显式闭包来返回客户的名字。下面的版本<code>serve(customer:)</code>执行相同的操作，但不是采用显式闭包，而是通过用参数的<code>@autoclosure</code>属性标记其参数类型来采用autoclosure 。现在你可以调用函数，就好像它使用了一个<code>String</code>参数而不是闭包。该参数会自动转换为闭包，因为该<code>customerProvider</code>参数的类型是用<code>@autoclosure</code>属性标记的。</p>
<ol>
<li><code>// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</code></li>
<li><code>func serve(customer customerProvider: @autoclosure () -&gt; String) {</code></li>
<li><code>print(&quot;Now serving \(customerProvider())!&quot;)</code></li>
<li><code>}</code></li>
<li><code>serve(customer: customersInLine.remove(at: 0))</code></li>
<li><code>// Prints &quot;Now serving Ewa!&quot;</code></li>
</ol>
<p>注意过度使用自动遮挡会使您的代码难以理解。上下文和函数名称应该明确表示评估正在推迟。</p>
<p>如果您想要允许转义的自动关闭，请使用<code>@autoclosure</code>和<code>@escaping</code>属性。该<code>@escaping</code>属性在上面的<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID546" target="_blank" rel="noopener">转义闭包中</a>描述。</p>
<ol>
<li><code>// customersInLine is [&quot;Barry&quot;, &quot;Daniella&quot;]</code></li>
<li><code>var customerProviders: [() -&gt; String] = []</code></li>
<li><code>func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) {</code></li>
<li><code>customerProviders.append(customerProvider)</code></li>
<li><code>}</code></li>
<li><code>collectCustomerProviders(customersInLine.remove(at: 0))</code></li>
<li><code>collectCustomerProviders(customersInLine.remove(at: 0))</code></li>
<li><code></code></li>
<li><code>print(&quot;Collected \(customerProviders.count) closures.&quot;)</code></li>
<li><code>// Prints &quot;Collected 2 closures.&quot;</code></li>
<li><code>for customerProvider in customerProviders {</code></li>
<li><code>print(&quot;Now serving \(customerProvider())!&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;Now serving Barry!&quot;</code></li>
<li><code>// Prints &quot;Now serving Daniella!&quot;</code></li>
</ol>
<p>在上面的代码，而不是调用传递给它作为它的闭合<code>customerProvider</code>参数，该<code>collectCustomerProviders(_:)</code>函数将所述封闭的<code>customerProviders</code>阵列。数组声明在函数范围之外，这意味着数组中的闭包可以在函数返回后执行。因此，<code>customerProvider</code>参数的值必须被允许转义该函数的作用域。</p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158" target="_blank" rel="noopener">功能</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145" target="_blank" rel="noopener">枚举</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Closures </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[集合类型]]></title>
      <url>/2018/05/07/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>##</p>
<p>Swift提供了三种主要的<em>集合类型</em>，称为数组，集合和字典，用于存储值的集合。数组是有序的值集合。集合是唯一值的无序集合。字典是键值关联的无序集合。</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png" alt="图片：../Art/CollectionTypes_intro_2x.png"></p>
<p>Swift中的数组，集合和字典总是清楚它们可以存储的值和键的类型。这意味着您不能错误地将错误类型的值插入到集合中。这也意味着您可以确信您将从集合中检索的值的类型。</p>
<p>注意Swift的数组，集合和字典类型被实现为<em>通用集合</em>。有关泛型类型和集合的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179" target="_blank" rel="noopener">泛型</a>。<br><a id="more"></a></p>
<h3 id="集合的可变性"><a href="#集合的可变性" class="headerlink" title="集合的可变性"></a>集合的可变性</h3><p>如果您创建数组，集合或字典，并将其分配给一个变量，则创建的集合将是<em>可变的</em>。这意味着，你可以改变（或<em>变异</em>它是由添加，删除或改变集合中的项目创建后）的集合。如果将数组，集合或字典分配给常量，那么该集合是<em>不可变的</em>，并且其大小和内容不能更改。</p>
<p>注意在集合不需要改变的所有情况下创建不可变集合是一个好习惯。这样做可以让您更轻松地推理代码，并使Swift编译器能够优化您创建的集合的性能。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一个<em>阵列</em>存储在有序列表中的相同类型的值。相同的值可以在不同位置多次出现在阵列中。</p>
<p>注意斯威夫特的<code>Array</code>类型被桥接到基金会的<code>NSArray</code>班级。有关<code>Array</code>在Foundation和Cocoa中使用的更多信息，请参阅在<em>Cocoa和Objective-C</em>中<em>使用Swift使用</em><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6" target="_blank" rel="noopener"> Cocoa数据类型</a><em>（Swift 4.1）</em>。</p>
<h3 id="数组类型速记语法"><a href="#数组类型速记语法" class="headerlink" title="数组类型速记语法"></a>数组类型速记语法</h3><p>Swift数组的类型完全写成<code>Array&lt;Element&gt;</code>，其中<code>Element</code>数组允许存储的值的类型在哪里。你也可以用简写形式写出数组的类型<code>[Element]</code>。尽管这两种形式在功能上是相同的，但是在引用数组类型时，速记形式是优选的，并且贯穿本指南。</p>
<h3 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h3><p>您可以使用初始化语法创建一个特定类型的空数组：</p>
<ol>
<li><code>var someInts = [Int]()</code></li>
<li><code>print(&quot;someInts is of type [Int] with \(someInts.count) items.&quot;)</code></li>
<li><code>// Prints &quot;someInts is of type [Int] with 0 items.&quot;</code></li>
</ol>
<p>请注意，<code>someInts</code>变量的类型被推断为<code>[Int]</code>来自初始值设定项的类型。</p>
<p>或者，如果上下文已经提供了类型信息，例如函数参数或已经存在类型的变量或常量，则可以创建一个空数组，其中包含一个空数组文字，该文字写为<code>[]</code>（一对空括号）：</p>
<ol>
<li><code>someInts.append(3)</code></li>
<li><code>// someInts now contains 1 value of type Int</code></li>
<li><code>someInts = []</code></li>
<li><code>// someInts is now an empty array, but is still of type [Int]</code></li>
</ol>
<h3 id="用默认值创建一个数组"><a href="#用默认值创建一个数组" class="headerlink" title="用默认值创建一个数组"></a>用默认值创建一个数组</h3><p>Swift的<code>Array</code>类型还提供了一个初始化器，用于创建一个具有特定大小的数组，并将其所有值设置为相同的默认值。您将此初始值设定项传递给适当类型（调用<code>repeating</code>）的默认值：以及在新数组（调用<code>count</code>）中重复该值的次数：</p>
<ol>
<li><code>var threeDoubles = Array(repeating: 0.0, count: 3)</code></li>
<li><code>// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</code></li>
</ol>
<h3 id="通过一起添加两个数组来创建一个数组"><a href="#通过一起添加两个数组来创建一个数组" class="headerlink" title="通过一起添加两个数组来创建一个数组"></a>通过一起添加两个数组来创建一个数组</h3><p>您可以通过使用添加运算符（<code>+</code>）添加具有兼容类型的两个现有数组来创建新数组。新数组的类型是根据您添加在一起的两个数组的类型推断的：</p>
<ol>
<li><code>var anotherThreeDoubles = Array(repeating: 2.5, count: 3)</code></li>
<li><code>// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]</code></li>
<li><code></code></li>
<li><code>var sixDoubles = threeDoubles + anotherThreeDoubles</code></li>
<li><code>// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</code></li>
</ol>
<h3 id="使用数组字面值创建数组"><a href="#使用数组字面值创建数组" class="headerlink" title="使用数组字面值创建数组"></a>使用数组字面值创建数组</h3><p>您还可以使用<em>数组文本</em>初始化数组，这是将一个或多个值作为数组集合写入的简写方法。数组文字被写为一列值，用逗号分隔，并由一对方括号包围：</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 值1，值2，值3 ]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面的示例创建一个调用<code>shoppingList</code>以存储<code>String</code>值的数组：</p>
<ol>
<li><code>var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]</code></li>
<li><code>// shoppingList has been initialized with two initial items</code></li>
</ol>
<p>该<code>shoppingList</code>变量被声明为“字符串值的数组”，写为<code>[String]</code>。由于此特定数组已指定值类型<code>String</code>，因此只允许存储<code>String</code>值。在这里，<code>shoppingList</code>数组被初始化为两个<code>String</code>值（<code>&quot;Eggs&quot;</code>和<code>&quot;Milk&quot;</code>），写入数组文字中。</p>
<p>注意该<code>shoppingList</code>数组被声明为一个变量（与<code>var</code>介绍人），而不是一个常量（与<code>let</code>介绍人），因为更多的项目被添加到下面的例子中的购物清单。</p>
<p>在这种情况下，数组文字包含两个<code>String</code>值，没有别的。这与<code>shoppingList</code>变量声明的类型（一个只能包含<code>String</code>值的数组）相匹配，因此允许使用数组文本的赋值作为初始化<code>shoppingList</code>两个初始项的方法。</p>
<p>感谢Swift的类型推断，如果使用包含相同类型值的数组字面值初始化数组，则不必编写数组的类型。初始化<code>shoppingList</code>本来可以用较短的形式写成：</p>
<ol>
<li><code>var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]</code></li>
</ol>
<p>因为数组文本中的所有值都是相同的类型，所以Swift可以推断出这<code>[String]</code>是用于<code>shoppingList</code>变量的正确类型。</p>
<h3 id="访问和修改数组"><a href="#访问和修改数组" class="headerlink" title="访问和修改数组"></a>访问和修改数组</h3><p>您可以通过其方法和属性或使用下标语法来访问和修改数组。</p>
<p>要找出数组中项目的数量，请检查其只读<code>count</code>属性：</p>
<ol>
<li><code>print(&quot;The shopping list contains \(shoppingList.count) items.&quot;)</code></li>
<li><code>// Prints &quot;The shopping list contains 2 items.&quot;</code></li>
</ol>
<p>使用Boolean <code>isEmpty</code>属性作为检查<code>count</code>属性是否等于的快捷方式<code>0</code>：</p>
<ol>
<li><code>if shoppingList.isEmpty {</code></li>
<li><code>print(&quot;The shopping list is empty.&quot;)</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;The shopping list is not empty.&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;The shopping list is not empty.&quot;</code></li>
</ol>
<p>您可以通过调用数组的<code>append(_:)</code>方法将新项添加到数组的末尾：</p>
<ol>
<li><code>shoppingList.append(&quot;Flour&quot;)</code></li>
<li><code>// shoppingList now contains 3 items, and someone is making pancakes</code></li>
</ol>
<p>或者，使用添加赋值运算符（<code>+=</code>）添加一个或多个兼容项目的数组：</p>
<ol>
<li><code>shoppingList += [&quot;Baking Powder&quot;]</code></li>
<li><code>// shoppingList now contains 4 items</code></li>
<li><code>shoppingList += [&quot;Chocolate Spread&quot;, &quot;Cheese&quot;, &quot;Butter&quot;]</code></li>
<li><code>// shoppingList now contains 7 items</code></li>
</ol>
<p>使用<em>subscript语法</em>从数组中检索一个值，并在数组名称后立即传递要检索的方括号内的值的索引：</p>
<ol>
<li><code>var firstItem = shoppingList[0]</code></li>
<li><code>// firstItem is equal to &quot;Eggs&quot;</code></li>
</ol>
<p>注意数组中的第一个项目的索引是<code>0</code>，而不是<code>1</code>。Swift中的数组始终为零索引。</p>
<p>您可以使用下标语法来更改给定索引处的现有值：</p>
<ol>
<li><code>shoppingList[0] = &quot;Six eggs&quot;</code></li>
<li><code>// the first item in the list is now equal to &quot;Six eggs&quot; rather than &quot;Eggs&quot;</code></li>
</ol>
<p>当使用下标语法时，您指定的索引需要有效。例如，编写<code>shoppingList[shoppingList.count] = &quot;Salt&quot;</code>试图将项添加到数组的末尾会导致运行时错误。</p>
<p>即使替换值的长度与要替换的范围不同，您也可以使用下标语法一次更改一系列值。下面的示例替换<code>&quot;Chocolate Spread&quot;</code>，<code>&quot;Cheese&quot;</code>以及<code>&quot;Butter&quot;</code>与<code>&quot;Bananas&quot;</code>和<code>&quot;Apples&quot;</code>：</p>
<ol>
<li><code>shoppingList[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;]</code></li>
<li><code>// shoppingList now contains 6 items</code></li>
</ol>
<p>要将一个项目插入到指定索引处的数组中，请调用该数组的<code>insert(_:at:)</code>方法：</p>
<ol>
<li><code>shoppingList.insert(&quot;Maple Syrup&quot;, at: 0)</code></li>
<li><code>// shoppingList now contains 7 items</code></li>
<li><code>// &quot;Maple Syrup&quot; is now the first item in the list</code></li>
</ol>
<p>这个<code>insert(_:at:)</code>方法的调用插入一个新的项目，其值为<code>&quot;Maple Syrup&quot;</code>购物清单的最开始处，由索引为<code>0</code>。</p>
<p>同样，您可以使用该<code>remove(at:)</code>方法从数组中移除一个项目。此方法删除指定索引处的项目并返回删除的项目（但如果不需要，您可以忽略返回的值）：</p>
<ol>
<li><code>let mapleSyrup = shoppingList.remove(at: 0)</code></li>
<li><code>// the item that was at index 0 has just been removed</code></li>
<li><code>// shoppingList now contains 6 items, and no Maple Syrup</code></li>
<li><code>// the mapleSyrup constant is now equal to the removed &quot;Maple Syrup&quot; string</code></li>
</ol>
<p>注意如果您尝试访问或修改数组现有边界之外的索引的值，则会触发运行时错误。通过将索引与数组的<code>count</code>属性进行比较，可以检查索引是否有效。数组中最大的有效索引是<code>count - 1</code>因为数组从零开始索引 - 但是，当<code>count</code>is <code>0</code>（意味着数组为空）时，没有有效的索引。</p>
<p>当一个项目被删除时，数组中的任何间隙都会关闭，因此index <code>0</code>处的值再次等于<code>&quot;Six eggs&quot;</code>：</p>
<ol>
<li><code>firstItem = shoppingList[0]</code></li>
<li><code>// firstItem is now equal to &quot;Six eggs&quot;</code></li>
</ol>
<p>如果要从数组中移除最后一项，请使用<code>removeLast()</code>方法而不是<code>remove(at:)</code>方法来避免查询数组的<code>count</code>属性。像该<code>remove(at:)</code>方法一样，<code>removeLast()</code>返回已删除的项目：</p>
<ol>
<li><code>let apples = shoppingList.removeLast()</code></li>
<li><code>// the last item in the array has just been removed</code></li>
<li><code>// shoppingList now contains 5 items, and no apples</code></li>
<li><code>// the apples constant is now equal to the removed &quot;Apples&quot; string</code></li>
</ol>
<h3 id="迭代数组"><a href="#迭代数组" class="headerlink" title="迭代数组"></a>迭代数组</h3><p>可以遍历整个集合值与数组<code>for</code>- <code>in</code>循环：</p>
<ol>
<li><code>for item in shoppingList {</code></li>
<li><code>print(item)</code></li>
<li><code>}</code></li>
<li><code>// Six eggs</code></li>
<li><code>// Milk</code></li>
<li><code>// Flour</code></li>
<li><code>// Baking Powder</code></li>
<li><code>// Bananas</code></li>
</ol>
<p>如果您需要每个项目的整数索引及其值，请使用该<code>enumerated()</code>方法遍历数组。对于数组中的每个项目，该<code>enumerated()</code>方法返回一个由整数和项目组成的元组。整数从零开始，每个项目加1; 如果您枚举整个数组，这些整数与项目的索引匹配。作为迭代的一部分，您可以将元组分解为临时常量或变量：</p>
<ol>
<li><code>for (index, value) in shoppingList.enumerated() {</code></li>
<li><code>print(&quot;Item \(index + 1): \(value)&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Item 1: Six eggs</code></li>
<li><code>// Item 2: Milk</code></li>
<li><code>// Item 3: Flour</code></li>
<li><code>// Item 4: Baking Powder</code></li>
<li><code>// Item 5: Bananas</code></li>
</ol>
<p>有关<code>for</code>- <code>in</code>循环的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID121" target="_blank" rel="noopener">For-In循环</a>。</p>
<h3 id="集"><a href="#集" class="headerlink" title="集"></a>集</h3><p>一个<em>集合</em>在同一个<em>集合中</em>存储相同类型的不同值并且没有定义的顺序。当项目顺序不重要时，或者需要确保项目只出现一次时，您可以使用一个集合而不是一个数组。</p>
<p>注意斯威夫特的<code>Set</code>类型被桥接到基金会的<code>NSSet</code>班级。有关<code>Set</code>在Foundation和Cocoa中使用的更多信息，请参阅在<em>Cocoa和Objective-C</em>中<em>使用Swift使用</em><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6" target="_blank" rel="noopener"> Cocoa数据类型</a><em>（Swift 4.1）</em>。</p>
<h3 id="集合类型的哈希值"><a href="#集合类型的哈希值" class="headerlink" title="集合类型的哈希值"></a>集合类型的哈希值</h3><p>一个类型必须是可<em>散列</em>的才能存储在一个集合中 - 也就是说，该类型必须提供一种为自己计算<em>散列值</em>的方法。哈希值是<code>Int</code>是对于同样比较所有对象，例如，如果相同的值<code>a == b</code>，它遵循<code>a.hashValue == b.hashValue</code>。</p>
<p>所有斯威夫特的基本类型（例如<code>String</code>，<code>Int</code>，<code>Double</code>，和<code>Bool</code>）默认情况下可哈希，并可以作为设定值类型或字典密钥类型。没有关联值的枚举大小写值（如<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145" target="_blank" rel="noopener">枚举中所述</a>）默认情况下也是可哈希的。</p>
<p>注意您可以使用自己的自定义类型作为设置值类型或字典键类型，使其符合<code>Hashable</code>Swift标准库中的协议。符合<code>Hashable</code>协议的类型必须提供一个<code>Int</code>名为gettable的属性<code>hashValue</code>。类型<code>hashValue</code>属性返回的值不需要在同一程序的不同执行过程中或在不同的程序中相同。由于<code>Hashable</code>协议符合<code>Equatable</code>，符合类型还必须提供equals运算符（<code>==</code>）的实现。该<code>Equatable</code>协议要求任何符合实现的<code>==</code>是等价关系。也就是说，一个实现<code>==</code>必须满足以下三个条件，所有值<code>a</code>，<code>b</code>以及<code>c</code>：<code>a == a</code> （自反）<code>a == b</code>暗示<code>b == a</code>（对称）<code>a == b &amp;&amp; b == c</code>意味着<code>a == c</code>（传递性）有关符合协议的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="noopener">协议</a>。</p>
<h3 id="设置类型语法"><a href="#设置类型语法" class="headerlink" title="设置类型语法"></a>设置类型语法</h3><p>Swift集合的类型被写为<code>Set&lt;Element&gt;</code>，<code>Element</code>集合允许存储的类型在哪里。与数组不同，集合不具有等效的速记形式。</p>
<h3 id="创建并初始化一个空集"><a href="#创建并初始化一个空集" class="headerlink" title="创建并初始化一个空集"></a>创建并初始化一个空集</h3><p>您可以使用初始化语法创建一个特定类型的空集：</p>
<ol>
<li><code>var letters = Set&lt;Character&gt;()</code></li>
<li><code>print(&quot;letters is of type Set&lt;Character&gt; with \(letters.count) items.&quot;)</code></li>
<li><code>// Prints &quot;letters is of type Set&lt;Character&gt; with 0 items.&quot;</code></li>
</ol>
<p>注意根据初始值设定项的类型<code>letters</code>推断变量<code>Set&lt;Character&gt;</code>的类型是。</p>
<p>或者，如果上下文已经提供了类型信息，例如函数参数或已经存在类型的变量或常量，则可以使用空数组文本创建一个空集：</p>
<ol>
<li><code>letters.insert(&quot;a&quot;)</code></li>
<li><code>// letters now contains 1 value of type Character</code></li>
<li><code>letters = []</code></li>
<li><code>// letters is now an empty set, but is still of type Set&lt;Character&gt;</code></li>
</ol>
<h3 id="使用数组文字创建一个集合"><a href="#使用数组文字创建一个集合" class="headerlink" title="使用数组文字创建一个集合"></a>使用数组文字创建一个集合</h3><p>您还可以使用数组文本初始化一个集合，作为将一个或多个值作为集合集合写入的简写方法。</p>
<p>下面的示例创建一个调用<code>favoriteGenres</code>存储<code>String</code>值的集合：</p>
<ol>
<li><code>var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]</code></li>
<li><code>// favoriteGenres has been initialized with three initial items</code></li>
</ol>
<p>该<code>favoriteGenres</code>变量被声明为“一组<code>String</code>值”，写为<code>Set&lt;String&gt;</code>。因为这个特定的集合已经指定了一个值类型<code>String</code>，所以<em>只</em>允许存储<code>String</code>值。在此，<code>favoriteGenres</code>集合被初始化具有三个<code>String</code>值（<code>&quot;Rock&quot;</code>，<code>&quot;Classical&quot;</code>，和<code>&quot;Hip hop&quot;</code>），阵列字面内写入。</p>
<p>注意该<code>favoriteGenres</code>集被声明为一个变量（与<code>var</code>介绍人），而不是一个常量（与<code>let</code>介绍人），因为在下面的例子中添加和删除了项目。</p>
<p>集合类型不能单独从数组文本中推断出来，所以<code>Set</code>必须明确声明类型。但是，由于Swift的类型推断，如果使用包含相同类型值的数组字面值初始化它，则不必编写该类型的集合。初始化<code>favoriteGenres</code>本来可以用较短的形式写成：</p>
<ol>
<li><code>var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]</code></li>
</ol>
<p>因为数组文本中的所有值都是相同的类型，所以Swift可以推断出这<code>Set&lt;String&gt;</code>是用于<code>favoriteGenres</code>变量的正确类型。</p>
<h3 id="访问和修改集合"><a href="#访问和修改集合" class="headerlink" title="访问和修改集合"></a>访问和修改集合</h3><p>你可以通过它的方法和属性来访问和修改一个集合。</p>
<p>要找出一组中的项目数量，请检查其只读<code>count</code>属性：</p>
<ol>
<li><code>print(&quot;I have \(favoriteGenres.count) favorite music genres.&quot;)</code></li>
<li><code>// Prints &quot;I have 3 favorite music genres.&quot;</code></li>
</ol>
<p>使用Boolean <code>isEmpty</code>属性作为检查<code>count</code>属性是否等于的快捷方式<code>0</code>：</p>
<ol>
<li><code>if favoriteGenres.isEmpty {</code></li>
<li><code>print(&quot;As far as music goes, I&#39;m not picky.&quot;)</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;I have particular music preferences.&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;I have particular music preferences.&quot;</code></li>
</ol>
<p>您可以通过调用set的<code>insert(_:)</code>方法将新项目添加到集合中：</p>
<ol>
<li><code>favoriteGenres.insert(&quot;Jazz&quot;)</code></li>
<li><code>// favoriteGenres now contains 4 items</code></li>
</ol>
<p>您可以通过调用set的<code>remove(_:)</code>方法从集合中删除一个项目，如果该项目是该集合的成员，则该项目将移除该项目，并返回已移除的值; <code>nil</code>如果该集合未包含该项目，则返回该值。或者，可以使用其<code>removeAll()</code>方法删除集合中的所有项目。</p>
<ol>
<li><code>if let removedGenre = favoriteGenres.remove(&quot;Rock&quot;) {</code></li>
<li><code>print(&quot;\(removedGenre)? I&#39;m over it.&quot;)</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;I never much cared for that.&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;Rock? I&#39;m over it.&quot;</code></li>
</ol>
<p>要检查一个集合是否包含特定项目，请使用该<code>contains(_:)</code>方法。</p>
<ol>
<li><code>if favoriteGenres.contains(&quot;Funk&quot;) {</code></li>
<li><code>print(&quot;I get up on the good foot.&quot;)</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;It&#39;s too funky in here.&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;It&#39;s too funky in here.&quot;</code></li>
</ol>
<h3 id="迭代集合"><a href="#迭代集合" class="headerlink" title="迭代集合"></a>迭代集合</h3><p>您可以使用<code>for</code>- <code>in</code>循环遍历集合中的值。</p>
<ol>
<li><code>for genre in favoriteGenres {</code></li>
<li><code>print(&quot;\(genre)&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Jazz</code></li>
<li><code>// Hip hop</code></li>
<li><code>// Classical</code></li>
</ol>
<p>有关<code>for</code>- <code>in</code>循环的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID121" target="_blank" rel="noopener">For-In循环</a>。</p>
<p>Swift的<code>Set</code>类型没有定义的顺序。要按特定顺序迭代集合的值，请使用该<code>sorted()</code>方法，该方法将集合的元素作为使用<code>&lt;</code>运算符排序的数组返回。</p>
<ol>
<li><code>for genre in favoriteGenres.sorted() {</code></li>
<li><code>print(&quot;\(genre)&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Classical</code></li>
<li><code>// Hip hop</code></li>
<li><code>// Jazz</code></li>
</ol>
<h3 id="执行集合操作"><a href="#执行集合操作" class="headerlink" title="执行集合操作"></a>执行集合操作</h3><p>您可以高效地执行基本集合操作，例如将两个集合组合在一起，确定两个集合具有哪些值，或确定两个集合是包含全部，部分还是不包含相同的值。</p>
<h3 id="基本设置操作"><a href="#基本设置操作" class="headerlink" title="基本设置操作"></a>基本设置操作</h3><p>下图描绘了两个集- <code>a</code>和<code>b</code>-附由阴影区域表示的各种设定操作的结果。</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png" alt="image：../Art/setVennDiagram_2x.png"></p>
<ul>
<li>使用该<code>intersection(_:)</code>方法创建一个仅具有两个集合通用值的新集合。</li>
<li>使用该<code>symmetricDifference(_:)</code>方法创建一个新的集合，其中任何一个集合中都有值，但不能同时包含两个值</li>
<li>使用该<code>union(_:)</code>方法创建一个包含两个集合中所有值的新集合。</li>
<li>使用该<code>subtracting(_:)</code>方法创建一个新的集合，其值不在指定的集合中。</li>
</ul>
<ol>
<li><code>let oddDigits: Set = [1, 3, 5, 7, 9]</code></li>
<li><code>let evenDigits: Set = [0, 2, 4, 6, 8]</code></li>
<li><code>let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]</code></li>
<li><code></code></li>
<li><code>oddDigits.union(evenDigits).sorted()</code></li>
<li><code>// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></li>
<li><code>oddDigits.intersection(evenDigits).sorted()</code></li>
<li><code>// []</code></li>
<li><code>oddDigits.subtracting(singleDigitPrimeNumbers).sorted()</code></li>
<li><code>// [1, 9]</code></li>
<li><code>oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()</code></li>
<li><code>// [1, 2, 9]</code></li>
</ol>
<h3 id="设置成员资格和平等"><a href="#设置成员资格和平等" class="headerlink" title="设置成员资格和平等"></a>设置成员资格和平等</h3><p>下面的插图描述了三个集合<code>a</code>，<code>b</code>以及<code>c</code>表示在集合之间共享元素的重叠区域。Set <code>a</code>是<em>集合的超</em>集<code>b</code>，因为<code>a</code>包含了所有元素<code>b</code>。相反，set <code>b</code>是集合的一个<em>子</em>集<code>a</code>，因为所有元素<code>b</code>都包含在内<code>a</code>。集合<code>b</code>和集合<code>c</code>彼此<em>不相交</em>，因为它们没有共同的元素。</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png" alt="image：../Art/setEulerDiagram_2x.png"></p>
<ul>
<li>使用“is equal”运算符（<code>==</code>）来确定两个集合是否包含所有相同的值。</li>
<li>使用该<code>isSubset(of:)</code>方法确定一个集合的所有值是否都包含在指定的集合中。</li>
<li>使用该<code>isSuperset(of:)</code>方法确定一个集合是否包含指定集合中的所有值。</li>
<li>使用<code>isStrictSubset(of:)</code>or <code>isStrictSuperset(of:)</code>方法来确定一个集合是一个子集或超集，但不等于一个指定的集合。</li>
<li>使用该<code>isDisjoint(with:)</code>方法确定两个集合是否没有共同的值。</li>
</ul>
<ol>
<li><code>let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]</code></li>
<li><code>let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]</code></li>
<li><code>let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]</code></li>
<li><code></code></li>
<li><code>houseAnimals.isSubset(of: farmAnimals)</code></li>
<li><code>// true</code></li>
<li><code>farmAnimals.isSuperset(of: houseAnimals)</code></li>
<li><code>// true</code></li>
<li><code>farmAnimals.isDisjoint(with: cityAnimals)</code></li>
<li><code>// true</code></li>
</ol>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>甲<em>字典</em>存储相同类型的密钥和一个集合中的相同类型的值与没有定义排序之间的关联。每个值都与一个唯一<em>键</em>相关联，该<em>键</em>用作字典中该值的标识符。与数组中的项目不同，字典中的项目没有指定的顺序。当需要根据标识符查找值时，您可以使用字典，这与使用真实世界字典查找特定字词的定义的方式大致相同。</p>
<p>注意斯威夫特的<code>Dictionary</code>类型被桥接到基金会的<code>NSDictionary</code>班级。有关<code>Dictionary</code>在Foundation和Cocoa中使用的更多信息，请参阅在<em>Cocoa和Objective-C</em>中<em>使用Swift使用</em><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6" target="_blank" rel="noopener">Cocoa数据类型</a><em>（Swift 4.1）</em>。</p>
<h3 id="字典类型速记语法"><a href="#字典类型速记语法" class="headerlink" title="字典类型速记语法"></a>字典类型速记语法</h3><p>Swift字典的类型完全写成<code>Dictionary&lt;Key, Value&gt;</code>，其中<code>Key</code>是可以用作字典键<code>Value</code>的值的类型，并且是字典为这些键存储的值的类型。</p>
<p>注意字典<code>Key</code>类型必须符合<code>Hashable</code>协议，就像集合的值类型一样。</p>
<p>您也可以用简写形式书写字典的类型<code>[Key: Value]</code>。尽管这两种形式在功能上是相同的，但是在引用字典类型时，缩写形式是优选的，并且贯穿本指南。</p>
<h3 id="创建一个空字典"><a href="#创建一个空字典" class="headerlink" title="创建一个空字典"></a>创建一个空字典</h3><p>与数组一样，您可以<code>Dictionary</code>使用初始化语法创建一个空的某种类型：</p>
<ol>
<li><code>var namesOfIntegers = [Int: String]()</code></li>
<li><code>// namesOfIntegers is an empty [Int: String] dictionary</code></li>
</ol>
<p>这个例子创建一个空的字典类型<code>[Int: String]</code>来存储可读的整数值名称。它的键是类型的<code>Int</code>，它的值是类型的<code>String</code>。</p>
<p>如果上下文已经提供了类型信息，则可以创建一个空字典，其中包含一个空字典文字，该文字被写为<code>[:]</code>（一对方括号内的冒号）：</p>
<ol>
<li><code>namesOfIntegers[16] = &quot;sixteen&quot;</code></li>
<li><code>// namesOfIntegers now contains 1 key-value pair</code></li>
<li><code>namesOfIntegers = [:]</code></li>
<li><code>// namesOfIntegers is once again an empty dictionary of type [Int: String]</code></li>
</ol>
<h3 id="使用字典文字创建字典"><a href="#使用字典文字创建字典" class="headerlink" title="使用字典文字创建字典"></a>使用字典文字创建字典</h3><p>您还可以使用<em>字典文字</em>来初始化字典，它具有与前面所看到的数组字面相似的语法。字典文字是将一个或多个键值对写入<code>Dictionary</code>集合的简写方法。</p>
<p>甲<em>键值对</em>是一个键和值的组合。在字典文字中，每个键 - 值对中的键和值由冒号分隔。键值对写成一个列表，用逗号分隔，并用一对方括号包围：</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 键1：值1，键2：值2，键3：值3 ]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面的示例创建一个字典来存储国际机场的名称。在这本词典中，关键字是三个字母的国际航空运输协会代码，其值是机场名称：</p>
<ol>
<li><code>var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]</code></li>
</ol>
<p>该<code>airports</code>字典被声明为具有式的<code>[String: String]</code>，意思是“一<code>Dictionary</code>键均为类型的<code>String</code>，并且其值是类型的也<code>String</code>”。</p>
<p>注意该<code>airports</code>字典被声明为一个变量（与<code>var</code>导引器），而不是一个常数（与<code>let</code>导引器），因为更多的机场被添加到词典中下面的例子。</p>
<p>该<code>airports</code>字典被初始化与含有两个键-值对的字典字面值。第一对有一个键<code>&quot;YYZ&quot;</code>和一个值<code>&quot;Toronto Pearson&quot;</code>。第二对有一个键<code>&quot;DUB&quot;</code>和一个值<code>&quot;Dublin&quot;</code>。</p>
<p>这个字典文字包含两<code>String: String</code>对。这个键值类型与<code>airports</code>变量声明的类型相匹配（只有<code>String</code>键和只有<code>String</code>值的词典），因此字典文本的赋值可以用来初始化<code>airports</code>带有两个初始化项的字典。</p>
<p>与数组一样，如果使用键和值具有一致类型的字典文字进行初始化，则不必编写字典的类型。初始化<code>airports</code>本来可以用较短的形式写成：</p>
<ol>
<li><code>var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]</code></li>
</ol>
<p>由于文本中的所有键都是彼此相同的类型，并且同样所有的值都是相同类型的，所以Swift可以推断出这<code>[String: String]</code>是用于<code>airports</code>字典的正确类型。</p>
<h3 id="访问和修改字典"><a href="#访问和修改字典" class="headerlink" title="访问和修改字典"></a>访问和修改字典</h3><p>您可以通过其方法和属性或使用下标语法来访问和修改字典。</p>
<p>与数组一样，您可以<code>Dictionary</code>通过检查其只读<code>count</code>属性来找出a中的项目数量：</p>
<ol>
<li><code>print(&quot;The airports dictionary contains \(airports.count) items.&quot;)</code></li>
<li><code>// Prints &quot;The airports dictionary contains 2 items.&quot;</code></li>
</ol>
<p>使用Boolean <code>isEmpty</code>属性作为检查<code>count</code>属性是否等于的快捷方式<code>0</code>：</p>
<ol>
<li><code>if airports.isEmpty {</code></li>
<li><code>print(&quot;The airports dictionary is empty.&quot;)</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;The airports dictionary is not empty.&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;The airports dictionary is not empty.&quot;</code></li>
</ol>
<p>您可以使用下标语法将新项目添加到字典中。使用适当类型的新键作为下标索引，并分配适当类型的新值：</p>
<ol>
<li><code>airports[&quot;LHR&quot;] = &quot;London&quot;</code></li>
<li><code>// the airports dictionary now contains 3 items</code></li>
</ol>
<p>您还可以使用下标语法来更改与特定键关联的值：</p>
<ol>
<li><code>airports[&quot;LHR&quot;] = &quot;London Heathrow&quot;</code></li>
<li><code>// the value for &quot;LHR&quot; has been changed to &quot;London Heathrow&quot;</code></li>
</ol>
<p>作为下标的替代<code>updateValue(_:forKey:)</code>方法，使用字典的方法来设置或更新特定键的值。就像上面的下标示例一样，<code>updateValue(_:forKey:)</code>如果某个键不存在，该方法将为该键设置一个值，或者如果该键已经存在，则更新该值。然而，与下标不同的是，该<code>updateValue(_:forKey:)</code>方法在执行更新后返回<em>旧</em>值。这使您可以检查是否发生更新。</p>
<p>该<code>updateValue(_:forKey:)</code>方法返回字典值类型的可选值。例如，对于存储<code>String</code>值的字典，该方法返回一个类型值<code>String?</code>或“可选<code>String</code>”。如果更新前存在该值，则此可选值包含该值的旧值，或者<code>nil</code>没有值：</p>
<ol>
<li><code>if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;) {</code></li>
<li><code>print(&quot;The old value for DUB was \(oldValue).&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;The old value for DUB was Dublin.&quot;</code></li>
</ol>
<p>您还可以使用下标语法从字典中检索特定键的值。因为可以请求不存在值的键，所以字典的下标返回字典值类型的可选值。如果字典包含请求键的值，则下标返回包含该键现有值的可选值。否则，下标返回<code>nil</code>：</p>
<ol>
<li><code>if let airportName = airports[&quot;DUB&quot;] {</code></li>
<li><code>print(&quot;The name of the airport is \(airportName).&quot;)</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;That airport is not in the airports dictionary.&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;The name of the airport is Dublin Airport.&quot;</code></li>
</ol>
<p>您可以使用下标语法通过指定该键的值来从字典中删除键值对<code>nil</code>：</p>
<ol>
<li><code>airports[&quot;APL&quot;] = &quot;Apple International&quot;</code></li>
<li><code>// &quot;Apple International&quot; is not the real airport for APL, so delete it</code></li>
<li><code>airports[&quot;APL&quot;] = nil</code></li>
<li><code>// APL has now been removed from the dictionary</code></li>
</ol>
<p>或者，使用该<code>removeValue(forKey:)</code>方法从字典中移除键值对。如果键值对存在并返回已除去的值，则该方法将移除键值对，<code>nil</code>如果没有值，则返回该值：</p>
<ol>
<li><code>if let removedValue = airports.removeValue(forKey: &quot;DUB&quot;) {</code></li>
<li><code>print(&quot;The removed airport&#39;s name is \(removedValue).&quot;)</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;The airports dictionary does not contain a value for DUB.&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;The removed airport&#39;s name is Dublin Airport.&quot;</code></li>
</ol>
<h3 id="迭代字典"><a href="#迭代字典" class="headerlink" title="迭代字典"></a>迭代字典</h3><p>您可以用字典遍历键值对<code>for</code>- <code>in</code>环。字典中的每一项都作为<code>(key, value)</code>元组返回，并且可以将元组的成员分解为临时常量或变量，作为迭代的一部分：</p>
<ol>
<li><code>for (airportCode, airportName) in airports {</code></li>
<li><code>print(&quot;\(airportCode): \(airportName)&quot;)</code></li>
<li><code>}</code></li>
<li><code>// YYZ: Toronto Pearson</code></li>
<li><code>// LHR: London Heathrow</code></li>
</ol>
<p>有关<code>for</code>- <code>in</code>循环的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID121" target="_blank" rel="noopener">For-In循环</a>。</p>
<p>您还可以通过访问其属性<code>keys</code>和<code>values</code>属性来检索字典键或值的可迭代集合：</p>
<ol>
<li><code>for airportCode in airports.keys {</code></li>
<li><code>print(&quot;Airport code: \(airportCode)&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Airport code: YYZ</code></li>
<li><code>// Airport code: LHR</code></li>
<li><code></code></li>
<li><code>for airportName in airports.values {</code></li>
<li><code>print(&quot;Airport name: \(airportName)&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Airport name: Toronto Pearson</code></li>
<li><code>// Airport name: London Heathrow</code></li>
</ol>
<p>如果您需要使用带有<code>Array</code>实例的API的字典键或值，请使用<code>keys</code>or <code>values</code>属性初始化新数组：</p>
<ol>
<li><code>let airportCodes = [String](airports.keys)</code></li>
<li><code>// airportCodes is [&quot;YYZ&quot;, &quot;LHR&quot;]</code></li>
<li><code></code></li>
<li><code>let airportNames = [String](airports.values)</code></li>
<li><code>// airportNames is [&quot;Toronto Pearson&quot;, &quot;London Heathrow&quot;]</code></li>
</ol>
<p>Swift的<code>Dictionary</code>类型没有定义的顺序。要按特定顺序遍历字典的键或值，请<code>sorted()</code>在其<code>keys</code>或<code>values</code>属性上使用该方法。</p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285" target="_blank" rel="noopener">字符串和字符</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" target="_blank" rel="noopener">控制流</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> apple </tag>
            
            <tag> 集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS嵌套类型]]></title>
      <url>/2018/05/07/%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>枚举通常被创建来支持特定的类或结构的功能。类似地，定义纯粹用于更复杂类型的上下文中的实用程序类和结构可能很方便。为了达到这个目的，Swift使您能够定义<em>嵌套类型</em>，从而将支持枚举，类和结构嵌套在它们支持的类型的定义中。</p>
<p>要将一个类型嵌套在另一个类型中，请将其定义写入其支持的类型的外括号中。类型可以嵌套到所需的级别。</p>
<h3 id="嵌套类型在行动"><a href="#嵌套类型在行动" class="headerlink" title="嵌套类型在行动"></a>嵌套类型在行动</h3><p>下面的例子定义了一个叫做“结构”的结构<code>BlackjackCard</code>，它模拟了21点游戏中使用的扑克牌。该<code>BlackjackCard</code>结构包含两个名为<code>Suit</code>and的嵌套枚举类型<code>Rank</code>。</p>
<p>在大酒杯中，Ace卡的价值为1或11。此功能由一个名为的结构表示，该结构<code>Values</code>嵌套在<code>Rank</code>枚举中：<br><a id="more"></a></p>
<ol>
<li><code>struct BlackjackCard {</code></li>
<li><code></code></li>
<li><code>// nested Suit enumeration</code></li>
<li><code>enum Suit: Character {</code></li>
<li><code>case spades = &quot;♠&quot;, hearts = &quot;♡&quot;, diamonds = &quot;♢&quot;, clubs = &quot;♣&quot;</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>// nested Rank enumeration</code></li>
<li><code>enum Rank: Int {</code></li>
<li><code>case two = 2, three, four, five, six, seven, eight, nine, ten</code></li>
<li><code>case jack, queen, king, ace</code></li>
<li><code>struct Values {</code></li>
<li><code>let first: Int, second: Int?</code></li>
<li><code>}</code></li>
<li><code>var values: Values {</code></li>
<li><code>switch self {</code></li>
<li><code>case .ace:</code></li>
<li><code>return Values(first: 1, second: 11)</code></li>
<li><code>case .jack, .queen, .king:</code></li>
<li><code>return Values(first: 10, second: nil)</code></li>
<li><code>default:</code></li>
<li><code>return Values(first: self.rawValue, second: nil)</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>// BlackjackCard properties and methods</code></li>
<li><code>let rank: Rank, suit: Suit</code></li>
<li><code>var description: String {</code></li>
<li><code>var output = &quot;suit is \(suit.rawValue),&quot;</code></li>
<li><code>output += &quot; value is \(rank.values.first)&quot;</code></li>
<li><code>if let second = rank.values.second {</code></li>
<li><code>output += &quot; or \(second)&quot;</code></li>
<li><code>}</code></li>
<li><code>return output</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>Suit</code>枚举描述了四种常见的扑克牌花色，与原料一起<code>Character</code>值来表示他们的象征。</p>
<p>该<code>Rank</code>枚举描述了十名三个可能扑克牌行列，与原料一起<code>Int</code>值来表示其面值。（这个原始<code>Int</code>值不用于Jack，Queen，King和Ace卡。）</p>
<p>如上所述，<code>Rank</code>枚举定义了它自己的另一个嵌套结构，称为<code>Values</code>。这种结构封装了大多数牌有一个值的事实，但是Ace牌有两个值。该<code>Values</code>结构定义了两个属性来表示它：</p>
<ul>
<li><code>first</code>，类型 <code>Int</code></li>
<li><code>second</code>，类型<code>Int?</code>或“可选<code>Int</code>”</li>
</ul>
<p><code>Rank</code>还定义了一个计算属性，<code>values</code>该属性返回<code>Values</code>结构的一个实例。该计算属性考虑卡的等级并<code>Values</code>基于其等级利用适当的值来初始化新的实例。它采用特殊值<code>jack</code>，<code>queen</code>，<code>king</code>，和<code>ace</code>。对于数字卡片，它使用等级的原始<code>Int</code>值。</p>
<p>该<code>BlackjackCard</code>结构本身有两个属性- <code>rank</code>和<code>suit</code>。它还定义了一个被称为的计算属性<code>description</code>，它使用存储在其中的值<code>rank</code>并<code>suit</code>构建卡的名称和值的描述。该<code>description</code>属性使用可选绑定来检查是否有第二个值要显示，如果是，则插入第二个值的附加描述细节。</p>
<p>由于<code>BlackjackCard</code>是没有自定义初始值设定项的结构，因此它具有隐式成员初始值设定项，如<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID214" target="_blank" rel="noopener">构造类型的</a>成员初始值设定项中所述。你可以使用这个初始化器来初始化一个新的常量<code>theAceOfSpades</code>：</p>
<ol>
<li><code>let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)</code></li>
<li><code>print(&quot;theAceOfSpades: \(theAceOfSpades.description)&quot;)</code></li>
<li><code>// Prints &quot;theAceOfSpades: suit is ♠, value is 1 or 11&quot;</code></li>
</ol>
<p>即使<code>Rank</code>和<code>Suit</code>被嵌套在<code>BlackjackCard</code>，它们的类型可以从上下文推断，所以这个实例的初始化是能够通过他们的名字的情况下（指枚举案件<code>.ace</code>和<code>.spades</code>单独的）。在上面的示例中，<code>description</code>属性正确地报告黑桃王牌值为<code>1</code>或<code>11</code>。</p>
<h3 id="参考嵌套类型"><a href="#参考嵌套类型" class="headerlink" title="参考嵌套类型"></a>参考嵌套类型</h3><p>要在其定义上下文之外使用嵌套类型，请在其名称前面添加嵌套类型的名称：</p>
<ol>
<li><code>let heartsSymbol = BlackjackCard.Suit.hearts.rawValue</code></li>
<li><code>// heartsSymbol is &quot;♡&quot;</code></li>
</ol>
<p>对于上面的示例，这使得的名字<code>Suit</code>，<code>Rank</code>和<code>Values</code>被保持故意短，因为它们的名称是天然通过在它们所定义的上下文合格。</p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22-ID338" target="_blank" rel="noopener">类型铸造</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" target="_blank" rel="noopener">扩展</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> 嵌套 </tag>
            
            <tag> apple </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[协议protocol]]></title>
      <url>/2018/05/07/%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>甲<em>协议</em>定义的该适合特定任务或片的功能的方法，属性和其他要求的蓝图。该协议然后可以<em>采用</em>由一个类，结构，或枚举，以提供实际实施方案的这些要求。据说满足协议要求的任何类型都<em>符合</em>该协议。</p>
<p>除了指定符合类型必须实现的要求外，还可以扩展协议以实现其中一些要求或实现符合类型可以利用的其他功能。</p>
<h3 id="协议语法"><a href="#协议语法" class="headerlink" title="协议语法"></a>协议语法</h3><p>您以与类，结构和枚举类似的方式定义协议：</p>
<ol>
<li><code>protocol SomeProtocol {</code></li>
<li><code>// protocol definition goes here</code></li>
<li><p><code>}</code></p>
<a id="more"></a>
<p>自定义类型声明他们采用特定协议，方法是将协议名称放在类型名称后面，并用冒号分隔，作为其定义的一部分。可以列出多个协议，并用逗号分隔：</p>
</li>
<li><p><code>struct SomeStructure: FirstProtocol, AnotherProtocol {</code></p>
</li>
<li><code>// structure definition goes here</code></li>
<li><code>}</code></li>
</ol>
<p>如果一个类有一个超类，那么在它所采用的任何协议之前列出超类的名称，后跟一个逗号：</p>
<ol>
<li><code>class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {</code></li>
<li><code>// class definition goes here</code></li>
<li><code>}</code></li>
</ol>
<h3 id="物业要求"><a href="#物业要求" class="headerlink" title="物业要求"></a>物业要求</h3><p>一个协议可以要求任何一致性类型提供一个实例属性或者具有特定名称和类型的类型属性。该协议没有指定属性是否应该是存储属性或计算属性 - 它只指定所需的属性名称和类型。该协议还规定每个属性是否必须是可获取的或可获取<em>和</em>可设置的。</p>
<p>如果一个协议要求一个属性是可获取和可设置的，那么该属性要求不能由一个常量存储属性或一个只读计算属性来满足。如果协议只需要一个属性是可以获取的，那么这个需求可以通过任何类型的属性来满足，如果这个属性对你自己的代码有用的话，这个属性也是可以设置的。</p>
<p>属性需求总是被声明为变量属性，并以<code>var</code>关键字为前缀。Gettable和可设置的属性通过<code>{ get set }</code>在它们的类型声明之后写入来指示，并且可写属性通过写入来指示<code>{ get }</code>。</p>
<ol>
<li><code>protocol SomeProtocol {</code></li>
<li><code>var mustBeSettable: Int { get set }</code></li>
<li><code>var doesNotNeedToBeSettable: Int { get }</code></li>
<li><code>}</code></li>
</ol>
<p><code>static</code>在协议中定义关键字时， 始终将关键字的类型属性需求作为前缀。即使类型属性要求可以用类<code>class</code>或<code>static</code>关键字作为前缀，但是由类实现时，该规则也适用：</p>
<ol>
<li><code>protocol AnotherProtocol {</code></li>
<li><code>static var someTypeProperty: Int { get set }</code></li>
<li><code>}</code></li>
</ol>
<p>以下是一个具有单个实例属性要求的协议示例：</p>
<ol>
<li><code>protocol FullyNamed {</code></li>
<li><code>var fullName: String { get }</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>FullyNamed</code>协议要求符合类型以提供完全合格的名称。该协议没有指定任何有关符合类型的性质 - 它仅指定该类型必须能够为其自身提供全名。该协议规定任何<code>FullyNamed</code>类型都必须有一个名为gettable的实例属性<code>fullName</code>，它是类型的<code>String</code>。</p>
<p>以下是采用并符合<code>FullyNamed</code>协议的简单结构示例：</p>
<ol>
<li><code>struct Person: FullyNamed {</code></li>
<li><code>var fullName: String</code></li>
<li><code>}</code></li>
<li><code>let john = Person(fullName: &quot;John Appleseed&quot;)</code></li>
<li><code>// john.fullName is &quot;John Appleseed&quot;</code></li>
</ol>
<p>这个例子定义了一个叫做的结构<code>Person</code>，它表示一个特定的具名人员。它表示它将该<code>FullyNamed</code>议定书作为其定义第一行的一部分。</p>
<p>每个实例<code>Person</code>都有一个名为的存储属性<code>fullName</code>，它是类型的<code>String</code>。这符合<code>FullyNamed</code>协议的单个要求，并且意味着<code>Person</code>已经正确地符合协议。（如果协议要求未满足，Swift在编译时报告错误。）</p>
<p>这是一个更复杂的类，它也采用并符合<code>FullyNamed</code>协议：</p>
<ol>
<li><code>class Starship: FullyNamed {</code></li>
<li><code>var prefix: String?</code></li>
<li><code>var name: String</code></li>
<li><code>init(name: String, prefix: String? = nil) {</code></li>
<li><code>self.name = name</code></li>
<li><code>self.prefix = prefix</code></li>
<li><code>}</code></li>
<li><code>var fullName: String {</code></li>
<li><code>return (prefix != nil ? prefix! + &quot; &quot; : &quot;&quot;) + name</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>var ncc1701 = Starship(name: &quot;Enterprise&quot;, prefix: &quot;USS&quot;)</code></li>
<li><code>// ncc1701.fullName is &quot;USS Enterprise&quot;</code></li>
</ol>
<p>该类将<code>fullName</code>属性需求作为星舰的计算只读属性实现。每个<code>Starship</code>类实例都存储一个必需的<code>name</code>和一个可选的<code>prefix</code>。该<code>fullName</code>属性使用该<code>prefix</code>值（如果存在），并将其预先设置<code>name</code>为为星舰创建完整名称的开头。</p>
<h3 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h3><p>协议可以要求特定的实例方法和类型方法通过符合类型来实现。这些方法是作为协议定义的一部分编写的，与普通实例和类型方法完全相同，但没有大括号或方法体。允许变量参数，遵循与正常方法相同的规则。但是，不能为协议定义中的方法参数指定默认值。</p>
<p>与类型属性要求一样，<code>static</code>当在协议中定义关键字时，始终将类型方法要求作为前缀。即使类型方法需求在由类实现时带有<code>class</code>or <code>static</code>关键字前缀，情况也是如此：</p>
<ol>
<li><code>protocol SomeProtocol {</code></li>
<li><code>static func someTypeMethod()</code></li>
<li><code>}</code></li>
</ol>
<p>以下示例使用单个实例方法要求定义一个协议：</p>
<ol>
<li><code>protocol RandomNumberGenerator {</code></li>
<li><code>func random() -&gt; Double</code></li>
<li><code>}</code></li>
</ol>
<p>这个协议<code>RandomNumberGenerator</code>要求任何一致性类型都有一个实例方法调用<code>random</code>，<code>Double</code>它在调用时会返回一个值。虽然它没有被指定为协议的一部分，但是假设这个值将是一个从<code>0.0</code>（但不包括）开始的数字<code>1.0</code>。</p>
<p>该<code>RandomNumberGenerator</code>协议并没有就如何每个随机数将任何假设产生的，它只是需要发电机提供一种标准方法来生成一个新的随机数。</p>
<p>这是一个采用并符合<code>RandomNumberGenerator</code>协议的类的实现。这个类实现了一个称为<em>线性同余发生器</em>的伪随机数生成器算法：</p>
<ol>
<li><code>class LinearCongruentialGenerator: RandomNumberGenerator {</code></li>
<li><code>var lastRandom = 42.0</code></li>
<li><code>let m = 139968.0</code></li>
<li><code>let a = 3877.0</code></li>
<li><code>let c = 29573.0</code></li>
<li><code>func random() -&gt; Double {</code></li>
<li><code>lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))</code></li>
<li><code>return lastRandom / m</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>let generator = LinearCongruentialGenerator()</code></li>
<li><code>print(&quot;Here&#39;s a random number: \(generator.random())&quot;)</code></li>
<li><code>// Prints &quot;Here&#39;s a random number: 0.37464991998171&quot;</code></li>
<li><code>print(&quot;And another one: \(generator.random())&quot;)</code></li>
<li><code>// Prints &quot;And another one: 0.729023776863283&quot;</code></li>
</ol>
<h3 id="变异方法要求"><a href="#变异方法要求" class="headerlink" title="变异方法要求"></a>变异方法要求</h3><p>有时一种方法需要修改（或<em>改变</em>）它所属的实例。例如，对于值类型（即结构和枚举）<code>mutating</code>的方法，您可以将关键字放在方法的<code>func</code>关键字之前，以指示该方法可以修改其所属的实例以及该实例的任何属性。此过程在“ <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID239" target="_blank" rel="noopener">从实例方法</a>中<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID239" target="_blank" rel="noopener">修改值类型”中</a>介绍。</p>
<p>如果您定义的协议实例方法要求旨在改变采用协议的任何类型的实例，请将<code>mutating</code>关键字标记为协议定义的一部分。这使得结构和枚举可以采用协议并满足该方法的要求。</p>
<p>注意如果将协议实例方法要求标记为<code>mutating</code>，则<code>mutating</code>在为该类编写该方法的实现时，不需要编写关键字。该<code>mutating</code>关键字仅用于结构和枚举。</p>
<p>下面的例子定义了一个调用的协议<code>Togglable</code>，它定义了一个调用的单个实例方法需求<code>toggle</code>。顾名思义，该<code>toggle()</code>方法旨在切换或反转任何符合类型的状态，通常通过修改该类型的属性。</p>
<p>该<code>toggle()</code>方法使用<code>mutating</code>关键字作为<code>Togglable</code>协议定义的一部分进行标记，以指示该方法在调用时会改变符合实例的状态：</p>
<ol>
<li><code>protocol Togglable {</code></li>
<li><code>mutating func toggle()</code></li>
<li><code>}</code></li>
</ol>
<p>如果您<code>Togglable</code>为结构或枚举实现协议，则该结构或枚举可以通过提供<code>toggle()</code>也被标记为的方法的实现来符合协议<code>mutating</code>。</p>
<p>下面的例子定义了一个枚举<code>OnOffSwitch</code>。此枚举在枚举案例<code>on</code>和枚举所指示的两个状态之间切换<code>off</code>。枚举的<code>toggle</code>实现标记为<code>mutating</code>符合<code>Togglable</code>协议的要求：</p>
<ol>
<li><code>enum OnOffSwitch: Togglable {</code></li>
<li><code>case off, on</code></li>
<li><code>mutating func toggle() {</code></li>
<li><code>switch self {</code></li>
<li><code>case .off:</code></li>
<li><code>self = .on</code></li>
<li><code>case .on:</code></li>
<li><code>self = .off</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>var lightSwitch = OnOffSwitch.off</code></li>
<li><code>lightSwitch.toggle()</code></li>
<li><code>// lightSwitch is now equal to .on</code></li>
</ol>
<h3 id="初始化程序要求"><a href="#初始化程序要求" class="headerlink" title="初始化程序要求"></a>初始化程序要求</h3><p>协议可能需要通过符合类型来实现特定的初始化程序。作为协议定义的一部分，这些初始化方法与正常初始化方法完全相同，但没有大括号或初始化体：</p>
<ol>
<li><code>protocol SomeProtocol {</code></li>
<li><code>init(someParameter: Int)</code></li>
<li><code>}</code></li>
</ol>
<h3 id="协议初始化器要求的类实现"><a href="#协议初始化器要求的类实现" class="headerlink" title="协议初始化器要求的类实现"></a>协议初始化器要求的类实现</h3><p>您可以在符合类上实现协议初始值设定项要求作为指定初始值设定项或便利初始值设定项。在这两种情况下，您都必须使用<code>required</code>修饰符标记初始化程序实现：</p>
<ol>
<li><code>class SomeClass: SomeProtocol {</code></li>
<li><code>required init(someParameter: Int) {</code></li>
<li><code>// initializer implementation goes here</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p><code>required</code>修饰符 的使用可以确保您为合格类的所有子类提供初始化器要求的显式或继承实现，以使它们也符合协议。</p>
<p>有关所需初始化程序的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID231" target="_blank" rel="noopener">必需初始化程序</a>。</p>
<p>注意您不需要使用带<code>required</code>修饰符标记的类的修饰符标记协议初始化程序实现<code>final</code>，因为最终的类不能进行子类化。有关<code>final</code>修饰符的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-ID202" target="_blank" rel="noopener">防止覆盖</a>。</p>
<p>如果一个子类从一个超类中重写了一个指定的初始值设定项，并且还从一个协议中实现了一个匹配的初始值设定项需求，那么使用<code>required</code>和<code>override</code>修饰符标记初始值设定项实现：</p>
<ol>
<li><code>protocol SomeProtocol {</code></li>
<li><code>init()</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>class SomeSuperClass {</code></li>
<li><code>init() {</code></li>
<li><code>// initializer implementation goes here</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>class SomeSubClass: SomeSuperClass, SomeProtocol {</code></li>
<li><code>// &quot;required&quot; from SomeProtocol conformance; &quot;override&quot; from SomeSuperClass</code></li>
<li><code>required override init() {</code></li>
<li><code>// initializer implementation goes here</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<h3 id="Failable初始化器要求"><a href="#Failable初始化器要求" class="headerlink" title="Failable初始化器要求"></a>Failable初始化器要求</h3><p>协议可以定义符合类型的可分解的初始化器要求，如<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID224" target="_blank" rel="noopener">Failable Initializers中</a>所定义。</p>
<p>可靠的初始化器要求可以通过符合类型的failable或nonfailable初始化器来满足。一个不可破解的初始化器需求可以由一个不可破的初始化器或一个隐式解包的可分解的初始化器来满足。</p>
<h3 id="作为类型的协议"><a href="#作为类型的协议" class="headerlink" title="作为类型的协议"></a>作为类型的协议</h3><p>协议本身并不实际实现任何功能。尽管如此，您创建的任何协议都将成为代码中使用的完整类型。</p>
<p>因为它是一种类型，所以可以在允许其他类型的许多地方使用协议，包括：</p>
<ul>
<li>作为函数，方法或初始值设定项中的参数类型或返回类型</li>
<li>作为常量，变量或属性的类型</li>
<li>作为数组，字典或其他容器中的项目类型</li>
</ul>
<p>注意由于协议的类型，开始他们的名称以大写字母（如<code>FullyNamed</code>和<code>RandomNumberGenerator</code>），以配合其他类型的雨燕的名称（如<code>Int</code>，<code>String</code>和<code>Double</code>）。</p>
<p>以下是一个用作类型的协议示例：</p>
<ol>
<li><code>class Dice {</code></li>
<li><code>let sides: Int</code></li>
<li><code>let generator: RandomNumberGenerator</code></li>
<li><code>init(sides: Int, generator: RandomNumberGenerator) {</code></li>
<li><code>self.sides = sides</code></li>
<li><code>self.generator = generator</code></li>
<li><code>}</code></li>
<li><code>func roll() -&gt; Int {</code></li>
<li><code>return Int(generator.random() * Double(sides)) + 1</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>这个例子定义了一个叫做的新类<code>Dice</code>，它代表了在棋盘游戏中使用的<em>n方向</em>骰子。<code>Dice</code>实例具有一个叫做的整数属性<code>sides</code>，它表示它们有多少面，以及一个称为的属性<code>generator</code>，它提供了一个随机数生成器，从中创建骰子滚动值。</p>
<p>该<code>generator</code>属性是类型<code>RandomNumberGenerator</code>。因此，您可以将其设置为采用协议的<em>任何</em>类型的实例<code>RandomNumberGenerator</code>。除了实例必须采用<code>RandomNumberGenerator</code>协议之外，您分配给此属性的实例不需要其他任何东西。</p>
<p><code>Dice</code>也有一个初始化器，来设置它的初始状态。这个初始化器有一个名为的参数<code>generator</code>，它也是类型的<code>RandomNumberGenerator</code>。初始化新<code>Dice</code>实例时，可以将任何符合类型的值传递给此参数。</p>
<p><code>Dice</code>提供了一个实例方法，<code>roll</code>它返回1和骰子边数之间的整数值。此方法调用生成器的<code>random()</code>方法在<code>0.0</code>和之间创建一个新的随机数<code>1.0</code>，并使用此随机数在正确的范围内创建骰子滚动值。因为<code>generator</code>已知采用<code>RandomNumberGenerator</code>，所以保证有一个<code>random()</code>方法可以调用。</p>
<p>以下是如何使用这个<code>Dice</code>类创建一个具有<code>LinearCongruentialGenerator</code>实例作为随机数生成器的六面骰子：</p>
<ol>
<li><code>var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())</code></li>
<li><code>for _ in 1...5 {</code></li>
<li><code>print(&quot;Random dice roll is \(d6.roll())&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Random dice roll is 3</code></li>
<li><code>// Random dice roll is 5</code></li>
<li><code>// Random dice roll is 4</code></li>
<li><code>// Random dice roll is 5</code></li>
<li><code>// Random dice roll is 4</code></li>
</ol>
<h3 id="代表团"><a href="#代表团" class="headerlink" title="代表团"></a>代表团</h3><p><em>委托</em>是一种设计模式，它使类或结构能够<em>将</em>其某些职责交给（或<em>委托</em>）其他类型的实例。这种设计模式是通过定义一个封装委托职责的协议来实现的，从而保证一致性类型（称为委托）能够提供已委派的功能。可以使用委托来响应特定操作，或者从外部源检索数据，而无需知道该源的基本类型。</p>
<p>下面的例子定义了两种用于基于骰子的棋盘游戏的协议：</p>
<ol>
<li><code>protocol DiceGame {</code></li>
<li><code>var dice: Dice { get }</code></li>
<li><code>func play()</code></li>
<li><code>}</code></li>
<li><code>protocol DiceGameDelegate: AnyObject {</code></li>
<li><code>func gameDidStart(_ game: DiceGame)</code></li>
<li><code>func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)</code></li>
<li><code>func gameDidEnd(_ game: DiceGame)</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>DiceGame</code>协议是一个可以被任何涉及骰子的游戏所采用的协议。</p>
<p>该<code>DiceGameDelegate</code>协议可以被用来跟踪一个进程<code>DiceGame</code>。为了防止强引用周期，代表被声明为弱引用。有关弱引用的信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID51" target="_blank" rel="noopener">类实例之间的强参考循环</a>。将协议标记为类只允许<code>SnakesAndLadders</code>本章后面的类声明它的委托必须使用弱引用。仅在类中使用的协议标记为它的继承，<code>AnyObject</code>如在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID281" target="_blank" rel="noopener">纯类协议中</a>讨论的。</p>
<p>以下是最初在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" target="_blank" rel="noopener">Control Flow中</a>引入的一个版本的<em>Snakes and Ladders</em>游戏。这个版本适合于使用其骰子卷的实例; 采用协议; 并通知其进展情况： <code>Dice``DiceGame``DiceGameDelegate</code></p>
<ol>
<li><code>class SnakesAndLadders: DiceGame {</code></li>
<li><code>let finalSquare = 25</code></li>
<li><code>let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())</code></li>
<li><code>var square = 0</code></li>
<li><code>var board: [Int]</code></li>
<li><code>init() {</code></li>
<li><code>board = Array(repeating: 0, count: finalSquare + 1)</code></li>
<li><code>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02</code></li>
<li><code>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08</code></li>
<li><code>}</code></li>
<li><code>weak var delegate: DiceGameDelegate?</code></li>
<li><code>func play() {</code></li>
<li><code>square = 0</code></li>
<li><code>delegate?.gameDidStart(self)</code></li>
<li><code>gameLoop: while square != finalSquare {</code></li>
<li><code>let diceRoll = dice.roll()</code></li>
<li><code>delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)</code></li>
<li><code>switch square + diceRoll {</code></li>
<li><code>case finalSquare:</code></li>
<li><code>break gameLoop</code></li>
<li><code>case let newSquare where newSquare &gt; finalSquare:</code></li>
<li><code>continue gameLoop</code></li>
<li><code>default:</code></li>
<li><code>square += diceRoll</code></li>
<li><code>square += board[square]</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>delegate?.gameDidEnd(self)</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>有关<em>Snakes and Ladders</em>游戏的描述，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID137" target="_blank" rel="noopener">Break</a>。</p>
<p>这个版本的游戏被封装为一个叫做的类<code>SnakesAndLadders</code>，它采用了<code>DiceGame</code>协议。它提供了一个gettable <code>dice</code>属性和一个<code>play()</code>方法以符合协议。（该<code>dice</code>属性被声明为一个常量属性，因为它不需要在初始化后更改，并且协议只要求它必须是可以获取的。）</p>
<p>该<em>蛇和梯子</em>游戏板的设置采取类的内进行<code>init()</code>初始化。所有的游戏逻辑都被移动到协议的<code>play</code>方法中，该方法使用协议的所需<code>dice</code>属性来提供其骰子滚动值。</p>
<p>请注意，该<code>delegate</code>属性被定义为可<em>选项</em> <code>DiceGameDelegate</code>，因为不需要委托来玩游戏。由于它是可选类型，因此该<code>delegate</code>属性会自动设置为初始值<code>nil</code>。此后，游戏实例化器可以选择将该属性设置为合适的代理。由于<code>DiceGameDelegate</code>协议仅为类，因此您可以声明委托<code>weak</code>以防止引用循环。</p>
<p><code>DiceGameDelegate</code>提供了三种跟踪游戏进度的方法。这三种方法已被纳入上述<code>play()</code>方法中的游戏逻辑，并在新游戏开始，新游戏开始或游戏结束时被调用。</p>
<p>因为该<code>delegate</code>属性是<em>可选的</em> <code>DiceGameDelegate</code>，所以<code>play()</code>每次它在委托上调用方法时，该方法都会使用可选的链接。如果该<code>delegate</code>属性为零，则这些委托调用会优雅而无错地失败。如果该<code>delegate</code>属性为非零，则调用委托方法，并将该<code>SnakesAndLadders</code>实例作为参数传递。</p>
<p>下一个例子显示了一个叫做的类<code>DiceGameTracker</code>，它采用了这个<code>DiceGameDelegate</code>协议：</p>
<ol>
<li><code>class DiceGameTracker: DiceGameDelegate {</code></li>
<li><code>var numberOfTurns = 0</code></li>
<li><code>func gameDidStart(_ game: DiceGame) {</code></li>
<li><code>numberOfTurns = 0</code></li>
<li><code>if game is SnakesAndLadders {</code></li>
<li><code>print(&quot;Started a new game of Snakes and Ladders&quot;)</code></li>
<li><code>}</code></li>
<li><code>print(&quot;The game is using a \(game.dice.sides)-sided dice&quot;)</code></li>
<li><code>}</code></li>
<li><code>func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {</code></li>
<li><code>numberOfTurns += 1</code></li>
<li><code>print(&quot;Rolled a \(diceRoll)&quot;)</code></li>
<li><code>}</code></li>
<li><code>func gameDidEnd(_ game: DiceGame) {</code></li>
<li><code>print(&quot;The game lasted for \(numberOfTurns) turns&quot;)</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p><code>DiceGameTracker</code>实现所需的所有三种方法<code>DiceGameDelegate</code>。它使用这些方法来跟踪游戏进行的转数。它<code>numberOfTurns</code>在游戏开始时将一个属性重置为零，每次新一轮开始时将其增加一次，并在游戏结束后打印总转数。</p>
<p><code>gameDidStart(_:)</code>上面显示 的实现使用该<code>game</code>参数来打印关于即将播放的游戏的一些介绍性信息。该<code>game</code>参数有一个类型<code>DiceGame</code>，不是<code>SnakesAndLadders</code>，因此<code>gameDidStart(_:)</code>只能访问和使用作为<code>DiceGame</code>协议一部分实现的方法和属性。但是，该方法仍然能够使用类型转换来查询基础实例的类型。在这个例子中，它检查<code>game</code>实际上是否是<code>SnakesAndLadders</code>幕后实例，如果是，则打印适当的消息。</p>
<p>该<code>gameDidStart(_:)</code>方法还访问<code>dice</code>传递的<code>game</code>参数的属性。因为<code>game</code>已知符合<code>DiceGame</code>协议，所以它保证有一个<code>dice</code>属性，所以该<code>gameDidStart(_:)</code>方法能够访问和打印骰子的<code>sides</code>属性，而不管正在玩什么类型的游戏。</p>
<p>以下是<code>DiceGameTracker</code>看起来如何行动：</p>
<ol>
<li><code>let tracker = DiceGameTracker()</code></li>
<li><code>let game = SnakesAndLadders()</code></li>
<li><code>game.delegate = tracker</code></li>
<li><code>game.play()</code></li>
<li><code>// Started a new game of Snakes and Ladders</code></li>
<li><code>// The game is using a 6-sided dice</code></li>
<li><code>// Rolled a 3</code></li>
<li><code>// Rolled a 5</code></li>
<li><code>// Rolled a 4</code></li>
<li><code>// Rolled a 5</code></li>
<li><code>// The game lasted for 4 turns</code></li>
</ol>
<h3 id="添加扩展协议一致性"><a href="#添加扩展协议一致性" class="headerlink" title="添加扩展协议一致性"></a>添加扩展协议一致性</h3><p>即使您无法访问现有类型的源代码，也可以扩展现有类型以采用并符合新协议。扩展可以向现有类型添加新的属性，方法和下标，因此可以添加协议可能要求的任何要求。有关扩展的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" target="_blank" rel="noopener">扩展</a>。</p>
<p>注意当一致性被添加到扩展中的实例类型时，现有类型的实例会自动采用并符合协议。</p>
<p>例如，这个被调用的协议<code>TextRepresentable</code>可以通过任何可以被表示为文本的方式来实现。这可能是对其自身的描述，或者是其当前状态的文本版本：</p>
<ol>
<li><code>protocol TextRepresentable {</code></li>
<li><code>var textualDescription: String { get }</code></li>
<li><code>}</code></li>
</ol>
<p><code>Dice</code>上面 的课程可以扩展为采用并符合<code>TextRepresentable</code>：</p>
<ol>
<li><code>extension Dice: TextRepresentable {</code></li>
<li><code>var textualDescription: String {</code></li>
<li><code>return &quot;A \(sides)-sided dice&quot;</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>此扩展采用新协议，方式与<code>Dice</code>原始实现中提供的方式完全相同。协议名称在类型名称之后提供，以冒号分隔，协议的所有要求的实现在扩展的大括号内提供。</p>
<p><code>Dice</code>现在可以将 任何实例视为<code>TextRepresentable</code>：</p>
<ol>
<li><code>let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())</code></li>
<li><code>print(d12.textualDescription)</code></li>
<li><code>// Prints &quot;A 12-sided dice&quot;</code></li>
</ol>
<p>同样，<code>SnakesAndLadders</code>游戏类可以扩展为采用并符合<code>TextRepresentable</code>协议：</p>
<ol>
<li><code>extension SnakesAndLadders: TextRepresentable {</code></li>
<li><code>var textualDescription: String {</code></li>
<li><code>return &quot;A game of Snakes and Ladders with \(finalSquare) squares&quot;</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>print(game.textualDescription)</code></li>
<li><code>// Prints &quot;A game of Snakes and Ladders with 25 squares&quot;</code></li>
</ol>
<h3 id="有条件地符合议定书"><a href="#有条件地符合议定书" class="headerlink" title="有条件地符合议定书"></a>有条件地符合议定书</h3><p>通用类型只能在某些条件下才能满足协议的要求，例如类型的通用参数符合协议。在扩展类型时，可以通过列出约束来使通用类型有条件地符合协议。通过编写通用<code>where</code>子句，将这些约束条件写在所采用协议的名称后面。有关泛型<code>where</code>子句的更多信息，请参见<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID192" target="_blank" rel="noopener">泛型Where子句</a>。</p>
<p>下面的扩展使得<code>Array</code>实例符合<code>TextRepresentable</code>协议，只要它们存储符合的类型的元素<code>TextRepresentable</code>。</p>
<ol>
<li><code>extension Array: TextRepresentable where Element: TextRepresentable {</code></li>
<li><code>var textualDescription: String {</code></li>
<li><code>let itemsAsText = self.map { $0.textualDescription }</code></li>
<li><code>return &quot;[&quot; + itemsAsText.joined(separator: &quot;, &quot;) + &quot;]&quot;</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>let myDice = [d6, d12]</code></li>
<li><code>print(myDice.textualDescription)</code></li>
<li><code>// Prints &quot;[A 6-sided dice, A 12-sided dice]&quot;</code></li>
</ol>
<h3 id="使用扩展声明协议采用"><a href="#使用扩展声明协议采用" class="headerlink" title="使用扩展声明协议采用"></a>使用扩展声明协议采用</h3><p>如果一个类型已经符合协议的所有要求，但尚未声明它采用该协议，则可以使其采用具有空扩展名的协议：</p>
<ol>
<li><code>struct Hamster {</code></li>
<li><code>var name: String</code></li>
<li><code>var textualDescription: String {</code></li>
<li><code>return &quot;A hamster named \(name)&quot;</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>extension Hamster: TextRepresentable {}</code></li>
</ol>
<p><code>Hamster</code>现在可以在任何<code>TextRepresentable</code>需要的类型中使用 实例：</p>
<ol>
<li><code>let simonTheHamster = Hamster(name: &quot;Simon&quot;)</code></li>
<li><code>let somethingTextRepresentable: TextRepresentable = simonTheHamster</code></li>
<li><code>print(somethingTextRepresentable.textualDescription)</code></li>
<li><code>// Prints &quot;A hamster named Simon&quot;</code></li>
</ol>
<p>注意只有满足其要求，类型才会自动采用协议。他们必须始终明确宣布他们通过协议。</p>
<h3 id="协议类型的集合"><a href="#协议类型的集合" class="headerlink" title="协议类型的集合"></a>协议类型的集合</h3><p>协议可以用作要存储在集合中的类型，如数组或字典，如<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID275" target="_blank" rel="noopener">协议类型中所述</a>。这个例子创建了一系列的<code>TextRepresentable</code>东西：</p>
<ol>
<li><code>let things: [TextRepresentable] = [game, d12, simonTheHamster]</code></li>
</ol>
<p>现在可以遍历数组中的项目，并打印每个项目的文本描述：</p>
<ol>
<li><code>for thing in things {</code></li>
<li><code>print(thing.textualDescription)</code></li>
<li><code>}</code></li>
<li><code>// A game of Snakes and Ladders with 25 squares</code></li>
<li><code>// A 12-sided dice</code></li>
<li><code>// A hamster named Simon</code></li>
</ol>
<p>请注意，<code>thing</code>常数是类型的<code>TextRepresentable</code>。它不是类型的<code>Dice</code>，或者<code>DiceGame</code>，<code>Hamster</code>即使幕后的实际实例属于这些类型之一。尽管如此，因为它是类型的<code>TextRepresentable</code>，并且任何<code>TextRepresentable</code>已知的<code>textualDescription</code>属性都有，所以<code>thing.textualDescription</code>每次通过循环访问都是安全的。</p>
<h3 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h3><p>一个协议可以<em>继承</em>一个或多个其他协议，并且可以在其继承的需求之上添加更多的需求。协议继承的语法与类继承的语法相似，但可以选择列出多个继承协议（用逗号分隔）：</p>
<ol>
<li><code>protocol InheritingProtocol: SomeProtocol, AnotherProtocol {</code></li>
<li><code>// protocol definition goes here</code></li>
<li><code>}</code></li>
</ol>
<p>以下是一个继承上述<code>TextRepresentable</code>协议的协议示例：</p>
<ol>
<li><code>protocol PrettyTextRepresentable: TextRepresentable {</code></li>
<li><code>var prettyTextualDescription: String { get }</code></li>
<li><code>}</code></li>
</ol>
<p>这个例子定义了一个新的协议<code>PrettyTextRepresentable</code>，它从中继承<code>TextRepresentable</code>。任何采取的措施都<code>PrettyTextRepresentable</code>必须满足所强制执行的所有要求<code>TextRepresentable</code>，<em>以及</em>强制实施的附加要求<code>PrettyTextRepresentable</code>。在这个例子中，<code>PrettyTextRepresentable</code>增加了一个单独的需求来提供一个叫做<code>prettyTextualDescription</code>返回a 的gettable属性<code>String</code>。</p>
<p>该<code>SnakesAndLadders</code>级可扩展到通过并符合<code>PrettyTextRepresentable</code>：</p>
<ol>
<li><code>extension SnakesAndLadders: PrettyTextRepresentable {</code></li>
<li><code>var prettyTextualDescription: String {</code></li>
<li><code>var output = textualDescription + &quot;:\n&quot;</code></li>
<li><code>for index in 1...finalSquare {</code></li>
<li><code>switch board[index] {</code></li>
<li><code>case let ladder where ladder &gt; 0:</code></li>
<li><code>output += &quot;▲ &quot;</code></li>
<li><code>case let snake where snake &lt; 0:</code></li>
<li><code>output += &quot;▼ &quot;</code></li>
<li><code>default:</code></li>
<li><code>output += &quot;○ &quot;</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>return output</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>该扩展指出它采用<code>PrettyTextRepresentable</code>协议并提供<code>prettyTextualDescription</code>该<code>SnakesAndLadders</code>类型属性的实现。任何东西也<code>PrettyTextRepresentable</code>必须是<code>TextRepresentable</code>这样的，所以<code>prettyTextualDescription</code>通过<code>textualDescription</code>从<code>TextRepresentable</code>协议访问属性开始执行输出字符串。它追加冒号和换行符，并将其用作其漂亮文本表示的开始。然后它遍历棋盘方格阵列，并附加一个几何形状来表示每个方格的内容：</p>
<ul>
<li>如果方格的值大于<code>0</code>，则它是梯子的基础，并由其表示<code>▲</code>。</li>
<li>如果方格的值小于<code>0</code>，则它是蛇的头部，并由其表示<code>▼</code>。</li>
<li>否则，广场的价值是<code>0</code>，这是一个“自由”的平方，由<code>○</code>。</li>
</ul>
<p>该<code>prettyTextualDescription</code>属性现在可以用来打印任何<code>SnakesAndLadders</code>实例的漂亮文本描述：</p>
<ol>
<li><code>print(game.prettyTextualDescription)</code></li>
<li><code>// A game of Snakes and Ladders with 25 squares:</code></li>
<li><code>// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</code></li>
</ol>
<h3 id="仅限于类的协议"><a href="#仅限于类的协议" class="headerlink" title="仅限于类的协议"></a>仅限于类的协议</h3><p>通过将<code>AnyObject</code>协议添加到协议的继承列表中，您可以将协议采用限制为类类型（而不是结构或枚举）。</p>
<ol>
<li><code>protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {</code></li>
<li><code>// class-only protocol definition goes here</code></li>
<li><code>}</code></li>
</ol>
<p>在上面的例子中，<code>SomeClassOnlyProtocol</code>只能通过类类型来采用。编写尝试采用的结构或枚举定义是编译时错误<code>SomeClassOnlyProtocol</code>。</p>
<p>注意当该协议的需求定义的行为假设或要求符合类型具有引用语义而不是值语义时，请使用仅类别协议。有关引用和值语义的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID88" target="_blank" rel="noopener">结构和枚举是值类型</a>和<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID89" target="_blank" rel="noopener">类是引用类型</a>。</p>
<h3 id="协议组成"><a href="#协议组成" class="headerlink" title="协议组成"></a>协议组成</h3><p>要求类型同时符合多个协议会很有用。您可以使用<em>协议组合</em>将多个协议组合成单个需求。协议组合的行为就好像您定义了一个临时本地协议，该协议具有组合中所有协议的组合要求。协议组合不定义任何新的协议类型。</p>
<p>协议组合具有这种形式<code>SomeProtocol &amp; AnotherProtocol</code>。您可以根据需要列出尽可能多的协议，并用＆符号（<code>&amp;</code>）分隔它们。除协议列表之外，协议组合还可以包含一个类类型，您可以使用它来指定所需的超类。</p>
<p>以下是一个将两个协议调用<code>Named</code>并<code>Aged</code>组合成一个函数参数的单个协议组合需求的示例：</p>
<ol>
<li><code>protocol Named {</code></li>
<li><code>var name: String { get }</code></li>
<li><code>}</code></li>
<li><code>protocol Aged {</code></li>
<li><code>var age: Int { get }</code></li>
<li><code>}</code></li>
<li><code>struct Person: Named, Aged {</code></li>
<li><code>var name: String</code></li>
<li><code>var age: Int</code></li>
<li><code>}</code></li>
<li><code>func wishHappyBirthday(to celebrator: Named &amp; Aged) {</code></li>
<li><code>print(&quot;Happy birthday, \(celebrator.name), you&#39;re \(celebrator.age)!&quot;)</code></li>
<li><code>}</code></li>
<li><code>let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)</code></li>
<li><code>wishHappyBirthday(to: birthdayPerson)</code></li>
<li><code>// Prints &quot;Happy birthday, Malcolm, you&#39;re 21!&quot;</code></li>
</ol>
<p>在这个例子中，该<code>Named</code>协议对于<code>String</code>所谓的gettable 属性有一个单独的要求<code>name</code>。该<code>Aged</code>协议对于<code>Int</code>所谓的gettable 属性有一个单独的要求<code>age</code>。两个协议都被一个叫做结构的结构采用<code>Person</code>。</p>
<p>该示例还定义了一个<code>wishHappyBirthday(to:)</code>函数。<code>celebrator</code>参数的类型是<code>Named &amp; Aged</code>，这意味着“符合<code>Named</code>和<code>Aged</code>协议的任何类型” 。只要符合所需的两种协议，传递给函数的是哪一种特定的类型都无关紧要。</p>
<p>然后该示例创建一个新<code>Person</code>实例<code>birthdayPerson</code>，并将该新实例传递给该<code>wishHappyBirthday(to:)</code>函数。由于<code>Person</code>符合两种协议，此调用是有效的，并且该<code>wishHappyBirthday(to:)</code>函数可以打印其生日问候语。</p>
<p>下面是一个将<code>Named</code>前一个示例中的协议与一个<code>Location</code>类相结合的示例：</p>
<ol>
<li><code>class Location {</code></li>
<li><code>var latitude: Double</code></li>
<li><code>var longitude: Double</code></li>
<li><code>init(latitude: Double, longitude: Double) {</code></li>
<li><code>self.latitude = latitude</code></li>
<li><code>self.longitude = longitude</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>class City: Location, Named {</code></li>
<li><code>var name: String</code></li>
<li><code>init(name: String, latitude: Double, longitude: Double) {</code></li>
<li><code>self.name = name</code></li>
<li><code>super.init(latitude: latitude, longitude: longitude)</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>func beginConcert(in location: Location &amp; Named) {</code></li>
<li><code>print(&quot;Hello, \(location.name)!&quot;)</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>let seattle = City(name: &quot;Seattle&quot;, latitude: 47.6, longitude: -122.3)</code></li>
<li><code>beginConcert(in: seattle)</code></li>
<li><code>// Prints &quot;Hello, Seattle!&quot;</code></li>
</ol>
<p>该<code>beginConcert(in:)</code>函数接受一个类型参数<code>Location &amp; Named</code>，这意味着“任何类型都是协议的子类，<code>Location</code>并且符合<code>Named</code>协议。”在这种情况下，<code>City</code>满足这两个要求。</p>
<p>传递<code>birthdayPerson</code>给<code>beginConcert(in:)</code>函数是无效的，因为<code>Person</code>它不是的子类<code>Location</code>。同样，如果您创建了<code>Location</code>不符合<code>Named</code>协议的子类，则<code>beginConcert(in:)</code>使用该类型的实例进行调用也是无效的。</p>
<h3 id="检查协议一致性"><a href="#检查协议一致性" class="headerlink" title="检查协议一致性"></a>检查协议一致性</h3><p>您可以使用<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22-ID338" target="_blank" rel="noopener">类型转换中</a>描述的<code>is</code>和<code>as</code>运算符来检查协议一致性，并转换为特定的协议。检查并转换为协议遵循与检查和转换为类型完全相同的语法：</p>
<ul>
<li>该<code>is</code>运算符返回<code>true</code>如果一个实例遵循的协议，并返回<code>false</code>，如果它不。</li>
<li><code>as?</code>downcast运算符 的版本返回协议类型的可选值，<code>nil</code>如果实例不符合该协议，则此值为。</li>
<li><code>as!</code>downcast操作符 的版本强制downcast转换为协议类型，如果downcast不成功，则触发运行时错误。</li>
</ul>
<p>这个例子定义了一个调用的协议<code>HasArea</code>，其中一个gettable <code>Double</code>属性的单个属性需求叫做<code>area</code>：</p>
<ol>
<li><code>protocol HasArea {</code></li>
<li><code>var area: Double { get }</code></li>
<li><code>}</code></li>
</ol>
<p>这里有两个类，<code>Circle</code>并且<code>Country</code>，这两者的符合<code>HasArea</code>协议：</p>
<ol>
<li><code>class Circle: HasArea {</code></li>
<li><code>let pi = 3.1415927</code></li>
<li><code>var radius: Double</code></li>
<li><code>var area: Double { return pi * radius * radius }</code></li>
<li><code>init(radius: Double) { self.radius = radius }</code></li>
<li><code>}</code></li>
<li><code>class Country: HasArea {</code></li>
<li><code>var area: Double</code></li>
<li><code>init(area: Double) { self.area = area }</code></li>
<li><code>}</code></li>
</ol>
<p>的<code>Circle</code>类实现<code>area</code>性能要求作为一个计算的属性的基础上，所存储的<code>radius</code>属性。本<code>Country</code>类实现了<code>area</code>直接需求的存储性能。两个类都正确地符合<code>HasArea</code>协议。</p>
<p>这是一个叫做的类<code>Animal</code>，它不符合<code>HasArea</code>协议：</p>
<ol>
<li><code>class Animal {</code></li>
<li><code>var legs: Int</code></li>
<li><code>init(legs: Int) { self.legs = legs }</code></li>
<li><code>}</code></li>
</ol>
<p>的<code>Circle</code>，<code>Country</code>而<code>Animal</code>类没有共享的基类。尽管如此，它们都是类，所有这三种类型的实例都可以用来初始化一个存储类型值的数组<code>AnyObject</code>：</p>
<ol>
<li><code>let objects: [AnyObject] = [</code></li>
<li><code>Circle(radius: 2.0),</code></li>
<li><code>Country(area: 243_610),</code></li>
<li><code>Animal(legs: 4)</code></li>
<li><code>]</code></li>
</ol>
<p>该<code>objects</code>阵列被初始化为常量，其中包含的阵列<code>Circle</code>具有2个单位的半径实例; 一个<code>Country</code>以平方公里的英国地表面积初始化的例子; 和<code>Animal</code>四条腿的例子。</p>
<p>的<code>objects</code>阵列现在可以重复，并且阵列中的每个对象可以被检查，看它是否符合<code>HasArea</code>协议：</p>
<ol>
<li><code>for object in objects {</code></li>
<li><code>if let objectWithArea = object as? HasArea {</code></li>
<li><code>print(&quot;Area is \(objectWithArea.area)&quot;)</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;Something that doesn&#39;t have an area&quot;)</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>// Area is 12.5663708</code></li>
<li><code>// Area is 243610.0</code></li>
<li><code>// Something that doesn&#39;t have an area</code></li>
</ol>
<p>只要数组中的某个对象符合该<code>HasArea</code>协议，<code>as?</code>运算符返回的可选值就会使用可选的绑定解压到一个名为常量的常量中<code>objectWithArea</code>。该<code>objectWithArea</code>常数是已知的类型<code>HasArea</code>，因此其<code>area</code>属性可以以类型安全的方式访问和打印。</p>
<p>请注意，投射过程不会更改底层对象。他们继续是一个<code>Circle</code>，一个<code>Country</code>和一个<code>Animal</code>。然而，在它们存储在<code>objectWithArea</code>常量中的时候，它们只知道是类型的<code>HasArea</code>，所以只有它们的<code>area</code>属性可以被访问。</p>
<h3 id="可选协议要求"><a href="#可选协议要求" class="headerlink" title="可选协议要求"></a>可选协议要求</h3><p>您可以为协议定义<em>可选的需求</em>，这些需求不一定要通过符合协议的类型来实现。<code>optional</code>作为协议定义的一部分，可选要求由修饰符作为前缀。可选的需求是可用的，以便您可以编写与Objective-C互操作的代码。协议和可选要求都必须用<code>@objc</code>属性标记。请注意，<code>@objc</code>协议只能由继承自Objective-C类或其他<code>@objc</code>类的类采用。它们不能被结构或枚举所采纳。</p>
<p>当您在可选需求中使用方法或属性时，其类型自动成为可选项。例如，类型的方法<code>(Int) -&gt; String</code>变为<code>((Int) -&gt; String)?</code>。请注意，整个函数类型都包含在可选项中，而不是方法的返回值。</p>
<p>一个可选的协议需求可以通过可选的链接来调用，以说明需求没有被一个符合协议的类型实现的可能性。通过在调用方法的名称后面写一个问号来检查可选方法的实现，例如<code>someOptionalMethod?(someArgument)</code>。有关可选链接的信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245" target="_blank" rel="noopener">可选链接</a>。</p>
<p>以下示例定义了一个称为的整数计数类<code>Counter</code>，它使用外部数据源来提供其增量。该数据源由<code>CounterDataSource</code>协议定义，该协议有两个可选要求：</p>
<ol>
<li><code>@objc protocol CounterDataSource {</code></li>
<li><code>@objc optional func increment(forCount count: Int) -&gt; Int</code></li>
<li><code>@objc optional var fixedIncrement: Int { get }</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>CounterDataSource</code>协议定义了一个可选的方法需求调用<code>increment(forCount:)</code>和一个可选的属性需求<code>fixedIncrement</code>。这些要求为数据源定义了两种不同的方式来为<code>Counter</code>实例提供适当的增量。</p>
<p>注意严格地说，您可以编写一个自定义的类，以符合<code>CounterDataSource</code>不需要执行<em>任何</em>协议要求。毕竟，它们都是可选的。尽管技术上允许，但这不会构成非常好的数据源。</p>
<p>的<code>Counter</code>类，下面定义，具有可选的<code>dataSource</code>类型的属性<code>CounterDataSource?</code>：</p>
<ol>
<li><code>class Counter {</code></li>
<li><code>var count = 0</code></li>
<li><code>var dataSource: CounterDataSource?</code></li>
<li><code>func increment() {</code></li>
<li><code>if let amount = dataSource?.increment?(forCount: count) {</code></li>
<li><code>count += amount</code></li>
<li><code>} else if let amount = dataSource?.fixedIncrement {</code></li>
<li><code>count += amount</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>在<code>Counter</code>类存储在一个名为变量属性的当前值<code>count</code>。的<code>Counter</code>类也定义了一个称为方法<code>increment</code>，其中递增<code>count</code>每次方法调用时属性。</p>
<p>该<code>increment()</code>方法首先尝试通过<code>increment(forCount:)</code>在其数据源上查找该方法的实现来检索增量量。该<code>increment()</code>方法使用可选的链接来尝试调用<code>increment(forCount:)</code>，并将当前<code>count</code>值作为方法的单个参数传递。</p>
<p>请注意，这里有<em>两个</em>级别的可选链接。首先，这可能是<code>dataSource</code>可能的<code>nil</code>，因此<code>dataSource</code>在其名称后面有一个问号，表示<code>increment(forCount:)</code>只有在<code>dataSource</code>没有问号时才应该调用它<code>nil</code>。其次，即使<code>dataSource</code> <em>不</em>存在，也不能保证它实现了<code>increment(forCount:)</code>，因为它是一个可选的要求。在这里，<code>increment(forCount:)</code>可能没有实现的可能性也由可选链处理。<code>increment(forCount:)</code>只有在<code>increment(forCount:)</code>存在的情况下才会发生呼叫- 即，如果不存在<code>nil</code>。这就是为什么<code>increment(forCount:)</code>在它的名字后面写上一个问号。</p>
<p>由于<code>increment(forCount:)</code>以上两种原因之一致使呼叫可能失败，因此呼叫将返回<em>可选</em> <code>Int</code>值。即使<code>increment(forCount:)</code>被定义为<code>Int</code>在定义中返回非选项值，情况也是如此<code>CounterDataSource</code>。即使有两个可选的链接操作，一个接一个，结果仍然包装在一个可选的。有关使用多个可选链接操作的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID252" target="_blank" rel="noopener">链接多个链接级别</a>。</p>
<p>打完电话后<code>increment(forCount:)</code>，可选的<code>Int</code>，它返回的是解开到一个名为常量<code>amount</code>，使用可选的绑定。如果可选<code>Int</code>确实包含一个值 - 即，如果委托和方法都存在，并且该方法返回一个值 - 则将解包的<code>amount</code>内容添加到存储的<code>count</code>属性中，并且增量完成。</p>
<p>如果<em>无法</em>从<code>increment(forCount:)</code>方法中检索值（无论是因为<code>dataSource</code>nil，还是因为数据源未实现），<code>increment(forCount:)</code>那么该<code>increment()</code>方法会尝试从数据源的<code>fixedIncrement</code>属性中检索值。该<code>fixedIncrement</code>属性也是一个可选的需求，所以它的值是一个可选<code>Int</code>值，尽管它<code>fixedIncrement</code>被定义为非可选<code>Int</code>属性作为<code>CounterDataSource</code>协议定义的一部分。</p>
<p>这是一个简单的<code>CounterDataSource</code>实现，数据源在<code>3</code>每次查询时返回一个常量值。它通过实现可选的<code>fixedIncrement</code>属性需求来实现这一点：</p>
<ol>
<li><code>class ThreeSource: NSObject, CounterDataSource {</code></li>
<li><code>let fixedIncrement = 3</code></li>
<li><code>}</code></li>
</ol>
<p>您可以使用一个实例<code>ThreeSource</code>作为新<code>Counter</code>实例的数据源：</p>
<ol>
<li><code>var counter = Counter()</code></li>
<li><code>counter.dataSource = ThreeSource()</code></li>
<li><code>for _ in 1...4 {</code></li>
<li><code>counter.increment()</code></li>
<li><code>print(counter.count)</code></li>
<li><code>}</code></li>
<li><code>// 3</code></li>
<li><code>// 6</code></li>
<li><code>// 9</code></li>
<li><code>// 12</code></li>
</ol>
<p>上面的代码创建一个新的<code>Counter</code>实例; 将其数据源设置为新<code>ThreeSource</code>实例; 并调用计数器的<code>increment()</code>方法四次。正如所料，该柜台的<code>count</code>财产每次增加三次<code>increment()</code>。</p>
<p>这是一个更复杂的数据源<code>TowardsZeroSource</code>，它使<code>Counter</code>实例从当前<code>count</code>值向上或向下趋近于零：</p>
<ol>
<li><code>class TowardsZeroSource: NSObject, CounterDataSource {</code></li>
<li><code>func increment(forCount count: Int) -&gt; Int {</code></li>
<li><code>if count == 0 {</code></li>
<li><code>return 0</code></li>
<li><code>} else if count &lt; 0 {</code></li>
<li><code>return 1</code></li>
<li><code>} else {</code></li>
<li><code>return -1</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>的<code>TowardsZeroSource</code>类实现可选的<code>increment(forCount:)</code>从方法<code>CounterDataSource</code>协议并使用该<code>count</code>参数值，以计算出在计数的方向。如果<code>count</code>已经是零，则该方法返回<code>0</code>到表示没有进一步的计数应该发生。</p>
<p>您可以使用<code>TowardsZeroSource</code>现有<code>Counter</code>实例的实例从<code>-4</code>0 开始计数。一旦计数器达到零，不再进行计数：</p>
<ol>
<li><code>counter.count = -4</code></li>
<li><code>counter.dataSource = TowardsZeroSource()</code></li>
<li><code>for _ in 1...5 {</code></li>
<li><code>counter.increment()</code></li>
<li><code>print(counter.count)</code></li>
<li><code>}</code></li>
<li><code>// -3</code></li>
<li><code>// -2</code></li>
<li><code>// -1</code></li>
<li><code>// 0</code></li>
<li><code>// 0</code></li>
</ol>
<h3 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h3><p>可以扩展协议以向符合类型提供方法，初始化程序，下标和计算属性实现。这允许您定义协议本身的行为，而不是每个类型的单独一致性或全局函数中的行为。</p>
<p>例如，该<code>RandomNumberGenerator</code>协议可以扩展为提供一种<code>randomBool()</code>方法，该方法使用所需<code>random()</code>方法的结果返回一个随机<code>Bool</code>值：</p>
<ol>
<li><code>extension RandomNumberGenerator {</code></li>
<li><code>func randomBool() -&gt; Bool {</code></li>
<li><code>return random() &gt; 0.5</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>通过在协议上创建扩展，所有符合类型自动获得此方法实现，无需任何额外的修改。</p>
<ol>
<li><code>let generator = LinearCongruentialGenerator()</code></li>
<li><code>print(&quot;Here&#39;s a random number: \(generator.random())&quot;)</code></li>
<li><code>// Prints &quot;Here&#39;s a random number: 0.37464991998171&quot;</code></li>
<li><code>print(&quot;And here&#39;s a random Boolean: \(generator.randomBool())&quot;)</code></li>
<li><code>// Prints &quot;And here&#39;s a random Boolean: true&quot;</code></li>
</ol>
<p>协议扩展可以将实现添加到符合类型，但不能使协议扩展或从另一个协议继承。协议继承总是在协议声明本身中指定的。</p>
<h3 id="提供默认实现"><a href="#提供默认实现" class="headerlink" title="提供默认实现"></a>提供默认实现</h3><p>您可以使用协议扩展来为该协议的任何方法或计算属性要求提供默认实现。如果一致性类型提供了自己的必需方法或属性的实现，则将使用该实现来代替扩展提供的实现。</p>
<p>注意通过扩展提供的默认实现的协议要求与可选的协议要求不同。尽管符合类型不必提供它们自己的实现，但可以在没有可选链接的情况下调用具有默认实现的需求。</p>
<p>例如，<code>PrettyTextRepresentable</code>继承<code>TextRepresentable</code>协议的协议可以提供其必需<code>prettyTextualDescription</code>属性的默认实现，以简单地返回访问该<code>textualDescription</code>属性的结果：</p>
<ol>
<li><code>extension PrettyTextRepresentable  {</code></li>
<li><code>var prettyTextualDescription: String {</code></li>
<li><code>return textualDescription</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<h3 id="将约束添加到协议扩展"><a href="#将约束添加到协议扩展" class="headerlink" title="将约束添加到协议扩展"></a>将约束添加到协议扩展</h3><p>定义协议扩展时，可以指定符合类型在扩展的方法和属性可用之前必须满足的约束。你通过编写一个通用的<code>where</code>子句，在你要扩展的协议的名字后写这些约束。有关泛型<code>where</code>子句的更多信息，请参见<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID192" target="_blank" rel="noopener">泛型Where子句</a>。</p>
<p>例如，您可以定义<code>Collection</code>适用于元素符合<code>Equatable</code>协议的任何集合的协议的扩展。通过将集合的元素约束到<code>Equatable</code>协议（标准库的一部分），可以使用<code>==</code>和<code>!=</code>运算符来检查两个元素之间的等式和不等式。</p>
<ol>
<li><code>extension Collection where Element: Equatable {</code></li>
<li><code>func allEqual() -&gt; Bool {</code></li>
<li><code>for element in self {</code></li>
<li><code>if element != self.first {</code></li>
<li><code>return false</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>return true</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>allEqual()</code>方法<code>true</code>仅在集合中的所有元素相等时才返回。</p>
<p>考虑两个整数数组，一个是所有元素都相同，另一个不是：</p>
<ol>
<li><code>let equalNumbers = [100, 100, 100, 100, 100]</code></li>
<li><code>let differentNumbers = [100, 100, 200, 100, 200]</code></li>
</ol>
<p>因为数组符合<code>Collection</code>和整数符合<code>Equatable</code>，<code>equalNumbers</code>并且<code>differentNumbers</code>可以使用该<code>allEqual()</code>方法：</p>
<ol>
<li><code>print(equalNumbers.allEqual())</code></li>
<li><code>// Prints &quot;true&quot;</code></li>
<li><code>print(differentNumbers.allEqual())</code></li>
<li><code>// Prints &quot;false&quot;</code></li>
</ol>
<p>注意如果符合类型满足多个约束扩展的要求，这些扩展为相同的方法或属性提供实现，则Swift使用与最专用约束相对应的实现。</p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" target="_blank" rel="noopener">扩展</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179" target="_blank" rel="noopener">泛型</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> apple </tag>
            
            <tag> protocol </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS泛型]]></title>
      <url>/2018/05/07/%E6%B3%9B%E5%9E%8BT/</url>
      <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><em>通用代码</em>使您能够编写灵活的，可重用的函数和类型，它们可以与任何类型一起使用，并符合您定义的要求。您可以编写避免重复的代码，并以清晰抽象的方式表达其意图。</p>
<p>泛型是Swift最强大的特性之一，Swift标准库的大部分都是用泛型代码构建的。实际上，即使您没有意识到，您在整个“ <em>语言指南”中</em>都一直在使用泛型。例如，Swift <code>Array</code>和<code>Dictionary</code>类型都是泛型集合。你可以创建一个包含<code>Int</code>值的数组，或者一个包含值的数组<code>String</code>，或者确实可以在Swift中创建任何其他类型的数组。同样，您可以创建一个字典来存储任何指定类型的值，并且对该类型可以是什么没有限制。</p>
<h3 id="泛型求解的问题"><a href="#泛型求解的问题" class="headerlink" title="泛型求解的问题"></a>泛型求解的问题</h3><p>这是一个标准的非泛型函数<code>swapTwoInts(_:_:)</code>，它可以交换两个<code>Int</code>值：</p>
<ol>
<li><code>func swapTwoInts(_ a: inout Int, _ b: inout Int) {</code></li>
<li><code>let temporaryA = a</code></li>
<li><code>a = b</code></li>
<li><code>b = temporaryA</code></li>
<li><code>}</code><a id="more"></a>
该功能利用了在出参数交换的值<code>a</code>和<code>b</code>，如在描述<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID173" target="_blank" rel="noopener">的In-Out参数</a>。</li>
</ol>
<p>该<code>swapTwoInts(_:_:)</code>函数将原始值交换<code>b</code>为<code>a</code>，并将原始值交换<code>a</code>为<code>b</code>。你可以调用这个函数来交换两个<code>Int</code>变量的值：</p>
<ol>
<li><code>var someInt = 3</code></li>
<li><code>var anotherInt = 107</code></li>
<li><code>swapTwoInts(&amp;someInt, &amp;anotherInt)</code></li>
<li><code>print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)</code></li>
<li><code>// Prints &quot;someInt is now 107, and anotherInt is now 3&quot;</code></li>
</ol>
<p>该<code>swapTwoInts(_:_:)</code>功能很有用，但它只能与<code>Int</code>值一起使用。如果你想交换两个<code>String</code>值或两个<code>Double</code>值，你必须编写更多的函数，比如下面的函数<code>swapTwoStrings(_:_:)</code>和<code>swapTwoDoubles(_:_:)</code>函数：</p>
<ol>
<li><code>func swapTwoStrings(_ a: inout String, _ b: inout String) {</code></li>
<li><code>let temporaryA = a</code></li>
<li><code>a = b</code></li>
<li><code>b = temporaryA</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {</code></li>
<li><code>let temporaryA = a</code></li>
<li><code>a = b</code></li>
<li><code>b = temporaryA</code></li>
<li><code>}</code></li>
</ol>
<p>您可能已经注意到的尸体<code>swapTwoInts(_:_:)</code>，<code>swapTwoStrings(_:_:)</code>和<code>swapTwoDoubles(_:_:)</code>功能是相同的。唯一的区别是该值的，他们接受的类型（<code>Int</code>，<code>String</code>，和<code>Double</code>）。</p>
<p>编写一个交换<em>任何</em>类型的两个值的单个函数更有用，而且更灵活。通用代码使您能够编写这样的功能。（这些函数的通用版本定义如下。）</p>
<p>注意在所有三个函数中，类型<code>a</code>和<code>b</code>必须是相同的。如果<code>a</code>和<code>b</code>不是同一类型，则不可能交换它们的值。Swift是一种类型安全的语言，不允许（例如）类型<code>String</code>的变量和类型的变量<code>Double</code>相互交换值。试图这样做会导致编译时错误。</p>
<h3 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h3><p><em>通用函数</em>可以处理任何类型。这是<code>swapTwoInts(_:_:)</code>上面函数的一个通用版本，称为<code>swapTwoValues(_:_:)</code>：</p>
<ol>
<li><code>func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {</code></li>
<li><code>let temporaryA = a</code></li>
<li><code>a = b</code></li>
<li><code>b = temporaryA</code></li>
<li><code>}</code></li>
</ol>
<p>所述的主体<code>swapTwoValues(_:_:)</code>的功能是相同的身体<code>swapTwoInts(_:_:)</code>功能。但是，第一行与第一行<code>swapTwoValues(_:_:)</code>稍有不同<code>swapTwoInts(_:_:)</code>。以下是第一行比较的方式：</p>
<ol>
<li><code>func swapTwoInts(_ a: inout Int, _ b: inout Int)</code></li>
<li><code>func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T)</code></li>
</ol>
<p>该函数的通用版本使用<em>占位符</em>的类型名（称为<code>T</code>，在这种情况下），而不是一个<em>实际的</em>类型名称（例如<code>Int</code>，<code>String</code>或<code>Double</code>）。占位符类型名字就不说了什么什么<code>T</code>必须的，但它<em>确实</em>说，双方<code>a</code>并<code>b</code>必须是同一类型的<code>T</code>，不管<code>T</code>代表。<code>T</code>每次<code>swapTwoValues(_:_:)</code>调用函数时都会确定要使用的实际类型。</p>
<p>泛型函数和非泛型函数之间的另一个区别在于泛型函数的名称（<code>swapTwoValues(_:_:)</code>）后面跟着<code>T</code>尖括号（<code>&lt;T&gt;</code>）中的占位符类型名称（）。括号告诉Swift，它<code>T</code>是<code>swapTwoValues(_:_:)</code>函数定义中的占位符类型名称。因为<code>T</code>是一个占位符，所以Swift不会寻找一个实际的类型<code>T</code>。</p>
<p><code>swapTwoValues(_:_:)</code>现在可以按照相同的方式调用 该函数<code>swapTwoInts</code>，只要它可以传递<em>任何</em>类型的两个值，只要这两个值的类型相同即可。每次<code>swapTwoValues(_:_:)</code>调用时，所用的类型<code>T</code>都是从传递给该函数的值的类型推断出来的。</p>
<p>在下面的两个例子中，<code>T</code>被推断为<code>Int</code>和<code>String</code>分别为：</p>
<ol>
<li><code>var someInt = 3</code></li>
<li><code>var anotherInt = 107</code></li>
<li><code>swapTwoValues(&amp;someInt, &amp;anotherInt)</code></li>
<li><code>// someInt is now 107, and anotherInt is now 3</code></li>
<li><code></code></li>
<li><code>var someString = &quot;hello&quot;</code></li>
<li><code>var anotherString = &quot;world&quot;</code></li>
<li><code>swapTwoValues(&amp;someString, &amp;anotherString)</code></li>
<li><code>// someString is now &quot;world&quot;, and anotherString is now &quot;hello&quot;</code></li>
</ol>
<p>注意<code>swapTwoValues(_:_:)</code>上面定义的函数受名为的通用函数的启发，该函数<code>swap</code>是Swift标准库的一部分，并且会自动提供给您在您的应用程序中使用。如果您需要<code>swapTwoValues(_:_:)</code>在自己的代码中使用该函数的行为，则可以使用Swift的现有<code>swap(_:_:)</code>函数，而不是提供自己的实现。</p>
<h3 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h3><p>在<code>swapTwoValues(_:_:)</code>上面的例子中，占位符类型<code>T</code>是一个<em>类型参数</em>的例子。类型参数指定并命名一个占位符类型，并在一对匹配的尖括号（如<code>&lt;T&gt;</code>）之间立即写入函数名称后面。</p>
<p>一旦您指定一个类型参数，你可以用它来定义一个函数的参数（如类型<code>a</code>，并<code>b</code>在参数<code>swapTwoValues(_:_:)</code>功能），或作为函数的返回类型，或者作为函数体中的一个类型的注释。在每种情况下，只要函数被调用，类型参数就会被<em>实际</em>类型替换。（在<code>swapTwoValues(_:_:)</code>上面的例子中，<code>T</code>被替换<code>Int</code>的第一次调用函数，并与被替换<code>String</code>，它被称为第二时间）。</p>
<p>您可以通过在尖括号内写入多个类型参数名称来提供多个类型参数，并用逗号分隔。</p>
<h3 id="命名类型参数"><a href="#命名类型参数" class="headerlink" title="命名类型参数"></a>命名类型参数</h3><p>在大多数情况下，类型参数具有描述性的名称，如<code>Key</code>和<code>Value</code>中<code>Dictionary&lt;Key, Value&gt;</code>和<code>Element</code>中<code>Array&lt;Element&gt;</code>，其中讲述的类型参数和泛型类型或功能它在使用之间的关系的读者。但是，如果没有它们之间建立有意义的关系，这是传统的给它们命名使用单个字母，例如<code>T</code>，<code>U</code>和<code>V</code>，如<code>T</code>在<code>swapTwoValues(_:_:)</code>上述功能。</p>
<p>注意总是给出类型参数上面的驼峰大小写名称（例如<code>T</code>和<code>MyTypeParameter</code>），以表明它们是<em>类型</em>的占位符，而不是值。</p>
<h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><p>除了泛型函数外，Swift还允许您定义自己的<em>泛型类型</em>。这是自定义类，结构和枚举，可以一起工作<em>的任何</em>类型，以类似的方式来<code>Array</code>和<code>Dictionary</code>。</p>
<p>本节介绍如何编写一个名为的通用集合类型<code>Stack</code>。堆栈是一组有序的值，与数组类似，但具有比Swift <code>Array</code>类型更有限的一组操作。数组允许在数组中的任何位置插入和移除新项目。但是，堆栈允许将新项目仅附加到集合的末尾（称为<em>将</em>新值<em>推</em>入堆栈）。同样，一个堆栈允许只从集合的末尾删除项目（称为从堆栈中<em>弹出</em>一个值）。</p>
<p>注意<code>UINavigationController</code>该类的概念用于在其导航层次结构中对视图控制器建模。您可以调用<code>UINavigationController</code>类<code>pushViewController(_:animated:)</code>方法将视图控制器添加（或推送）到导航堆栈，以及从导航堆栈<code>popViewControllerAnimated(_:)</code>中删除（或弹出）视图控制器的方法。无论何时需要严格的“先进先出”方法来管理集合，堆栈都是一个有用的集合模型。</p>
<p>下图显示了堆栈的推送和弹出行为：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png" alt="image：../Art/stackPushPop_2x.png"></p>
<ol>
<li>目前在堆栈中有三个值。</li>
<li>第四个值被压入栈顶。</li>
<li>堆栈现在包含四个值，最近的一个在顶部。</li>
<li>弹出堆栈中的顶层项目。</li>
<li>弹出一个值后，堆栈再次保存三个值。</li>
</ol>
<p>以下是如何编写一个非通用版本的堆栈，在这种情况下，为一堆<code>Int</code>值：</p>
<ol>
<li><code>struct IntStack {</code></li>
<li><code>var items = [Int]()</code></li>
<li><code>mutating func push(_ item: Int) {</code></li>
<li><code>items.append(item)</code></li>
<li><code>}</code></li>
<li><code>mutating func pop() -&gt; Int {</code></li>
<li><code>return items.removeLast()</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>该结构使用一个<code>Array</code>调用的属性<code>items</code>将值存储在堆栈中。<code>Stack</code>提供了两种方法，<code>push</code>并<code>pop</code>在堆栈上和堆栈之间推送和弹出值。这些方法被标记为<code>mutating</code>，因为它们需要修改（或<em>变异</em>）结构的<code>items</code>数组。</p>
<p><code>IntStack</code>上面显示 的类型只能与<code>Int</code>值一起使用，但是。定义一个<em>通用</em> <code>Stack</code>类可以管理<em>任何</em>类型的值的堆栈会更有用。</p>
<p>以下是相同代码的通用版本：</p>
<ol>
<li><code>struct Stack&lt;Element&gt; {</code></li>
<li><code>var items = [Element]()</code></li>
<li><code>mutating func push(_ item: Element) {</code></li>
<li><code>items.append(item)</code></li>
<li><code>}</code></li>
<li><code>mutating func pop() -&gt; Element {</code></li>
<li><code>return items.removeLast()</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>请注意，泛型版本<code>Stack</code>与非泛型版本基本相同，但是调用类型参数<code>Element</code>而不是实际类型<code>Int</code>。此类型参数写在<code>&lt;Element&gt;</code>结构名称后面的一对尖括号（）中。</p>
<p><code>Element</code>为稍后提供的类型定义一个占位符名称。这种未来类型可以被称为<code>Element</code>结构定义中的任何地方。在这种情况下，<code>Element</code>在三个地方用作占位符：</p>
<ul>
<li>创建一个名为的属性<code>items</code>，该属性使用类型为空的值的空数组进行初始化<code>Element</code></li>
<li>指定该<code>push(_:)</code>方法具有一个调用的单个参数<code>item</code>，该参数必须是类型的<code>Element</code></li>
<li>指定该<code>pop()</code>方法返回的值将是一个类型的值<code>Element</code></li>
</ul>
<p>因为它是一个通用型，<code>Stack</code>可用于创建一叠<em>任何</em>斯威夫特有效的类型，以类似的方式来<code>Array</code>和<code>Dictionary</code>。</p>
<p><code>Stack</code>通过在尖括号内写入要存储在堆栈中的类型来 创建一个新实例。例如，要创建一个新的字符串堆栈，可以这样写<code>Stack&lt;String&gt;()</code>：</p>
<ol>
<li><code>var stackOfStrings = Stack&lt;String&gt;()</code></li>
<li><code>stackOfStrings.push(&quot;uno&quot;)</code></li>
<li><code>stackOfStrings.push(&quot;dos&quot;)</code></li>
<li><code>stackOfStrings.push(&quot;tres&quot;)</code></li>
<li><code>stackOfStrings.push(&quot;cuatro&quot;)</code></li>
<li><code>// the stack now contains 4 strings</code></li>
</ol>
<p>下面是<code>stackOfStrings</code>将这四个值推入堆栈后的外观：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png" alt="image：../Art/stackPushedFourStrings_2x.png"></p>
<p>从堆栈中弹出一个值将删除并返回顶部值<code>&quot;cuatro&quot;</code>：</p>
<ol>
<li><code>let fromTheTop = stackOfStrings.pop()</code></li>
<li><code>// fromTheTop is equal to &quot;cuatro&quot;, and the stack now contains 3 strings</code></li>
</ol>
<p>以下是弹出最高值后堆栈的外观：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png" alt="image：../Art/stackPoppedOneString_2x.png"></p>
<h3 id="扩展一个通用类型"><a href="#扩展一个通用类型" class="headerlink" title="扩展一个通用类型"></a>扩展一个通用类型</h3><p>扩展泛型时，不提供类型参数列表作为扩展定义的一部分。相反，<em>原始</em>类型定义中的类型参数列表在扩展的主体中可用，并且原始类型参数名称用于引用原始定义中的类型参数。</p>
<p>以下示例扩展泛型<code>Stack</code>类型以添加名为的只读计算属性<code>topItem</code>，该属性返回堆栈中的顶层项目，而不弹出堆栈中的顶层项目：</p>
<ol>
<li><code>extension Stack {</code></li>
<li><code>var topItem: Element? {</code></li>
<li><code>return items.isEmpty ? nil : items[items.count - 1]</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>topItem</code>属性返回一个可选的类型值<code>Element</code>。如果堆栈为空，则<code>topItem</code>返回<code>nil</code>; 如果堆栈不为空，则<code>topItem</code>返回<code>items</code>数组中的最后一项。</p>
<p>请注意，此扩展未定义类型参数列表。而是在扩展中使用<code>Stack</code>类型的现有类型参数名称，<code>Element</code>以指示<code>topItem</code>计算属性的可选类型。</p>
<p>在<code>topItem</code>计算性能，现在可以与任何使用<code>Stack</code>实例来访问，而没有删除它查询其顶端的项目。</p>
<ol>
<li><code>if let topItem = stackOfStrings.topItem {</code></li>
<li><code>print(&quot;The top item on the stack is \(topItem).&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;The top item on the stack is tres.&quot;</code></li>
</ol>
<p>通用类型的扩展还可以包括扩展类型的实例必须满足以获得新功能的要求，正如在下面<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID553" target="_blank" rel="noopener">的通用Where子句的扩展中</a>所讨论的。</p>
<h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><p>该<code>swapTwoValues(_:_:)</code>功能和<code>Stack</code>类型可以与任何类型的工作。但是，对可以与泛型函数和泛型类型一起使用的类型强制执行某些<em>类型约束</em>有时很有用。类型约束指定类型参数必须从特定的类继承，或者符合特定的协议或协议组合。</p>
<p>例如，Swift <code>Dictionary</code>类型对可用作字典键的类型进行了限制。如<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID113" target="_blank" rel="noopener">字典</a>所述，<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID113" target="_blank" rel="noopener">字典</a>键的类型必须是可<em>散列的</em>。也就是说，它必须提供一种使自己唯一可代表的方式。<code>Dictionary</code>需要它的密钥是可散列的，以便它可以检查它是否已经包含特定密钥的值。如果没有这个要求，<code>Dictionary</code>无法判断它是否应该插入或替换某个特定键的值，也不能找到字典中已有键的值。</p>
<p>这个要求是通过对key类型的类型约束来实施的<code>Dictionary</code>，它指定了密钥类型必须符合<code>Hashable</code>协议，这是一个在Swift标准库中定义的特殊协议。所有斯威夫特的基本类型（例如<code>String</code>，<code>Int</code>，<code>Double</code>，和<code>Bool</code>）默认情况下可哈希。</p>
<p>您可以在创建自定义泛型时定义自己的类型约束，这些约束提供了泛型编程的很多功能。抽象概念喜欢<code>Hashable</code>根据其概念特征来表征类型，而不是其具体类型。</p>
<h3 id="类型约束语法"><a href="#类型约束语法" class="headerlink" title="类型约束语法"></a>类型约束语法</h3><p>通过在类型参数的名称之后放置单个类或协议约束（用冒号分隔）作为类型参数列表的一部分来编写类型约束。泛型函数的类型约束的基本语法如下所示（尽管泛型类型的语法是相同的）：</p>
<ol>
<li><code>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {</code></li>
<li><code>// function body goes here</code></li>
<li><code>}</code></li>
</ol>
<p>上面的假设函数有两个类型参数。第一个类型参数，<code>T</code>有一个类型约束，需要<code>T</code>成为的子类<code>SomeClass</code>。第二个类型参数，<code>U</code>具有需要<code>U</code>符合协议的类型约束<code>SomeProtocol</code>。</p>
<h3 id="类型约束在行动"><a href="#类型约束在行动" class="headerlink" title="类型约束在行动"></a>类型约束在行动</h3><p>下面是一个非泛型函数<code>findIndex(ofString:in:)</code>，它被赋予一个<code>String</code>值来查找和<code>String</code>找到它的值的数组。该<code>findIndex(ofString:in:)</code>函数返回一个可选<code>Int</code>值，该值是数组中第一个匹配字符串的索引（如果找到<code>nil</code>该字符串），或者该字符串不可找到：</p>
<ol>
<li><code>func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {</code></li>
<li><code>for (index, value) in array.enumerated() {</code></li>
<li><code>if value == valueToFind {</code></li>
<li><code>return index</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>return nil</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>findIndex(ofString:in:)</code>函数可用于在字符串数组中找到字符串值：</p>
<ol>
<li><code>let strings = [&quot;cat&quot;, &quot;dog&quot;, &quot;llama&quot;, &quot;parakeet&quot;, &quot;terrapin&quot;]</code></li>
<li><code>if let foundIndex = findIndex(ofString: &quot;llama&quot;, in: strings) {</code></li>
<li><code>print(&quot;The index of llama is \(foundIndex)&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;The index of llama is 2&quot;</code></li>
</ol>
<p>然而，查找数组中的值的索引的原理并不仅适用于字符串。您可以通过用某种类型的值替换任何字符串来编写与通用函数相同的功能<code>T</code>。</p>
<p>以下是您可能期望写入的<code>findIndex(ofString:in:)</code>所谓的通用版本<code>findIndex(of:in:)</code>。请注意，此函数的返回类型仍然是<code>Int?</code>，因为函数返回一个可选的索引号，而不是数组中的可选值。不过要注意的是，这个函数不能编译，因为在这个例子之后解释的原因：</p>
<ol>
<li><code>func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {</code></li>
<li><code>for (index, value) in array.enumerated() {</code></li>
<li><code>if value == valueToFind {</code></li>
<li><code>return index</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>return nil</code></li>
<li><code>}</code></li>
</ol>
<p>这个函数不像上面写的那样编译。问题在于平等检查，“ <code>if value == valueToFind</code>”。并非Swift中的每个类型都可以与等号运算符（<code>==</code>）进行比较。例如，如果您创建自己的类或结构来表示复杂的数据模型，那么对于该类或结构而言，“等于”的含义不是Swift可以为您猜测的。因此，不可能保证此代码适用于<em>所有</em>可能的类型<code>T</code>，并且在尝试编译代码时会报告相应的错误。</p>
<p>然而，所有的东西都不会丢失。Swift标准库定义了一个调用的协议<code>Equatable</code>，它要求任何符合类型实现等于运算符（<code>==</code>）和不等于运算符（<code>!=</code>）来比较该类型的任何两个值。所有Swift的标准类型都自动支持该<code>Equatable</code>协议。</p>
<p>任何类型<code>Equatable</code>的<code>findIndex(of:in:)</code>函数都可以安全地使用，因为它保证支持等于操作符。为了表达这个事实，<code>Equatable</code>当你定义函数时，你写了一个类型约束作为类型参数定义的一部分：</p>
<ol>
<li><code>func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {</code></li>
<li><code>for (index, value) in array.enumerated() {</code></li>
<li><code>if value == valueToFind {</code></li>
<li><code>return index</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>return nil</code></li>
<li><code>}</code></li>
</ol>
<p>单一类型参数<code>findIndex(of:in:)</code>写成<code>T: Equatable</code>，意思是“ <code>T</code>符合<code>Equatable</code>协议的任何类型”。</p>
<p>该<code>findIndex(of:in:)</code>函数现在编译成功，可以用于任何类型<code>Equatable</code>，如<code>Double</code>或<code>String</code>：</p>
<ol>
<li><code>let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])</code></li>
<li><code>// doubleIndex is an optional Int with no value, because 9.3 isn&#39;t in the array</code></li>
<li><code>let stringIndex = findIndex(of: &quot;Andrea&quot;, in: [&quot;Mike&quot;, &quot;Malcolm&quot;, &quot;Andrea&quot;])</code></li>
<li><code>// stringIndex is an optional Int containing a value of 2</code></li>
</ol>
<h3 id="相关类型"><a href="#相关类型" class="headerlink" title="相关类型"></a>相关类型</h3><p>在定义协议时，将一个或多个关联类型声明为协议定义的一部分有时很有用。一个<em>相关联的类型</em>给出了一个占位符名称到被用作协议的一部分的类型。在采用该协议之前，不会指定用于该关联类型的实际类型。关联的类型由<code>associatedtype</code>关键字指定。</p>
<h3 id="关联的类型在行动"><a href="#关联的类型在行动" class="headerlink" title="关联的类型在行动"></a>关联的类型在行动</h3><p>下面是一个调用协议的示例<code>Container</code>，它声明了一个名为的关联类型<code>Item</code>：</p>
<ol>
<li><code>protocol Container {</code></li>
<li><code>associatedtype Item</code></li>
<li><code>mutating func append(_ item: Item)</code></li>
<li><code>var count: Int { get }</code></li>
<li><code>subscript(i: Int) -&gt; Item { get }</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>Container</code>协议定义了任何容器必须提供的三种必需的功能：</p>
<ul>
<li>使用方法必须可以将新项目添加到容器<code>append(_:)</code>。</li>
<li>必须可以通过<code>count</code>返回<code>Int</code>值的属性访问容器中的项目数。</li>
<li>必须可以使用带有<code>Int</code>索引值的下标来检索容器中的每个项目。</li>
</ul>
<p>该协议并未指定容器中的项目应如何存储或允许的类型。协议只规定了任何类型为了被认为是必须提供的三个功能位<code>Container</code>。符合类型可以提供额外的功能，只要满足这三个要求即可。</p>
<p>任何符合<code>Container</code>协议的类型都必须能够指定它存储的值的类型。具体来说，它必须确保只有正确类型的项目才会添加到容器中，并且必须清楚其下标所返回项目的类型。</p>
<p>为了定义这些需求，<code>Container</code>协议需要一种方法来引用容器将容纳的元素的类型，而不知道特定容器的类型。该<code>Container</code>协议需要指定传递给该<code>append(_:)</code>方法的任何值必须具有与该容器的元素类型相同的类型，并且该容器的下标返回的值将与该容器的元素类型具有相同的类型。</p>
<p>为了达到这个目的，<code>Container</code>协议声明了一个名为的关联类型<code>Item</code>，写为<code>associatedtype Item</code>。该协议没有定义什么<code>Item</code>是 - 该信息留给任何符合类型提供。尽管如此，<code>Item</code>别名提供了一种方法来引用a中的项目类型<code>Container</code>，并定义一种用于<code>append(_:)</code>方法和下标的类型，以确保<code>Container</code>强制执行任何预期的行为。</p>
<p>以下是<code>IntStack</code>来自上述<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID184" target="_blank" rel="noopener">泛型类型</a>的非<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID184" target="_blank" rel="noopener">泛型类型</a>的一个版本，适用于该<code>Container</code>协议：</p>
<ol>
<li><code>struct IntStack: Container {</code></li>
<li><code>// original IntStack implementation</code></li>
<li><code>var items = [Int]()</code></li>
<li><code>mutating func push(_ item: Int) {</code></li>
<li><code>items.append(item)</code></li>
<li><code>}</code></li>
<li><code>mutating func pop() -&gt; Int {</code></li>
<li><code>return items.removeLast()</code></li>
<li><code>}</code></li>
<li><code>// conformance to the Container protocol</code></li>
<li><code>typealias Item = Int</code></li>
<li><code>mutating func append(_ item: Int) {</code></li>
<li><code>self.push(item)</code></li>
<li><code>}</code></li>
<li><code>var count: Int {</code></li>
<li><code>return items.count</code></li>
<li><code>}</code></li>
<li><code>subscript(i: Int) -&gt; Int {</code></li>
<li><code>return items[i]</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>IntStack</code>类型实现了<code>Container</code>协议所有三个要求，并且在每种情况下都包装了该<code>IntStack</code>类型现有功能的一部分以满足这些要求。</p>
<p>而且，<code>IntStack</code>指定对于这个实现<code>Container</code>，适当<code>Item</code>使用是一种类型的<code>Int</code>。该定义<code>typealias Item = Int</code>将抽象类型<code>Item</code>转换<code>Int</code>为该<code>Container</code>协议实现的具体类型。</p>
<p>感谢Swift的类型推断，你实际上不需要声明具体<code>Item</code>的<code>Int</code>作为定义的一部分<code>IntStack</code>。因为<code>IntStack</code>符合<code>Container</code>协议的所有要求，所以Swift可以<code>Item</code>简单地通过查看<code>append(_:)</code>方法<code>item</code>参数的类型和下标的返回类型来推断恰当的使用方式。事实上，如果你<code>typealias Item = Int</code>从上面的代码中删除了这一行，所有东西仍然有效，因为很清楚应该使用什么类型<code>Item</code>。</p>
<p>您也可以使通用<code>Stack</code>类型符合<code>Container</code>协议：</p>
<ol>
<li><code>struct Stack&lt;Element&gt;: Container {</code></li>
<li><code>// original Stack&lt;Element&gt; implementation</code></li>
<li><code>var items = [Element]()</code></li>
<li><code>mutating func push(_ item: Element) {</code></li>
<li><code>items.append(item)</code></li>
<li><code>}</code></li>
<li><code>mutating func pop() -&gt; Element {</code></li>
<li><code>return items.removeLast()</code></li>
<li><code>}</code></li>
<li><code>// conformance to the Container protocol</code></li>
<li><code>mutating func append(_ item: Element) {</code></li>
<li><code>self.push(item)</code></li>
<li><code>}</code></li>
<li><code>var count: Int {</code></li>
<li><code>return items.count</code></li>
<li><code>}</code></li>
<li><code>subscript(i: Int) -&gt; Element {</code></li>
<li><code>return items[i]</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>这次，类型参数<code>Element</code>被用作<code>append(_:)</code>方法<code>item</code>参数的类型和下标的返回类型。因此，Swift可以推断这<code>Element</code>是<code>Item</code>用于这个特定容器的适当类型。</p>
<h3 id="扩展现有类型以指定关联类型"><a href="#扩展现有类型以指定关联类型" class="headerlink" title="扩展现有类型以指定关联类型"></a>扩展现有类型以指定关联类型</h3><p>您可以扩展现有类型以添加协议，如<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID277" target="_blank" rel="noopener">添加扩展协议一致性中</a>所述。这包括一个关联类型的协议。</p>
<p>Swift的<code>Array</code>类型已经提供了一个<code>append(_:)</code>方法，一个<code>count</code>属性和一个带<code>Int</code>索引的下标来检索它的元素。这三个功能符合<code>Container</code>协议的要求。这意味着您可以简单地通过声明采用协议来扩展<code>Array</code>以符合协议。您可以使用空白扩展名来执行此操作，如<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID278" target="_blank" rel="noopener">使用扩展声明协议采用中</a>所述： <code>Container``Array</code></p>
<ol>
<li><code>extension Array: Container {}</code></li>
</ol>
<p>Array的现有<code>append(_:)</code>方法和下标使Swift能够推断出适用的类型<code>Item</code>，就像<code>Stack</code>上面的泛型一样。定义这个扩展后，你可以使用任何<code>Array</code>一个<code>Container</code>。</p>
<h3 id="将约束添加到关联的类型"><a href="#将约束添加到关联的类型" class="headerlink" title="将约束添加到关联的类型"></a>将约束添加到关联的类型</h3><p>您可以将类型约束添加到协议中的关联类型，以要求符合类型满足这些约束。例如，下面的代码定义了一个<code>Container</code>需要容器中的项目可以相等的版本。</p>
<ol>
<li><code>protocol Container {</code></li>
<li><code>associatedtype Item: Equatable</code></li>
<li><code>mutating func append(_ item: Item)</code></li>
<li><code>var count: Int { get }</code></li>
<li><code>subscript(i: Int) -&gt; Item { get }</code></li>
<li><code>}</code></li>
</ol>
<p>为了符合这个版本<code>Container</code>，容器的<code>Item</code>类型必须符合<code>Equatable</code>协议。</p>
<h3 id="在其关联类型的约束中使用协议"><a href="#在其关联类型的约束中使用协议" class="headerlink" title="在其关联类型的约束中使用协议"></a>在其关联类型的约束中使用协议</h3><p>协议可以作为其自身要求的一部分出现。例如，这是一个改进<code>Container</code>协议的协议，增加了<code>suffix(_:)</code>方法的要求。该<code>suffix(_:)</code>方法从容器的末尾返回给定数量的元素，将它们存储在<code>Suffix</code>类型的实例中。</p>
<ol>
<li><code>protocol SuffixableContainer: Container {</code></li>
<li><code>associatedtype Suffix: SuffixableContainer where Suffix.Item == Item</code></li>
<li><code>func suffix(_ size: Int) -&gt; Suffix</code></li>
<li><code>}</code></li>
</ol>
<p>在这个协议中，<code>Suffix</code>是一个关联类型，就像上面例子中的<code>Item</code>类型<code>Container</code>。<code>Suffix</code>有两个约束：它必须符合<code>SuffixableContainer</code>协议（当前正在定义的协议），其<code>Item</code>类型必须与容器的<code>Item</code>类型相同。约束<code>Item</code>是一个通用的<code>where</code>子句，在下面的<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID557" target="_blank" rel="noopener">关联类型中使用</a>通用的子句讨论。</p>
<p>这是上面<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID56" target="_blank" rel="noopener">关闭的强参考周期</a><code>Stack</code>类型的一个扩展，它增加了协议的一致性： <code>SuffixableContainer</code></p>
<ol>
<li><code>extension Stack: SuffixableContainer {</code></li>
<li><code>func suffix(_ size: Int) -&gt; Stack {</code></li>
<li><code>var result = Stack()</code></li>
<li><code>for index in (count-size)..&lt;count {</code></li>
<li><code>result.append(self[index])</code></li>
<li><code>}</code></li>
<li><code>return result</code></li>
<li><code>}</code></li>
<li><code>// Inferred that Suffix is Stack.</code></li>
<li><code>}</code></li>
<li><code>var stackOfInts = Stack&lt;Int&gt;()</code></li>
<li><code>stackOfInts.append(10)</code></li>
<li><code>stackOfInts.append(20)</code></li>
<li><code>stackOfInts.append(30)</code></li>
<li><code>let suffix = stackOfInts.suffix(2)</code></li>
<li><code>// suffix contains 20 and 30</code></li>
</ol>
<p>在上面的例子中，<code>Suffix</code>关联的类型<code>Stack</code>也是<code>Stack</code>，所以后缀操作<code>Stack</code>返回另一个<code>Stack</code>。或者，符合的类型<code>SuffixableContainer</code>可以具有<code>Suffix</code>与自身不同的类型 - 这意味着后缀操作可以返回不同的类型。例如，下面是扩展符合性的非泛型<code>IntStack</code>类型的扩展<code>SuffixableContainer</code>，使用<code>Stack&lt;Int&gt;</code>后缀类型代替<code>IntStack</code>：</p>
<ol>
<li><code>extension IntStack: SuffixableContainer {</code></li>
<li><code>func suffix(_ size: Int) -&gt; Stack&lt;Int&gt; {</code></li>
<li><code>var result = Stack&lt;Int&gt;()</code></li>
<li><code>for index in (count-size)..&lt;count {</code></li>
<li><code>result.append(self[index])</code></li>
<li><code>}</code></li>
<li><code>return result</code></li>
<li><code>}</code></li>
<li><code>// Inferred that Suffix is Stack&lt;Int&gt;.</code></li>
<li><code>}</code></li>
</ol>
<h3 id="通用条款"><a href="#通用条款" class="headerlink" title="通用条款"></a>通用条款</h3><p>如类型约束中所述，<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID186" target="_blank" rel="noopener">类型约束</a>使您能够定义与通用函数，下标或类型关联的类型参数的需求。</p>
<p>定义关联类型的需求也很有用。你通过定义一个<em>通用的where子句来</em>做到这一点。泛型<code>where</code>子句使您能够要求相关类型必须符合特定协议，或者某些类型参数和相关类型必须相同。通用<code>where</code>子句从<code>where</code>关键字开始，随后是关联类型的约束或类型和关联类型之间的相等关系。您<code>where</code>在类型或函数的正文的开始大括号之前编写通用子句。</p>
<p>下面的示例定义了一个名为的泛型函数<code>allItemsMatch</code>，它检查两个<code>Container</code>实例是否以相同的顺序包含相同的项目。<code>true</code>如果所有项目匹配，该函数将返回布尔值，如果不匹配，则返回值<code>false</code>。</p>
<p>要检查的两个容器不必是相同类型的容器（尽管它们可以），但它们必须保持相同类型的容器。此要求通过类型约束和通用<code>where</code>子句的组合来表达：</p>
<ol>
<li><code>func allItemsMatch&lt;C1: Container, C2: Container&gt;</code></li>
<li><code>(_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool</code></li>
<li><code>where C1.Item == C2.Item, C1.Item: Equatable {</code></li>
<li><code></code></li>
<li><code>// Check that both containers contain the same number of items.</code></li>
<li><code>if someContainer.count != anotherContainer.count {</code></li>
<li><code>return false</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>// Check each pair of items to see if they&#39;re equivalent.</code></li>
<li><code>for i in 0..&lt;someContainer.count {</code></li>
<li><code>if someContainer[i] != anotherContainer[i] {</code></li>
<li><code>return false</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code></code></li>
<li><code>// All items match, so return true.</code></li>
<li><code>return true</code></li>
<li><code>}</code></li>
</ol>
<p>这个函数有两个参数叫做<code>someContainer</code>and <code>anotherContainer</code>。该<code>someContainer</code>参数是类型<code>C1</code>，以及<code>anotherContainer</code>参数的类型的<code>C2</code>。既<code>C1</code>和<code>C2</code>当调用该函数时要确定了两个容器类型是类型参数。</p>
<p>以下要求放在函数的两个类型参数上：</p>
<ul>
<li><code>C1</code>必须符合<code>Container</code>协议（写为<code>C1: Container</code>）。</li>
<li><code>C2</code>还必须符合<code>Container</code>协议（写为<code>C2: Container</code>）。</li>
<li>该<code>Item</code>对<code>C1</code>必须相同<code>Item</code>的<code>C2</code>（写成<code>C1.Item == C2.Item</code>）。</li>
<li>在<code>Item</code>用于<code>C1</code>必须符合<code>Equatable</code>协议（写为<code>C1.Item: Equatable</code>）。</li>
</ul>
<p>第一个和第二个需求在函数的类型参数列表中定义，第三个和第四个需求在函数的通用<code>where</code>子句中定义。</p>
<p>这些要求意味着：</p>
<ul>
<li><code>someContainer</code>是一种类型的容器<code>C1</code>。</li>
<li><code>anotherContainer</code>是一种类型的容器<code>C2</code>。</li>
<li><code>someContainer</code>并<code>anotherContainer</code>包含相同类型的项目。</li>
<li><code>someContainer</code>可以使用不相等的运算符（<code>!=</code>）来检查 项目，看它们是否彼此不同。</li>
</ul>
<p>第三和第四的要求相结合，意味着中的项目<code>anotherContainer</code>可以<em>也</em>可以与检查<code>!=</code>经营者，因为他们是完全一样的类型中的项目<code>someContainer</code>。</p>
<p>这些要求使<code>allItemsMatch(_:_:)</code>函数能够比较两个容器，即使它们是不同的容器类型。</p>
<p>该<code>allItemsMatch(_:_:)</code>功能首先检查两个容器是否包含相同数量的项目。如果它们包含不同数量的项目，则它们无法匹配，并且函数返回<code>false</code>。</p>
<p>在做这个检查后，函数<code>someContainer</code>用<code>for</code>- <code>in</code>循环和半开范围运算符（<code>..&lt;</code>）遍历所有项。对于每个项目，函数检查项目from <code>someContainer</code>是否不等于in中的相应项目<code>anotherContainer</code>。如果两个项目不相等，则两个容器不匹配，并且函数返回<code>false</code>。</p>
<p>如果循环完成而不发现不匹配，则两个容器匹配，并且函数返回<code>true</code>。</p>
<p>以下是该<code>allItemsMatch(_:_:)</code>功能如何起作用的功能：</p>
<ol>
<li><code>var stackOfStrings = Stack&lt;String&gt;()</code></li>
<li><code>stackOfStrings.push(&quot;uno&quot;)</code></li>
<li><code>stackOfStrings.push(&quot;dos&quot;)</code></li>
<li><code>stackOfStrings.push(&quot;tres&quot;)</code></li>
<li><code></code></li>
<li><code>var arrayOfStrings = [&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;]</code></li>
<li><code></code></li>
<li><code>if allItemsMatch(stackOfStrings, arrayOfStrings) {</code></li>
<li><code>print(&quot;All items match.&quot;)</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;Not all items match.&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;All items match.&quot;</code></li>
</ol>
<p>上面的例子创建一个<code>Stack</code>存储<code>String</code>值的实例，并将三个字符串推入堆栈。该示例还创建了一个<code>Array</code>使用包含与堆栈相同的三个字符串的数组字面值初始化的实例。即使堆栈和阵列属于不同的类型，它们都符合<code>Container</code>协议，并且都包含相同类型的值。因此可以<code>allItemsMatch(_:_:)</code>用这两个容器作为参数来调用函数。在上面的示例中，该<code>allItemsMatch(_:_:)</code>函数可以正确报告两个容器中的所有项目都匹配。</p>
<h3 id="扩展与通用的where子句"><a href="#扩展与通用的where子句" class="headerlink" title="扩展与通用的where子句"></a>扩展与通用的where子句</h3><p>您也可以使用通用<code>where</code>子句作为扩展的一部分。下面的例子扩展了<code>Stack</code>前面例子的通用结构以添加一个<code>isTop(_:)</code>方法。</p>
<ol>
<li><code>extension Stack where Element: Equatable {</code></li>
<li><code>func isTop(_ item: Element) -&gt; Bool {</code></li>
<li><code>guard let topItem = items.last else {</code></li>
<li><code>return false</code></li>
<li><code>}</code></li>
<li><code>return topItem == item</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>这个新<code>isTop(_:)</code>方法首先检查堆栈是否为空，然后比较给定的项目和堆栈的最上面的项目。如果您尝试在没有泛型<code>where</code>子句的情况下执行<code>isTop(_:)</code>此<code>==</code>操作，则会遇到问题：实现使用运算符，但定义<code>Stack</code>不要求其项目可以相等，因此使用<code>==</code>运算符会导致编译时错误。使用通用<code>where</code>子句可让您向扩展添加新的需求，以便<code>isTop(_:)</code>只有当堆栈中的项目可以相等时，扩展才会添加该方法。</p>
<p>以下是该<code>isTop(_:)</code>方法的实际应用情况：</p>
<ol>
<li><code>if stackOfStrings.isTop(&quot;tres&quot;) {</code></li>
<li><code>print(&quot;Top element is tres.&quot;)</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;Top element is something else.&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;Top element is tres.&quot;</code></li>
</ol>
<p>如果您尝试<code>isTop(_:)</code>在其元素不相等的堆栈上调用该方法，则会出现编译时错误。</p>
<ol>
<li><code>struct NotEquatable { }</code></li>
<li><code>var notEquatableStack = Stack&lt;NotEquatable&gt;()</code></li>
<li><code>let notEquatableValue = NotEquatable()</code></li>
<li><code>notEquatableStack.push(notEquatableValue)</code></li>
<li><code>notEquatableStack.isTop(notEquatableValue)  // Error</code></li>
</ol>
<p>您可以使用通用<code>where</code>子句以及对协议的扩展。下面的例子<code>Container</code>从前面的例子扩展了协议来添加一个<code>startsWith(_:)</code>方法。</p>
<ol>
<li><code>extension Container where Item: Equatable {</code></li>
<li><code>func startsWith(_ item: Item) -&gt; Bool {</code></li>
<li><code>return count &gt;= 1 &amp;&amp; self[0] == item</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>startsWith(_:)</code>方法首先确保容器至少有一个项目，然后检查容器中的第一个项目是否与给定的项目相匹配。只要容器的物品是可以平衡的，这种新<code>startsWith(_:)</code>方法就可以用于任何符合<code>Container</code>协议的类型，包括上面使用的堆栈和数组。</p>
<ol>
<li><code>if [9, 9, 9].startsWith(42) {</code></li>
<li><code>print(&quot;Starts with 42.&quot;)</code></li>
<li><code>} else {</code></li>
<li><code>print(&quot;Starts with something else.&quot;)</code></li>
<li><code>}</code></li>
<li><code>// Prints &quot;Starts with something else.&quot;</code></li>
</ol>
<p><code>where</code>上面示例中 的通用子句要求<code>Item</code>符合协议，但您也可以编写一个通用<code>where</code>子句，它们需要<code>Item</code>是特定的类型。例如：</p>
<ol>
<li><code>extension Container where Item == Double {</code></li>
<li><code>func average() -&gt; Double {</code></li>
<li><code>var sum = 0.0</code></li>
<li><code>for index in 0..&lt;count {</code></li>
<li><code>sum += self[index]</code></li>
<li><code>}</code></li>
<li><code>return sum / Double(count)</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
<li><code>print([1260.0, 1200.0, 98.6, 37.0].average())</code></li>
<li><code>// Prints &quot;648.9&quot;</code></li>
</ol>
<p>此示例将<code>average()</code>方法添加到<code>Item</code>类型为的容器<code>Double</code>。它迭代容器中的项目以将它们相加，然后除以容器的计数来计算平均值。它明确地将count从<code>Int</code>to <code>Double</code>转换为能够进行浮点除法。</p>
<p>您可以将多个需求包含在<code>where</code>作为扩展的一部分的通用子句中，就像您可以为<code>where</code>其他地方编写的通用子句一样。用逗号分隔列表中的每个要求。</p>
<h3 id="与通用条款相关联的类型"><a href="#与通用条款相关联的类型" class="headerlink" title="与通用条款相关联的类型"></a>与通用条款相关联的类型</h3><p>您可以<code>where</code>在关联的类型中包含通用子句。例如，假设你想制作一个<code>Container</code>包含迭代器的版本，就像<code>Sequence</code>协议在标准库中使用的那样。以下是你如何写的：</p>
<ol>
<li><code>protocol Container {</code></li>
<li><code>associatedtype Item</code></li>
<li><code>mutating func append(_ item: Item)</code></li>
<li><code>var count: Int { get }</code></li>
<li><code>subscript(i: Int) -&gt; Item { get }</code></li>
<li><code></code></li>
<li><code>associatedtype Iterator: IteratorProtocol where Iterator.Element == Item</code></li>
<li><code>func makeIterator() -&gt; Iterator</code></li>
<li><code>}</code></li>
</ol>
<p>通用<code>where</code>子句on <code>Iterator</code>要求迭代器必须遍历与容器项目相同的项目类型的元素，而不管迭代器的类型如何。该<code>makeIterator()</code>函数提供对容器迭代器的访问。</p>
<p>对于从另一个协议继承的协议，通过<code>where</code>在协议声明中包含通用子句，可以为继承的关联类型添加约束。例如，以下代码声明了<code>ComparableContainer</code>需要<code>Item</code>符合的协议<code>Comparable</code>：</p>
<ol>
<li><code>protocol ComparableContainer: Container where Item: Comparable { }</code></li>
</ol>
<h3 id="通用下标"><a href="#通用下标" class="headerlink" title="通用下标"></a>通用下标</h3><p>下标可以是通用的，并且可以包括通用的<code>where</code>子句。您在后面的尖括号内写入占位符类型名称<code>subscript</code>，然后<code>where</code>在下标的正文的开始大括号之前写下一个通用子句。例如：</p>
<ol>
<li><code>extension Container {</code></li>
<li><code>subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item]</code></li>
<li><code>where Indices.Iterator.Element == Int {</code></li>
<li><code>var result = [Item]()</code></li>
<li><code>for index in indices {</code></li>
<li><code>result.append(self[index])</code></li>
<li><code>}</code></li>
<li><code>return result</code></li>
<li><code>}</code></li>
<li><code>}</code></li>
</ol>
<p>该<code>Container</code>协议的扩展添加了一个下标，它接收一系列索引并返回一个包含每个给定索引处的项目的数组。这个通用下标的约束如下：</p>
<ul>
<li><code>Indices</code>尖括号中 的通用参数必须是符合<code>Sequence</code>标准库协议的类型。</li>
<li>下标采用单个参数，<code>indices</code>它是该<code>Indices</code>类型的一个实例。</li>
<li>通用<code>where</code>子句要求序列的迭代器必须遍历类型的元素<code>Int</code>。这确保序列中的索引与用于容器的索引相同。</li>
</ul>
<p>总之，这些约束条件意味着为<code>indices</code>参数传递的值是一个整数序列。</p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="noopener">协议</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID48" target="_blank" rel="noopener">自动引用计数</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> apple </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS struct ifaddrs]]></title>
      <url>/2018/05/04/struct%20ifaddrs%20/</url>
      <content type="html"><![CDATA[<p><code>import Darwin</code></p>
<p><code>public struct ifaddrs {</code></p>
<p>​    public var ifa_next: UnsafeMutablePointer<ifaddrs>!</ifaddrs></p>
<p>​    public var ifa_name: UnsafeMutablePointer<int8>!</int8></p>
<p>​    public var ifa_flags: UInt32</p>
<p>​    public var ifa_addr: UnsafeMutablePointer<sockaddr>!</sockaddr></p>
<p>​    public var ifa_netmask: UnsafeMutablePointer<sockaddr>!</sockaddr></p>
<p>​    public var ifa_dstaddr: UnsafeMutablePointer<sockaddr>!</sockaddr></p>
<p>​    public var ifa_data: UnsafeMutableRawPointer!</p>
<p>​    public init()</p>
<p>​    public init(ifa_next: UnsafeMutablePointer<ifaddrs>!, ifa_name: UnsafeMutablePointer<int8>!, ifa_flags: UInt32, ifa_addr: UnsafeMutablePointer<sockaddr>!, ifa_netmask: UnsafeMutablePointer<sockaddr>!, ifa_dstaddr: UnsafeMutablePointer<sockaddr>!, ifa_data: UnsafeMutableRawPointer!)<br><a id="more"></a><br><code>}</code></sockaddr></sockaddr></sockaddr></int8></ifaddrs></p>
<p><code>/*</code></p>
<ul>
<li>This may have been defined in <net if.h="">.  Note that if <net if.h=""> is</net></net></li>
<li><p>to be included it must be included before this header file.</p>
<p>*/</p>
</li>
</ul>
<p><code>/* broadcast address interface */</code></p>
<p><code>public struct ifmaddrs {</code></p>
<p>​    public var ifma_next: UnsafeMutablePointer<ifmaddrs>!</ifmaddrs></p>
<p>​    public var ifma_name: UnsafeMutablePointer<sockaddr>!</sockaddr></p>
<p>​    public var ifma_addr: UnsafeMutablePointer<sockaddr>!</sockaddr></p>
<p>​    public var ifma_lladdr: UnsafeMutablePointer<sockaddr>!</sockaddr></p>
<p>​    public init()</p>
<p>​    public init(ifma_next: UnsafeMutablePointer<ifmaddrs>!, ifma_name: UnsafeMutablePointer<sockaddr>!, ifma_addr: UnsafeMutablePointer<sockaddr>!, ifma_lladdr: UnsafeMutablePointer<sockaddr>!)</sockaddr></sockaddr></sockaddr></ifmaddrs></p>
<p><code>}</code></p>
<p><code>public func getifaddrs(_: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;ifaddrs&gt;?&gt;!) -&gt; Int32</code></p>
<p><code>public func freeifaddrs(_: UnsafeMutablePointer&lt;ifaddrs&gt;!)</code></p>
<p><code>@available(iOS 4.3, *)</code></p>
<p><code>public func getifmaddrs(_: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;ifmaddrs&gt;?&gt;!) -&gt; Int32</code></p>
<p><code>@available(iOS 4.3, *)</code></p>
<p><code>public func freeifmaddrs(_: UnsafeMutablePointer&lt;ifmaddrs&gt;!)</code></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> ifaddrs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[获取手机SSID和BSSID以及IP地址]]></title>
      <url>/2018/05/04/%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BASSID%E5%92%8CBSSID%E4%BB%A5%E5%8F%8AIP%E5%9C%B0%E5%9D%80/</url>
      <content type="html"><![CDATA[<p>获取手机SSID和BSSID以及IP地址</p>
<p>import SystemConfiguration</p>
<p>import SystemConfiguration.CaptiveNetwork</p>
<p>extension NSObject{</p>
<p>​    </p>
<p>​    func GetIPAddresses() -&gt; String? {</p>
<p>​        var addresses = <a href="">String</a></p>
<p>​   <a id="more"></a></p>
<p>​        var ifaddr : UnsafeMutablePointer<ifaddrs>? = nil</ifaddrs></p>
<p>​        if getifaddrs(&amp;ifaddr) == 0 {</p>
<p>​            var ptr = ifaddr</p>
<p>​            while (ptr != nil) {</p>
<p>​                let flags = Int32(ptr!.pointee.ifa_flags)</p>
<p>​                var addr = ptr!.pointee.ifa_addr.pointee</p>
<p>​                if (flags &amp; (IFF_UP|IFF_RUNNING|IFF_LOOPBACK)) == (IFF_UP|IFF_RUNNING) {</p>
<p>​                    if addr.sa_family == UInt8(AF_INET) || addr.sa_family == UInt8(AF_INET6) {</p>
<p>​                        var hostname = <a href="repeating: 0, count: Int(NI_MAXHOST" target="_blank" rel="noopener">CChar</a>)</p>
<p>​                        if (getnameinfo(&amp;addr, socklen_t(addr.sa_len), &amp;hostname, socklen_t(hostname.count),nil, socklen_t(0), NI_NUMERICHOST) == 0) {</p>
<p>​                            if let address = String(validatingUTF8:hostname) {</p>
<p>​                                addresses.append(address)</p>
<p>​                            }</p>
<p>​                        }</p>
<p>​                    }</p>
<p>​                }</p>
<p>​                ptr = ptr!.pointee.ifa_next</p>
<p>​            }</p>
<p>​            freeifaddrs(ifaddr)</p>
<p>​        }</p>
<p>​        return addresses.first</p>
<p>​    }</p>
<p>​    </p>
<p>​    </p>
<p>​    func getUsedSSID() -&gt; (String,String) {</p>
<p>​        let interfaces = CNCopySupportedInterfaces()</p>
<p>​        var ssid = “”</p>
<p>​        var bssid = “”</p>
<p>​        if interfaces != nil {</p>
<p>​            let interfacesArray = CFBridgingRetain(interfaces) as! Array<anyobject></anyobject></p>
<p>​            if interfacesArray.count &gt; 0 {</p>
<p>​                let interfaceName = interfacesArray[0] as! CFString</p>
<p>​                let ussafeInterfaceData = CNCopyCurrentNetworkInfo(interfaceName)</p>
<p>​                if (ussafeInterfaceData != nil) {</p>
<p>​                    let interfaceData = ussafeInterfaceData as! Dictionary<string, any=""></string,></p>
<p>​                    ssid = interfaceData[“SSID”]! as! String</p>
<p>​                    bssid = interfaceData[“BSSID”]! as! String</p>
<p>​                }</p>
<p>​            }</p>
<p>​        }</p>
<p>​        return (ssid,bssid)</p>
<p>​    }</p>
<p>}</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> SSID </tag>
            
            <tag> IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UICollectionViewLayout布局详解]]></title>
      <url>/2018/05/02/UICollectionViewLayout%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>转载：<a href="https://www.jianshu.com/p/45ff718090a8" target="_blank" rel="noopener">https://www.jianshu.com/p/45ff718090a8</a></p>
<h3 id="首先我们先看一下-我们今天要最终实现的效果图"><a href="#首先我们先看一下-我们今天要最终实现的效果图" class="headerlink" title="首先我们先看一下 我们今天要最终实现的效果图"></a>首先我们先看一下 我们今天要最终实现的效果图</h3><hr>
<h3 id="UICollectionView的简单介绍"><a href="#UICollectionView的简单介绍" class="headerlink" title="UICollectionView的简单介绍"></a>UICollectionView的简单介绍</h3><ul>
<li>UICollectionView的结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cells</span><br><span class="line">Supplementary Views 追加视图 （类似Header或者Footer）</span><br><span class="line">Decoration Views 装饰视图 （用作背景展示）</span><br></pre></td></tr></table></figure>
<ul>
<li>由两个方面对UICollectionView进行支持。<ul>
<li>和tableView一样，即提供数据的UICollectionViewDataSource以及处理用户交互的UICollectionViewDelegate。</li>
</ul>
</li>
<li>另一方面，对于cell的样式和组织方式，由于collectionView比tableView要复杂得多，因此没有按照类似于tableView的style的方式来定义，而是专门使用了一个类来对collectionView的布局和行为进行描述，这就是<code>UICollectionViewLayout</code>。</li>
<li>而我们主要讲UICollectionViewLayout，因为这不仅是collectionView和tableView的最重要求的区别，也是整个UICollectionView的精髓所在。</li>
<li>如果对UICollectionView的基本构成要素和使用方法还不清楚的话，可以查看：<a href="https://link.jianshu.com/?t=http://www.onevcat.com/2012/06/introducing-collection-views/" target="_blank" rel="noopener">UICollectionView详解</a>中进行一些了解。</li>
</ul>
<hr>
<a id="more"></a>
<ul>
<li>​</li>
</ul>
<h3 id="UICollectionViewLayoutAttributes类的介绍"><a href="#UICollectionViewLayoutAttributes类的介绍" class="headerlink" title="UICollectionViewLayoutAttributes类的介绍"></a>UICollectionViewLayoutAttributes类的介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic) CGRect frame</span><br><span class="line">@property (nonatomic) CGPoint center</span><br><span class="line">@property (nonatomic) CGSize size</span><br><span class="line">@property (nonatomic) CATransform3D transform3D</span><br><span class="line">@property (nonatomic) CGFloat alpha</span><br><span class="line">@property (nonatomic) NSInteger zIndex</span><br><span class="line">@property (nonatomic, getter=isHidden) BOOL hidden</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，UICollectionViewLayoutAttributes的实例中包含了诸如边框，中心点，大小，形状，透明度，层次关系和是否隐藏等信息。<br>1.一个cell对应一个UICollectionViewLayoutAttributes对象<br>2.UICollectionViewLayoutAttributes对象决定了cell的摆设位置（frame）</p>
</blockquote>
<h3 id="自定义的UICollectionViewLayout"><a href="#自定义的UICollectionViewLayout" class="headerlink" title="自定义的UICollectionViewLayout"></a>自定义的UICollectionViewLayout</h3><ul>
<li>UICollectionViewLayout的功能为向UICollectionView提供布局信息，不仅包括cell的布局信息，也包括追加视图和装饰视图的布局信息。实现一个自定义layout的常规做法是继承UICollectionViewLayout类，然后重载下列方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-(void)prepareLayout</span><br><span class="line">准备方法被自动调用，以保证layout实例的正确。</span><br><span class="line"></span><br><span class="line">-(CGSize)collectionViewContentSize</span><br><span class="line">返回collectionView的内容的尺寸</span><br><span class="line"></span><br><span class="line">-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect</span><br><span class="line"> 1.返回rect中的所有的元素的布局属性</span><br><span class="line"> 2.返回的是包含UICollectionViewLayoutAttributes的NSArray</span><br><span class="line"> 3.UICollectionViewLayoutAttributes可以是cell，追加视图或装饰视图的信息，通过不同的UICollectionViewLayoutAttributes初始化方法可以得到不同类型的UICollectionViewLayoutAttributes：</span><br><span class="line">  1)layoutAttributesForCellWithIndexPath:</span><br><span class="line">  2)layoutAttributesForSupplementaryViewOfKind:withIndexPath:</span><br><span class="line">  3)layoutAttributesForDecorationViewOfKind:withIndexPath:</span><br><span class="line"></span><br><span class="line">-(UICollectionViewLayoutAttributes )layoutAttributesForItemAtIndexPath:(NSIndexPath )indexPath</span><br><span class="line">返回对应于indexPath的位置的cell的布局属性</span><br><span class="line"></span><br><span class="line">-(UICollectionViewLayoutAttributes )layoutAttributesForSupplementaryViewOfKind:(NSString )kind atIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">返回对应于indexPath的位置的追加视图的布局属性，如果没有追加视图可不重载</span><br><span class="line"></span><br><span class="line">-(UICollectionViewLayoutAttributes * )layoutAttributesForDecorationViewOfKind:(NSString)decorationViewKind atIndexPath:(NSIndexPath )indexPath</span><br><span class="line">返回对应于indexPath的位置的装饰视图的布局属性，如果没有装饰视图可不重载</span><br><span class="line"></span><br><span class="line">-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds</span><br><span class="line">当边界发生改变时，是否应该刷新布局。如果YES则在边界变化（一般是scroll到其他地方）时，将重新计算需要的布局信息。</span><br></pre></td></tr></table></figure>
<ul>
<li>调用顺序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1）-(void)prepareLayout  设置layout的结构和初始需要的参数等。</span><br><span class="line"></span><br><span class="line">2)  -(CGSize) collectionViewContentSize 确定collectionView的所有内容的尺寸。</span><br><span class="line"></span><br><span class="line">3）-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect初始的layout的外观将由该方法返回的UICollectionViewLayoutAttributes来决定。</span><br><span class="line"></span><br><span class="line">4)在需要更新layout时，需要给当前layout发送 </span><br><span class="line">     1)-invalidateLayout， 该消息会立即返回，并且预约在下一个loop的时候刷新当前layout</span><br><span class="line">     2)-prepareLayout，</span><br><span class="line">     3)依次再调用-collectionViewContentSize和-layoutAttributesForElementsInRect来生成更新后的布局。</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/a16ffb4bbcc2" target="_blank" rel="noopener">LineLayout</a>：<strong>流水布局实例</strong><a href="https://www.jianshu.com/p/a16ffb4bbcc2" target="_blank" rel="noopener">http://www.jianshu.com/p/a16ffb4bbcc2</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1418424-2d1ced7aba5fae41.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/360" alt="img"></p>
<p>流水布局</p>
<hr>
<p><a href="https://www.jianshu.com/p/83e31a2f18d9" target="_blank" rel="noopener">圆形布局CircleLayout</a> <a href="https://www.jianshu.com/p/83e31a2f18d9" target="_blank" rel="noopener">http://www.jianshu.com/p/83e31a2f18d9</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1418424-5c7d83b061a53437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/325" alt="img"></p>
<p>圆形布局</p>
<hr>
<p><a href="https://www.jianshu.com/p/58e06e1f2f6d" target="_blank" rel="noopener">方行布局</a><a href="https://www.jianshu.com/p/58e06e1f2f6d" target="_blank" rel="noopener">http://www.jianshu.com/p/58e06e1f2f6d</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1418424-a790ec383a44c5e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/365" alt="img"></p>
<p>SquareLayout</p>
<p><a href="https://www.jianshu.com/p/9414a0d98514" target="_blank" rel="noopener">瀑布流布局</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1418424-2396e207ae4f4edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/404" alt="img"></p>
<p>瀑布流布局</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> UICollectionViewLayout </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 11.0 news]]></title>
      <url>/2018/05/02/What's%20New%20in%20iOS%2011.0/</url>
      <content type="html"><![CDATA[<p><a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/" target="_blank" rel="noopener">https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/</a></p>
<p>iOS 11.0</p>
<p>This article summarizes the key developer-related features introduced in iOS 11, which runs on currently shipping iOS devices. The article also lists the documents that describe new features in more detail.</p>
<p>For late-breaking news and information about known issues, see <em>iOS 11 Release Notes</em>.</p>
<p>For a complete list of new, modified, and deprecated APIs, see <a href="https://developer.apple.com/documentation?changes=latest_major" target="_blank" rel="noopener">Apple Developer Documentation</a>.</p>
<p>To learn about new features for SafariServices and WebKit, see <em>What’s New in Safari</em>.<br><a id="more"></a><br>To learn about what’s new in Swift, see <a href="https://developer.apple.com/library/content/releasenotes/DeveloperTools/RN-Xcode/Chapters/Introduction.html#//apple_ref/doc/uid/TP40001051-CH1-SW485" target="_blank" rel="noopener">Swift Language</a> in <em>What’s New in Xcode</em> and <em>The Swift Programming Language (Swift 4.1)</em>.</p>
<h2 id="General"><a href="#General" class="headerlink" title="General"></a>General</h2><ul>
<li><strong>New in iOS 11.0 - Support for binary (nontext) barcodes.</strong><ul>
<li>Added APIs to AV Foundation, Core Image, and SiriKit to support detection, decoding, and creation of barcodes with binary content.</li>
<li>Added a new barcode descriptor object, <code>CIBarcodeDescriptor</code> to Core Image to provide interoperability with AV Foundation and the Vision APIs.</li>
</ul>
</li>
<li><strong>New in iOS 11.0 - MusicKit.</strong><ul>
<li>MusicKit gives your app access to the full Apple Music catalog, and to the user’s library.</li>
<li>Added and updated functionality in StoreKit for retrieving client tokens and storefront identifiers.</li>
<li>Added and updated functionality in Media Player to enable station playback.</li>
<li>Added display of custom messages in the Apple Music subscriber setup flow.</li>
</ul>
</li>
</ul>
<h2 id="App-Frameworks"><a href="#App-Frameworks" class="headerlink" title="App Frameworks"></a>App Frameworks</h2><ul>
<li><p><strong>New in iOS 11.0 - Support for drag and drop. </strong>Drag and drop in iOS lets a user drag items from one location to another onscreen, either within a single app or in different apps.</p>
<ul>
<li>Added functionally to identify views as drag sources and as drag destinations.</li>
<li>Added customizable previews and set-down animations.</li>
</ul>
<p>See <a href="https://developer.apple.com/documentation/uikit/drag_and_drop" target="_blank" rel="noopener">Drag and Drop</a> in the documentation.</p>
</li>
<li><p><strong>New in iOS 11.0 - Browsing local and iCloud documents.</strong></p>
<ul>
<li>Added view controllers for browsing documents stored locally and in the cloud. See <code>UIDocumentBrowserViewController</code> and <code>UIDocumentBrowserTransitionController</code>.</li>
<li>Added <code>UIDocumentBrowserAction</code>, an object for creating a custom action for the document browser.</li>
<li>Added the <a href="https://developer.apple.com/documentation/fileprovider" target="_blank" rel="noopener">FileProvider</a> and <a href="https://developer.apple.com/documentation/fileproviderui" target="_blank" rel="noopener">FileProviderUI</a> frameworks for adding third party storage services.</li>
</ul>
<p>See <a href="https://developer.apple.com/documentation/uikit/system_view_controllers/adding_a_document_browser_to_your_app" target="_blank" rel="noopener">Adding a Document Browser to Your App</a>.</p>
</li>
<li><p>Improved Dynamic Type support.</p>
<ul>
<li>Added <code>UIFontMetrics</code>, an object for creating custom fonts that scale based on the currently selected text size.</li>
<li>Updated Auto Layout to dynamically adjust spacing based on the font sizes when a baseline anchor is part of a constraint that uses the system spacing.</li>
<li>Added an attribute to preserve vector data for PDF assets to enable smooth scaling. You can use this attribute to show a larger version of bar items and segmented control items, as well as to adjust image sizes to match the user’s text size. To enable scaling in the PDF, in the asset catalog Attributes inspector, select “Preserve vector data” for the PDF to enable scaling.</li>
<li>Added <code>UIAccessibilityContentSizeCategoryImageAdjusting</code>, a protocol for scaling images for accessibility text sizes.</li>
</ul>
</li>
<li><p>Improved Auto Layout support for Dynamic Type.</p>
<ul>
<li>Updated <code>NSLayoutXAxisAnchor</code> and <code>NSLayoutYAxisAnchor</code> to provide factory methods that create constraints using the system spacing between two anchors. Previously the only way to create such a constraint was with the dash (<code>-</code>) in the Visual Format Language.</li>
<li>Added an option to <code>NSLayoutFormatOptions</code> for creating a Visual Format Language string that uses baseline-to-baseline spacing.</li>
<li>Updated <code>UIStackView</code> to enable system spacing and customized spacing.</li>
</ul>
</li>
<li><p>Updated text content to work with App Password autofill.</p>
<ul>
<li>Added <code>username</code> and <code>password</code> properties to <code>UITextContentType</code>.</li>
</ul>
</li>
<li><p>Added <code>primaryEdge</code>, a property of <code>UISplitViewController</code> for setting the side for the master view controller.</p>
</li>
<li><p>Added <code>sectionInsetReference</code>, a new enum property for <code>UICollectionViewFlowLayout</code>, that specifies the boundary used for relative section insets.</p>
</li>
<li><p>Updated keyboard extensions.</p>
<ul>
<li>Added <code>selectedText</code>, a property of <code>UITextDocumentProxy</code> that returns the currently selected text in the document.</li>
<li>Added <code>documentIdentifier</code>, a property of <code>UITextDocumentProxy</code> that specifies whether the user is navigating to a new text widget.</li>
<li>Added <code>hasFullAccess</code>, a property of <code>UIInputViewController</code> that checks keyboard permissions.</li>
<li>Added <code>needsInputModeSwitchKey</code>, a property of <code>UIInputViewController</code> to control the display of the input-mode switch key.</li>
<li>Added new system permissions in Settings for app access to included keyboard extensions.</li>
</ul>
</li>
<li><p>Improved API for available storage space.</p>
<ul>
<li>Added new keys to the <code>URL</code> class for different usage scenarios.<ul>
<li>The <code>volumeAvailableCapacityForImportantUsageKey</code> key returns total amount of bytes available for operations explicitly requested by user or essential to proper functioning of your apps.</li>
<li>The <code>volumeAvailableCapacityForOpportunisticUsageKey</code> key returns total amount of bytes available for storing nonessential items, such as content predownloaded for performance that may or may not get used by the user.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Graphics-and-Games"><a href="#Graphics-and-Games" class="headerlink" title="Graphics and Games"></a>Graphics and Games</h2><ul>
<li><strong>New in iOS 11.0 - Support for augmented reality.</strong><ul>
<li>Added the <a href="https://developer.apple.com/documentation/arkit" target="_blank" rel="noopener">ARKit framework</a> that combines device motion tracking, camera scene capture, advanced scene processing, and display conveniences to simplify the task of building an AR experience.</li>
</ul>
</li>
<li><strong>New in iOS 11.0 - High performance image analysis.</strong><ul>
<li>Added the <a href="https://developer.apple.com/documentation/vision" target="_blank" rel="noopener">Vision framework</a> for detecting faces, bar codes, text, image horizon, and rectangular regions.</li>
<li>Provided support for integrating the Vision framework with Core ML to run custom models on images.</li>
<li>Added object-tracking in video.</li>
<li>Added support for image registration.</li>
</ul>
</li>
<li><strong>New in iOS 11.0 - Ability to write custom image blending kernels for Core Image.</strong><ul>
<li>Added <code>CIBlendKernel</code>, a special type of <code>CIColorKernel</code> to blend two images (supported by <code>CIRenderDestination</code> and <code>CIImageAccumulator</code>).</li>
<li>Added <code>init(functionName:fromMetalLibraryData:)</code> to <code>CIKernel</code> for writing kernels using Metal to benefit from the improved language features and the reduced compile time.</li>
</ul>
</li>
<li><strong>New in iOS 11.0 - Lightweight render destination.</strong><ul>
<li>Added <code>CIRenderDestination</code>, an object for creating renderers that return to the caller after the work has been issued. You can specify all the destination attributes of the renderer for different destinations, including a surface (<code>IOSurface</code>), Core Video pixel buffer (<code>CVPixelBuffer</code>), GL textures, Metal textures, and memory.</li>
</ul>
</li>
<li>Extended the <a href="https://developer.apple.com/documentation/replaykit" target="_blank" rel="noopener">ReplayKit framework</a>.<ul>
<li>Updated <code>RPScreenRecorder</code> for screen capture and back camera support.</li>
</ul>
</li>
<li>Added new Core Image filters <code>CITextImageGenerator</code>, <code>CIColorCurves</code>, <code>CILabDeltaE</code>, <code>CIBokehBlur</code>, <code>CIMinMaxRed</code>, and <code>CIBicubicScaleTransform</code>.</li>
</ul>
<h2 id="Metal-2"><a href="#Metal-2" class="headerlink" title="Metal 2"></a>Metal 2</h2><p>Metal 2 contains significant additions and updates to Metal, the Metal Shading Language, and the Metal Performance Shaders framework. Items below indicate where the updates occur:</p>
<p>  – MTL: An update in the <a href="https://developer.apple.com/documentation/metal" target="_blank" rel="noopener">Metal framework</a>.</p>
<p>  – MSL: An update in the <a href="https://developer.apple.com/metal/metal-shading-language-specification.pdf" target="_blank" rel="noopener">Metal Shading Language</a>.</p>
<p>  – MPS: An update in the <a href="https://developer.apple.com/documentation/metalperformanceshaders" target="_blank" rel="noopener">Metal Performance Shaders framework</a>.</p>
<ul>
<li><strong>MPS: New in Metal 2 - Cross-platform Metal Performance Shaders support.</strong><ul>
<li>All Metal Performance Shaders functionality is available in iOS 11.0, tvOS 11.0, and macOS 10.13.</li>
</ul>
</li>
<li><strong>MPS: New in iOS 11.0 - Neural network support.</strong><ul>
<li>Added support for neural networks to the Metal Performance Shaders framework.</li>
<li>Added graphs to offer a higher level API for simplifying the creation of neural networks, including objects that allow state to be transferred between nodes in a neural network.</li>
<li>Added convolutional neural networks (CNN) to support implementing and running deep learning using previously obtained training data.</li>
<li>Added recurrent neural networks for implementing inference on images and matrices.</li>
</ul>
</li>
<li><strong>New in iOS 11.0 - Argument buffers.</strong> Group your resources into an argument buffer (AB) to reduce CPU overhead.<ul>
<li>MSL: Added the <code>[[id(n)]]</code> attribute qualifier to identify resources in an AB structure.</li>
<li>MTL: Added the <code>MTLArgumentEncoder</code> protocol to encode resources into an AB.</li>
</ul>
</li>
<li><strong>MTL: New in iOS 11.0 - Programmable sample positions.</strong> Configure the position of samples when rendering to a multisampled render target.<ul>
<li>Updated the <code>MTLRenderPassDescriptor</code> class to set and get sample positions for a render pass.</li>
</ul>
</li>
<li><strong>MSL: New in iOS 11.0 - Uniform type.</strong><ul>
<li>Added the <code>uniform</code> type to declare variables that are uniform for all threads that execute the graphics or compute function of a draw or dispatch call.</li>
</ul>
</li>
<li><strong>MSL: New in iOS 11.0 - Array of samplers.</strong><ul>
<li>Added the <code>array&lt;sampler, size_t N&gt;</code> type to store an array of samplers.</li>
</ul>
</li>
<li><strong>MTL: New in iOS 11.0 - BGR10A2 pixel format.</strong><ul>
<li>Added the <code>bgr10A2Unorm</code> pixel format to present wide color content on P3 displays.</li>
</ul>
</li>
<li>MPS: Added new filters.<ul>
<li>Added filters for image statistics, such as computing the mean and variance for an image region.</li>
<li>Added filters for combining two images together, such as an element-wise sum.</li>
<li>Added filters for matrix decomposition and solving, such as decomposition using Cholesky or LU (lower upper) factorization.</li>
</ul>
</li>
<li>MSL: Extended function specialization. Members of a structure used in a graphics, compute, or user function can be used with function constants.<ul>
<li>Extended <code>[[color(n)]]</code> and <code>[[raster_order_group(index)]]</code> attribute qualifiers to work with function constants.</li>
</ul>
</li>
<li>MTL: Extended vertex formats.<ul>
<li>Added new <code>MTLVertexFormat</code> values for small formats such as <code>char</code>, <code>short</code>, and <code>half</code>.</li>
</ul>
</li>
<li>Added dual-source blending support to iOS. Output two source colors to a single render target in a fixed-function blending operation.<ul>
<li>MSL: Added a new <code>[[index(i)]]</code> attribute qualifier to the <code>[[color(n)]]</code> attribute qualifier to output a second source color.</li>
<li>MTL: Updated <code>MTLBlendFactor</code> to operate on a second source color.</li>
</ul>
</li>
</ul>
<h2 id="App-Services"><a href="#App-Services" class="headerlink" title="App Services"></a>App Services</h2><ul>
<li><p><strong>New in iOS 11.0 - Support for machine learning models.</strong></p>
<ul>
<li>Added the <a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener">Core ML framework</a> for easily integrating machine learning models into apps.</li>
</ul>
</li>
<li><p><strong>New in iOS 11.0 - SiriKit support for visual codes.</strong></p>
<ul>
<li>Added the <a href="https://developer.apple.com/documentation/sirikit/visual_codes" target="_blank" rel="noopener">Visual Codes domain</a> to Sirkit to support showing visual codes for exchanging payment and contact information.</li>
</ul>
</li>
<li><p><strong>New in iOS 11.0 - SiriKit support for notes and to-do lists.</strong></p>
<ul>
<li>Added the <a href="https://developer.apple.com/documentation/sirikit/lists_and_notes" target="_blank" rel="noopener">Lists and Notes domain</a> to SiriKit to support using Siri to add notes, interact with to-do lists, and interact with reminders.</li>
</ul>
</li>
<li><p>Added intents to SiriKit domains.</p>
<ul>
<li>Added ride canceling and feedback to the <a href="https://developer.apple.com/documentation/sirikit/ride_booking" target="_blank" rel="noopener">Ride Booking domain</a>.</li>
<li>Added transferring money and searching for accounts to the <a href="https://developer.apple.com/documentation/sirikit/payments" target="_blank" rel="noopener">Payments domain</a>.</li>
</ul>
</li>
<li><p><strong>New in iOS 11.0 - Find the heading of the device.</strong></p>
<ul>
<li>Added <code>heading</code> to <code>CMDeviceMotion</code>, a property that returns the heading angle with respect to the <code>CMAttitudeReferenceFrame</code>. The returned value is the heading in degrees as a<code>double</code>. A negative value is returned when the reference frame is <code>xArbitraryZVertical</code> or <code>xArbitraryCorrectedZVertical</code>.</li>
</ul>
</li>
<li><p><strong>New in iOS 11.0 - Multipath TCP.</strong></p>
<ul>
<li>Added support for using multiple interfaces, like Wi-Fi and cellular, to transmit a single data stream, by extending <code>URLSessionConfiguration</code> to support Multipath TCP as defined in<a href="https://tools.ietf.org/html/rfc6824" target="_blank" rel="noopener">IETF RFC 6824</a>. See <code>URLSessionConfiguration.MultipathServiceType</code>.</li>
</ul>
</li>
<li><p><strong>New in iOS 11.0 - DNS Proxy.</strong></p>
<ul>
<li>Added a new DNS Proxy app extension type to the Network Extension framework.</li>
</ul>
</li>
<li><p>Enhanced end user transaction flow in Apple Pay.</p>
<ul>
<li>Added <code>PKPaymentError</code> to PassKit, a structure for detailed reporting of errors in a user’s shipping and payment information, and for authorization errors. Developers can use the information to provide a customized error string.</li>
<li>Updated the handler methods in <code>PKPaymentAuthorizationControllerDelegate</code> to receive a <code>PKPaymentError</code>.</li>
<li>Updated <code>PKPaymentRequest</code> to use <code>PKContactField</code> for contact information.</li>
<li>Added <code>supportedCountries</code> to <code>PKPaymentRequest</code> for specifying supported countries for a transaction.</li>
<li>Added support for presenting payment buttons even if there are no supported payment methods in Wallet. Apple Pay now handles payment without leaving your app, and then returns to checkout.</li>
</ul>
</li>
<li><p><strong>New in iOS 11.0 - Promoting in-app purchases on the App Store.</strong></p>
<ul>
<li>Developers can promote up to 20 in-app purchases on their App Store product page. Customers can start their purchase on the App Store, and then be taken to the app to complete the transaction.</li>
<li>Added <code>paymentQueue(_:shouldAddStore:for:)</code>, a new method of <code>SKPaymentTransactionObserver</code> for promoted in-app purchases. Apps need to support this delegate for promoted in-app purchases to display on the App Store.</li>
</ul>
</li>
<li><p><strong>New in iOS 11.0 - Live messages.</strong></p>
<ul>
<li><p>Added <code>MSMessageLiveLayout</code>, a new message layout for showing live messages that can display dynamic content, such as games. Each live message has its own<code>MSMessagesAppViewController</code>, and there can be multiple active live messages on the screen at once.</p>
<p>The following code shows adding a live message to a message stream, including an alternate layout for devices that do not support live messages.</p>
<p>| <code>**guard** **let** conversation = activeConversation **else** {</code> |<br>| —————————————- |<br>| <code>fatalError(&quot;No active conversation&quot;)</code> |<br>| <code>}</code>                                      |<br>| <code></code>                                      |<br>| <code>**let** alternateLayout = MSMessageTemplateLayout()</code> |<br>| <code>alternateLayout.image = UIImage(named: &quot;SuperSweetGameImage&quot;)</code> |<br>| <code>alternateLayout.caption = &quot;$(\(conversation.localParticipantIdentifier)) wants to play a game!&quot;</code> |<br>| <code>**let** layout = MSMessageLiveLayout(alternateLayout: alternateLayout)</code> |<br>| <code></code>                                      |<br>| <code>**let** message = MSMessage()</code>          |<br>| <code>message.layout = layout</code>                |<br>| <code></code>                                      |<br>| <code>conversation.insert(message, completionHandler: **nil**)</code> |</p>
</li>
</ul>
</li>
<li><p>Enhanced triggers for HomeKit.</p>
<ul>
<li>Enhanced time-based conditions for triggers. <code>HMSignificantTimeEvent</code> specifies an offset from sunrise and sunset. <code>HMCalendarEvent</code> specifies a date and time. <code>HMDurationEvent</code>specifies a time interval.</li>
<li>Added <code>HMCharacteristicThresholdRangeEvent</code> to support tracking the state of an accessory within a range, such as running an action when the temperature is between 68 and 72 degrees.</li>
<li>Added <code>HMPresenceEvent</code> for adding a condition based on the presence or absence of users.</li>
<li>Updated <code>HMEventTrigger</code> to enable multiple recurrences of the event.</li>
</ul>
</li>
<li><p>Added <code>home:didUpdateHomeHubState:</code> to support receiving updates of the home hub state.</p>
</li>
<li><p>Updated MapKit for clearer display of developer data.</p>
<ul>
<li>Added <code>mutedStandard</code>, a new map display mode that emphasizes developer data.</li>
<li>Added properties to customize how annotations behave when collisions occur. Developers use a combination of <code>displayPriority</code>, <code>collisionMode</code>, and <code>clusteringIdentifier</code> to influence which annotations remain on the map.</li>
</ul>
</li>
<li><p>Added the <code>authorizationStatus</code> method to the <code>CMAltimiter</code>, <code>CMPedometer</code>, <code>CMMotionActivityManager</code>, and <code>CMSensorRecorder</code> classes of the Core Motion framework. The method is used to determine if an app is authorized to recieve data from a source.</p>
</li>
</ul>
<h2 id="Media-and-Web"><a href="#Media-and-Web" class="headerlink" title="Media and Web"></a>Media and Web</h2><ul>
<li><strong>New in iOS 11.0 - Support for High Efficiency Video Coding (HEVC). </strong>High Efficiency Video Coding (HEVC) is a new standard for video encoding that offers substantially better compression than H.264 at the same level of visual quality.<ul>
<li>Added support for using AV Foundation to play back movies containing HEVC-encoded tracks, and to capture and export videos.</li>
<li>Added support for using <code>VideoToolbox</code> clients to encode and decode HEVC video bitstreams.</li>
</ul>
</li>
<li><strong>New in iOS 11.0 - Support for High Efficiency Image Format (HEIF).</strong> High Efficiency Image Format (HEIF) is a new standard of image compression that nearly doubles current data compression ratios for the same level of image quality.<ul>
<li>Added functionality to the Photos and Core Image frameworks to display, encode, and export HEIF images.</li>
</ul>
</li>
<li><strong>New in iOS 11.0 - Support for capturing and manipulating depth data, and enhanced photo capture.</strong><ul>
<li>Added objects to AV Foundation for capturing and representing depth data. See <code>AVCaptureDepthDataOutput</code>, <code>AVDepthData</code>, and related APIs.</li>
<li>Added <code>AVCapturePhoto</code>, an object that encapsulates the information for a captured photo and supports HEVC and HEIC encoded images.</li>
<li>Updated <code>AVCapturePhotoOutput</code> to provide more information about camera features and supported output formats.</li>
</ul>
</li>
<li><strong>New in iOS 11.0 - Automatic storage management.</strong><ul>
<li>Added automatic storage management of HTTP live streaming assets to <code>AVAssetDownloadTask</code>. The system can automatically purge expired or unneeded downloads when space is required. Use priorities to influence the purging policy.</li>
</ul>
</li>
<li><strong>New in iOS 11.0 - AirPlay 2.</strong><ul>
<li>Improved AirPlay reliability for some audio playback interfaces in AV Foundation. To take advantage of the increased reliability, play audio using <code>AVPlayer</code> or the new<code>AVSampleBufferAudioRenderer</code> object.</li>
<li>Added multiple speaker support to AirPlay for long-form audio, such as music and podcasts. To mark your application as presenting long-form audio, invoke the <code>AVAudioSession</code>method <code>setCategory(_:mode:routeSharingPolicy:options:)</code> and use <code>AVAudioSessionRouteSharingPolicyLongForm</code> as the parameter value.</li>
<li>Added <code>AVRoutePickerView</code> to the AVKit framework and <code>AVRouteDetector</code> to the AVFoundation framework for enabling users to choose the route for playing content when multiple routes are available. Use <code>AVRouteDetector</code> to determine if multiple routes are available when route detection is enabled. If multiple routes are available, use <code>AVRoutePickerView</code> to present an interface for the user to choose the routes.</li>
</ul>
</li>
<li>Added FairPlay streaming key management.<ul>
<li>Improved the functionality of <code>AVContentKeySession</code>. Use <code>AVContentKeySession</code> to initiate content key requests independent of playback or downloading of media assets. Objects conforming to the <code>AVContentKeyRecipient</code> protocol, such as <code>AVURLAsset</code>, can be added as a recipient to <code>AVContentKeySession</code> to obtain access to existing content keys and initiate new content key requests</li>
</ul>
</li>
<li>Added more Live Photo adjustments.<ul>
<li>Added a collection of Live Photo adjustments, called <em>effects</em>, that render the live photo as Loop, Bounce, or Long Exposure. Unlike regular live photos, Loop and Bounce videos will play in a continuous loop.</li>
<li>Added a <code>playbackStyle</code>, a new property that identifies how to present the <code>PHAsset</code> to the user.</li>
</ul>
</li>
</ul>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><ul>
<li><strong>New in iOS 11.0 - Hotspot configuration.</strong><ul>
<li>Added a network extension for hotspot configuration. See <code>NEHotspotConfiguration</code>.</li>
</ul>
</li>
<li><strong>New in iOS 11.0 - Detect NFC tags and read messages that contain NDEF data.</strong><ul>
<li>Added <a href="https://developer.apple.com/documentation/corenfc" target="_blank" rel="noopener">Core NFC</a>, a new framework for reading Near Field Communications (NFC) tags and data in NFC Data Exchange Format (NDEF.)</li>
</ul>
</li>
<li>Updated the Core Bluetooth framework.<ul>
<li>Added support for L2CAP Channels.</li>
<li>Extended session restoration to work across Bluetooth resets and device reboots.</li>
<li>Updated the APIs in the <a href="https://developer.apple.com/documentation/corebluetooth" target="_blank" rel="noopener">Core Bluetooth framework</a> to match across iOS, tvOS, watchOS, and macOS, and marked the platform availability of each API.</li>
</ul>
</li>
<li>APFS is now the default filesystem.<ul>
<li>Added normalization-insensitive support for a case sensitive filesystem.</li>
</ul>
</li>
</ul>
<h1 id="iOS-11-0"><a href="#iOS-11-0" class="headerlink" title="iOS 11.0"></a>iOS 11.0</h1><p>本文总结了iOS 11中引入的关键开发人员相关功能，该功能在当前正在运行的iOS设备上运行。本文还列出了更详细描述新功能的文档。</p>
<p>有关已知问题的最新消息和信息，请参阅<em>iOS 11发行说明</em>。</p>
<p>有关新的，已修改的和已弃用的API的完整列表，请参阅<a href="https://developer.apple.com/documentation?changes=latest_major" target="_blank" rel="noopener">Apple开发人员文档</a>。</p>
<p>要了解SafariServices和WebKit的新功能，请参阅<em>Safari中的</em>新增功能。</p>
<p>要了解Swift中的新功能，请参阅 <a href="https://developer.apple.com/library/content/releasenotes/DeveloperTools/RN-Xcode/Chapters/Introduction.html#//apple_ref/doc/uid/TP40001051-CH1-SW485" target="_blank" rel="noopener">Swift语言</a>中<em>的Xcode新增功能</em>和<em>Swift编程语言（Swift 4.1）</em>。</p>
<h2 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h2><ul>
<li><strong>iOS 11.0新增功能 - 支持二进制（非文本）条形码。</strong><ul>
<li>为AV Foundation，Core Image和SiriKit添加了API，以支持使用二进制内容检测，解码和创建条形码。</li>
<li><code>CIBarcodeDescriptor</code>向Core Image 添加了一个新的条形码描述符对象，以提供与AV Foundation和Vision API的互操作性。</li>
</ul>
</li>
<li><strong>iOS 11.0新增功能 - MusicKit。</strong><ul>
<li>MusicKit可让您的应用程序访问完整的Apple音乐目录以及用户的图书馆。</li>
<li>在StoreKit中添加并更新了用于检索客户端令牌和店面标识符的功能。</li>
<li>在媒体播放器中添加和更新功能以启用电台播放。</li>
<li>在Apple Music用户设置流程中添加了自定义消息的显示。</li>
</ul>
</li>
</ul>
<h2 id="应用程序框架"><a href="#应用程序框架" class="headerlink" title="应用程序框架"></a>应用程序框架</h2><ul>
<li><p><strong>iOS 11.0新增功能 - 支持拖放操作。</strong>通过在iOS中拖放，用户可以将项目从一个位置拖到另一个位置，可以在单个应用程序中或在不同的应用程序中进行拖放。</p>
<ul>
<li>新增功能可将视图识别为拖动源和拖动目标。</li>
<li>添加了可自定义的预览和设置动画。</li>
</ul>
<p>请参阅文档中的<a href="https://developer.apple.com/documentation/uikit/drag_and_drop" target="_blank" rel="noopener">拖放</a>。</p>
</li>
<li><p><strong>iOS 11.0新增功能 - 浏览本地和iCloud文档。</strong></p>
<ul>
<li>添加了用于浏览本地和云中存储文件的视图控制器。见<code>UIDocumentBrowserViewController</code>和<code>UIDocumentBrowserTransitionController</code>。</li>
<li>添加<code>UIDocumentBrowserAction</code>了一个用于为文档浏览器创建自定义操作的对象。</li>
<li>添加了<a href="https://developer.apple.com/documentation/fileprovider" target="_blank" rel="noopener">FileProvider</a>和<a href="https://developer.apple.com/documentation/fileproviderui" target="_blank" rel="noopener">FileProviderUI</a>框架以添加第三方存储服务。</li>
</ul>
<p>请参阅<a href="https://developer.apple.com/documentation/uikit/system_view_controllers/adding_a_document_browser_to_your_app" target="_blank" rel="noopener">向应用程序添加文档浏览器</a>。</p>
</li>
<li><p>改进的动态类型支持。</p>
<ul>
<li>添加<code>UIFontMetrics</code>了一个对象，用于创建基于当前选定文本大小进行缩放的自定义字体。</li>
<li>当基线锚点是使用系统间距的约束的一部分时，更新了自动布局以根据字体大小动态调整间距。</li>
<li>添加了一个属性以保留PDF资产的矢量数据以启用平滑缩放。您可以使用此属性显示更大版本的条形项目和分段控制项目，以及调整图像大小以匹配用户的文本大小。要在PDF中启用缩放，请在资产目录属性检查器中为PDF选择“保留矢量数据”以启用缩放。</li>
<li>新增<code>UIAccessibilityContentSizeCategoryImageAdjusting</code>了一个协议，用于缩放可访问文本大小的图像。</li>
</ul>
</li>
<li><p>改进了动态类型的自动布局支持。</p>
<ul>
<li>更新<code>NSLayoutXAxisAnchor</code>并<code>NSLayoutYAxisAnchor</code>提供工厂方法，使用两个锚点之间的系统间距创建约束。以前，创建这种约束的唯一方法是使用<code>-</code>Visual Format Language中的dash（）。</li>
<li>添加了一个<code>NSLayoutFormatOptions</code>用于创建使用基线到基线间距的视觉格式语言字符串的选项。</li>
<li>已更新<code>UIStackView</code>以启用系统间距和自定义间距。</li>
</ul>
</li>
<li><p>更新文本内容以使用应用程序密码自动填充。</p>
<ul>
<li>已添加<code>username</code>和<code>password</code>属性<code>UITextContentType</code>。</li>
</ul>
</li>
<li><p>新增<code>primaryEdge</code>了一个<code>UISplitViewController</code>用于设置主视图控制器侧的属性。</p>
</li>
<li><p>新增<code>sectionInsetReference</code>了一个新的enum属性<code>UICollectionViewFlowLayout</code>，用于指定用于相对节插页的边界。</p>
</li>
<li><p>更新了键盘扩展。</p>
<ul>
<li>已添加<code>selectedText</code>，该属性<code>UITextDocumentProxy</code>返回文档中当前选定的文本。</li>
<li>增加<code>documentIdentifier</code>了一个属性，<code>UITextDocumentProxy</code>用于指定用户是否正在导航到新的文本小部件。</li>
<li>增加<code>hasFullAccess</code>了一个<code>UIInputViewController</code>检查键盘权限的属性。</li>
<li>增加<code>needsInputModeSwitchKey</code>了<code>UIInputViewController</code>控制输入模式切换键显示的属性。</li>
<li>在设置中添加新的系统权限，以便对包含的键盘扩展程序进行应用访</li>
</ul>
</li>
<li><p>改进了可用存储空间的API。</p>
<ul>
<li><code>URL</code>为不同的使用场景添加了新的关键字。<ul>
<li>该<code>volumeAvailableCapacityForImportantUsageKey</code>键返回用户明确请求的操作的可用字节总数，或者返回应用程序正常运行所必需的基本字节数。</li>
<li>该<code>volumeAvailableCapacityForOpportunisticUsageKey</code>键返回可用于存储非必需项目的总字节数，例如为可能会或可能不会被用户使用的性能而预先加载的内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图形和游戏"><a href="#图形和游戏" class="headerlink" title="图形和游戏"></a>图形和游戏</h2><ul>
<li><strong>iOS 11.0新增功能 - 支持增强现实。</strong><ul>
<li>添加了<a href="https://developer.apple.com/documentation/arkit" target="_blank" rel="noopener">ARKit框架</a>，该<a href="https://developer.apple.com/documentation/arkit" target="_blank" rel="noopener">框架</a>结合了设备运动跟踪，相机场景捕捉，高级场景处理和显示便利，从而简化了构建AR体验的任务。</li>
</ul>
</li>
<li><strong>iOS 11.0新增功能 - 高性能图像分析。</strong><ul>
<li>添加了<a href="https://developer.apple.com/documentation/vision" target="_blank" rel="noopener">Vision框架，</a>用于检测面部，条形码，文本，图像视野和矩形区域。</li>
<li>为将Vision框架与Core ML集成在图像上运行定制模型提供了支持。</li>
<li>在视频中添加了对象跟踪。</li>
<li>增加了对图像注册的支持。</li>
</ul>
</li>
<li><strong>iOS 11.0中的新功能 - 可以为Core Image编写自定义图像混合内核。</strong><ul>
<li>添加<code>CIBlendKernel</code>了一种特殊的类型<code>CIColorKernel</code>来混合两个图像（由<code>CIRenderDestination</code>and 支持<code>CIImageAccumulator</code>）。</li>
<li>添加<code>init(functionName:fromMetalLibraryData:)</code>到<code>CIKernel</code>编写使用金属从改进的语言特性，并减少编译时间受益内核。</li>
</ul>
</li>
<li><strong>iOS 11.0中的新功能 - 轻量级渲染目标。</strong><ul>
<li>添加<code>CIRenderDestination</code>了一个用于创建呈现器的对象，该对象在作品发布后返回给调用者。您可以为不同的目标指定渲染器的所有目标属性，包括surface（<code>IOSurface</code>），Core Video像素缓冲区（<code>CVPixelBuffer</code>），GL纹理，Metal贴图和内存。</li>
</ul>
</li>
<li>扩展了<a href="https://developer.apple.com/documentation/replaykit" target="_blank" rel="noopener">ReplayKit框架</a>。<ul>
<li>更新<code>RPScreenRecorder</code>了屏幕捕获和背部照相机支持。</li>
</ul>
</li>
<li>增加了新的核心图像过滤器<code>CITextImageGenerator</code>，<code>CIColorCurves</code>，<code>CILabDeltaE</code>，<code>CIBokehBlur</code>，<code>CIMinMaxRed</code>，和<code>CIBicubicScaleTransform</code>。</li>
</ul>
<h2 id="Metal2"><a href="#Metal2" class="headerlink" title="Metal2"></a>Metal2</h2><p>Metal 2包含对Metal，Metal Shading Language和Metal Performance Shaders框架的重要补充和更新。下面的项目表示更新发生的地方：</p>
<ul>
<li><p>MTL：<a href="https://developer.apple.com/documentation/metal" target="_blank" rel="noopener">Metal框架中</a>的更新。</p>
</li>
<li><p>MSL：<a href="https://developer.apple.com/metal/metal-shading-language-specification.pdf" target="_blank" rel="noopener">金属着色语言</a>的更新。</p>
</li>
<li><p>MPS：<a href="https://developer.apple.com/documentation/metalperformanceshaders" target="_blank" rel="noopener">金属性能着色器框架中</a>的更新。</p>
</li>
</ul>
<ul>
<li><strong>MPS：金属2中的新功能 - 跨平台金属性能着色器支持。</strong><ul>
<li>所有Metal Performance Shaders功能在iOS 11.0，tvOS 11.0和macOS 10.13中均可用。</li>
</ul>
</li>
<li><strong>MPS：iOS 11.0新增功能 - 神经网络支持。</strong><ul>
<li>在金属性能着色器框架中增加了对神经网络的支持。</li>
<li>增加图形以提供更高级别的API，用于简化神经网络的创建，包括允许状态在神经网络中的节点之间传输的对象。</li>
<li>增加了卷积神经网络（CNN），以支持使用先前获得的训练数据实施和运行深度学习。</li>
<li>添加循环神经网络来实现对图像和矩阵的推断。</li>
</ul>
</li>
<li><strong>iOS 11.0新增功能 - 参数缓冲区。</strong>将您的资源分组到一个参数缓冲区（AB）以减少CPU开销。<ul>
<li>MSL：添加了<code>[[id(n)]]</code>属性限定符来标识AB结构中的资源。</li>
<li>MTL：增加了<code>MTLArgumentEncoder</code>将资源编码到AB 的协议。</li>
</ul>
</li>
<li><strong>MTL：iOS 11.0新增功能 - 可编程样本位置。</strong>配置渲染到多重采样渲染目标时的样本位置。<ul>
<li>更新了<code>MTLRenderPassDescriptor</code>要设置的类并获取渲染过程的样本位置。</li>
</ul>
</li>
<li><strong>MSL：iOS 11.0新增功能 - 统一类型。</strong><ul>
<li>添加<code>uniform</code>类型来声明执行draw或dispatch调用的图形或计算函数的所有线程的统一变量。</li>
</ul>
</li>
<li><strong>MSL：iOS 11.0中的新功能 - 采样器阵列。</strong><ul>
<li>添加了<code>array&lt;sampler, size_t N&gt;</code>用于存储采样器数组的类型。</li>
</ul>
</li>
<li><strong>MTL：iOS 11.0中的新功能 - BGR10A2像素格式。</strong><ul>
<li>添加了<code>bgr10A2Unorm</code>像素格式以在P3显示器上显示宽色彩内容。</li>
</ul>
</li>
<li>MPS：增加了新的过滤器。<ul>
<li>为图像统计添加了过滤器，例如计算图像区域的均值和方差。</li>
<li>增加了用于将两个图像组合在一起的过滤器，例如按元素求和。</li>
<li>为矩阵分解和求解增加了过滤器，例如使用Cholesky或LU（较低上层）分解的分解。</li>
</ul>
</li>
<li>MSL：扩展功能专业化。用于图形，计算或用户函数的结构成员可以与函数常量一起使用。<ul>
<li>扩展<code>[[color(n)]]</code>和<code>[[raster_order_group(index)]]</code>属性限定符与函数常量一起使用。</li>
</ul>
</li>
<li>MTL：扩展顶点格式。<ul>
<li>增加了新<code>MTLVertexFormat</code>的小格式，如价值观<code>char</code>，<code>short</code>和<code>half</code>。</li>
</ul>
</li>
<li>为iOS添加了双源混合支持。在固定功能混合操作中将两种源颜色输出到单个渲染目标。<ul>
<li>MSL：<code>[[index(i)]]</code>向<code>[[color(n)]]</code>属性限定符添加了新的属性限定符以输出第二个源颜色。</li>
<li>MTL：已更新<code>MTLBlendFactor</code>为以第二种来源颜色进行操作。</li>
</ul>
</li>
</ul>
<h2 id="应用服务"><a href="#应用服务" class="headerlink" title="应用服务"></a>应用服务</h2><ul>
<li><p><strong>iOS 11.0新增功能 - 支持机器学习模型。</strong></p>
<ul>
<li>增加了<a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="noopener">核心ML框架</a>，可轻松将机器学习模型集成到应用程序中。</li>
</ul>
</li>
<li><p><strong>iOS 11.0新增功能 - SiriKit支持可视代码。</strong></p>
<ul>
<li>向Sirkit 添加了<a href="https://developer.apple.com/documentation/sirikit/visual_codes" target="_blank" rel="noopener">可视代码域</a>，以支持显示交换付款和联系信息的可视代码。</li>
</ul>
</li>
<li><p><strong>iOS 11.0新增功能 - SiriKit支持笔记和待办事项列表。</strong></p>
<ul>
<li>为SiriKit 添加了<a href="https://developer.apple.com/documentation/sirikit/lists_and_notes" target="_blank" rel="noopener">列表和注释域</a>，以支持使用Siri添加注释，与待办事项列表进行交互以及与提醒进行交互。</li>
</ul>
</li>
<li><p>增加了SiriKit域的意图。</p>
<ul>
<li>在<a href="https://developer.apple.com/documentation/sirikit/ride_booking" target="_blank" rel="noopener">乘车预订域</a>添加了乘车取消和反馈。</li>
<li>增加了转账资金和搜索账户到<a href="https://developer.apple.com/documentation/sirikit/payments" target="_blank" rel="noopener">付款域</a>。</li>
</ul>
</li>
<li><p><strong>iOS 11.0中的新功能 - 查找设备的标题。</strong></p>
<ul>
<li>添加<code>heading</code>到<code>CMDeviceMotion</code>一个属性，该属性返回与该方向相关的标题角度<code>CMAttitudeReferenceFrame</code>。返回的值是以度为单位的标题<code>double</code>。参考帧为<code>xArbitraryZVertical</code>或时，返回负值<code>xArbitraryCorrectedZVertical</code>。</li>
</ul>
</li>
<li><p><strong>iOS 11.0中的新功能 - 多路径TCP。</strong></p>
<ul>
<li>通过扩展<code>URLSessionConfiguration</code>以支持<a href="https://tools.ietf.org/html/rfc6824" target="_blank" rel="noopener">IETF RFC 6824中</a>定义的多路径TCP，增加了对使用多个接口（如Wi-Fi和蜂窝）传输单个数据流的支持。看<code>URLSessionConfiguration.MultipathServiceType</code>。</li>
</ul>
</li>
<li><p><strong>iOS 11.0中的新功能 - DNS代理。</strong></p>
<ul>
<li>向网络扩展框架添加了新的DNS代理应用扩展类型。</li>
</ul>
</li>
<li><p>增强Apple Pay中的最终用户交易流程。</p>
<ul>
<li>添加<code>PKPaymentError</code>到PassKit中，用于详细报告用户运输和付款信息中的错误以及授权错误的结构。开发人员可以使用这些信息来提供自定义的错误字符串。</li>
<li>更新处理器方法<code>PKPaymentAuthorizationControllerDelegate</code>以接收一个<code>PKPaymentError</code>。</li>
<li>已更新<code>PKPaymentRequest</code>以<code>PKContactField</code>用于联系信息。</li>
<li>添加<code>supportedCountries</code>到<code>PKPaymentRequest</code>指定支持的国家的交易。</li>
<li>即使在电子钱包中没有支持的付款方式，也添加了对付款按钮的支持。Apple Pay现在可以在不离开您的应用程序的情况下处理付款，然后返回结帐。</li>
</ul>
</li>
<li><p><strong>iOS 11.0新增功能 - 在App Store中推广应用程序内购买。</strong></p>
<ul>
<li>开发人员可以在其App Store产品页面上推广最多20个应用内购买。客户可以在App Store上开始购买，然后转到应用程序完成交易。</li>
<li>新增<code>paymentQueue(_:shouldAddStore:for:)</code>了一种<code>SKPaymentTransactionObserver</code>促销应用内购买的新方法。应用程序需要支持此代理才能在应用商店中显示促销的应用内购买内容。</li>
</ul>
</li>
<li><p><strong>iOS 11.0中的新功能 - 实时消息。</strong></p>
<ul>
<li><p>新增<code>MSMessageLiveLayout</code>了一个新的消息布局，用于显示可显示动态内容的实时消息，如游戏。每条实时消息都有自己的消息<code>MSMessagesAppViewController</code>，并且一次可以在屏幕上显示多个活动的实时消息。</p>
<p>以下代码显示向消息流添加实时消息，包括不支持实时消息的设备的备用布局。</p>
<p>| <code>**警卫** **让**对话= activeConversation **其他** {</code> |<br>| —————————————- |<br>| <code>fatalError（“没有活跃的对话”）</code>           |<br>| <code>}</code>                                      |<br>| <code></code>                                      |<br>| <code>**让** alternateLayout = MSMessageTemplateLayout（）</code> |<br>| <code>alternateLayout.image = UIImage（名为：“SuperSweetGameImage”）</code> |<br>| <code>alternateLayout.caption =“$（\（conversation.localParticipantIdentifier））想玩游戏！”</code> |<br>| <code>**让** layout = MSMessageLiveLayout（alternateLayout：alternateLayout）</code> |<br>| <code></code>                                      |<br>| <code>**让** message = MSMessage（）</code>            |<br>| <code>message.layout =布局</code>                     |<br>| <code></code>                                      |<br>| <code>conversation.insert（message，completionHandler：**nil**）</code> |</p>
</li>
</ul>
</li>
<li><p>增强了HomeKit的触发器。</p>
<ul>
<li>增强触发器的基于时间的条件。<code>HMSignificantTimeEvent</code>指定日出和日落的偏移量。<code>HMCalendarEvent</code>指定日期和时间。<code>HMDurationEvent</code>指定一个时间间隔。</li>
<li>新增<code>HMCharacteristicThresholdRangeEvent</code> 支持跟踪某个范围内的附件状态，例如温度在68到72度之间时执行操作。</li>
<li>添加<code>HMPresenceEvent</code>用于根据用户的存在或不存在添加条件。</li>
<li>已更新<code>HMEventTrigger</code>以启用事件的多次重复。</li>
</ul>
</li>
<li><p>添加<code>home:didUpdateHomeHubState:</code>为支持接收家庭集线器状态的更新。</p>
</li>
<li><p>更新MapKit以更清晰地显示开发人员数据。</p>
<ul>
<li>新增<code>mutedStandard</code>了一种强调开发者数据的新地图显示模式。</li>
<li>添加属性以自定义冲突发生时注释行为的方式。开发人员使用的组合<code>displayPriority</code>，<code>collisionMode</code>以及<code>clusteringIdentifier</code>对影响哪个注解持续显示在地图上。</li>
</ul>
</li>
<li><p>添加<code>authorizationStatus</code>方法的<code>CMAltimiter</code>，<code>CMPedometer</code>，<code>CMMotionActivityManager</code>，和<code>CMSensorRecorder</code>类核心运动框架。该方法用于确定应用程序是否有权从源接收数据。</p>
</li>
</ul>
<h2 id="媒体和网络"><a href="#媒体和网络" class="headerlink" title="媒体和网络"></a>媒体和网络</h2><ul>
<li><strong>iOS 11.0新增功能 - 支持高效视频编码（HEVC）。</strong>高效视频编码（HEVC）是视频编码的新标准，在视觉质量相同的情况下，其压缩比H.264要好得多。<ul>
<li>增加了对使用AV Foundation播放包含HEVC编码音轨的电影以及捕获和导出视频的支持。</li>
<li>增加了对使用<code>VideoToolbox</code>客户端编码和解码HEVC视频比特流的支持。</li>
</ul>
</li>
<li><strong>iOS 11.0新增功能 - 支持高效图像格式（HEIF）。</strong>高效率图像格式（HEIF）是图像压缩的新标准，几乎使当前数据压缩率翻倍达到相同的图像质量水平。<ul>
<li>为Photos和Core Image框架添加了显示，编码和导出HEIF图像的功能。</li>
</ul>
</li>
<li><strong>iOS 11.0新增功能 - 支持捕获和处理深度数据以及增强图片捕获。</strong><ul>
<li>向AV Foundation添加对象以捕获和表示深度数据。请参阅<code>AVCaptureDepthDataOutput</code>，<code>AVDepthData</code>和相关的API。</li>
<li>添加<code>AVCapturePhoto</code>了一个对象，该对象封装了拍摄照片的信息并支持HEVC和HEIC编码图像。</li>
<li>已更新<code>AVCapturePhotoOutput</code>，提供有关相机功能和支持的输出格式的更多信息。</li>
</ul>
</li>
<li><strong>iOS 11.0新增功能 - 自动存储管理。</strong><ul>
<li>增加了HTTP实时流媒体资产的自动存储管理<code>AVAssetDownloadTask</code>。当需要空间时，系统可以自动清除过期或不需要的下载。使用优先级来影响清除策略。</li>
</ul>
</li>
<li><strong>iOS 11.0新增功能 - AirPlay 2。</strong><ul>
<li>AV Foundation中某些音频播放界面的AirPlay可靠性得到改善。要利用增强的可靠性，请使用<code>AVPlayer</code>或使用新<code>AVSampleBufferAudioRenderer</code>对象播放音频。</li>
<li>为AirPlay增加了多种扬声器支持，用于音乐和播客等长形式音频。要将您的应用程序标记为呈现长形式音频，请调用该<code>AVAudioSession</code>方法<code>setCategory(_:mode:routeSharingPolicy:options:)</code>并将其<code>AVAudioSessionRouteSharingPolicyLongForm</code>用作参数值。</li>
<li>添加<code>AVRoutePickerView</code>到AVKit框架和<code>AVRouteDetector</code>AVFoundation框架中，使用户能够在多条路线可用时选择播放内容的路线。使用<code>AVRouteDetector</code>以确定是否启用路由检测时，多条路线可供选择。如果有多条路由可用，请使用<code>AVRoutePickerView</code>为用户提供一个接口来选择路由。</li>
</ul>
</li>
<li>增加了FairPlay流媒体密钥管理。<ul>
<li>改进的功能<code>AVContentKeySession</code>。使用<code>AVContentKeySession</code>启动独立播放或媒体资产的下载的内容密钥请求。符合<code>AVContentKeyRecipient</code>协议的对象（例如<code>AVURLAsset</code>）可以作为接收者添加<code>AVContentKeySession</code>以获得对现有内容密钥的访问并发起新的内容密钥请求</li>
</ul>
</li>
<li>增加了更多实时图片调整。<ul>
<li>添加了一组实时照片调整，称为<em>效果</em>，可将现场照片渲染为循环，反弹或长时间曝光。与普通的实时照片不同，循环和跳动视频将连续循环播放。</li>
<li>添加了<code>playbackStyle</code>一个新属性，用于标识如何向<code>PHAsset</code>用户展示。</li>
</ul>
</li>
</ul>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><ul>
<li><strong>iOS 11.0中的新增功能 - 热点配置。</strong><ul>
<li>为热点配置添加了网络扩展。看<code>NEHotspotConfiguration</code>。</li>
</ul>
</li>
<li><strong>iOS 11.0新增功能 - 检测NFC标签并读取包含NDEF数据的消息。</strong><ul>
<li>新增<a href="https://developer.apple.com/documentation/corenfc" target="_blank" rel="noopener">核心NFC</a>，阅读近场通信（NFC）标签和数据在NFC数据交换格式的新框架（NDEF）。</li>
</ul>
</li>
<li>更新了核心蓝牙框架。<ul>
<li>增加了对L2CAP频道的支持。</li>
<li>扩展的会话恢复工作可通过蓝牙重置和设备重启进行。</li>
<li>更新<a href="https://developer.apple.com/documentation/corebluetooth" target="_blank" rel="noopener">Core蓝牙框架中</a>的API 以跨越iOS，tvOS，watchOS和macOS进行匹配，并标记每个API的平台可用性。</li>
</ul>
</li>
<li>APFS现在是默认的文件系统。<ul>
<li>为区分大小写的文件系统增加了对规范化不敏感的支持。</li>
</ul>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> apple </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IOS中设置中找不到开发者选项的解决办法]]></title>
      <url>/2018/04/28/%E5%85%B3%E4%BA%8EIOS%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%89%BE%E4%B8%8D%E5%88%B0%E5%BC%80%E5%8F%91%E8%80%85%E9%80%89%E9%A1%B9%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>关于IOS中设置中找不到开发者选项的解决办法</p>
<p>今天做开发的时候突然要用到限速测试，</p>
<p>记得以前都是在开发者选项里去打开network link conditioner开关，然后选择一个profile ,</p>
<p>今天去设置里从头到尾仔细找了遍，没发现有开发者选项，后来终于在网上找到答案了，</p>
<p>觉得很受用，这里为了方便广大iOS童鞋，记录如下：</p>
<p>1、XCode 6 , 数据线连接手机到Mac上，Xcode -》 Windows-》Organizer -》选中当前手机设备 ，选中Use for Development.</p>
<p>2、XCode 7,  数据线连接手机到Mac上，Xcode -》 Windows-》Devices -》选中当前手机设备，右键弹出菜单-》选择Show Provisioning Profiles…-》</p>
<p>会弹出一个证书列表窗口，如果手机已经安装了必要的开发者证书，直接点击done按钮即可，否则需要点击左下角的+号，把从网上下载下来的证书导入进去，</p>
<p>点击done按钮关闭窗口，此时再看手机设置里是不是多了一个开发者选项。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> other </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS判断当前网络状态的三种方法]]></title>
      <url>/2018/04/28/iOS%20%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><p>转：<a href="http://www.cocoachina.com/cms/tags.php?/iOS/" target="_blank" rel="noopener"> iOS</a><a href="http://www.cocoachina.com/cms/tags.php?/%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81/" target="_blank" rel="noopener">网络状态</a> </p>
<p>在项目中，为了好的用户体验，有些场景必须线判断网络状态，然后才能决定改干嘛。比如视频播放，需要线判断是Wifi还是4G，Wifi直接播放，4G先提示用户。获取网络状态的方法大概有三种：</p>
<p><strong>1. Reachability</strong></p>
<p>这是苹果的官方演示demo中使用到的方法，我们可以到苹果官方文档里<a href="https://developer.apple.com/library/content/samplecode/Reachability/Listings/Reachability_Reachability_h.html#//apple_ref/doc/uid/DTS40007324-Reachability_Reachability_h-DontLinkElementID_8" target="_blank" rel="noopener">下载Demo</a>(点击左上角Download Sample Code 即可下载)，然后把Demo里的Reachability.h和.m考到自己项目中，并在Build Phases 的 Link Binary 添加SystemConfiguration.framework框架，然后在需要使用的地方导入Reachability头文件<br><a id="more"></a><br>在 Reachability头文件中我们可以看到无网络，wifi和蜂窝网三个网络状态的枚举值，如下：</p>
<p>typedef enum : NSInteger {</p>
<pre><code>NotReachable = 0,
ReachableViaWiFi,
ReachableViaWWAN
</code></pre><p>} NetworkStatus;</p>
<p>（1）获取网络状态：</p>
<p>在iOS 7之前，当用户网络为蜂窝网络时，是没法判断3G、4G等网络类型的，iOS 7 后是可以判断的</p>
<p>-(NSString *)internetStatus {<br>​     </p>
<pre><code>Reachability *reachability   = [Reachability reachabilityWithHostName:@&quot;www.apple.com&quot;];
NetworkStatus internetStatus = [reachability currentReachabilityStatus];
NSString *net = @&quot;WIFI&quot;;
switch (internetStatus) {
    case ReachableViaWiFi:
        net = @&quot;WIFI&quot;;
        break;

    case ReachableViaWWAN:
        net = @&quot;蜂窝数据&quot;;
        //net = [self getNetType ];   //判断具体类型
        break;

    case NotReachable:
        net = @&quot;当前无网路连接&quot;;

    default:
        break;
}

return net;
</code></pre><p>（2）当用户为手机自带网络时，判断具体网络类型</p>
<p>这时可以使用系统自带的API来判断是2G、3G还是4G，这就要使用到CTTelephonyNetworkInfo这类，记得在工程添加CoreTelephony.framework，并导入头文件、</p>
<ul>
<li>(NSString *)getNetType<br>{<pre><code>CTTelephonyNetworkInfo *info = [[CTTelephonyNetworkInfo alloc] init];
     NSString *currentStatus = info.currentRadioAccessTechnology;
     if ([currentStatus isEqualToString:@&quot;CTRadioAccessTechnologyGPRS&quot;]) {
         netconnType = @&quot;GPRS&quot;;
     }else if ([currentStatus isEqualToString:@&quot;CTRadioAccessTechnologyEdge&quot;]) {
         netconnType = @&quot;2.75G EDGE&quot;;
     }else if ([currentStatus isEqualToString:@&quot;CTRadioAccessTechnologyWCDMA&quot;]){
         netconnType = @&quot;3G&quot;;
     }else if ([currentStatus isEqualToString:@&quot;CTRadioAccessTechnologyHSDPA&quot;]){
         netconnType = @&quot;3.5G HSDPA&quot;;
     }else if ([currentStatus isEqualToString:@&quot;CTRadioAccessTechnologyHSUPA&quot;]){
         netconnType = @&quot;3.5G HSUPA&quot;;
     }else if ([currentStatus isEqualToString:@&quot;CTRadioAccessTechnologyCDMA1x&quot;]){
         netconnType = @&quot;2G&quot;;
     }else if ([currentStatus isEqualToString:@&quot;CTRadioAccessTechnologyCDMAEVDORev0&quot;]){
         netconnType = @&quot;3G&quot;;
     }else if ([currentStatus isEqualToString:@&quot;CTRadioAccessTechnologyCDMAEVDORevA&quot;]){
         netconnType = @&quot;3G&quot;;
     }else if ([currentStatus isEqualToString:@&quot;CTRadioAccessTechnologyCDMAEVDORevB&quot;]){
         netconnType = @&quot;3G&quot;;
     }else if ([currentStatus isEqualToString:@&quot;CTRadioAccessTechnologyeHRPD&quot;]){
         netconnType = @&quot;HRPD&quot;;
     }else if ([currentStatus isEqualToString:@&quot;CTRadioAccessTechnologyLTE&quot;]){
         netconnType = @&quot;4G&quot;;
     }
</code></pre>}</li>
</ul>
<p>用此方法判断的蜂窝网络类型有如下类型:</p>
<p>CTRadioAccessTechnologyGPRS         //介于2G和3G之间，也叫2.5G ,过度技术<br>CTRadioAccessTechnologyEdge         //EDGE为GPRS到第三代移动通信的过渡，EDGE俗称2.75G<br>CTRadioAccessTechnologyWCDMA<br>CTRadioAccessTechnologyHSDPA            //亦称为3.5G(3?G)<br>CTRadioAccessTechnologyHSUPA            //3G到4G的过度技术<br>CTRadioAccessTechnologyCDMA1x       //3G<br>CTRadioAccessTechnologyCDMAEVDORev0    //3G标准<br>CTRadioAccessTechnologyCDMAEVDORevA<br>CTRadioAccessTechnologyCDMAEVDORevB<br>CTRadioAccessTechnologyeHRPD        //电信使用的一种3G到4G的演进技术， 3.75G<br>CTRadioAccessTechnologyLTE          //接近4G</p>
<p><strong>2. 通过系统statusBar判断</strong></p>
<p>这种方法在iPhone X 上可能引起奔溃，可能是苹果修改了statusBar的keyPath，所以拿到的东西为nil，导致崩溃</p>
<p>//获取当前网络状态  （iPhone X 上可能引发崩溃）</p>
<ul>
<li><p>(NSString <em>)networkingStatesFromStatebar {<br>  // 状态栏是由当前app控制的，首先获取当前app<br>  UIApplication </em>app = [UIApplication sharedApplication];<br>  //iphone X 会在这里崩溃<br>  NSArray *children = [[[app valueForKeyPath:@”statusBar”] valueForKeyPath:@”foregroundView”] subviews];    </p>
<p>  int type = 0;<br>  for (id child in children) {  </p>
<pre><code>if ([child isKindOfClass:[NSClassFromString(@&quot;UIStatusBarDataNetworkItemView&quot;) class]]) {  
    type = [[child valueForKeyPath:@&quot;dataNetworkType&quot;] intValue];  
}  
</code></pre><p>  }  </p>
<p>  NSString *stateString = @”wifi”;  </p>
<p>  switch (type) {  </p>
<pre><code>case 0:  
    stateString = @&quot;notReachable&quot;;  
    break;  

case 1:  
    stateString = @&quot;2G&quot;;  
    break;  

case 2:  
    stateString = @&quot;3G&quot;;  
    break;  

case 3:  
    stateString = @&quot;4G&quot;;  
    break;  

case 4:  
    stateString = @&quot;LTE&quot;;  
    break;  

case 5:  
    stateString = @&quot;wifi&quot;;  
    break;  

default:  
    break;  
</code></pre><p>  }  </p>
<p>  return stateString;<br>  }</p>
</li>
</ul>
<p><strong>3. 通过AFNetworking</strong></p>
<p>此方法可以写在AppDelegate中，每当网络状态发生变化时，就可以发通知，实时监测网络变化，然后做相应的处理</p>
<p>#pragma mark - ————- 监测网络状态 ————-</p>
<ul>
<li>(void)monitorNetworking<br>{<br>  [[AFNetworkReachabilityManager sharedManager] startMonitoring];<br>  [[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {<pre><code>switch (status) {
    case -1:
        NSLog(@&quot;未知网络&quot;);
        break;
    case 0:
        NSLog(@&quot;网络不可达&quot;);
        break;
    case 1:
    {
        NSLog(@&quot;GPRS网络&quot;);
        //发通知，带头搞事
        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;monitorNetworking&quot; object:@&quot;1&quot; userInfo:nil];
    }
        break;
    case 2:
    {
        NSLog(@&quot;wifi网络&quot;);
        //发通知，搞事情
        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;monitorNetworking&quot; object:@&quot;2&quot; userInfo:nil];
    }
        break;
    default:
        break;
}
if (status == AFNetworkReachabilityStatusReachableViaWWAN || status == AFNetworkReachabilityStatusReachableViaWiFi) {
    NSLog(@&quot;有网&quot;);
}else{
    NSLog(@&quot;没网&quot;);
}
</code></pre>  }];<br>}</li>
</ul>
<h2 id="swift："><a href="#swift：" class="headerlink" title="swift："></a>swift：</h2><p>import Alamofire</p>
<p>let reachabilitymanager = NetworkReachabilityManager(host: “<a href="https://github.com/Alamofire/Alamofire.git" target="_blank" rel="noopener">https://github.com/Alamofire/Alamofire.git</a>“)</p>
<p>func netWorklisten()  {</p>
<p>​        </p>
<p>​        reachabilitymanager?.listener = { status in</p>
<p>​            </p>
<p>​            switch status {</p>
<p>​            case .notReachable:</p>
<p>​                print(“notReachable”)</p>
<p>​                DispatchQueue.main.async {</p>
<p>​                    self.alert_noNetwrok()</p>
<p>​                }</p>
<p>​            case .unknown:</p>
<p>​                LTLog(“连接类型：未知”)</p>
<p>​            case .reachable(.ethernetOrWiFi):</p>
<p>​                LTLog(“连接类型：移动网络”)</p>
<p>​            case .reachable(.wwan):</p>
<p>​                LTLog(“连接类型：WiFi”)</p>
<p>​                </p>
<p>​            }</p>
<p>​        }</p>
<p>​        reachabilitymanager?.startListening()</p>
<p>​    }</p>
<p>### </p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Subclassing Provider and refreshing session automatically（子类化Provider，session的自动刷新）--Moya文档]]></title>
      <url>/2018/04/28/%E5%AD%90%E7%B1%BB%E5%8C%96Provider%EF%BC%8Csession%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%EF%BC%89--Moya%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<p>#</p>
<p>参考简书文集：<a href="https://www.jianshu.com/nb/13910345" target="_blank" rel="noopener">https://www.jianshu.com/nb/13910345</a></p>
<p>基于<a href="https://www.jianshu.com/p/a82fd2768c27" target="_blank" rel="noopener"> Artsy’s implementation.</a> 使用RxSwift</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">class OnlineProvider: RxMoyaProvider&lt;MyService&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // First of all, we need to override designated initializer</span><br><span class="line">  override init(endpointClosure: MoyaProvider&lt;MyService&gt;.EndpointClosure = MoyaProvider.defaultEndpointMapping,</span><br><span class="line">      requestClosure: MoyaProvider&lt;MyService&gt;.RequestClosure = MoyaProvider.defaultRequestMapping,</span><br><span class="line">      stubClosure: MoyaProvider&lt;MyService&gt;.StubClosure = MoyaProvider.neverStub,</span><br><span class="line">      manager: Manager = Alamofire.SessionManager.default,</span><br><span class="line">      plugins: [PluginType] = []) &#123;</span><br><span class="line"></span><br><span class="line">      super.init(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure: stubClosure, manager: manager, plugins: plugins)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Request to fetch and store new XApp token if the current token is missing or expired.</span><br><span class="line">  func XAppTokenRequest() -&gt; Observable&lt;String?&gt; &#123;</span><br><span class="line"></span><br><span class="line">      var appToken = UserInfo.shared.accessToken</span><br><span class="line"></span><br><span class="line">      // If we have a valid token, just return it</span><br><span class="line">      if appToken.isValidAndNotExpired &#123;</span><br><span class="line">          return Observable.just(appToken.token)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Do not attempt to refresh a session if we don&apos;t have valid credentials</span><br><span class="line">      guard let userId = UserInfo.shared.userId, refreshToken = UserInfo.shared.accessToken.refreshToken else &#123;</span><br><span class="line">          return Observable.just(nil)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Create actual refresh request</span><br><span class="line">      let newTokenRequest = super.request(MyService.refreshSession(userId: userId, refreshToken: refreshToken))</span><br><span class="line">          .filterSuccessfulStatusCodes()</span><br><span class="line">          .mapJSON()</span><br><span class="line">          .map &#123; element -&gt; (token: String?, refreshToken: String?, expiryTime: Double?) in</span><br><span class="line">              guard let dictionary = element as? NSDictionary else &#123; return (token: nil, refreshToken: nil, expiryTime: nil) &#125;</span><br><span class="line"></span><br><span class="line">              return (token: dictionary[&quot;auth_token&quot;] as? String, refreshToken: dictionary[&quot;refresh_token&quot;] as? String, expiryTime: dictionary[&quot;session_time_valid&quot;] as? Double)</span><br><span class="line">          &#125;</span><br><span class="line">          .doOn &#123; event in</span><br><span class="line">              guard case .next(let element) = event else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">              UserInfo.shared.accessToken.token = element.0</span><br><span class="line">              UserInfo.shared.accessToken.refreshToken = element.1</span><br><span class="line">              UserInfo.shared.accessToken.setExpirySecondsLeft(element.2)</span><br><span class="line">          &#125;</span><br><span class="line">          .map &#123; (token, refreshToken, expiry) -&gt; String? in</span><br><span class="line">              return token</span><br><span class="line">          &#125;</span><br><span class="line">          .catchError &#123; e -&gt; Observable&lt;String?&gt; in</span><br><span class="line">              guard let error = e as? MoyaError else &#123; throw e &#125;</span><br><span class="line">              guard case .statusCode(let response) = error else &#123; throw e &#125;</span><br><span class="line"></span><br><span class="line">              // If we have 401 error - delete all credentials and handle logout</span><br><span class="line">              if response.statusCode == 401 &#123;</span><br><span class="line">                  UserInfo.shared.invalidate()</span><br><span class="line">                  Router.shared.popToLoginScreen()</span><br><span class="line">              &#125;</span><br><span class="line">              throw error</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      return newTokenRequest</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Override request to inject XAppTokenRequest if needed</span><br><span class="line">  override func request(token: MyService) -&gt; Observable&lt;Moya.Response&gt; &#123;</span><br><span class="line">      let actualRequest = super.request(token)</span><br><span class="line"></span><br><span class="line">      return self.XAppTokenRequest().flatMap &#123; _ in</span><br><span class="line">          actualRequest</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建自定义provider像往常一样以同样的方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let MyServiceProvider = OnlineProvider()</span><br></pre></td></tr></table></figure>
<p>同样 你也可以传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let MyServiceProvider = OnlineProvider(endpointClosure: endpointClosure, plugins: [NetworkLogger()])</span><br></pre></td></tr></table></figure>
<h3 id="总结-这小节的核心"><a href="#总结-这小节的核心" class="headerlink" title="总结 这小节的核心:"></a>总结 这小节的核心:</h3><ol>
<li>自定义Provider</li>
<li>实现一个具体的session自动刷新的案例</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Network </tag>
            
            <tag> Moya </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[苹果企业账号发布APP详解——通过自己网站分发应用]]></title>
      <url>/2018/04/27/%E8%8B%B9%E6%9E%9C%E4%BC%81%E4%B8%9A%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83APP%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E8%87%AA%E5%B7%B1%E7%BD%91%E7%AB%99%E5%88%86%E5%8F%91%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>转：<a href="https://www.jianshu.com/p/0418f5051185" target="_blank" rel="noopener">https://www.jianshu.com/p/0418f5051185</a></p>
<h2 id="一、通过企业账号申请证书"><a href="#一、通过企业账号申请证书" class="headerlink" title="一、通过企业账号申请证书"></a>一、通过企业账号申请证书</h2><ul>
<li><strong>1 Certificate Signing Request (CSR)文件</strong></li>
</ul>
<p>在Mac系统中进入“钥匙串访问”，选择“钥匙串访问”-“证书助理”-“从证书颁发机构请求证书…”，如图1所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-4f833ce5acd0cd16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>钥匙串请求证书</p>
<p>—&gt;填写前两项，并选择“存储到磁盘”，如图2所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-bda6eb8ba786059a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<ul>
<li><strong>2 请求Certificate证书</strong><br>登录<a href="https://link.jianshu.com/?t=https://developer.apple.com" target="_blank" rel="noopener">https://developer.apple.com</a> —&gt;<code>MemberCenter</code>—&gt;<code>Certificates, Indentifiers &amp; Profiles</code>—&gt;<code>Certificates</code>，如图3所示：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-5f6b1a8cbf07b321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>—&gt;在图4页面，点击右上角加号，添加一个证书：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-d7ec28b1103666d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>—&gt;选择In-House and Ad Hoc，点继续，如图5所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-72096ca91b9726e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>—&gt;如图6：Choose File选择第1步的CSR文件上传，点击generate生成cer证书，下载后双击安转（需要输入Mac的密码）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-8ad19b13232f4db7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<ul>
<li><strong>3 App ID</strong></li>
</ul>
<p>点击右上角的加号按钮，如图7所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-1747ad7a163a4436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>—&gt;有两项需要填（如图8所示），name为描述可以随便填写.bundleID必须与APP的bundleID完全一致（如图9所示）。至于App Services根据自己需要选择。最后点击继续-&gt;submit-&gt;done</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-4b59673c3f3b862e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-c3d17ea45cda0caa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<ul>
<li><strong>4 生成最终的Provisioning Profile(企业版不需要device即iPhone的UDID，因此跳过)</strong></li>
</ul>
<p>选择Provisioning Profile-&gt;ALL，点击右上角加号：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-9803422f46a87fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-80e187cc47f376f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>—&gt;选择刚创建的AppID，点击继续，如图12所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-2764f943ee12bf1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>—&gt;选择cer证书点击继续.图13 给最终生成的Profile文件命名方便自己识别。然后点击生成，并下载双击打开。至此证书环节完毕</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-b1ec7bd0f4486268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<h2 id="二、打包ipa，手动生成plist"><a href="#二、打包ipa，手动生成plist" class="headerlink" title="二、打包ipa，手动生成plist"></a>二、打包ipa，手动生成plist</h2><p>这一步开始前，需要将手机插入电脑，并调试选项选择真机。（防止无法Archive），如果没有真机，可以选择iOS Device（这个没有测试）。</p>
<h4 id="1-打包ipa"><a href="#1-打包ipa" class="headerlink" title="1 打包ipa"></a>1 打包ipa</h4><ul>
<li>1.1 Edit scheme</li>
</ul>
<p>用Xcode打开对应APP。Product-&gt;Scheme-&gt;Edit scheme，填写Archive name，即为打包后的ipa名字,如图14所示</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-b9a2a5b0c95d6704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<ul>
<li>1.2 选择对应证书，即刚才生成的证书，如图15所示：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-d4d0596dbc143cea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<ul>
<li>1.3 归档，Product-&gt;Archive，并按图16，图17操作(选择Save for Enterprise Deployment)：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-2e5b7a7a10095dae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-ea0f98a4a2fd02a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>完成之后会生成一个ipa包。</p>
<h2 id="三、发布APP"><a href="#三、发布APP" class="headerlink" title="三、发布APP"></a>三、发布APP</h2><p>要发布还必须有一个plist文件，在Xcode6之前会自动生成一个plist文件，但是Xcode6之后需要我们自己创建plist，文章最后提供一个plist模板，复制并重命名为plist后打开根据提示操作即可.图18为plist的截图，可以看到有三个URL，分别存放ipa，大小图标。下图的1(ipa)、2(大图)、3(小图)填写我们自己生成的URL，即将ipa和大小图标放在我们自己的服务器，当用Safari打开plist时会根据填的plist里面的1、2、3对应的URL来下载安装ipa、大小图标。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1785352-a0a126bb6bd89416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>那么plist放在哪里呢（即Safari打开plist的URL是多少呢）？苹果对plist存放地址有要求，必须是https的，如果没有https网站，我们可以把plist放在<a href="https://link.jianshu.com/?t=https://git.oschina.net" target="_blank" rel="noopener">https://git.oschina.net</a>。</p>
<p>具体做法就是在上面创建一个项目（不能是私人的），然后将编辑好的plist传到项目，最后将plist的URL赋值下来，比如<a href="https://link.jianshu.com/?t=https://git.oschina.net/waitwait/companytest/blob/master/MDDTest.plist" target="_blank" rel="noopener">https://git.oschina.net/waitwait/companytest/blob/master/MDDTest.plist</a>。然后我们在Safari中输入：<code>itms-services:///?action=download-manifest&amp;url=https://git.oschina.net/waitwait/companytest/blob/master/MDDTest.plist</code>就可以安装了(Safari会解析<code>itms-services:///?action=download-manifest&amp;url=</code>)。</p>
<blockquote>
<p>注意，有简友反应oschina的https不能使用，其实公用的https链接经常会被封掉，可以试试github，百度云，七牛云存储等等。另外，最好还是用自己的</p>
</blockquote>
<p>Safari操作的具体流程是：</p>
<ul>
<li>1 Safari解析我们输入的那一串字符串，找到plist文件</li>
<li>2 根据plist文件里面提供的信息下载并安装ipa包，还会访问大小图标，大小图标在ipa包正在下载时显示，当下载完毕后显示程序自带的图标</li>
<li>下载安装后，如果想打开程序还需要在手机 设置-&gt;通用-&gt;描述文件与设备管理(不同系统可能名字不一样) 里面选择相应的证书信任后，方可打开程序</li>
</ul>
<p>下面是plist模板的文本形式，将其复制到文本然后重命名.plist，用Xcode打开按照提示编辑即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;items&lt;/key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">        &lt;dict&gt;</span><br><span class="line">            &lt;key&gt;assets&lt;/key&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;dict&gt;</span><br><span class="line">                    &lt;key&gt;kind&lt;/key&gt;</span><br><span class="line">                    &lt;string&gt;software-package&lt;/string&gt;</span><br><span class="line">                    &lt;key&gt;url&lt;/key&gt;</span><br><span class="line">                    &lt;string&gt;ipa包URL（必填）&lt;/string&gt;</span><br><span class="line">                &lt;/dict&gt;</span><br><span class="line">                &lt;dict&gt;</span><br><span class="line">                    &lt;key&gt;kind&lt;/key&gt;</span><br><span class="line">                    &lt;string&gt;full-size-image&lt;/string&gt;</span><br><span class="line">                    &lt;key&gt;needs-shine&lt;/key&gt;</span><br><span class="line">                    &lt;false/&gt;</span><br><span class="line">                    &lt;key&gt;url&lt;/key&gt;</span><br><span class="line">                    &lt;string&gt;下载时大图（非必填）&lt;/string&gt;</span><br><span class="line">                &lt;/dict&gt;</span><br><span class="line">                &lt;dict&gt;</span><br><span class="line">                    &lt;key&gt;kind&lt;/key&gt;</span><br><span class="line">                    &lt;string&gt;display-image&lt;/string&gt;</span><br><span class="line">                    &lt;key&gt;needs-shine&lt;/key&gt;</span><br><span class="line">                    &lt;false/&gt;</span><br><span class="line">                    &lt;key&gt;url&lt;/key&gt;</span><br><span class="line">                    &lt;string&gt;下载时小图（非必填）&lt;/string&gt;</span><br><span class="line">                &lt;/dict&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">            &lt;key&gt;metadata&lt;/key&gt;</span><br><span class="line">            &lt;dict&gt;</span><br><span class="line">                &lt;key&gt;bundle-identifier&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;BundleID（必填）&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;bundle-version&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;1.0&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;kind&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;software&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;subtitle&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;副标题（非必填）&lt;/string&gt;</span><br><span class="line">                &lt;key&gt;title&lt;/key&gt;</span><br><span class="line">                &lt;string&gt;应用名（必填）&lt;/string&gt;</span><br><span class="line">            &lt;/dict&gt;</span><br><span class="line">        &lt;/dict&gt;</span><br><span class="line">    &lt;/array&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[URLSessionConfiguration]]></title>
      <url>/2018/04/27/URLSessionConfiguration/</url>
      <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration#2888288" target="_blank" rel="noopener">https://developer.apple.com/documentation/foundation/urlsessionconfiguration#2888288</a></p>
<p>配置对象，用于定义URL会话的行为和策略。</p>
<p>软件开发工具包</p>
<ul>
<li>iOS 7.0+</li>
<li>macOS 10.9+</li>
<li>tvOS 9.0+</li>
<li>watchOS 2.0+</li>
</ul>
<p>骨架</p>
<ul>
<li>基础</li>
</ul>
<p>在本页<a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration#overview" target="_blank" rel="noopener">概观</a><a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration#topics" target="_blank" rel="noopener">主题</a><a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration#relationships" target="_blank" rel="noopener">关系</a><a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration#see-also" target="_blank" rel="noopener">也可以看看</a></p>
<h2 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h2><p>一个对象定义了使用对象上传和下载数据时要使用的行为和策略。上传或下载数据时，创建配置对象始终是您必须采取的第一步。您可以使用此对象来配置打算用于对象的超时值，缓存策略，连接要求和其他类型的信息。<code>URLSessionConfiguration</code><a href="https://developer.apple.com/documentation/foundation/urlsession" target="_blank" rel="noopener"><code>URLSession</code></a><code>URLSession</code></p>
<p>在使用它来初始化会话对象之前，正确配置对象非常重要。会话对象会复制您提供的配置设置，并使用这些设置来配置会话。配置完成后，会话对象将忽略您对该对象所做的任何更改。如果您需要修改传输策略，则必须更新会话配置对象并使用它创建新对象。<code>URLSessionConfiguration``URLSessionConfiguration``URLSession</code></p>
<p>注意在某些情况下，此配置中定义的策略可能会被<a href="https://developer.apple.com/documentation/foundation/nsurlrequest" target="_blank" rel="noopener"><code>NSURLRequest</code></a>为任务提供的对象指定的策略覆盖。在请求对象上指定的任何策略都会受到尊重，除非会话的策略更具限制性。例如，如果会话配置指定不应允许蜂窝网络，则该<a href="https://developer.apple.com/documentation/foundation/nsurlrequest" target="_blank" rel="noopener"><code>NSURLRequest</code></a>对象不能请求蜂窝网络。</p>
<p>有关使用配置对象创建会话的更多信息，请参阅<a href="https://developer.apple.com/documentation/foundation/urlsession" target="_blank" rel="noopener"><code>URLSession</code></a>。</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><h3 id="创建会话配置对象"><a href="#创建会话配置对象" class="headerlink" title="创建会话配置对象"></a>创建会话配置对象</h3><p><code>class var</code>default<code>: URLSessionConfiguration</code></p>
<p>返回新创建的默认会话配置对象。</p>
<p><code>class var ephemeral: URLSessionConfiguration</code></p>
<p>返回不使用缓存，Cookie或凭证的持久性存储的会话配置。</p>
<p><code>class func background(withIdentifier: String)</code></p>
<p>返回一个会话配置对象，允许在后台执行HTTP和HTTPS上传或下载。</p>
<h3 id="设置常规属性"><a href="#设置常规属性" class="headerlink" title="设置常规属性"></a>设置常规属性</h3><p><code>var identifier: String?</code></p>
<p>配置对象的后台会话标识符。</p>
<p><code>var httpAdditionalHeaders: [AnyHashable : Any]?</code></p>
<p>与请求一起发送的附加头文件的字典。</p>
<p><code>var networkServiceType: NSURLRequest.NetworkServiceType</code></p>
<p>网络服务的类型。</p>
<p><code>var allowsCellularAccess: Bool</code></p>
<p>一个布尔值，用于确定是否应通过蜂窝网络进行连接。</p>
<p><code>var timeoutIntervalForRequest: TimeInterval</code></p>
<p>等待其他数据时使用的超时间隔。</p>
<p><code>var timeoutIntervalForResource: TimeInterval</code></p>
<p>资源请求应该允许的最大时间量。</p>
<p><code>var sharedContainerIdentifier: String?</code></p>
<p>应该下载后台URL会话中的文件的共享容器的标识符。</p>
<p><code>var waitsForConnectivity: Bool</code></p>
<p>一个布尔值，指示会话是否应等待连接变为可用或者立即失败。</p>
<h3 id="设置Cookie政策"><a href="#设置Cookie政策" class="headerlink" title="设置Cookie政策"></a>设置Cookie政策</h3><p><code>var httpCookieAcceptPolicy: HTTPCookie.AcceptPolicy</code></p>
<p>决定何时应该接受Cookie的策略常量。</p>
<p><code>var httpShouldSetCookies: Bool</code></p>
<p>一个布尔值，用于确定请求是否应包含来自Cookie存储的Cookie。</p>
<p><code>var httpCookieStorage: HTTPCookieStorage?</code></p>
<p>用于在此会话中存储Cookie的Cookie存储。</p>
<p><code>class HTTPCookieStorage</code></p>
<p>管理cookie存储的单一对象（共享实例）。</p>
<p><code>class HTTPCookie</code></p>
<p>表示HTTP cookie的对象。它是一个不可变的对象，从包含cookie属性的字典中初始化。</p>
<h3 id="设置安全策略"><a href="#设置安全策略" class="headerlink" title="设置安全策略"></a>设置安全策略</h3><p><code>var tlsMaximumSupportedProtocol: SSLProtocol</code></p>
<p>在此会话中进行连接时客户端应请求的最大TLS协议版本。</p>
<p><code>var tlsMinimumSupportedProtocol: SSLProtocol</code></p>
<p>协议协商期间应该接受的最小TLS协议。</p>
<p><code>var urlCredentialStorage: URLCredentialStorage?</code></p>
<p>提供身份验证凭据的凭证存储。</p>
<h3 id="设置缓存策略"><a href="#设置缓存策略" class="headerlink" title="设置缓存策略"></a>设置缓存策略</h3><p><code>var urlCache: URLCache?</code></p>
<p>用于向会话中的请求提供缓存响应的URL缓存。</p>
<p><code>var requestCachePolicy: NSURLRequest.CachePolicy</code></p>
<p>一个预定义常量，用于确定何时从缓存中返回响应。</p>
<h3 id="支持后台转移"><a href="#支持后台转移" class="headerlink" title="支持后台转移"></a>支持后台转移</h3><p><code>var sessionSendsLaunchEvents: Bool</code></p>
<p>一个布尔值，指示在传输完成时是否应该在后台继续或启动应用程序。</p>
<p><code>var isDiscretionary: Bool</code></p>
<p>一个布尔值，用于确定是否可以根据系统的判断来调度后台任务以获得最佳性能。</p>
<p><a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1409517-shoulduseextendedbackgroundidlem" target="_blank" rel="noopener"><code>var shouldUseExtendedBackgroundIdleMode: Bool</code></a></p>
<h3 id="支持自定义协议"><a href="#支持自定义协议" class="headerlink" title="支持自定义协议"></a>支持自定义协议</h3><p><code>var protocolClasses: [AnyClass]?</code></p>
<p>在会话中处理请求的额外协议子类的数组。</p>
<p><code>class URLProtocol</code></p>
<p>一个<code>NSURLProtocol</code>对象处理加载协议特定的URL数据。在<code>NSURLProtocol</code>类本身是一个抽象类，可以为与特定URL方案的URL处理基础设施。您可以为您的应用支持的任何自定义协议或URL方案创建子类。</p>
<h3 id="支持多路径TCP"><a href="#支持多路径TCP" class="headerlink" title="支持多路径TCP"></a>支持多路径TCP</h3><p>使用多路径TCP提高网络可靠性</p>
<p>使用iOS设备中的可用收音机来提高应用程序的网络可靠性和性能。</p>
<p><code>var multipathServiceType: URLSessionConfiguration.MultipathServiceType</code></p>
<p>指定用于通过Wi-Fi和蜂窝接口传输数据的多路径TCP连接策略的服务类型。</p>
<p><code>enum URLSessionConfiguration.MultipathServiceType</code></p>
<p>指定多路径TCP使用的服务类型的常量。</p>
<h3 id="设置HTTP策略和代理属性"><a href="#设置HTTP策略和代理属性" class="headerlink" title="设置HTTP策略和代理属性"></a>设置HTTP策略和代理属性</h3><p><code>var httpMaximumConnectionsPerHost: Int</code></p>
<p>同时连接到给定主机的最大数量。</p>
<p><code>var httpShouldUsePipelining: Bool</code></p>
<p>一个布尔值，用于确定会话是否应使用HTTP流水线。</p>
<p><code>var connectionProxyDictionary: [AnyHashable : Any]?</code></p>
<p>包含有关在此会话中使用的代理信息的字典。</p>
<h3 id="支持连接变化"><a href="#支持连接变化" class="headerlink" title="支持连接变化"></a>支持连接变化</h3><p><code>var waitsForConnectivity: Bool</code></p>
<p>一个布尔值，指示会话是否应等待连接变为可用或者立即失败。</p>
<h3 id="已弃用的方法"><a href="#已弃用的方法" class="headerlink" title="已弃用的方法"></a>已弃用的方法</h3><p><code>class func backgroundSessionConfiguration(String)</code></p>
<p>返回一个会话配置对象，允许在后台执行HTTP和HTTPS上传或下载。</p>
<p>弃用</p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="继承自"><a href="#继承自" class="headerlink" title="继承自"></a>继承自</h3><p><a href="https://developer.apple.com/documentation/objectivec/nsobject" target="_blank" rel="noopener"><code>NSObject</code></a></p>
<h3 id="符合"><a href="#符合" class="headerlink" title="符合"></a>符合</h3><ul>
<li><a href="https://developer.apple.com/documentation/swift/cvararg" target="_blank" rel="noopener"><code>CVarArg</code></a></li>
<li><a href="https://developer.apple.com/documentation/swift/equatable" target="_blank" rel="noopener"><code>Equatable</code></a></li>
<li><a href="https://developer.apple.com/documentation/swift/hashable" target="_blank" rel="noopener"><code>Hashable</code></a></li>
<li><a href="https://developer.apple.com/documentation/foundation/nscopying" target="_blank" rel="noopener"><code>NSCopying</code></a></li>
</ul>
<h2 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>将网站数据存入内存</p>
<p>通过从URL会话创建数据任务，将数据直接接收到内存中。</p>
<p>上传数据到网站</p>
<p>将数据从应用程序发布到服务器。</p>
<p>在后台下载文件</p>
<p>创建在您的应用处于非活动状态时下载文件的任务</p>
<p><code>class URLSession</code></p>
<p>协调一组相关网络数据传输任务的对象。</p>
<p><code>class URLSessionTask</code></p>
<p>一个任务，比如下载一个特定的资源，由一个URL会话进行。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Network </tag>
            
            <tag> URLSession </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Multipath TCP 为 iOS 创建备份连接]]></title>
      <url>/2018/04/27/Multipath%20TCP/</url>
      <content type="html"><![CDATA[<p>如果您是网络管理员，您可以将 Multipath TCP 与 iOS 搭配使用，以加强与您的目标主机的连接。</p>
<p><a href="https://github.com/below/MultipathTCP" target="_blank" rel="noopener">https://github.com/below/MultipathTCP</a></p>
<p>iOS 支持 <a href="http://datatracker.ietf.org/doc/rfc6824/?include_text=1" target="_blank" rel="noopener">Multipath TCP (MPTCP)</a>，并且允许 iPhone 或 iPad 通过蜂窝移动数据连接建立与目标主机的备份 TCP 连接。</p>
<p>网络管理员可能需要使用 MPTCP。使用标准家庭网络的客户无需启用 MPTCP。</p>
<h2 id="关于-Multipath-TCP"><a href="#关于-Multipath-TCP" class="headerlink" title="关于 Multipath TCP"></a>关于 Multipath TCP</h2><p>MPTCP 是对传输控制协议 (TCP) 规范的一组扩展。凭借 MPTCP，客户端可以通过不同网络适配器连接到有多个连接的同一目标主机。这可在各主机间建立强大而高效的数据连接，并且与现有的网络基础设施兼容。 </p>
<h2 id="iPhone-或-iPad-上的-Mulitpath-TCP"><a href="#iPhone-或-iPad-上的-Mulitpath-TCP" class="headerlink" title="iPhone 或 iPad 上的 Mulitpath TCP"></a>iPhone 或 iPad 上的 Mulitpath TCP</h2><p>iPhone 和 iPad 在具有活跃的蜂窝移动数据连接的情况下使用 MPTCP 来建立两个连接：</p>
<ul>
<li>通过 Wi-Fi 的主要 TCP 连接</li>
<li>通过蜂窝移动数据的备用连接</li>
</ul>
<p>如果 Wi-Fi 不可用或无响应，iOS 会使用蜂窝移动数据连接。</p>
<p>MPTCP 使用 TCP 选项域 30，这是互联网编号分配机构 (IANA) 专为此用途而保留的。如果 iOS 设备与服务器之间的任何中间盒（如路由器或交换机）都不支持 MPTCP，则 iOS 会建立标准的 TCP 连接。</p>
<p>例如，当您向 Siri 提问时，Siri 会尝试通过 Wi-Fi 建立 MPTCP 连接。如果连接成功，Siri 会通过蜂窝移动数据建立备用连接。如果 Wi-Fi 不可用或不可靠，则 MPTCP 会立即在后台切换到蜂窝移动数据。</p>
<h2 id="为网络开启-MPTCP"><a href="#为网络开启-MPTCP" class="headerlink" title="为网络开启 MPTCP"></a>为网络开启 MPTCP</h2><p>MPTCP 与现有网络兼容。如果某个网络不支持 MPTCP，则客户端会使用标准的 TCP 连接。不过，网络管理员必须查看其防火墙政策，以确保所有介入设备都允许 TCP 选项 30，才能以未修改的方式传递信号。</p>
<p>很多商用路由器会将未知的 TCP 选项替换为 NOOP 数据。询问您的供应商如何开启 TCP 选项。</p>
<p>有关非 Apple 制造的产品或非 Apple 控制或测试的独立网站的信息仅供参考，不代表 Apple 的任何建议或保证。Apple 对于第三方网站或产品的选择、性能或使用不承担任何责任。Apple 对于第三方网站的准确性和可靠性不作任何担保。互联网的使用具有一定风险。请<a href="https://support.apple.com/zh-cn/HT201777" target="_blank" rel="noopener">联系供应商</a>以了解其他信息。其他公司和产品名称可能是其各自所有公司的商标。</p>
<p>ios7.0之后，通过wifi建立tcp连接时，还会通过3g/4g建立一个备用的连接。</p>
<p>然后搜索这玩意儿如何用法:</p>
<p>不要填dns就ok了。</p>
<p>为了验证这种说法，</p>
<p>验证一: 连接了盯盯拍的wifi（老板买了一个盯盯拍给大家琢磨），点进细节一看，dhcp的信息里果然没有dns信息。</p>
<p>验证二:连接了一个支持ap模式的wifi，记录下dhcp模式下的ip、掩码、网关，然后设置为static模式，填写 刚才记录的信息。注意不要填写dns信息。果然可以同时连接ap模式的ipc，也可以3g/4g翻看网页。只是这种做法下，手机顶部没有扇形的连接信号。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Multipath </tag>
            
            <tag> Network </tag>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Moya的设计之道]]></title>
      <url>/2018/04/27/Moya%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93/</url>
      <content type="html"><![CDATA[<h2 id="转载-https-blog-csdn-net-Hello-Hwc-article-details-77096648"><a href="#转载-https-blog-csdn-net-Hello-Hwc-article-details-77096648" class="headerlink" title="转载    https://blog.csdn.net/Hello_Hwc/article/details/77096648"></a>转载    <a href="https://blog.csdn.net/Hello_Hwc/article/details/77096648" target="_blank" rel="noopener">https://blog.csdn.net/Hello_Hwc/article/details/77096648</a></h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Moya是一个基于Alamofire开发的，轻量级的Swift网络层。Moya的可扩展性非常强，可以方便的RXSwift，PromiseKit和ObjectMapper结合。</p>
</blockquote>
<p>如果你的项目刚刚搭建，并且是纯Swift的，非常推荐以Moya为核心去搭建你的网络层。另外,如果你对Alamofire的源码感兴趣，推荐我之前的一篇博客：</p>
<ul>
<li><a href="http://blog.csdn.net/hello_hwc/article/details/72853786" target="_blank" rel="noopener">Alamofire的设计之道</a></li>
</ul>
<blockquote>
<p>Moya除了依赖Alamofire，还依赖<a href="https://github.com/antitypical/Result" target="_blank" rel="noopener">Result</a>。Result用一种枚举的方式提供函数处理结果：</p>
<ul>
<li><code>.success(let data)</code> // 成功，关联值是数据</li>
<li><code>.falure(let error)</code> // 失败, 关联值是错误原因</li>
</ul>
</blockquote>
<p><strong>本文的讲解顺序：Moya的实现原理 -&gt; Moya的设计理念 -&gt; Moya与RxSwift，ObjectMapper一起工作</strong></p>
<p>–</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote>
<p>分析任何代码都是从它的接口开始的。</p>
</blockquote>
<p>我们先来看看通过Moya如何去写一个网络API请求。Moya中，通过协议<a href="https://github.com/Moya/Moya/blob/master/Sources/Moya/TargetType.swift" target="_blank" rel="noopener">TargetType</a>来表示这是一个API请求。</p>
<p>协议要求提供以下属性，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public protocol TargetType &#123;</span><br><span class="line">    var baseURL: URL &#123; get &#125;</span><br><span class="line">    var path: String &#123; get &#125;</span><br><span class="line">    var method: Moya.Method &#123; get &#125;</span><br><span class="line">    var parameters: [String: Any]? &#123; get &#125; //参数</span><br><span class="line">    var parameterEncoding: ParameterEncoding &#123; get &#125; //编码方式</span><br><span class="line">    var sampleData: Data &#123; get &#125;//stub数据</span><br><span class="line">    var task: Task &#123; get &#125;//请求类型，Data/Downlaod/Upload</span><br><span class="line">    var validate: Bool &#123; get &#125; //是否需要对返回值验证，默认值false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过枚举来管理一组API，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public enum GitHub &#123;</span><br><span class="line">    case zen</span><br><span class="line">    case userProfile(String)</span><br><span class="line">&#125;</span><br><span class="line">extension GitHub: TargetType &#123;</span><br><span class="line">    public var baseURL: URL &#123; return URL(string: &quot;https://api.github.com&quot;)! &#125;</span><br><span class="line">    public var path: String &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .zen:</span><br><span class="line">            return &quot;/zen&quot;</span><br><span class="line">        case .userProfile(let name):</span><br><span class="line">            return &quot;/users/\(name.urlEscaped)&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然也可以让你的Class/Stuct来实现TargetType协议，使用枚举可以方便的管理一组API，优点是方便复用baseURL,method等，缺点是不得不写大量的Switch语句</p>
</blockquote>
<p>然后，在进行API请求的时候，要创建<code>MoyaProvider</code>，接着调用Request方法进行实际的请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let provider = MoyaProvider&lt;GitHub&gt;()</span><br><span class="line">provider.request(.zen) &#123; result in</span><br><span class="line">    if case let .success(response) = result &#123;</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，Moya通过协议来定义一个网络请求，并且属性都是只读的。协议意味着是依赖于抽象，而不是具体的实现，这样更易控制藕合，并且容易扩展；只读的意味着不可变状态，不可变状态会让你的代码行为可预测。</p>
</blockquote>
<hr>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>通过功能划分，Moya大致分为几个模块</p>
<ul>
<li><p><strong>Request</strong>，包括TargetType，Endpoint，Cancellable集中类型</p>
</li>
<li><p><strong>Provider</strong>，网络请求的枢纽，Provider会把<code>TargetType</code>转换成<code>Endpoint</code>再转换成<code>URLRequest</code>交给Alamofire去实际执行</p>
</li>
<li><p><strong>Response</strong>，回调给上层的数据结构，支持<code>filter</code>，<code>mapJSON</code>等方法</p>
</li>
<li><p><strong>Alamofire封装</strong>，通过桥接的方式对上层隐藏alamofire的细节</p>
</li>
<li><p><strong>Plguins</strong>，插件。moya提供了插件来给给外部。包括四个方法，这里知道方法就好，后文会具体的讲解插件的方法在何时工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public protocol PluginType &#123;</span><br><span class="line">    func prepare(_ request: URLRequest, target: TargetType) -&gt; URLRequest</span><br><span class="line">    func willSend(_ request: RequestType, target: TargetType)</span><br><span class="line">    func didReceive(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span><br><span class="line">    func process(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) -&gt; Result&lt;Moya.Response, MoyaError&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>为了更好的讲解Moya的处理流程，我画了一张图（用Sketch画的）：</p>
<p><img src="https://img-blog.csdn.net/20170809135909929?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGVsbG9fSHdj/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>第一眼看到这张图的时候，你肯定是困惑的，我们来一点点讲解图中的过程。通过上文的讲解我们知道，<a href="https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider.swift" target="_blank" rel="noopener">Provider</a>这个类是网络请求的枢纽，它接受一个TargetType(请求)，并且通过闭包的方式给上层回调。</p>
<p>那么，我们来看看<a href="https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider.swift" target="_blank" rel="noopener">Provider</a>的初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public init(endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping,</span><br><span class="line">            requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping,</span><br><span class="line">            stubClosure: @escaping StubClosure = MoyaProvider.neverStub,</span><br><span class="line">            manager: Manager = MoyaProvider&lt;Target&gt;.defaultAlamofireManager(),</span><br><span class="line">            plugins: [PluginType] = [],</span><br><span class="line">            trackInflights: Bool = false) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化的时候的几个参数：</p>
<ul>
<li><code>endpointClosure</code> 作用是把TargetType转换成EndPoint，EndPoint是Moya网络请求的一个中间态。</li>
<li><code>requestClosure</code> 作用是把Endpoint转换成URLRequest</li>
<li><code>stubClosure</code> 是用来桩测试的，也就是模拟服务端假数据，这里先不管。</li>
<li><code>manager</code>，实际请求的Alamofire的SessionManager</li>
<li><code>plugins</code>, 插件</li>
<li><code>trackInflights</code>，是否要跟踪重复网络请求</li>
</ul>
<hr>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p><img src="https://camo.githubusercontent.com/11d7f03370059f782a5c2170360165656cf6ec45/68747470733a2f2f7261772e6769746875622e636f6d2f4d6f79612f4d6f79612f6d61737465722f7765622f706970656c696e652e706e67" alt="img"></p>
<p>在Moya中，请求是按照如图的方式进行转换的。其中,TargetType到Endpoint的转换是通过闭包<code>endpointClosure</code>来完成的。闭包的输入是TargetType，输出是<code>EndPoint</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public typealias EndpointClosure = (Target) -&gt; Endpoint&lt;Target&gt;</span><br></pre></td></tr></table></figure>
<p>在初始化Provider的时候，<code>endpointClosure</code>有默认参数，可以看到默认实现只是由Target创建了一个Endpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class func defaultEndpointMapping(for target: Target) -&gt; Endpoint&lt;Target&gt; &#123;</span><br><span class="line">    return Endpoint(</span><br><span class="line">        url: url(for: target).absoluteString,</span><br><span class="line">        sampleResponseClosure: &#123; .networkResponse(200, target.sampleData) &#125;,</span><br><span class="line">        method: target.method,</span><br><span class="line">        parameters: target.parameters,</span><br><span class="line">        parameterEncoding: target.parameterEncoding</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，通过<code>requestClosure</code>将Endpoing映射到URLRequest。这是你最后修改Request的机会，同样它也有默认参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class func defaultRequestMapping(for endpoint: Endpoint&lt;Target&gt;, closure: RequestResultClosure) &#123;</span><br><span class="line">    if let urlRequest = endpoint.urlRequest &#123;//urlReuqest有效，就以success执行闭包</span><br><span class="line">        closure(.success(urlRequest))</span><br><span class="line">    &#125; else &#123;//无效，以faliure执行闭包</span><br><span class="line">        closure(.failure(MoyaError.requestMapping(endpoint.url)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么要用闭包进行TargetType-&gt;Endpoint-&gt;URLRequest映射呢？</strong></p>
<blockquote>
<p><strong>为了在灵活性和易用性之间进行平衡</strong>。</p>
</blockquote>
<p>对于大部分API请求来说，使用Moya提供的默认闭包映射足以，这样大多数时候根本不需要关心着两个闭包的内容。但是有时候，有一些额外需求，比如对所有API请求增加额外的<code>HTTP Header</code>，moya通过闭包的方式开发者可以去修改这些内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let endpointClosure = &#123; (target: MyTarget) -&gt; Endpoint&lt;MyTarget&gt; in</span><br><span class="line">    let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)</span><br><span class="line">    return defaultEndpoint.adding(newHTTPHeaderFields: [&quot;APP_NAME&quot;: &quot;MY_AWESOME_APP&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么要引入requestClosure，把底层的URLRequest暴露给外部？</strong></p>
<blockquote>
<p>我想有几点原因</p>
<ul>
<li>有些信息只有<code>URLRequest</code>创建之后才能知晓，比如cookie。</li>
<li><code>URLRequest</code>属性很多，大多不常用，比如<code>allowsCellularAccess</code>，没必在Moya这一层封装。</li>
<li>Endpoint到URLRequest的映射是通过闭包回调的方式进行的，意味着你可以异步回调。</li>
</ul>
</blockquote>
<p><strong>为什么要引入Endpoint，不直接映射成URLRequest?也就是说，两步闭包映射变成一步</strong></p>
<blockquote>
<p>为了保证TargetType维持不可变状态（属性全都是只读），同时给外部友好的API。通过Endpoint你可以方便的：添加新的参数,添加HttpHeader….</p>
</blockquote>
<hr>
<h3 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h3><p>这里我们先不管流程图中的Plugins（插件），先顺着流程走，接下来我们到了一个叫做stub的模块。stub是一个测试相关的概念，通过stub你可以返回一些假数据。</p>
<blockquote>
<p>Moya的stub原理很简单，如果Provider决定Stub，那么就返回Endpoint中的假数据；否则就进行实际的网络请求。</p>
</blockquote>
<p>Moya通过<code>StubClosure</code>闭包开决定stub的模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public typealias StubClosure = (Target) -&gt; Moya.StubBehavior</span><br></pre></td></tr></table></figure>
<p>模式分为三种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum StubBehavior &#123;</span><br><span class="line">    case never //不Stub</span><br><span class="line">    case immediate //立刻返回数据</span><br><span class="line">    case delayed(seconds: TimeInterval)//延时返回数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回数据的时候，就是简单的根据EndPoint中的假数据闭包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch endpoint.sampleResponseClosure() &#123;</span><br><span class="line">    case .networkResponse(let statusCode, let data):</span><br><span class="line">        let response = Moya.Response(statusCode: statusCode, data: data, request: request, response: nil)</span><br><span class="line">        completion(.success(response))</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的Endpoint的<code>sampleResponseClosure</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sampleResponseClosure: &#123; .networkResponse(200, target.sampleData) &#125;,</span><br></pre></td></tr></table></figure>
<p>Moya采用了这种简单粗暴，但是效果却很好的stub方式。</p>
<p><strong>这里很多人肯定会问，假如我不用Moya，我还想返回假数据，我该咋么做呢？</strong></p>
<blockquote>
<p>答案是<a href="https://developer.apple.com/documentation/foundation/urlprotocol" target="_blank" rel="noopener">URLProtocol</a>。通过<a href="https://developer.apple.com/documentation/foundation/urlprotocol" target="_blank" rel="noopener">URLProtocol</a>可以拦截网络请求，你可以把网络请求重定向到假数据。</p>
<p>对于NSURLConnection发起的请求可以直接拦截。在拦截NSURLSession的时候有一点tricky，因为URLSession支持的拦截是通过<a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration" target="_blank" rel="noopener">URLSessionConfiguration</a>的属性<a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1411050-protocolclasses" target="_blank" rel="noopener">protocolClasses</a>来决定的，一般的做法是hook URLSession的初始化方法<code>init(configuration: URLSessionConfiguration, delegate: URLSessionDelegate?, delegateQueue: OperationQueue?)</code>，然后把想要的拦截Protocol注册到URLSessionConfiguration中。</p>
</blockquote>
<hr>
<h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><blockquote>
<p>Plugin提供了一种插件的机制让你可以在网络请求的关键节点插入代码，比如显示小菊花扽等。</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20170809135909929?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGVsbG9fSHdj/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>这里我们再看一下这张图，可以清楚的看到四个plugin方法作用的时机。</p>
<blockquote>
<p>Note：Plugin没有用范型编程，所以不要尝试在plugin中进行JSON解析然后传递给上层。</p>
</blockquote>
<p>Moya提供了四种Plugin：</p>
<ul>
<li><a href="https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/AccessTokenPlugin.swift" target="_blank" rel="noopener">AccessTokenPlugin</a> OAuth的Token验证</li>
<li><a href="https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/CredentialsPlugin.swift" target="_blank" rel="noopener">CredentialsPlugin</a> 证书</li>
<li><a href="https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/NetworkActivityPlugin.swift" target="_blank" rel="noopener">NetworkActivityPlugin</a> 网络请求状态</li>
<li><a href="https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/NetworkLoggerPlugin.swift" target="_blank" rel="noopener">NetworkLoggerPlugin</a> 网络日志</li>
</ul>
<hr>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><blockquote>
<p>Moya并没有对Response进行特殊处理，仅仅是把Alamofire层面返回的数据封装成<code>Moya.Response</code>，然后再调用<code>convertResponseToResult</code>进一步封装成<code>Result&lt;Moya.Response, MoyaError&gt;</code>类型交给上层</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public func convertResponseToResult(_ response: HTTPURLResponse?, request: URLRequest?, data: Data?, error: Swift.Error?) -&gt;</span><br><span class="line">    Result&lt;Moya.Response, MoyaError&gt; &#123;</span><br><span class="line">        switch (response, data, error) &#123;</span><br><span class="line">        case let (.some(response), data, .none):</span><br><span class="line">            let response = Moya.Response(statusCode: response.statusCode, data: data ?? Data(), request: request, response: response)</span><br><span class="line">            return .success(response)</span><br><span class="line">        case let (_, _, .some(error)):</span><br><span class="line">            //....</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你要对Response进一步转换成JSON，可以用Response的方法，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func mapJSON(failsOnEmptyData: Bool = true) throws -&gt; Any &#123;/* */&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到这里，Moya做的事情已经很清晰了：提供一种面向协议的接口来进行网络请求的编写；提供灵活的闭包接口来自定义请求；提供插件来让客户端在各个节点去介入网络请求；返回原始的请求数据给层。</p>
</blockquote>
<p>Moya最大的优点:</p>
<ul>
<li><strong>纯粹的轻量级网络层。</strong></li>
</ul>
<hr>
<h3 id="Cancel"><a href="#Cancel" class="headerlink" title="Cancel"></a>Cancel</h3><p>网络API请求应该是可以被取消的。也就是说，在发起一个API请求后，客户端应该能够有一个数据结构能够取消这个请求。Moya返回协议<code>Cancellable</code>给客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public protocol Cancellable &#123;</span><br><span class="line">    var isCancelled: Bool &#123; get &#125;</span><br><span class="line">    func cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这符合《最少知识原则》。客户端不知道请求是什么，它唯一能做的就是<code>cancel</code>。</p>
</blockquote>
<p>在内部实现中，引入了一个<code>CancellableWrapper</code>来进行实际的Cancel动作包装，返回的实际实现协议的类型就是它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">internal class CancellableWrapper: Cancellable &#123;</span><br><span class="line">    internal var innerCancellable: Cancellable = SimpleCancellable()</span><br><span class="line"></span><br><span class="line">    var isCancelled: Bool &#123; return innerCancellable.isCancelled &#125;</span><br><span class="line"></span><br><span class="line">    internal func cancel() &#123;</span><br><span class="line">        innerCancellable.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal class SimpleCancellable: Cancellable &#123;</span><br><span class="line">    var isCancelled = false</span><br><span class="line">    func cancel() &#123;</span><br><span class="line">        isCancelled = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么要用一个CancellableWrapper进行包装呢？</strong></p>
<p>原因是：</p>
<ul>
<li>对于没有实际发出的请求（参数错误），cancel动作直接用<code>SimpleCancellable</code>即可。</li>
<li>对于实际发出的请求请求，cancel则需要取消实际的网络请求。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let cancellableToken = CancellableWrapper()</span><br><span class="line">if error&#123; //参数出错</span><br><span class="line">    return cancellableToken</span><br><span class="line">&#125;</span><br><span class="line">cancellableToken.innerCancellable = CancellableToken(request:request)</span><br></pre></td></tr></table></figure>
<p>而<code>CancellableToken</code>中，取消网络请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class CancellableToken: Cancellable&#123;</span><br><span class="line">    //...</span><br><span class="line">    fileprivate var lock: DispatchSemaphore = DispatchSemaphore(value: 1)</span><br><span class="line">    public func cancel() &#123;</span><br><span class="line">        _ = lock.wait(timeout: DispatchTime.distantFuture)</span><br><span class="line">        defer &#123; lock.signal() &#125;</span><br><span class="line">        guard !isCancelled else &#123; return &#125;</span><br><span class="line">        isCancelled = true</span><br><span class="line">        cancelAction()</span><br><span class="line">    &#125;</span><br><span class="line">    init(request: Request) &#123;</span><br><span class="line">        self.request = request</span><br><span class="line">        self.cancelAction = &#123;</span><br><span class="line">            request.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里用到了信号量，为了防止两个线程同时执行cancel操作。</p>
</blockquote>
<hr>
<h3 id="Alamofire封装"><a href="#Alamofire封装" class="headerlink" title="Alamofire封装"></a>Alamofire封装</h3><p>Moya采用桥接的方式，把Alamofire的API细节进行封装，详细的封装细节可见<a href="https://github.com/Moya/Moya/blob/master/Sources/Moya/Moya%2BAlamofire.swift" target="_blank" rel="noopener">Moya+Alamofire.swift</a>。总的来说，采用了两种方式：</p>
<p>简单的类型桥接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//用typealias进行桥接</span><br><span class="line">public typealias Method = Alamofire.HTTPMethod</span><br><span class="line">public typealias ParameterEncoding = Alamofire.ParameterEncoding</span><br></pre></td></tr></table></figure>
<p>协议桥接</p>
<p>Alamofire对外的接口是<a href="https://github.com/Alamofire/Alamofire/blob/master/Source/Request.swift" target="_blank" rel="noopener">Request</a>类型。而Moya需要在Plugin中对Reuqest进行暴露，用协议怼Request进行了桥接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public protocol RequestType &#123;</span><br><span class="line">    var request: URLRequest? &#123; get &#125;</span><br><span class="line">    func authenticate(user: String, password: String, persistence: URLCredential.Persistence) -&gt; Self</span><br><span class="line">    func authenticate(usingCredential credential: URLCredential) -&gt; Self</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal typealias Request = Alamofire.Request</span><br><span class="line">extension Request: RequestType &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>然后，暴露给外部的接口变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func willSend(_ request: RequestType, target: TargetType)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>采用桥接的方式对外隐藏了细节，这样即使有一天Moya的底层依赖不再是Alamofire，对上层也没有任何影响。</p>
</blockquote>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>moya的很多设计原则是值得借鉴的，这些原则在软件开发领域是通用的。</p>
<h3 id="面向协议"><a href="#面向协议" class="headerlink" title="面向协议"></a>面向协议</h3><blockquote>
<p>Swift是一个面向协议的语言。(这句话我好像在博客里写过好多遍了)</p>
</blockquote>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol TargetType &#123;&#125; //表示这是一个API请求</span><br><span class="line">public protocol Cancellable&#123;&#125;//唯一确定请求，只有一个接口用来取消</span><br><span class="line">public protocol RequestType&#123;&#125;//对外提供的请求类型，隐藏Alamofire的细节</span><br><span class="line">public protocol PluginType&#123;&#125; //插件类型</span><br></pre></td></tr></table></figure>
<p>面向协议的最大优点是：</p>
<ul>
<li>协议是建立的是一个抽象的依赖关系。</li>
</ul>
<p>同时，Swift协议支持扩展，你可以通过协议扩展为协议中的方法提供默认实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public extension TargetType &#123;</span><br><span class="line">    var validate: Bool &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不可变状态"><a href="#不可变状态" class="headerlink" title="不可变状态"></a>不可变状态</h3><blockquote>
<p>不可变状态会让你的代码可预测，可测试。</p>
</blockquote>
<p>不可变状态是函数式编程里的一个核心概念。在Moya中，很多状态都是不可变的。典型的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public protocol TargetType &#123;</span><br><span class="line">    var baseURL: URL &#123; get &#125; //只读</span><br><span class="line">    var path: String &#123; get &#125; //只读</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，还体现在Endpoint中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">open class Endpoint&lt;Target&gt; &#123;</span><br><span class="line">    open let url: String //常量</span><br><span class="line">    open let method: Moya.Method</span><br><span class="line">    //...</span><br><span class="line">    //不修改自身，而是返回一个新的实例</span><br><span class="line">     open func adding(newHTTPHeaderFields: [String: String]) -&gt; Endpoint&lt;Target&gt; &#123;</span><br><span class="line">        return adding(httpHeaderFields: newHTTPHeaderFields)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><blockquote>
<p>Swift中，函数是一等公民，意味着你可以把它作为函数的参数和返回值。当一个函数作为函数参数或者返回值的时候，称之为高阶函数。</p>
</blockquote>
<p><strong>高阶函数让你的代码可以输入/输出逻辑，这样就增加了灵活性。</strong></p>
<p>比如在Provider初始化的时候传入的三个闭包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">endpointClosure: = MoyaProvider.defaultEndpointMapping,</span><br><span class="line">requestClosure: = MoyaProvider.defaultRequestMapping,</span><br><span class="line">stubClosure: = MoyaProvider.neverStub,</span><br></pre></td></tr></table></figure>
<blockquote>
<p>高阶函数配合函数默认值，是Swift开发中进行接口暴露的常用技巧。</p>
</blockquote>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件是我认为Moya这个框架最吸引我的地方。</p>
<p><img src="https://img-blog.csdn.net/20170809135909929?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGVsbG9fSHdj/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<blockquote>
<p>通过在各个节点暴露出插件的接口，让Moya的日志，授权，小菊花等功能无需耦合到核心代码里，同时也给外部足够的灵活性，能够插入任何想要的代码。</p>
</blockquote>
<h3 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h3><blockquote>
<p>使用枚举来保证类型安全是Swift中常用技巧。</p>
</blockquote>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//返回假数据</span><br><span class="line">public enum EndpointSampleResponse &#123;</span><br><span class="line">    case networkResponse(Int, Data)</span><br><span class="line">    case response(HTTPURLResponse, Data)</span><br><span class="line">    case networkError(NSError)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Moya的错误处理主要采用了两种方式：</p>
<p>抛异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public func filterSuccessfulStatusAndRedirectCodes() throws -&gt; Response &#123;</span><br><span class="line">    return try filter(statusCodes: 200...399)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func convertResponseToResult(****) -&gt; Result&lt;Moya.Response, MoyaError&gt; &#123;</span><br><span class="line">    return .success(response) </span><br><span class="line">    return .failure(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Swift中，通过Result类型来处理异步错误是一个很常见也很有效的做法。</p>
</blockquote>
<p>使用Result类型最大的好处是可以不用每一步都处理错误。</p>
<p>比如，类似这个链式调用，每一步都有可能出错，通过Result类型，我们可以在最后统一处理错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">provider.request(...).filter().mapJSON.filter().&#123; result in</span><br><span class="line">    switch result &#123;</span><br><span class="line">        case let .success(moyaResponse):</span><br><span class="line"></span><br><span class="line">        case let .failure(error):</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>延伸阅读： <a href="http://blog.csdn.net/hello_hwc/article/details/63685843" target="_blank" rel="noopener">详解Swift中的错误处理</a></li>
</ul>
<hr>
<h2 id="RxSwift"><a href="#RxSwift" class="headerlink" title="RxSwift"></a>RxSwift</h2><blockquote>
<p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>是一个响应式编程框架，它是语言层面的扩展，改变的是你写代码的方式，与具体业务细节无关。</p>
</blockquote>
<p>如果你对RxSwift并不熟悉，推荐我之前的一篇博客：<a href="http://blog.csdn.net/hello_hwc/article/details/51859330" target="_blank" rel="noopener">RxSwift使用教程</a>。另外，我还维护了一个<a href="https://github.com/LeoMobileDeveloper/awesome-rxswift" target="_blank" rel="noopener">awesome-rxswift</a>列表。</p>
<p>Moya核心代码并没有支持RxSwift，那样就与另外一个框架耦合在一起了。Moya采用了扩展的方式，让Moya支持RxSwift，具体代码参见<a href="https://github.com/Moya/Moya/tree/master/Sources/RxMoya" target="_blank" rel="noopener">RxMoya</a>。</p>
<p>在扩展中，提供了<code>RxMoyaProvider</code>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class RxMoyaProvider&lt;Target&gt;: MoyaProvider&lt;Target&gt;</span><br></pre></td></tr></table></figure>
<p>在请求的时候，不再通过闭包进行回调，而是返回<code>Observable&lt;Response&gt;</code>（一个可监听的信号源）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">open func request(_ token: Target) -&gt; Observable&lt;Response&gt; &#123;</span><br><span class="line">    return Observable.create &#123; observer in </span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，通过extension扩展ObservableType为Response提供各种响应式处理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension ObservableType where E == Response &#123;</span><br><span class="line">     public func mapJSON(failsOnEmptyData: Bool = true) -&gt; Observable&lt;Any&gt;</span><br><span class="line">     public func filter(statusCode: Int) -&gt; Observable&lt;E&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h2><blockquote>
<p><a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a> 是一个用来做把JSON转换成Struct/Class的Swift框架。</p>
</blockquote>
<p>实际开发中，先把JSON转换成对象再进行下一步UI操作是很常见的事情。结合RxSwift，我们可以很容易的把ObjectMapper插入响应式处理的一个节点中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension ObservableType where E == Response &#123;</span><br><span class="line">    public func mapObject&lt;T: Mappable&gt;(_ type: T.Type) -&gt; Observable&lt;T&gt; &#123;</span><br><span class="line">        return flatMap &#123; response -&gt; Observable&lt;T&gt; in</span><br><span class="line">            return Observable.just&#123;/* 这里引入ObjectMapper进行JSON解析*/&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个方法，可以进行信号中包含的信息转换：</p>
<p><img src="https://img-blog.csdn.net/20170811103606241?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGVsbG9fSHdj/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>于是，通过RxSwift和ObjectMapper，就可以这么处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rxRrovider.request(.targetType)</span><br><span class="line">  .mapObject(YouClass.type)</span><br><span class="line">  .subscribe &#123; event -&gt; Void in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .next(let object):</span><br><span class="line">      self.object = object</span><br><span class="line">    case .error(let error):</span><br><span class="line">      print(error)</span><br><span class="line">    default:</span><br><span class="line">      break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Network </tag>
            
            <tag> Moya </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Moya源码解析]]></title>
      <url>/2018/04/27/Moya%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>转<a href="https://blog.csdn.net/lh844386434/article/details/51818017" target="_blank" rel="noopener">https://blog.csdn.net/lh844386434/article/details/51818017</a></p>
<p><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener"><strong>Moya</strong></a>是一个高度抽象的网络库，他的理念是让你不用关心网络请求的底层的实现细节，只用定义你关心的业务。且Moya采用桥接和组合来进行封装(默认桥接了<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener"><strong>Alamofire</strong></a>)，使得Moya非常好扩展，让你不用修改Moya源码就可以轻易定制。官方给出几个Moya主要优点：</p>
<ul>
<li>编译时检查API endpoint权限</li>
<li>让你使用枚举定义各种不同Target, endpoints</li>
<li>把stubs当做一等公民对待，因此测试超级简单。</li>
</ul>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>开始Moya之旅的第一步便是，建立一个Enum的Target，这个Target便是你网络请求相关行为的定义。Target必须实现TargetType协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public protocol TargetType &#123;</span><br><span class="line">    var baseURL: NSURL &#123; get &#125;</span><br><span class="line">    var path: String &#123; get &#125;</span><br><span class="line">    var method: Moya.Method &#123; get &#125;</span><br><span class="line">    var parameters: [String: AnyObject]? &#123; get &#125;</span><br><span class="line">    var sampleData: NSData &#123; get &#125;</span><br><span class="line">&#125; 1234567</span><br></pre></td></tr></table></figure>
<p>例如有一个AccountAPI模块，模块实现注册登录的功能。所以第一件事情，我们需要定义一个Target</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">enum AccountAPI &#123;</span><br><span class="line">    case Login(userName: String, passwd: String)</span><br><span class="line">    case Register(userName: String, passwd: String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension AccountAPI: TargetType &#123;</span><br><span class="line">    var baseURL: NSURL &#123;</span><br><span class="line">        return NSURL(string: &quot;https://www.myapp.com&quot;)!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var path: String &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Login:</span><br><span class="line">            return &quot;/login&quot;</span><br><span class="line">        case .Register:</span><br><span class="line">            return &quot;/register&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var method: Moya.Method &#123;</span><br><span class="line">        return .GET</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var parameters: [String: AnyObject]? &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Login:</span><br><span class="line">            return nil</span><br><span class="line">        case .Register(let userName, let passwd):</span><br><span class="line">            return [&quot;username&quot;: userName, &quot;password&quot;: passwd]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var sampleData: NSData &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Login:</span><br><span class="line">            return &quot;&#123;&apos;code&apos;: 1,6&apos;Token&apos;:&apos;123455&apos;&#125;&quot;.dataUsingEncoding(NSUTF8StringEncoding)!</span><br><span class="line">        case .Register(let userName, let passwd):</span><br><span class="line">            return &quot;找不到数据&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;1234567891011121314151617181920212223242526272829303132333435363738394041</span><br></pre></td></tr></table></figure>
<p>主要是实现了TargetType协议，里面的网址和内容，是随便写的，可能不make sence（不合理）, 但 仅仅是做一个例子而已。</p>
<h2 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h2><p>Providers是Moya中的核心，Moya中所有的API请求都是通过Provider来发起的。因此大多数时候，你的代码请求像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let provider = MoyaProvider&lt;AccountAPI&gt;()</span><br><span class="line">provider.request(.Login) &#123; result in</span><br><span class="line">    // `result` is either .Success(response) or .Failure(error)</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<p>我们初始化了一个AccountAPI的Provider，并且调用了Login请求。怎么样？干净简单吧！</p>
<h3 id="从Provider的构造函数说起"><a href="#从Provider的构造函数说起" class="headerlink" title="从Provider的构造函数说起"></a><strong>从Provider的构造函数说起</strong></h3><p>Provider真正做的事情可以用一个流来表示：<strong>Target -&gt; Endpoint -&gt; Request</strong>。在这个例子中，它将AccountAPI转换成Endpoint, 再将其转换成为NSRURLRequest。最后将这个NSRURLRequest交给<strong>Alamofire</strong>去进行网络请求。</p>
<p>我们从Provider的构造函数开始切入，一步一步地扒开它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Moya.swift</span><br><span class="line"></span><br><span class="line">public init(endpointClosure: EndpointClosure = MoyaProvider.DefaultEndpointMapping,</span><br><span class="line">        requestClosure: RequestClosure = MoyaProvider.DefaultRequestMapping,   </span><br><span class="line">        stubClosure: StubClosure = MoyaProvider.NeverStub,</span><br><span class="line">        manager: Manager = MoyaProvider&lt;Target&gt;.DefaultAlamofireManager(),</span><br><span class="line">        plugins: [PluginType] = []) 1234567</span><br></pre></td></tr></table></figure>
<ol>
<li>首先我们发现的是3个Closure：endpointClosure、requestClosure、stubClosure。这3个Closure是让我们定制请求和进行测试时用的。非常有用，后面细说。</li>
<li>然后是一个Manager，Manager是真正用来网络请求的类，Moya自己并不提供Manager类，Moya只是对其他网络请求类进行了简单的桥接。这么做是为了让调用方可以轻易地定制、更换网络请求的库。比如你不想用Alamofire，可以十分简单的换成其他库</li>
<li>最后是一个类型为PluginType的数组。Moya提供了一个插件机制，使我们可以建立自己的插件类来做一些额外的事情。比如写Log，显示“菊花”等。抽离出Plugin层的目的，就是让Provider职责单一，满足开闭原则。把和自己网络无关的行为抽离。避免各种业务揉在一起不利于扩展。</li>
</ol>
<p>先来看看第一个<strong>EndpointClosure</strong></p>
<h3 id="EndpointClosure"><a href="#EndpointClosure" class="headerlink" title="EndpointClosure"></a><strong>EndpointClosure</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Moya.swift</span><br><span class="line"></span><br><span class="line">public typealias EndpointClosure = Target -&gt; Endpoint&lt;Target&gt;123</span><br></pre></td></tr></table></figure>
<p><strong>EndpointClosure</strong>这个闭包，输入是一个Target，返回<strong>Endpoint</strong>。这就是我们前面说的Target -&gt; Endpoint的转换，那么<strong>Endpoint</strong>是个什么鬼？<br><strong>Endpoint</strong> 是Moya最终进行网络请求前的一种数据结构，它保存了这些数据：</p>
<ul>
<li>URL</li>
<li>HTTP请求方式 (GET, POST, etc).</li>
<li>本次请求的参数</li>
<li>参数的编码方式 (URL, JSON, custom, etc).</li>
<li>stub数据的 response(测试用的)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Endpoint.swift</span><br><span class="line"></span><br><span class="line">public class Endpoint&lt;Target&gt; &#123;</span><br><span class="line">    public typealias SampleResponseClosure = () -&gt; EndpointSampleResponse</span><br><span class="line"></span><br><span class="line">    public let URL: String</span><br><span class="line">    public let method: Moya.Method</span><br><span class="line">    public let sampleResponseClosure: SampleResponseClosure</span><br><span class="line">    public let parameters: [String: AnyObject]?</span><br><span class="line">    public let parameterEncoding: Moya.ParameterEncoding</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">  &#125;12345678910111213</span><br></pre></td></tr></table></figure>
<p>Moya提供一个默认<strong>EndpointClosure</strong>的函数，来实现这个Target到Endpoint的转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Moya.swift</span><br><span class="line"></span><br><span class="line">public final class func DefaultEndpointMapping(target: Target) -&gt; Endpoint&lt;Target&gt; &#123;</span><br><span class="line">     let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString</span><br><span class="line">     return Endpoint(URL: url, sampleResponseClosure: &#123;.NetworkResponse(200, target.sampleData)&#125;, method: target.method, parameters: target.parameters)</span><br><span class="line"> &#125;123456</span><br></pre></td></tr></table></figure>
<p>上面的代码只是单纯地创建并返回一个Endpoint实例。然而在很多时候，我们需要自定义这个闭包来做更多额外的事情。后面在stub小节，你会看到，我们用stub模拟API请求失败的场景，给客户端返回一个非200的状态码。为了实现这个功能，在这个闭包里处理相关的逻辑，再合适不过了！或者说这个闭包就是让我们根据业务需求定制网络请求的。</p>
<h3 id="RequestClosure"><a href="#RequestClosure" class="headerlink" title="RequestClosure"></a><strong>RequestClosure</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Moya.swift</span><br><span class="line"></span><br><span class="line">public typealias RequestClosure = (Endpoint&lt;Target&gt;, NSURLRequest -&gt; Void) -&gt; Void123</span><br></pre></td></tr></table></figure>
<p><strong>RequestClosure</strong>这个闭包就是实现将Endpoint -&gt; NSURLRequest，Moya也提供了一个默认实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Moya.swift</span><br><span class="line"></span><br><span class="line">public final class func DefaultRequestMapping(endpoint: Endpoint&lt;Target&gt;, closure: NSURLRequest -&gt; Void) &#123;</span><br><span class="line">      return closure(endpoint.urlRequest)</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure>
<p>默认实现也只是简单地调用endpoint.urlRequest取得一个NSURLRequest实例。然后调用了closure。然而，你可以在这里修改这个请求Request, 事实上这也是Moya给你的最后的机会。举个例子, 你想禁用所有的cookie，并且设置超时时间等。那么你可以实现这样的闭包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let requestClosure = &#123; (endpoint: Endpoint&lt;GitHub&gt;, done: NSURLRequest -&gt; Void) in</span><br><span class="line">    //可以在这里修改request</span><br><span class="line">    let request: NSMutableURLRequest = endpoint.urlRequest.mutableCopy() as NSMutableURLRequest</span><br><span class="line">    request.HTTPShouldHandleCookies = false</span><br><span class="line">    request.timeoutInterval = 20 </span><br><span class="line"></span><br><span class="line">    done(request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider = MoyaProvider(requestClosure: requestClosure)</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure>
<p>从上面可以清晰地看出，<strong>EndpointClosure</strong> 和 <strong>RequestClosure</strong> 实现了 <strong>Target -&gt; Endpoint -&gt; NSRequest</strong>的转换流</p>
<h3 id="StubClosure"><a href="#StubClosure" class="headerlink" title="StubClosure"></a><strong>StubClosure</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Moya.swift</span><br><span class="line"></span><br><span class="line">public typealias StubClosure = Target -&gt; Moya.StubBehavior123</span><br></pre></td></tr></table></figure>
<p><strong>StubClosure</strong>这个闭包比较简单，返回一个<strong>StubBehavior</strong>的枚举值。它就是让你告诉Moya你是否使用Stub返回数据或者怎样使用Stub返回数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Moya.swift</span><br><span class="line"></span><br><span class="line">public enum StubBehavior &#123;</span><br><span class="line">    case Never          //不使用Stub返回数据</span><br><span class="line">    case Immediate      //立即使用Stub返回数据</span><br><span class="line">    case Delayed(seconds: NSTimeInterval) //一段时间间隔后使用Stub返回的数据</span><br><span class="line">&#125;1234567</span><br></pre></td></tr></table></figure>
<p>Never表明不使用Stub来返回模拟的网络数据， Immediate表示马上返回Stub的数据， Delayed是在几秒后返回。Moya默认是不使用Stub来测试。</p>
<p>在Target那一节我们定义了一个AccountAPI, API中我们实现了接口sampleData, 这个属性是返回Stub数据的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">extension AccountAPI: TargetType &#123;</span><br><span class="line">    ...</span><br><span class="line">    var sampleData: NSData &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Login:</span><br><span class="line">            return &quot;&#123;&apos;code&apos;: 1,6&apos;Token&apos;:&apos;123455&apos;&#125;&quot;.dataUsingEncoding(NSUTF8StringEncoding)!</span><br><span class="line">        case .Register(let userName, let passwd):</span><br><span class="line">            return &quot;找不到数据&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let endPointAction = &#123; (target: TargetType) -&gt; Endpoint&lt;AccountAPI&gt; in</span><br><span class="line">    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString</span><br><span class="line"></span><br><span class="line">    switch target &#123;</span><br><span class="line">    case .Login:</span><br><span class="line">        return Endpoint(URL: url, sampleResponseClosure: &#123;.NetworkResponse(200, target.sampleData)&#125;, method: target.method, parameters: target.parameters)</span><br><span class="line">    case .Register:</span><br><span class="line">        return Endpoint(URL: url, sampleResponseClosure: &#123;.NetworkResponse(404, target.sampleData)&#125;, method: target.method, parameters: target.parameters)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let stubAction: (type: AccountAPI) -&gt; Moya.StubBehavior  = &#123; type in</span><br><span class="line">    switch type &#123;</span><br><span class="line">    case .Login:</span><br><span class="line">        return Moya.StubBehavior.Immediate</span><br><span class="line">    case .Register:</span><br><span class="line">        return Moya.StubBehavior.Delayed(seconds: 3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let loginAPIProvider = MoyaProvider&lt;AccountAPI&gt;(</span><br><span class="line">    endpointClosure: endPointAction,</span><br><span class="line">    stubClosure: stubAction</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">self.netProvider = loginAPIProvider</span><br><span class="line">loginAPIProvider.request(AccountAPI.Login(userName: &quot;user&quot;, passwd: &quot;123456&quot;)) &#123; (result) in</span><br><span class="line">    switch result &#123;</span><br><span class="line">    case .Success(let respones) :</span><br><span class="line">        print(respones)</span><br><span class="line"></span><br><span class="line">    case .Failure(_) :</span><br><span class="line">        print(&quot;We got an error&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    print(result)</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748</span><br></pre></td></tr></table></figure>
<p>就这样我们就实现了一个Stub! Login和Register都使用了Stub返回的数据。</p>
<blockquote>
<p>注意：Moya中Provider对象在销毁的时候会去Cancel网络请求。为了得到正确的结果，你必须保证在网络请求的时候你的Provider不会被释放。否者你会得到下面的错误 “But don’t forget to keep a reference for it in property. If it gets deallocated you’ll see -999 “cancelled” error on response” 。通常为了避免这种情况，你可以将Provider实例设置为类成员变量，或者shared实例</p>
</blockquote>
<h3 id="Moya中Stub的实现"><a href="#Moya中Stub的实现" class="headerlink" title="Moya中Stub的实现"></a><strong>Moya中Stub的实现</strong></h3><p>大多iOS的Http的Stub框架本质都是实现一个HTTP网络请求的代理类，去Hook系统Http请求。 如<a href="https://github.com/AliSoftware/OHHTTPStubs" target="_blank" rel="noopener"><strong>OHHTTPStub</strong></a>就是这么做的。在iOS中，HTTP代理类需要继承<strong>NSURLProtocol</strong>类，重载一些父类的方法，然后将这个代理类注册到系统中去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyHttpProxy : NSURLProtocol &#123;</span><br><span class="line">    //重载一些父类的方法</span><br><span class="line">     override class func canInitWithRequest(request: NSURLRequest) -&gt; Bool &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override class func canonicalRequestForRequest(request: NSURLRequest) -&gt; NSURLRequest &#123;</span><br><span class="line">        return super.canonicalRequestForRequest(request)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//注册</span><br><span class="line">NSURLProtocol.registerClass(MyHttpProxy.self) </span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>
<p>之后我们APP中所有的网络请求，都会去经过我们MyHttpProxy的代理类。<br>然而Moya的Stub不是这样的，Moya的Stub的实现原理也超级无敌简单！它不是系统级别的，非入侵式的。它只是简单的加了一个判断而已！还是在Moya的Request方法里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Moya.swift</span><br><span class="line"></span><br><span class="line">public func request(target: Target, queue:dispatch_queue_t?, completion: Moya.Completion) -&gt; Cancellable &#123;</span><br><span class="line">        let endpoint = self.endpoint(target)</span><br><span class="line">        let stubBehavior = self.stubClosure(target)</span><br><span class="line">        var cancellableToken = CancellableWrapper()</span><br><span class="line"></span><br><span class="line">        let performNetworking = &#123; (request: NSURLRequest) in</span><br><span class="line">            if cancellableToken.isCancelled &#123; return &#125;</span><br><span class="line"></span><br><span class="line">            switch stubBehavior &#123;</span><br><span class="line">            case .Never:</span><br><span class="line">                cancellableToken.innerCancellable = self.sendRequest(target, request: request, queue: queue, completion: completion)</span><br><span class="line">            default:</span><br><span class="line">                cancellableToken.innerCancellable = self.stubRequest(target, request: request, completion: completion, endpoint: endpoint, stubBehavior: stubBehavior)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        requestClosure(endpoint, performNetworking)</span><br><span class="line"></span><br><span class="line">        return cancellableToken</span><br><span class="line">    &#125;12345678910111213141516171819202122</span><br></pre></td></tr></table></figure>
<p>Moya先调用我们在构造函数中传入的stubClosure闭包，如果stubBehavior是Never就真正的发起网络请求，否<br>者就调用self.stubRequest</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Moya.swift</span><br><span class="line"></span><br><span class="line">internal func stubRequest(target: Target, request: NSURLRequest, completion: Moya.Completion, endpoint: Endpoint&lt;Target&gt;, stubBehavior: Moya.StubBehavior) -&gt; CancellableToken &#123;</span><br><span class="line">        ...</span><br><span class="line">        let stub: () -&gt; () = createStubFunction(cancellableToken, forTarget: target, withCompletion: completion, endpoint: endpoint, plugins: plugins)</span><br><span class="line">        switch stubBehavior &#123;</span><br><span class="line">        case .Immediate:</span><br><span class="line">            stub()</span><br><span class="line">        case .Delayed(let delay):</span><br><span class="line">            let killTimeOffset = Int64(CDouble(delay) * CDouble(NSEC_PER_SEC))</span><br><span class="line">            let killTime = dispatch_time(DISPATCH_TIME_NOW, killTimeOffset)</span><br><span class="line">            dispatch_after(killTime, dispatch_get_main_queue()) &#123;</span><br><span class="line">                stub()</span><br><span class="line">            &#125;</span><br><span class="line">        case .Never:</span><br><span class="line">            fatalError(&quot;Method called to stub request when stubbing is disabled.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">&#125;1234567891011121314151617181920</span><br></pre></td></tr></table></figure>
<p>如果Immediate，就马上调用stub返回，是Delayed的话就Dispatch after延迟调用。</p>
<h3 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a><strong>Manager</strong></h3><p>我们知道，Moya并不是一个网络请求的三方库，它只是一个抽象的网络层。它对其他网络库的进行了桥接，真正进行网络请求是别人的网络库（比如默认的Alamofire.Manager）<br>为了达到这个目的Moya做了几件事情：</p>
<p>首先抽象了一个<strong>RequestType</strong>协议，利用这个协议将Alamofire隐藏了起来，让Provider类依赖于这个协议，而不是具体细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Plugin.swift</span><br><span class="line"></span><br><span class="line">public protocol RequestType &#123;</span><br><span class="line">    var request: NSURLRequest? &#123; get &#125;</span><br><span class="line"></span><br><span class="line">    func authenticate(user user: String, password: String, persistence: NSURLCredentialPersistence) -&gt; Self</span><br><span class="line"></span><br><span class="line">    func authenticate(usingCredential credential: NSURLCredential) -&gt; Self</span><br><span class="line">&#125;123456789</span><br></pre></td></tr></table></figure>
<p>然后让Moya.Manager == Alamofire.Manager，并且让Alamofire.Manager也实现RequestType协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Moya+Alamofire.swift</span><br><span class="line"></span><br><span class="line">public typealias Manager = Alamofire.Manager</span><br><span class="line"></span><br><span class="line">/// Choice of parameter encoding.</span><br><span class="line">public typealias ParameterEncoding = Alamofire.ParameterEncoding</span><br><span class="line"></span><br><span class="line">//让Alamofire.Manager也实现 RequestType协议</span><br><span class="line">extension Request: RequestType &#123; &#125;123456789</span><br></pre></td></tr></table></figure>
<p>上面几步，就完成了Alamofire的封装、桥接。正因为桥接封装了Alamofire, 因此Moya的request,最终一定会调用Alamofire的request。简单的跟踪下Moya的Request方法就可以发现sendRequest调用了Alamofire。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Moya.swift</span><br><span class="line"></span><br><span class="line">func sendRequest(target: Target, request: NSURLRequest, queue: dispatch_queue_t?, completion: Moya.Completion) -&gt; CancellableToken &#123;</span><br><span class="line">    //调用Alamofire发起网络请求</span><br><span class="line">    let alamoRequest = manager.request(request)</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>
<p>如果你想自定义你自己的Manager, 你可以传入你自己的Manager到Privoder。之后所有的请求都会经过你的这个Manager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let policies: [String: ServerTrustPolicy] = [</span><br><span class="line">    &quot;example.com&quot;: .PinPublicKeys(</span><br><span class="line">        publicKeys: ServerTrustPolicy.publicKeysInBundle(),</span><br><span class="line">        validateCertificateChain: true,</span><br><span class="line">        validateHost: true</span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let manager = Manager(</span><br><span class="line">    configuration: NSURLSessionConfiguration.defaultSessionConfiguration(),</span><br><span class="line">    serverTrustPolicyManager: ServerTrustPolicyManager(policies: policies)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">let provider = MoyaProvider&lt;MyTarget&gt;(manager: manager)1234567891011121314</span><br></pre></td></tr></table></figure>
<h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a><strong>Plugin</strong></h3><p>Moya提供还提供插件机制，你可以自定义各种插件，所有插件必须满足<strong>PluginType</strong>协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Plugin.swift</span><br><span class="line"></span><br><span class="line">public protocol PluginType &#123;</span><br><span class="line">    /// Called immediately before a request is sent over the network (or stubbed).</span><br><span class="line">    func willSendRequest(request: RequestType, target: TargetType)</span><br><span class="line"></span><br><span class="line">    // Called after a response has been received, but before the MoyaProvider has invoked its completion handler.</span><br><span class="line">    func didReceiveResponse(result: Result&lt;Moya.Response, Moya.Error&gt;, target: TargetType)</span><br><span class="line">&#125;123456789</span><br></pre></td></tr></table></figure>
<p>协议里只有两个方法，willSendRequest和didReceiveResponse。在进行网络请求之前和收到请求后，Moya会遍历所有的插件。分别去调用插件各自的willSendRequest和didReceiveResponse方法。</p>
<p>个人觉得这个插件更像是一个网络回调的Delegate，只是取了一个高大上的名字而已。不过将网络回调抽取出来确实能更好地将无关业务隔离，让Privoder更加专心的做自己的事情。而且以后也非常好扩展。</p>
<p>Moya默认提供了三个插件：</p>
<ul>
<li>Authentication插件 (CredentialsPlugin.swift)。 HTTP认证的插件。</li>
<li>Logging插件(NetworkLoggerPlugin.swift)。在调试是，输入网络请求的调试信息到控制台</li>
<li>Network Activity Indicator插件（NetworkActivityPlugin.swift）。可以用这个插件来显示网络菊花</li>
</ul>
<p>Network Activity Indicator插件用法示例，在网络进行请求开始请求时添加一个Spinner, 请求结束隐藏Spinner。这里用的是<a href="https://github.com/icanzilb/SwiftSpinner" target="_blank" rel="noopener"><strong>SwiftSpinner</strong></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let spinerPlugin = NetworkActivityPlugin &#123; state in</span><br><span class="line">    if state == .Began &#123;</span><br><span class="line">        SwiftSpinner.show(&quot;Connecting...&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        SwiftSpinner.show(&quot;request finish...&quot;)</span><br><span class="line">        SwiftSpinner.hide()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">let loginAPIProvider = MoyaProvider&lt;AccountAPI&gt;(</span><br><span class="line">    plugins: [spinerPlugin]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">loginAPIProvider.request(.Login) &#123; _ in &#125;</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure>
<p><strong>插件实现代码</strong></p>
<p>插件的源码实现也超级简单。在进行网络请求之前和收到请求后，遍历所有的插件，调用其相关的接口。只是要分别处理下Stub和真正进行网络请求的两种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//Moya.swift</span><br><span class="line"></span><br><span class="line">func sendRequest(target: Target, request: NSURLRequest, queue: dispatch_queue_t?, completion: Moya.Completion) -&gt; CancellableToken &#123;</span><br><span class="line">        let alamoRequest = manager.request(request)</span><br><span class="line">        let plugins = self.plugins</span><br><span class="line"></span><br><span class="line">        // 遍历插件，通知开始请求</span><br><span class="line">        plugins.forEach &#123; $0.willSendRequest(alamoRequest, target: target) &#125;</span><br><span class="line"></span><br><span class="line">        // Perform the actual request</span><br><span class="line">        alamoRequest.response(queue: queue) &#123; (_, response: NSHTTPURLResponse?, data: NSData?, error: NSError?) -&gt; () in</span><br><span class="line">            let result = convertResponseToResult(response, data: data, error: error)</span><br><span class="line">            // 遍历插件，通知收到请求</span><br><span class="line">            plugins.forEach &#123; $0.didReceiveResponse(result, target: target) &#125;</span><br><span class="line">            completion(result: result)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        alamoRequest.resume()</span><br><span class="line"></span><br><span class="line">        return CancellableToken(request: alamoRequest)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//在测试时，Stub分支的也要，遍历调用一次插件</span><br><span class="line"></span><br><span class="line">internal final func createStubFunction(token: CancellableToken, forTarget target: Target, withCompletion completion: Moya.Completion, endpoint: Endpoint&lt;Target&gt;, plugins: [PluginType]) -&gt; (() -&gt; ()) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            if (token.canceled) &#123;</span><br><span class="line">                let error = Moya.Error.Underlying(NSError(domain: NSURLErrorDomain, code: NSURLErrorCancelled, userInfo: nil))</span><br><span class="line">                //调用插件</span><br><span class="line">                plugins.forEach &#123; $0.didReceiveResponse(.Failure(error), target: target) &#125;</span><br><span class="line">                completion(result: .Failure(error))</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch endpoint.sampleResponseClosure() &#123;</span><br><span class="line">            case .NetworkResponse(let statusCode, let data):</span><br><span class="line">                let response = Moya.Response(statusCode: statusCode, data: data, response: nil)</span><br><span class="line">                //成功情况，调用插件</span><br><span class="line">                plugins.forEach &#123; $0.didReceiveResponse(.Success(response), target: target) &#125;</span><br><span class="line">                completion(result: .Success(response))</span><br><span class="line">            case .NetworkError(let error):</span><br><span class="line">                let error = Moya.Error.Underlying(error)</span><br><span class="line">                //失败情况，调用插件</span><br><span class="line">                plugins.forEach &#123; $0.didReceiveResponse(.Failure(error), target: target) &#125;</span><br><span class="line">                completion(result: .Failure(error))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>总的来说Moya的实现比较简单，但是基于作者这种桥接、封装的思路，使得Moya扩展十分灵活，所以Moya有各种Provider, 能和RxSwift, RAC等等轻松的结合。 而Moya用起来也非常的干净。你不用关心Request具体实现。只用专注于你自己的Target设计就行。再加上Moya的Stub特性，的确使得它十分易于测试。</p>
<h2 id="自己的思考"><a href="#自己的思考" class="headerlink" title="自己的思考"></a>自己的思考</h2><hr>
<p>成也萧何败也萧何。然而我自己的感受，Moya让我们把所有的业务都放到Target中去，也会导致另外一些问题：<br>（以下仅是个人观点，仅供参考）</p>
<ol>
<li><p><strong>枚举无法重载，代码未必简洁</strong><br>比如，现在要添加一个新接口，还是要求实现Login功能，除了支持已有的用户名/密码登录，还要支持指纹登录。那么我们想定义可能想这样：Login(fingerPrint: String)。这两种登录情况实际上只是参数不一样。但在因为枚举中不能重载，所以为了添加这个case，我们不得不重新取一个名字，而不能利用函数重载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum AccountAPI &#123;</span><br><span class="line">case Login(userName: String, passwd: String)</span><br><span class="line">case Register(userName: String, passwd: String)</span><br><span class="line">//case Login(fingerPrint: String) //error: 不能这样添加错的，不支持重载</span><br><span class="line">case LoginWithPrint(fingerPrint: String) //正确. 只能改名</span><br><span class="line">&#125;</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>
<p>我个人觉得这样做，似乎并没有重载简洁。相比修改名字，我更喜欢重载。</p>
</li>
<li><p><strong>Target碎片化，后期维护困难</strong><br>随着业务的增加，Target会变得很复杂。TargetType协议它是利用多个属性：method属性、parameters属性等。将一次API请求的实现的分割到多个了函数（属性）中去实现。这就导致实现碎片化了。添加一个API请求，你需要修改几个函数（属性）， 改几个switch语句。如果文件很长，修改起来真的很烦，根本不好归类整理。</p>
</li>
<li><p><strong>不利于多人协作开发</strong><br>因为大家每次添加新功能，修改的都是这几个相同的函数（属性），所以非常容易导致文件冲突。</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Network </tag>
            
            <tag> Moya </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 使用Moya网络请求]]></title>
      <url>/2018/04/26/iOS%20%E4%BD%BF%E7%94%A8Moya%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
      <content type="html"><![CDATA[<h4 id="Moya简介"><a href="#Moya简介" class="headerlink" title="Moya简介"></a>Moya简介</h4><p><strong>Moya</strong> 是你的 app 中缺失的网络层。不用再去想在哪儿（或者如何）安放网络请求，Moya 替你管理。</p>
<p><strong>Moya</strong>有几个比较好的特性:</p>
<ul>
<li>编译时检查正确的API端点访问.</li>
<li>使你定义不同端点枚举值对应相应的用途更加明晰.</li>
<li>提高测试地位从而使单元测试更加容易.</li>
</ul>
<p>Swift我们用<strong>Alamofire</strong>来做网络库.而<a href="https://link.jianshu.com/?t=https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a>在Alamofire的基础上又封装了一层,如下流程图说明<strong>Moya</strong>的简单工作流程图:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/49368-4bf918cee5f14d1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>简单流程图</p>
<p><strong> Moya</strong>的官方下载地址<a href="https://link.jianshu.com/?t=https://github.com/Moya/Moya" target="_blank" rel="noopener">点我强大的Moya</a>,有具体的使用方法在demo里面有说明。</p>
<p>本文主要介绍一下<strong>Moya</strong>的用法</p>
<ul>
<li>设置请求头部信息</li>
<li>设置超时时间</li>
<li>自定义插件</li>
<li>自签名证书</li>
</ul>
<p>注意：以下所出现的<strong>NetAPIManager</strong>跟官网上demo的<strong> GitHub</strong>是一样类型的文件，都是这个enum实现一个协议TargetType，点进去可以看到TargetType定义了我们发送一个网络请求所需要的东西，什么baseURL，parameter，method等一些计算性属性，我们要做的就是去实现这些东西，当然有带默认值的我们可以不去实现，但是设置头部信息跟超时时间就要修改这些系统默认设置了。</p>
<p>为了看得更加清楚，贴上<strong>NetAPIManager</strong>文件的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  NetAPIManager.swift</span><br><span class="line">//  NN110</span><br><span class="line">//</span><br><span class="line">//  Created by 陈亦海 on 2017/5/12.</span><br><span class="line">//  Copyright © 2017年 陈亦海. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">import Foundation</span><br><span class="line">import Moya</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum NetAPIManager &#123;</span><br><span class="line">    case Show</span><br><span class="line">    case upload(bodyData: Data)</span><br><span class="line">    case download</span><br><span class="line">    case request(isTouch: Bool, body: Dictionary&lt;String, Any&gt;? ,isShow: Bool)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extension NetAPIManager: TargetType &#123;</span><br><span class="line">    var baseURL: URL &#123;//服务器地址</span><br><span class="line">        </span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .request( _, _, _):</span><br><span class="line">            return URL(string: &quot;https://www.pmphmall.com&quot;)!</span><br><span class="line">        default:</span><br><span class="line">            return URL(string: &quot;https://httpbin.org&quot;)!</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var path: String &#123;//具体某个方法的路径</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Show:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        case .upload(_):</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        case .request(_, _, _):</span><br><span class="line">            return &quot;/app/json.do&quot;</span><br><span class="line">        case .download:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var method: Moya.Method &#123;//请求的方法 get或者post之类的</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Show:</span><br><span class="line">            return .get</span><br><span class="line">        case .request(_, _, _):</span><br><span class="line">            return .post</span><br><span class="line">        default:</span><br><span class="line">            return .post</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var parameters: [String: Any]? &#123;//请求的get post给服务器的参数</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Show:</span><br><span class="line">            return nil</span><br><span class="line">        case .request(_, _, _):</span><br><span class="line">            return [&quot;msg&quot;:&quot;H4sIAAAAAAAAA11SSZJFIQi7EqPAEgTvf6TP62W7sMoSQhKSWDrs6ZUKVWogLwYV7RjHFBZJlNlzloN6LVqID4a+puxqRdUKVNLwE1TRcZIC/fjF2rPotuXmb84r1gMXbiASZIZbhQdKEewJlz41znDkujCHuQU3dU7G4/PmVRnwArMLXukBv0J23XVahNO3VX35wlgce6TLUzzgPQJFuHngAczl6VhaNXpmRLxJBlMml6gdLWiXxTdO7I+iEyC7XuTirCQXOk4dotgArgkH/InxVjfNTnE/uY46++hyAiLFuFL4cv1Z8WH5DgB2GnvFXMh5gm53Tr13vqqrEYtcdXfkNsMwKB+9sAQ77grNJmquFWOhfXA/DELlMB0KKFtHOc/ronj1ml+Z7qas82L3VWiCVQ+HEitjTVzoFw8RisFN/jJxBY4awvq427McXqnyrfCsl7oeEU6wYgW9yJtj1lOkx0ELL5Fw4z071NaVzRA9ebxWXkFyothgbB445cpRmTC+//F73r1kOyQ3lTpec12XNDR00nnq5/YmJItW3+w1z27lSOLqgVctrxG4xdL9WVPdkH1tkiZ/pUKBGhADAAA=&quot;]</span><br><span class="line">        default:</span><br><span class="line">            return nil</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var sampleData: Data &#123; //编码转义</span><br><span class="line">       return &quot;&#123;&#125;&quot;.data(using: String.Encoding.utf8)!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var task: Task &#123; //一个请求任务事件</span><br><span class="line">        </span><br><span class="line">        switch self &#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        case let .upload(data):</span><br><span class="line">        return .upload(.multipart([MultipartFormData(provider: .data(data), name: &quot;file&quot;, fileName: &quot;gif.gif&quot;, mimeType: &quot;image/gif&quot;)]))</span><br><span class="line">            </span><br><span class="line">        default:</span><br><span class="line">            return .request</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    var parameterEncoding: ParameterEncoding &#123;//编码的格式</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .request(_, _, _):</span><br><span class="line">            return URLEncoding.default</span><br><span class="line">        default:</span><br><span class="line">            return URLEncoding.default</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //以下两个参数是我自己写，用来控制网络加载的时候是否允许操作，跟是否要显示加载提示，这两个参数在自定义插件的时候会用到</span><br><span class="line">    var touch: Bool &#123; //是否可以操作</span><br><span class="line">        </span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .request(let isTouch, _, _):</span><br><span class="line">            return isTouch</span><br><span class="line">        default:</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var show: Bool &#123; //是否显示转圈提示</span><br><span class="line">        </span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .request( _, _,let isShow):</span><br><span class="line">            return isShow</span><br><span class="line">        default:</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何设置Moya请求头部信息"><a href="#如何设置Moya请求头部信息" class="headerlink" title="如何设置Moya请求头部信息"></a>如何设置<strong>Moya</strong>请求头部信息</h2><p>头部信息的设置在开发过程中很重要，如服务器生成的token，用户唯一标识等<br>我们直接上代码，不说那么多理论的东西，哈哈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// MARK: - 设置请求头部信息</span><br><span class="line">let myEndpointClosure = &#123; (target: NetAPIManager) -&gt; Endpoint&lt;NetAPIManager&gt; in</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    let url = target.baseURL.appendingPathComponent(target.path).absoluteString</span><br><span class="line">    let endpoint = Endpoint&lt;NetAPIManager&gt;(</span><br><span class="line">        url: url,</span><br><span class="line">        sampleResponseClosure: &#123; .networkResponse(200, target.sampleData) &#125;,</span><br><span class="line">        method: target.method,</span><br><span class="line">        parameters: target.parameters,</span><br><span class="line">        parameterEncoding: target.parameterEncoding</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    //在这里设置你的HTTP头部信息</span><br><span class="line">    return endpoint.adding(newHTTPHeaderFields: [</span><br><span class="line">        &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">        &quot;ECP-COOKIE&quot; : &quot;&quot;</span><br><span class="line">        ])</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何设置请求超时时间"><a href="#如何设置请求超时时间" class="headerlink" title="如何设置请求超时时间"></a>如何设置请求超时时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// MARK: - 设置请求超时时间</span><br><span class="line">let requestClosure = &#123; (endpoint: Endpoint&lt;NetAPIManager&gt;, done: @escaping MoyaProvider&lt;NetAPIManager&gt;.RequestResultClosure) in</span><br><span class="line">    </span><br><span class="line">    guard var request = endpoint.urlRequest else &#123; return &#125;</span><br><span class="line">    </span><br><span class="line">    request.timeoutInterval = 30    //设置请求超时时间</span><br><span class="line">    done(.success(request))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h2><p>自定义插件必须<strong>PluginType</strong>协议的两个方法willSend与didReceive</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  MyNetworkActivityPlugin.swift</span><br><span class="line">//  NN110</span><br><span class="line">//</span><br><span class="line">//  Created by 陈亦海 on 2017/5/10.</span><br><span class="line">//  Copyright © 2017年 CocoaPods. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">import Foundation</span><br><span class="line">import Result</span><br><span class="line">import Moya</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// Network activity change notification type.</span><br><span class="line">public enum MyNetworkActivityChangeType &#123;</span><br><span class="line">    case began, ended</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Notify a request&apos;s network activity changes (request begins or ends).</span><br><span class="line">public final class MyNetworkActivityPlugin: PluginType &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public typealias MyNetworkActivityClosure = (_ change: MyNetworkActivityChangeType, _ target: TargetType) -&gt; Void</span><br><span class="line">    let myNetworkActivityClosure: MyNetworkActivityClosure</span><br><span class="line">    </span><br><span class="line">    public init(newNetworkActivityClosure: @escaping MyNetworkActivityClosure) &#123;</span><br><span class="line">        self.myNetworkActivityClosure = newNetworkActivityClosure</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // MARK: Plugin</span><br><span class="line">    </span><br><span class="line">    /// Called by the provider as soon as the request is about to start</span><br><span class="line">    public func willSend(_ request: RequestType, target: TargetType) &#123;</span><br><span class="line">        myNetworkActivityClosure(.began,target)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// Called by the provider as soon as a response arrives, even if the request is cancelled.</span><br><span class="line">    public func didReceive(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) &#123;</span><br><span class="line">        myNetworkActivityClosure(.ended,target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用自定义插件方法"><a href="#使用自定义插件方法" class="headerlink" title="使用自定义插件方法"></a>使用自定义插件方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// MARK: - 自定义的网络提示请求插件</span><br><span class="line">let myNetworkPlugin = MyNetworkActivityPlugin &#123; (state,target) in</span><br><span class="line">    if state == .began &#123;</span><br><span class="line">        //        SwiftSpinner.show(&quot;Connecting...&quot;)</span><br><span class="line">        </span><br><span class="line">        let api = target as! NetAPIManager</span><br><span class="line">        if api.show &#123;</span><br><span class="line">            print(&quot;我可以在这里写加载提示&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if !api.touch &#123;</span><br><span class="line">            print(&quot;我可以在这里写禁止用户操作，等待请求结束&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(&quot;我开始请求\(api.touch)&quot;)</span><br><span class="line">        </span><br><span class="line">        UIApplication.shared.isNetworkActivityIndicatorVisible = true</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //        SwiftSpinner.show(&quot;request finish...&quot;)</span><br><span class="line">        //        SwiftSpinner.hide()</span><br><span class="line">        print(&quot;我结束请求&quot;)</span><br><span class="line">        UIApplication.shared.isNetworkActivityIndicatorVisible = false</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h1><p>在16年的WWDC中，Apple已表示将从2017年1月1日起，<strong>所有新提交的App必须强制性应用HTTPS协议来进行网络请求。</strong>默认情况下非HTTPS的网络访问是禁止的并且不能再通过简单粗暴的向Info.plist中添加NSAllowsArbitraryLoads<br>设置绕过ATS(App Transport Security)的限制（否则须在应用审核时进行说明并很可能会被拒）。所以还未进行相应配置的公司需要尽快将升级为HTTPS的事项提上进程了。本文将简述HTTPS及配置数字证书的原理并以配置实例和出现的问题进行说明，希望能对你提供帮助。(比心~)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1644286-54496771bcca464d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1644286-757b5df7d56bc86f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/648" alt="img"></p>
<ol>
<li>一种是向权威认证机构购买的证书，服务端使用该种证书时，因为苹果系统内置了其受信任的签名根证书，所以客户端不需额外的配置。为了证书安全，在证书发布机构公布证书时，证书的指纹算法都会加密后再和证书放到一起公布以防止他人伪造数字证书。而证书机构使用自己的私钥对其指纹算法加密，可以用内置在操作系统里的机构签名根证书来解密，以此保证证书的安全。</li>
<li>另一种是自己制作的证书，即自签名证书。好处是不需要花钱购2买，但使用这种证书是不会受信任的，所以<strong>需要我们在代码中将该证书配置为信任证书.</strong></li>
</ol>
<p>自签名证书具体实现:<br>我们在使用自签名证书来实现HTTPS请求时，因为不像机构颁发的证书一样其签名根证书在系统中已经内置了，所以我们需要在App中内置自己服务器的签名根证书来验证数字证书。首先将服务端生成的.cer格式的根证书添加到项目中，注意在添加证书要一定要记得勾选要添加的targets。<strong>这里有个地方要注意</strong>：苹果的ATS要求服务端必须支持TLS 1.2或以上版本；必须使用支持前向保密的密码；证书必须使用SHA-256或者更好的签名hash算法来签名，如果证书无效，则会导致连接失败。由于我在生成的根证书时签名hash算法低于其要求，在配置完请求时一直报<em>NSURLErrorServerCertificateUntrusted</em> = -1202错误，希望大家可以注意到这一点。</p>
<p>那么如何在Moya中使用自签名的证书来实现HTTPS网络请求呢，请期待下回我专门分享……需要自定义一个Manager管理</p>
<h1 id="综合使用的方法如下"><a href="#综合使用的方法如下" class="headerlink" title="综合使用的方法如下"></a>综合使用的方法如下</h1><h2 id="定义一个公用的Moya请求服务对象"><a href="#定义一个公用的Moya请求服务对象" class="headerlink" title="定义一个公用的Moya请求服务对象"></a>定义一个公用的<strong>Moya</strong>请求服务对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">let MyAPIProvider = MoyaProvider&lt;NetAPIManager&gt;(endpointClosure: myEndpointClosure,requestClosure: requestClosure, plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter),myNetworkPlugin])</span><br><span class="line"></span><br><span class="line">// MARK: -创建一个Moya请求</span><br><span class="line">func sendRequest(_ postDict: Dictionary&lt;String, Any&gt;? = nil,</span><br><span class="line">                 success:@escaping (Dictionary&lt;String, Any&gt;)-&gt;(),</span><br><span class="line">                 failure:@escaping (MoyaError)-&gt;()) -&gt; Cancellable? &#123;</span><br><span class="line">    </span><br><span class="line">   let request = MyAPIProvider.request(.Show) &#123; result in    </span><br><span class="line">        switch result &#123;</span><br><span class="line">        case let .success(moyaResponse):</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            do &#123;</span><br><span class="line">                let any = try moyaResponse.mapJSON()</span><br><span class="line">                let data =  moyaResponse.data</span><br><span class="line">                let statusCode =  moyaResponse.statusCode</span><br><span class="line">                MyLog(&quot;\(data) --- \(statusCode) ----- \(any)&quot;)</span><br><span class="line">                </span><br><span class="line">                success([&quot;&quot;:&quot;&quot;])</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            &#125; catch &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        case let .failure(error):</span><br><span class="line">            </span><br><span class="line">            print(error)</span><br><span class="line">            failure(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取消所有的Moya请求"><a href="#取消所有的Moya请求" class="headerlink" title="取消所有的Moya请求"></a>取消所有的Moya请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// MARK: -取消所有请求</span><br><span class="line">func cancelAllRequest() &#123;</span><br><span class="line">//    MyAPIProvider.manager.session.invalidateAndCancel()  //取消所有请求</span><br><span class="line">    MyAPIProvider.manager.session.getTasksWithCompletionHandler &#123; dataTasks, uploadTasks, downloadTasks in</span><br><span class="line">        dataTasks.forEach &#123; $0.cancel() &#125;</span><br><span class="line">        uploadTasks.forEach &#123; $0.cancel() &#125;</span><br><span class="line">        downloadTasks.forEach &#123; $0.cancel() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //let sessionManager = Alamofire.SessionManager.default</span><br><span class="line">    //sessionManager.session.getTasksWithCompletionHandler &#123; dataTasks, uploadTasks, downloadTasks in</span><br><span class="line">    //    dataTasks.forEach &#123; $0.cancel() &#125;</span><br><span class="line">    //    uploadTasks.forEach &#123; $0.cancel() &#125;</span><br><span class="line">    //    downloadTasks.forEach &#123; $0.cancel() &#125;</span><br><span class="line">    //&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Moya </tag>
            
            <tag> NetWork </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Moya设计]]></title>
      <url>/2018/04/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Moya%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h2 id="关于Moya"><a href="#关于Moya" class="headerlink" title="关于Moya"></a>关于Moya</h2><p>Moya是一个网络抽象层，它在底层将Alamofire进行封装，对外提供更简洁的接口供开发者调用。在以往的Objective-C中，大部分开发者会使用AFNetwork进行网络请求，当业务复杂一些时，会对AFNetwork进行二次封装，编写一个适用于自己项目的网络抽象层。在Objective-C中，有著名的<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fyuantiku%2FYTKNetwork" target="_blank" rel="noopener">YTKNetwork</a>，它将AFNetworking封装成抽象父类，然后根据每一种不同的网络请求，都编写不同的子类，子类继承父类，来实现请求业务。Moya在项目层次中的地位，有点类似于YTKNetwork。可以看下图对比</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612dcff3e63b1cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="面向协议编程（POP）"><a href="#面向协议编程（POP）" class="headerlink" title="面向协议编程（POP）"></a>面向协议编程（POP）</h2><p>在阅读Moya源码之前，如果对POP有一定了解，那么理解其Moya会事半功倍的效果。在Objective-C也有协议，一般是让对象遵守协议，然后实现协议规定的方法，通过这种方式来对类实现扩展。POP其实就是把这种思路进一步强化。很多时候事物具备多样化的特质，而这些特质是无法单纯从一个类中继承而来的。为了解决这个痛点，C++有了多继承，即一个子类可以继承多种父类，这些被继承的父类之间不一定有关联。但是这依然会有其他问题，比如子类继承父类后，不一定需要用到所有的父类方法和属性，等于子类拥有了一些毫无用处的属性和方法。比如父类进行了修改，那么很难避免影响到子类。C++的多继承还会带来<code>菱形缺陷</code>，什么是<code>菱形缺陷</code>？本节的下方我会放两个链接，方便大家查阅。而Swift则引入了面向协议编程，通过协议来规定事物的实现。通过遵守不同的协议，来对一个类或者结构体或者枚举进行定制，它只需要实现协议所规定的属性或方法即可，有点类似于搭建积木，取每一块有需求的模块，进行组合拼接，相对于OOP，其耦合性更低，也为代码的维护和拓展提供更多的可能性。关于POP思想大致是这样，下面是王巍关于POP的两篇文章，值得读一番。 <a href="https://link.juejin.im/?target=https%3A%2F%2Fonevcat.com%2F2016%2F11%2Fpop-cocoa-1%2F" target="_blank" rel="noopener">面向协议编程与 Cocoa 的邂逅 (上)</a> <a href="https://link.juejin.im/?target=https%3A%2F%2Fonevcat.com%2F2016%2F12%2Fpop-cocoa-2%2F" target="_blank" rel="noopener">面向协议编程与 Cocoa 的邂逅 (下)</a></p>
<h2 id="Moya的模块组成"><a href="#Moya的模块组成" class="headerlink" title="Moya的模块组成"></a>Moya的模块组成</h2><p>由于Moya是使用POP来设计的一个网络抽象层，因此他整体的逻辑结构并没有明显的继承关系。Moya的核心代码，可以分成以下几个模块</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612dbe2be371e0a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>provider是一个提供网络请求服务的提供者。通过一些初始化配置之后，在外部可以直接用provider来发起request。</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>在使用Moya进行网络请求时，第一步需要进行配置，来生成一个Request。首先按照官方文档，创建一个枚举，遵守TargetType协议，并实现协议所规定的属性。为什么要创建枚举来遵守协议，而不像Objective-C那样创建类来遵守协议呢？其实使用类或者结构体也是可以的，这里猜测使用枚举的原因是因为swift的枚举功能比Objective-C强大许多，枚举结合switch语句，使得API管理起来比较方便。 Request的生成过程如下图</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612dbedd7bdfe2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">baseURL</span><br><span class="line">path</span><br><span class="line">method</span><br><span class="line">sampleData</span><br><span class="line">task</span><br><span class="line">headers</span><br></pre></td></tr></table></figure>
<p>提供了这些网络请求的“基本材料”之后，就可以进一步配置去生成所需要的请求。看上图的第一个箭头，通过了一个EndpointClosure生成了endPoint。endPoit是一个对象，把网络请求所需的一些属性和方法进行了包装，在EndPoint类中有如下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public typealias SampleResponseClosure = () -&gt; EndpointSampleResponse</span><br><span class="line"></span><br><span class="line">open let url: String</span><br><span class="line">open let sampleResponseClosure: SampleResponseClosure</span><br><span class="line">open let method: Moya.Method</span><br><span class="line">open let task: Task</span><br><span class="line">open let httpHeaderFields: [String: String]?</span><br></pre></td></tr></table></figure>
<p>可以很直观地看出来，EndPoint这几个属性可以和上面通过TargetTpye配置的变量对应起来。那么这个过程在代码中做了哪些事？ 在MoyaProvider类里，有如下声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// Closure that defines the endpoints for the provider.</span><br><span class="line">   public typealias EndpointClosure = (Target) -&gt; Endpoint&lt;Target&gt;</span><br><span class="line">   </span><br><span class="line">   open let endpointClosure: EndpointClosure</span><br></pre></td></tr></table></figure>
<p>声明了一个闭包，参数为Target，它是一个泛型，然后返回一个EndPoint。endPoint是一个类，它对请求的参数和动作进行了包装，下面会对它进行详细说明，先继续看endpointClosure做了什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping</span><br></pre></td></tr></table></figure>
<p>在MoyaProvider的初始化方法里，调用其扩展的类方法<code>defaultEndpointMapping</code>输入Target作为参数，返回了一个endPoint对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class func defaultEndpointMapping(for target: Target) -&gt; Endpoint&lt;Target&gt; &#123;</span><br><span class="line">    return Endpoint(</span><br><span class="line">        url: URL(target: target).absoluteString,</span><br><span class="line">        sampleResponseClosure: &#123; .networkResponse(200, target.sampleData) &#125;,</span><br><span class="line">        method: target.method,</span><br><span class="line">        task: target.task,</span><br><span class="line">        httpHeaderFields: target.headers</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Target就是一开始进行配置的枚举，通过点语法取出Target的变量，完成endPoint的初始化。这里可能对于url和sampleResponseClosure会感到一些疑惑。url初始化，可以进入<code>URL+Moya.swift</code>查看，它对NSURL类进行构造器的扩展，让其具备根据Moya的TargetType来进行初始化的能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// Initialize URL from Moya&apos;s `TargetType`.</span><br><span class="line"> init&lt;T: TargetType&gt;(target: T) &#123;</span><br><span class="line">     // When a TargetType&apos;s path is empty, URL.appendingPathComponent may introduce trailing /, which may not be wanted in some cases</span><br><span class="line">     if target.path.isEmpty &#123;</span><br><span class="line">         self = target.baseURL</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         self = target.baseURL.appendingPathComponent(target.path)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>sampleResponseClosure是一个和网络请求返回假数据相关的闭包，这里可以先忽略，不影响对Moya生成Request过程的理解。 我们知道了MoyaProvider.defaultEndpointMapping可以返回endPoint对象后，重新看一遍这句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping</span><br></pre></td></tr></table></figure>
<p>使用@escaping把endpointClosure声明为逃逸闭包，我们可以把</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EndpointClosure = MoyaProvider.defaultEndpointMapping</span><br></pre></td></tr></table></figure>
<p>转换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Target) -&gt; Endpoint&lt;Target&gt; = func defaultEndpointMapping(for target: Target) -&gt; Endpoint&lt;Target&gt;</span><br></pre></td></tr></table></figure>
<p>再进一步转换，等号左边的可以写成一个常规的闭包表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;(Target)-&gt;Endpoint&lt;Target&gt; in</span><br><span class="line">	return Endpoint(</span><br><span class="line">            url: URL(target: target).absoluteString,</span><br><span class="line">            sampleResponseClosure: &#123; .networkResponse(200, target.sampleData) &#125;,</span><br><span class="line">            method: target.method,</span><br><span class="line">            task: target.task,</span><br><span class="line">            httpHeaderFields: target.headers</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即endpointClosure这个闭包，传入了Target作为参数，该闭包可以返回一个endPoint对象,如何获取到闭包返回的endPoint对象？MoyaProvider提供了这么一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// Returns an `Endpoint` based on the token, method, and parameters by invoking the `endpointClosure`.</span><br><span class="line">open func endpoint(_ token: Target) -&gt; Endpoint&lt;Target&gt; &#123;</span><br><span class="line">    return endpointClosure(token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是关于TargetType通过endpointClosure转化为endPoint的过程。</p>
<p>下一步就是把利用requestClosure，传入endPoint，然后生成request。request生成过程和endPoint很相似。</p>
<p>在MoyaProvider中声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/// Closure that decides if and what request should be performed</span><br><span class="line">  public typealias RequestResultClosure = (Result&lt;URLRequest, MoyaError&gt;) -&gt; Void</span><br><span class="line">  open let requestClosure: RequestClosure</span><br></pre></td></tr></table></figure>
<p>然后在MoyaProvider的初始化方法里有很相似的一句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping,</span><br></pre></td></tr></table></figure>
<p>进入查看defaultRequestMapping方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class func defaultRequestMapping(for endpoint: Endpoint&lt;Target&gt;, closure: RequestResultClosure) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        let urlRequest = try endpoint.urlRequest()</span><br><span class="line">        closure(.success(urlRequest))</span><br><span class="line">    &#125; catch MoyaError.requestMapping(let url) &#123;</span><br><span class="line">        closure(.failure(MoyaError.requestMapping(url)))</span><br><span class="line">    &#125; catch MoyaError.parameterEncoding(let error) &#123;</span><br><span class="line">        closure(.failure(MoyaError.parameterEncoding(error)))</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        closure(.failure(MoyaError.underlying(error, nil)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和endpointClosure类似，我们经过转换，可以得到requestClosure的表达式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;(endpoint:Endpoint&lt;Target&gt;, closure:RequestResultClosure) in</span><br><span class="line">   do &#123;</span><br><span class="line">       let urlRequest = try endpoint.urlRequest()</span><br><span class="line">       closure(.success(urlRequest))</span><br><span class="line">   &#125; catch MoyaError.requestMapping(let url) &#123;</span><br><span class="line">       closure(.failure(MoyaError.requestMapping(url)))</span><br><span class="line">   &#125; catch MoyaError.parameterEncoding(let error) &#123;</span><br><span class="line">       closure(.failure(MoyaError.parameterEncoding(error)))</span><br><span class="line">   &#125; catch &#123;</span><br><span class="line">       closure(.failure(MoyaError.underlying(error, nil)))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体上使用do-catch语句来初始化一个urlRequest，根据不同结果向闭包传入不同的参数。一开始使用try来调用endpoint.urlRequest()，如果抛出错误，会切换到catch语句中去。endpoint.urlRequest()这个方法比较长，这里就不放出来，感兴趣可自行到Moya核心代码里的Endpoint.swift里查看。它其实做的事情很简单，就是根据前面说到的endpoint的那些属性来初始化一个NSURLRequest的对象。</p>
<p>以上就是上方图中所画的，根据TargetType最终生成Request的过程。很多人会感到疑惑，为什么搞得这么麻烦，直接一步到位，传一些必要参数生成Request不就完了？为什么还要再增加endPoint这么一个节点？根据Endpoint类所提供的一些方法来看，个人认为应该是为了更灵活地配置网络请求，以适应更多样化的业务需求。Endpoint类还有几个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with added HTTP header fields.</span><br><span class="line">open func adding(newHTTPHeaderFields: [String: String]) -&gt; Endpoint&lt;Target&gt; </span><br><span class="line"></span><br><span class="line">    /// Convenience method for creating a new `Endpoint` with the same properties as the receiver, but with replaced `task` parameter.</span><br><span class="line">open func replacing(task: Task) -&gt; Endpoint&lt;Target&gt;</span><br></pre></td></tr></table></figure>
<p>借用这些方法，在endpointClosure中可以给一些网络请求添加请求头，替换请求参数，让这些请求配置更加灵活。</p>
<p>我们看完了整个Request生成过程，那么通过requestClosure生成的的Request是如何被外部拿到的呢？这就是我们下一步要探讨的，Provider发送请求实现过程。在下一节里将会看到如何使用这个Request。</p>
<h3 id="Provider发送请求"><a href="#Provider发送请求" class="headerlink" title="Provider发送请求"></a>Provider发送请求</h3><p>我们再来看一下官方文档里说明的Moya的基本使用步骤</p>
<ol>
<li>创建枚举，遵守TargetType协议，实现规定的属性。</li>
<li>初始化 <code>provider = MoyaProvider&lt;Myservice&gt;()</code></li>
<li>调用provider.request，在闭包里处理请求结果。</li>
</ol>
<p>其中第一步我们在上方已经说明完了，MoyaProvider的初始化我们只说明了一小部分。在此不准备一口气初始化方法中剩余的部分讲完，这又会涉及很多东西，同时理解起来会比较麻烦。在后面的代码解读中，如果有涉及到相关属性，再回到初始化方法中一个一个突破。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">open func request(_ target: Target,</span><br><span class="line">                  callbackQueue: DispatchQueue? = .none,</span><br><span class="line">                  progress: ProgressBlock? = .none,</span><br><span class="line">                  completion: @escaping Completion) -&gt; Cancellable &#123;</span><br><span class="line"></span><br><span class="line">    let callbackQueue = callbackQueue ?? self.callbackQueue</span><br><span class="line">    return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接从这里可能看不出什么，再追溯到<code>requestNormal</code>中去 这个方法内容比较长，其中一些插件相关的代码，和测试桩的代码，暂且跳过不做说明，暂时不懂他们并不会成为理解provider.request的阻碍，它们属于可选内容，而不是必须的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let endpoint = self.endpoint(target)</span><br></pre></td></tr></table></figure>
<p>生成了endPoint对象，这个很好理解，前面已经做过说明。 查看<code>performNetworking</code>闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if cancellableToken.isCancelled &#123;</span><br><span class="line">          self.cancelCompletion(pluginsWithCompletion, target: target)</span><br><span class="line">          return</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>如果取消请求，则调用取消完成的回调，并return,不在执行闭包内下面的语句。 在这个闭包里传入了参数<code>(requestResult: Result&lt;URLRequest, MoyaError&gt;)</code>，这里用到了<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fantitypical%2FResult" target="_blank" rel="noopener">Result</a>,想深入了解，可自行研究，这里简单说一下Result是干什么的。Result使用枚举方式，提供一些运行处理的结果,如下，很容易能看懂它所表达的意思。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch requestResult &#123;</span><br><span class="line">         case .success(let urlRequest):</span><br><span class="line">             request = urlRequest</span><br><span class="line">         case .failure(let error):</span><br><span class="line">             pluginsWithCompletion(.failure(error))</span><br><span class="line">             return</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>如果请求成功，会拿到URLRequest，如果失败，会使用插件去处理失败回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Allow plugins to modify request</span><br><span class="line">let preparedRequest = self.plugins.reduce(request) &#123; $1.prepare($0, target: target) &#125;</span><br></pre></td></tr></table></figure>
<p>使用插件对请求进行完善</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cancellableToken.innerCancellable = self.performRequest(target, request: preparedRequest, callbackQueue: callbackQueue, progress: progress, completion: networkCompletion, endpoint: endpoint, stubBehavior: stubBehavior)</span><br></pre></td></tr></table></figure>
<p>这里的<code>self.performRequest</code>就是进行实际的网络请求，内部代码比较多，但是思路很简单，使用Alamofire的SessionManager来发送请求。 配置完成后就可以调用<code>requestClosure(endpoint, performNetworking)</code>，执行这个闭包获取到上方所说的Request，来执行具体的网络请求了。</p>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>在使用Alamofire发送请求时，定义了闭包来处理请求的响应。Response这个类对于请求结果，提供了一些加工方法，比如data转json,图片转换等。</p>
<h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>Moya提供了一个插件协议<code>PluginType</code>，协议里规定了几种方法，阐明了插件的应用区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// Called to modify a request before sending</span><br><span class="line">   func prepare(_ request: URLRequest, target: TargetType) -&gt; URLRequest</span><br><span class="line"></span><br><span class="line">   /// Called immediately before a request is sent over the network (or stubbed).</span><br><span class="line">   func willSend(_ request: RequestType, target: TargetType)</span><br><span class="line"></span><br><span class="line">   /// Called after a response has been received, but before the MoyaProvider has invoked its completion handler.</span><br><span class="line">   func didReceive(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span><br><span class="line"></span><br><span class="line">   /// Called to modify a result before completion</span><br><span class="line">   func process(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) -&gt; Result&lt;Moya.Response, MoyaError&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>prepare</code>可以在请求之前对request进行修改。</p>
</li>
<li><p><code>willSend</code>在请求发送之前的一瞬间调用，这个可以用来添加请求时转圈圈的Toast</p>
</li>
<li><p><code>didReceive</code>在接收到请求响应时，且MoyaProvider的completion handler之前调用。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process</span><br></pre></td></tr></table></figure>
<p>在completion handler之前调用，用来修改请求结果 可以通过以下图来直观地理解插件调用时机</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/25/1612dc3d457ac445?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>使用插件的方式，让代码仅保持着主干逻辑，使用者根据业务需求自行加入插件来配置自己的网络业务层，这样做更加灵活，低耦合。Moya提供了4种插件</p>
</li>
<li><p>AccessTokenPlugin OAuth的Token验证</p>
</li>
<li><p>CredentialsPlugin 证书</p>
</li>
<li><p>NetworkActivityPlugin 网络请求状态</p>
</li>
<li><p>NetworkLoggerPlugin 网络日志 可以根据需求编写自己的插件，选取NetworkActivityPlugin来查看插件内部构成。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class NetworkActivityPlugin: PluginType &#123;</span><br><span class="line"></span><br><span class="line">    public typealias NetworkActivityClosure = (_ change: NetworkActivityChangeType, _ target: TargetType) -&gt; Void</span><br><span class="line">    let networkActivityClosure: NetworkActivityClosure</span><br><span class="line"></span><br><span class="line">    public init(networkActivityClosure: @escaping NetworkActivityClosure) &#123;</span><br><span class="line">        self.networkActivityClosure = networkActivityClosure</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public func willSend(_ request: RequestType, target: TargetType) &#123;</span><br><span class="line">        networkActivityClosure(.began, target)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public func didReceive(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) &#123;</span><br><span class="line">        networkActivityClosure(.ended, target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插件内部结构很简单，除了自行定义的一些变量外，就是遵守<code>PluginType</code>协议后，去实现协议规定的方法，在特定方法内做自己需要做的事。因为<code>PluginType</code>它已经有一个协议扩展，把方法的默认实现都完成了，在具体插件内不一定需要实现所有的协议方法，仅根据需要实现特定方法即可。 写好插件之后，使用起来也比较简答，MoyaProvider的初始化方法中，有个形参<code>plugins: [PluginType] = []</code>，把网络请求中需要用到的插件加入数组中。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Network </tag>
            
            <tag> Moya </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift网络请求（Moya篇）]]></title>
      <url>/2018/04/26/Swift%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%88Moya%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="Swift网络请求（Moya篇）"><a href="#Swift网络请求（Moya篇）" class="headerlink" title="Swift网络请求（Moya篇）"></a><a href="http://www.cnblogs.com/jadonblog/p/6945974.html" target="_blank" rel="noopener">Swift网络请求（Moya篇）</a></h2><p>　　在使用<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a>进行网络请求的时候，相信大部分的同学都会封装一个抽象的NetworkLayer，如”APIManager” 或者 “NetworkModel”等等。但是位置业务功能增加，会渐渐混合各种请求，不够清晰，而Moya能很好地解决这类问题。Moya在Alamofire基础上进行封装，是一个允许高度自定义的网络层，可以根据具体的需求进行接口的设置。具体的介绍可以参考Moya的<a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">官方链接</a>，结构图如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/1177038/201706/1177038-20170605145011934-501739786.png" alt="img"></p>
<p>　　接下来就介绍一下Moya的一些常见的用法：</p>
<p>（一）根据业务需求创建具体请求：</p>
<p>　　打比方现在我们需要书写账户的相关接口，如Login、userInfo。那么首先我们得创建AccountService:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum AccountService &#123;</span><br><span class="line">    case login(phoneNum: NSInteger,passWord: NSInteger)</span><br><span class="line">    case logout</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　然后让AccountService实现TargetType协议，定义请求需要的基本信息：</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">extension AccountService: TargetType &#123;</span><br><span class="line">    var baseURL: URL &#123;</span><br><span class="line">        return URL(string: ServiceBaseURL)!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var path: String &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .login(_, _):</span><br><span class="line">            return &quot;accountService/login&quot;</span><br><span class="line">        case .logout:</span><br><span class="line">            return &quot;accountService/logout&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var method: Moya.Method &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .login(_, _):</span><br><span class="line">            return .post</span><br><span class="line">        case .logout:</span><br><span class="line">            return .get</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var parameters: [String: Any]? &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .login(let phoneNum, let passWord):</span><br><span class="line">            return [&quot;phoneNum&quot;: phoneNum, &quot;passWord&quot;: passWord]</span><br><span class="line">        case .logout:</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var parameterEncoding: ParameterEncoding &#123;</span><br><span class="line">        return JSONEncoding.default // Send parameters as JSON in request body</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var sampleData: Data &#123;</span><br><span class="line">        return &quot;&quot;.data(using: .utf8)!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var task: Task &#123;</span><br><span class="line">        return .request</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>　　如上我们就已经完成了网络请求所需要的一个<code>endpoint</code>。接着通过Moya提供一个发送请求的<code>Provider就完成了基本的使用：</code></p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let provider = MoyaProvider&lt;AccountService&gt;()</span><br><span class="line"></span><br><span class="line">provider.request(.login(phoneNum: 12345678901, passWord: 123456)) &#123; result in</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    switch result &#123;</span><br><span class="line">    case let .success(response):</span><br><span class="line">        //...............</span><br><span class="line">        break</span><br><span class="line">    case let .failure(error):</span><br><span class="line">        //...............</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>（二）通过HTTPHeader设置公共请求参数</p>
<p>　　在实际开发中我们可能会需要在请求头内添加一些公共请求参数，如用于识别一些平台标志、辨别接口的版本号。你可以定义一个Endpoint的闭包，</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let publicParamEndpointClosure = &#123; (target: AccountService) -&gt; Endpoint&lt;AccountService&gt; in</span><br><span class="line">            let url = target.baseURL.appendingPathComponent(target.path).absoluteString</span><br><span class="line">            let endpoint = Endpoint&lt;AccountService&gt;(url: url, sampleResponseClosure: &#123; .networkResponse(200, target.sampleData) &#125;, method: target.method, parameters: target.parameters, parameterEncoding: target.parameterEncoding)</span><br><span class="line">            return endpoint.adding(newHTTPHeaderFields: [&quot;x-platform&quot; : &quot;iOS&quot;, &quot;x-interface-version&quot; : &quot;1.0&quot;])</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>　　然后在创建请求的<code>Provider把它添加上去，</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let provider = MoyaProvider(endpointClosure: publicParamEndpointClosure)</span><br></pre></td></tr></table></figure>
<p>（三）通过插件的方式监听网络状态</p>
<p>　　通常我们会在进行网络请求的时候进行一些状态展示，如loading，那么你可以通过插件的方式来实现。Moya默认有4个插件:</p>
<ul>
<li>AccessTokenPlugin 管理AccessToken的插件</li>
<li>CredentialsPlugin 管理认证的插件</li>
<li>NetworkActivityPlugin 管理网络状态的插件</li>
<li>NetworkLoggerPlugin 管理网络log的插件</li>
</ul>
<p>　　在这里就演示一下NetworkActivityPlugin的使用：</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let networkPlugin = NetworkActivityPlugin &#123; (type) in</span><br><span class="line">            switch type &#123;</span><br><span class="line">            case .began:</span><br><span class="line">                NSLog(&quot;显示loading&quot;)</span><br><span class="line">            case .ended:</span><br><span class="line">                NSLog(&quot;隐藏loading&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>　　同样在创建请求的<code>Provider把它添加上去即可</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let provider = MoyaProvider&lt;AccountService&gt;(plugins: [networkPlugin])</span><br></pre></td></tr></table></figure>
<p>　　当然你也可以自定义一些功能的插件,只需要实现PluginType协议，具体功能实现可参考Moya默认的插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final class CustomPlugin: PluginType &#123;</span><br><span class="line">    </span><br><span class="line">    // MARK: Plugin</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（四）设置接口的超时时间</p>
<p>　　一般网络的请求需要根据具体的业务接口设置合适的超时时间，你可以参照一下方法进行设置，</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let requestTimeoutClosure = &#123; (endpoint: Endpoint&lt;AccountService&gt;, done: @escaping MoyaProvider&lt;AccountService&gt;.RequestResultClosure) in</span><br><span class="line">            </span><br><span class="line">            guard var request = endpoint.urlRequest else &#123; return &#125;</span><br><span class="line">            </span><br><span class="line">            request.timeoutInterval = 30    //设置请求超时时间</span><br><span class="line">            done(.success(request))</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>　　同样<em>在创建请求的Provider把它添加上去即可</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let provider = MoyaProvider&lt;AccountService&gt;(requestClosure: requestTimeoutClosure)</span><br></pre></td></tr></table></figure>
<p>　　</p>
<p><em>资料参考：</em></p>
<p><em><a href="http://www.jianshu.com/p/38fbc22a1e2b" target="_blank" rel="noopener">http://www.jianshu.com/p/38fbc22a1e2b</a></em></p>
<p><em><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">https://github.com/Moya/Moya</a></em></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Moya </tag>
            
            <tag> NetWork </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift之沙盒与数据存储]]></title>
      <url>/2018/04/26/Swift%E4%B9%8B%E6%B2%99%E7%9B%92%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
      <content type="html"><![CDATA[<h5 id="应用沙盒结构分析"><a href="#应用沙盒结构分析" class="headerlink" title="应用沙盒结构分析"></a>应用沙盒结构分析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、应用程序包：包含了所有的资源文件和可执行文件</span><br><span class="line"></span><br><span class="line">2、Documents：保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录</span><br><span class="line"></span><br><span class="line">3、tmp：保存应用运行时所需要的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行，系统也可能会清除该目录下的文件，iTunes不会同步备份该目录</span><br><span class="line"></span><br><span class="line">4、Library/Cache：保存应用运行时生成的需要持久化的数据，iTunes同步设备时不备份该目录。一般存放体积大、不需要备份的非重要数据</span><br><span class="line"></span><br><span class="line">5、Library/Preference：保存应用的所有偏好设置，IOS的Settings应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录</span><br></pre></td></tr></table></figure>
<h5 id="IOS中的数据存储"><a href="#IOS中的数据存储" class="headerlink" title="IOS中的数据存储"></a>IOS中的数据存储</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">NSSearchPathDirectory.DocumentDirectory 查找Documents文件夹</span><br><span class="line">NSSearchPathDomainMask.UserDomainMask 在用户的应用程序下查找</span><br><span class="line">true 展开路径   false 当前应用的根路径 == “~”</span><br><span class="line">*/</span><br><span class="line">let docPath = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory, NSSearchPathDomainMask.UserDomainMask, true)[0] as NSString</span><br><span class="line"></span><br><span class="line">// 上面代码代替下面代码，防止Documen文件夹不存在*****************************************************************</span><br><span class="line"></span><br><span class="line">// 获得沙盒的根路径</span><br><span class="line">let home = NSHomeDirectory() as NSString;</span><br><span class="line">// 获得Documents路径，使用NSString对象的stringByAppendingPathComponent()方法拼接路径</span><br><span class="line">let docPath = home.stringByAppendingPathComponent(&quot;Documents&quot;) as NSString;</span><br></pre></td></tr></table></figure>
<p>1、存储为plist属性列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func saveWithFile() &#123;</span><br><span class="line">    // 1、获得沙盒的根路径</span><br><span class="line">    let home = NSHomeDirectory() as NSString;</span><br><span class="line">    // 2、获得Documents路径，使用NSString对象的stringByAppendingPathComponent()方法拼接路径</span><br><span class="line">    let docPath = home.stringByAppendingPathComponent(&quot;Documents&quot;) as NSString;</span><br><span class="line">    // 3、获取文本文件路径</span><br><span class="line">    let filePath = docPath.stringByAppendingPathComponent(&quot;data.plist&quot;);</span><br><span class="line">    let dataSource = NSMutableArray();</span><br><span class="line">    dataSource.addObject(&quot;衣带渐宽终不悔&quot;);</span><br><span class="line">    dataSource.addObject(&quot;为伊消得人憔悴&quot;);</span><br><span class="line">    dataSource.addObject(&quot;故国不堪回首明月中&quot;);</span><br><span class="line">    dataSource.addObject(&quot;人生若只如初见&quot;);</span><br><span class="line">    dataSource.addObject(&quot;暮然回首，那人却在灯火阑珊处&quot;);</span><br><span class="line">    // 4、将数据写入文件中</span><br><span class="line">    dataSource.writeToFile(filePath, atomically: true);</span><br><span class="line">&#125;</span><br><span class="line">func readWithFile() &#123;</span><br><span class="line">    /// 1、获得沙盒的根路径</span><br><span class="line">    let home = NSHomeDirectory() as NSString;</span><br><span class="line">    /// 2、获得Documents路径，使用NSString对象的stringByAppendingPathComponent()方法拼接路径</span><br><span class="line">    let docPath = home.stringByAppendingPathComponent(&quot;Documents&quot;) as NSString;</span><br><span class="line">    /// 3、获取文本文件路径</span><br><span class="line">    let filePath = docPath.stringByAppendingPathComponent(&quot;data.plist&quot;);</span><br><span class="line">    let dataSource = NSArray(contentsOfFile: filePath);</span><br><span class="line">    print(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、使用NSUserDefaults存储数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func saveWithNSUserDefaults() &#123;  </span><br><span class="line">    // 1、利用NSUserDefaults存储数据  </span><br><span class="line">    let defaults = NSUserDefaults.standardUserDefaults();  </span><br><span class="line">    // 2、存储数据  </span><br><span class="line">    defaults.setObject(&quot;衣带渐宽终不悔&quot;, forKey: &quot;name&quot;);  </span><br><span class="line">    // 3、同步数据  </span><br><span class="line">    defaults.synchronize();  </span><br><span class="line">&#125;</span><br><span class="line">func readWithNSUserDefaults()&#123;</span><br><span class="line">    let defaults = NSUserDefaults.standardUserDefaults();</span><br><span class="line">    let name = defaults.stringForKey(&quot;name&quot;)</span><br><span class="line">    let switch = defaults.boolForKey(&quot;bool&quot;)</span><br><span class="line">    print(name)</span><br><span class="line">    print(switch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、归档存储：对象需要实现NSCoding协议，归档对应encode，反归档对应decode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 归档数据</span><br><span class="line"> 需要实现NSCoding协议</span><br><span class="line"> */</span><br><span class="line">func saveWithNSKeyedArchiver() &#123;</span><br><span class="line">    let docPath = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory, NSSearchPathDomainMask.UserDomainMask, true)[0] as NSString</span><br><span class="line">    let filePath = docPath.stringByAppendingPathComponent(&quot;contact.data&quot;);</span><br><span class="line">    let contact = Contact(name: &quot;123333&quot;, phone: &quot;123456&quot;)</span><br><span class="line">    /**</span><br><span class="line">    *  数据归档处理</span><br><span class="line">    */</span><br><span class="line">    NSKeyedArchiver.archiveRootObject(contact, toFile: filePath);</span><br><span class="line">&#125;</span><br><span class="line">// 如果上面直接运行会报错，因为你需要在要归档的对象中遵循NSCoding协议，并实现归档方法和解析方法 如：</span><br><span class="line">class Contact: NSObject, NSCoding &#123;</span><br><span class="line"></span><br><span class="line">    var name: String?</span><br><span class="line">    var phone: String?</span><br><span class="line">    </span><br><span class="line">    required init(name: String, phone: String)&#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.phone = phone</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 在对象归档的时候调用（哪些属性需要归档，怎么归档）</span><br><span class="line">    func encodeWithCoder(aCoder: NSCoder) &#123;</span><br><span class="line">        aCoder.encodeObject(name, forKey: &quot;name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 解析NIB/XIB的时候会调用</span><br><span class="line">    required init?(coder aDecoder: NSCoder) &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        name = aDecoder.decodeObjectForKey(&quot;name&quot;) as? String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> 反归档数据</span><br><span class="line"> */</span><br><span class="line">func readWithNSKeyedUnarchiver() &#123;</span><br><span class="line">    let docPath = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory, NSSearchPathDomainMask.UserDomainMask, true)[0] as NSString</span><br><span class="line">    let filePath = docPath.stringByAppendingPathComponent(&quot;contact.data&quot;);</span><br><span class="line">    let contact = NSKeyedUnarchiver.unarchiveObjectWithFile(filePath) as! Contact;</span><br><span class="line">    print(contact.name!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> 数据存储 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[‘‘required’ initializer ‘init(coder:)’ must be provided by subclass of’]]></title>
      <url>/2018/04/26/init(coder%20aDecoder:%20NSCoder)/</url>
      <content type="html"><![CDATA[<p>转载。 <a href="https://blog.csdn.net/top_roboo/article/details/51313103" target="_blank" rel="noopener">https://blog.csdn.net/top_roboo/article/details/51313103</a></p>
<p><em>Mast call a designated initializer of the superclass</em><br><em>‘required’ initializer ‘init(coder:)’ must be provided by subclass of</em></p>
<p>如果你要用 <code>Swift</code>创建一个实现了 <code>NSCoding</code>协议的类（<code>UIView,UIViewController</code>）的子类的时候，你就会发现一种很尴尬的情况，<code>required init?(coder aDecoder: NSCoder)</code>, 还是必须实现的，然而你可能并不知道这是什么鬼，也不知道有什么卵用，你可能只是简单的知道他是 <code>NSCoding</code> 的协议方法而已.</p>
<ul>
<li><p>在<code>Swift</code>中，如果你要重写父类的构造器，并且父类实现了 <code>NSCoding</code>，那么在子类中你也必须实现这个构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">required init?(coder aDecoder: NSCoder) &#123;</span><br><span class="line">     super.init(coder: aDecoder)</span><br><span class="line">    &#125;123</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以你觉得万事大吉了，对不起，你错了。<code>Swift</code>在类初始化时，出于对安全性的考虑，对类的所有内部属性必须全部被初始化(通俗一点就是分配一个默认值)，否则编译器报错，next eg.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"> var name: String</span><br><span class="line"> var age : Int</span><br><span class="line"> init() &#123;</span><br><span class="line">   name = &quot;Paul&quot;</span><br><span class="line">   age = 24</span><br><span class="line">   super.init(nibName: nil, bundle:nil)</span><br><span class="line"> &#125;</span><br><span class="line"> required init(coder: NSCoder) &#123;</span><br><span class="line">   super.init(coder: coder)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;123456789101112</span><br></pre></td></tr></table></figure>
</li>
<li><p>有些人说话了，谁说了一定要初始化，比如 <code>var age : Int?</code> 就不需要在<code>super.init()</code>之前必须初始化，<code>?</code>是可选型符号，这种写法规定你的 <code>age</code>属性是个可选型，什么是可选型，可选型是指，在你没有赋值的情况下默认赋值为<code>nil</code>，所以即使 <code>age</code>定义的时候没有初始化，但是它已经被初始化了(nil 表示空值，和OC中的空对象区别，例如 Swift 中是不能通过 age=nil 来释放一个对象的),</p>
</li>
<li><p><strong>但是，如果你想要实现一个自定义的构造器，怎么做</strong>，我猜可能是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    let name: String</span><br><span class="line">    init() &#123;</span><br><span class="line">      name = &quot;Paul&quot;</span><br><span class="line">      super.init(nibName: nil, bundle:nil)</span><br><span class="line">     &#125;</span><br><span class="line">     init(name aName : String) &#123;</span><br><span class="line">        name = &quot;Paul&quot;</span><br><span class="line">        super.init(nibName: nil, bundle:nil)</span><br><span class="line">     &#125;</span><br><span class="line">    required init(coder: NSCoder) &#123;</span><br><span class="line">        name = &quot;Paul&quot;   \\ 索性都写上，</span><br><span class="line">        super.init(coder: coder)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;123456789101112131415</span><br></pre></td></tr></table></figure>
<p>如果我有10个，100个属性呢？耗时间，那干脆想oc一样，写一个赋值的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    let name: String</span><br><span class="line">    init() &#123;</span><br><span class="line">      setup()</span><br><span class="line">      super.init(nibName: nil, bundle:nil)</span><br><span class="line">     &#125;</span><br><span class="line">     init(name aName : String) &#123;</span><br><span class="line">        setup()</span><br><span class="line">        super.init(nibName: nil, bundle:nil)</span><br><span class="line">     &#125;</span><br><span class="line">    required init(coder: NSCoder) &#123;</span><br><span class="line">        setup()</span><br><span class="line">        super.init(coder: coder)</span><br><span class="line">     &#125;</span><br><span class="line">     func setup() &#123;</span><br><span class="line">        name = &quot;Paul&quot;</span><br><span class="line">        age = 25</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;12345678910111213141516171819</span><br></pre></td></tr></table></figure>
<p>这样一来有一百个也无妨，想法很不错，有见地，但是很可惜，编译未通过，(举个例子，对象好比蛋里面的鸡，属性是肌肉，方法是鸡翅、鸡爪等)，在<code>super.init</code>之前(蛋孵化之前)，方法也同样没有被初始化(鸡都没有孵出来，你就想烤鸡翅了？)</p>
</li>
<li><p>废话说了这么多，到底怎么解决呢，别着急，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    let name: String</span><br><span class="line">    // 自定义的构造器</span><br><span class="line">    init(_ coder: NSCoder? = nil) &#123;</span><br><span class="line">        name = &quot;Paul&quot;</span><br><span class="line">        if let coder = coder &#123;</span><br><span class="line">            super.init(coder: coder)!</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.init(nibName: nil, bundle:nil)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    required convenience init(coder: NSCoder) &#123;</span><br><span class="line">        self.init(coder)</span><br><span class="line">    &#125;</span><br><span class="line">    // 下面这句可省去</span><br><span class="line">    override convenience init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) &#123;</span><br><span class="line">        self.init(nil)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;12345678910111213141516171819</span><br></pre></td></tr></table></figure>
<p>像这样，我们在我们自定义的构造器 <code>init(_ coder: NSCoder? = nil)</code> 中添加了一个可选型的 <code>NSCoding</code> 的参数，默认是nil，所以我们像之前那样不用任何参数调用<code>init(nil)</code></p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> error </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[smart_monkey移动性能测试]]></title>
      <url>/2018/04/26/iOS%20Monkey%20%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h1 id="移动性能测试-iOS-Monkey-测试方案-大家可以通过-gem-install-smart-monkey-进行安装了"><a href="#移动性能测试-iOS-Monkey-测试方案-大家可以通过-gem-install-smart-monkey-进行安装了" class="headerlink" title="移动性能测试 iOS Monkey 测试方案 [大家可以通过 gem install smart_monkey 进行安装了]"></a><a href="https://testerhome.com/topics/node32" target="_blank" rel="noopener">移动性能测试</a> iOS Monkey 测试方案 [大家可以通过 gem install smart_monkey 进行安装了]</h1><p><a href="https://testerhome.com/vigossjjj" target="_blank" rel="noopener">vigossjjj</a> · 2015年05月10日 · 最后由 <a href="https://testerhome.com/Hapenl" target="_blank" rel="noopener">Hapenl</a> 回复于 2017年11月03日 · 2221 次阅读</p>
<p>** 本帖已被设为精华帖！</p>
<p>** 目录 </p>
<h2 id="再次声明，如有任何问题，请先去github查阅，再在github提issue，这样也方便其他同学查阅。"><a href="#再次声明，如有任何问题，请先去github查阅，再在github提issue，这样也方便其他同学查阅。" class="headerlink" title="再次声明，如有任何问题，请先去github查阅，再在github提issue，这样也方便其他同学查阅。"></a>再次声明，如有任何问题，请先去github查阅，再在github提issue，这样也方便其他同学查阅。</h2><p><a href="https://github.com/vigossjjj/CrashMonkey4IOS/issues" target="_blank" rel="noopener">github issue 传送门</a></p>
<h2 id="先为小白用户说明下安装："><a href="#先为小白用户说明下安装：" class="headerlink" title="先为小白用户说明下安装："></a>先为小白用户说明下安装：</h2><p>Step 1. <code>brew install libimobiledevice</code><br>Step 2. <code>brew install -HEAD ideviceinstaller</code><br>Step 3. <code>brew install imagemagick</code><br>Step 4. <code>gem install smart_monkey</code><br>上面这三部都执行成功就可以执行了，具体执行看说ReadMe <a href="https://github.com/vigossjjj/CrashMonkey4IOS" target="_blank" rel="noopener">https://github.com/vigossjjj/CrashMonkey4IOS</a> 或者直接 smart_monkey -h</p>
<h2 id="CrashMonkey4IOS"><a href="#CrashMonkey4IOS" class="headerlink" title="CrashMonkey4IOS"></a>CrashMonkey4IOS</h2><p>iOS Monkey Test Tool.</p>
<h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明:"></a>简要说明:</h3><ol>
<li>支持<strong>真机测试、模拟器测试</strong></li>
<li>支持收集<strong>系统日志(Systemlog)</strong>、<strong>崩溃日志(Crashlog)</strong>、<strong>instrument行为日志</strong></li>
<li>支持测试报告截图，绘制行为轨迹</li>
<li>支持测试设备信息收集</li>
<li>使用最新版的<a href="https://github.com/jonathanpenn/ui-auto-monkey/blob/master/UIAutoMonkey.js" target="_blank" rel="noopener">UIAutoMonkey</a>，加入<code>UI Holes</code>与<code>Application Not Repsonding (&quot;ANR&quot;)</code>的处理，添加<a href="https://github.com/vigossjjj/CrashMonkey4IOS/blob/master/lib/ui-auto-monkey/custom.js" target="_blank" rel="noopener">custom.js</a>作为入口脚本.</li>
<li>加入<a href="https://github.com/vigossjjj/CrashMonkey4IOS/tree/master/lib/ui-auto-monkey/tuneup" target="_blank" rel="noopener">tuneup</a>依赖</li>
<li>修改<strong>UIAutoMonkey.js</strong>中截图策略，为每个Event Action进行截图</li>
<li>支持测试执行过程中App进入后台，自动恢复(测试不会block)</li>
</ol>
<h3 id="系统及环境要求"><a href="#系统及环境要求" class="headerlink" title="系统及环境要求:"></a>系统及环境要求:</h3><ol>
<li>安装Ruby运行环境，建议不要使用OS X自带版本，可自行使用RVM安装最新版的Ruby。建议使用淘宝镜像安装，速度比较快，<code>$ sed -i -e &#39;s/ftp\.ruby-lang\.org\/pub\/ruby/ruby\.taobao\.org\/mirrors\/ruby/g&#39; ~/.rvm/config/db</code></li>
<li>确保gem可用，也建议使用淘宝镜像 <code>gem sources --remove https://rubygems.org/;gem sources -a http://ruby.taobao.org/;gem sources -l</code></li>
<li>安装<strong>Homebrew</strong> <code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li>
<li>建议Xcode 6.x +</li>
</ol>
<h3 id="必要依赖安装"><a href="#必要依赖安装" class="headerlink" title="必要依赖安装:"></a>必要依赖安装:</h3><ol>
<li><code>brew install -HEAD ideviceinstaller</code></li>
<li><code>brew install libimobiledevice</code></li>
<li><code>brew install imagemagick</code></li>
</ol>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明:"></a>使用说明:</h3><h6 id="安装Release版"><a href="#安装Release版" class="headerlink" title="安装Release版"></a>安装Release版</h6><p><code>gem install smart_monkey</code>, 执行入口: 终端下直接使用<code>smart_monkey</code></p>
<h6 id="安装开发版"><a href="#安装开发版" class="headerlink" title="安装开发版"></a>安装开发版</h6><p>直接clone本项目, 执行入口: <code>/CrashMonkey4IOS/bin/smart_monkey</code></p>
<h6 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h6><p><code>smart_monkey -a ${App_BunnelID}</code></p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明:"></a>参数说明:</h3><ul>
<li><p><strong>-a</strong>: 指向被测程序的<strong>BundleID</strong>(不可缺省)。e.g.<code>-a com.mytest.app</code></p>
</li>
<li><p><strong>-w</strong>: 指向测试设备的<strong>UDID</strong>，可以通过<code>$instruments -s devices</code>进行设备id的查看，若缺省则默认指向第一台设备(模拟器或真机)。e.g.<code>-w 26701a3a5bc17038ca0465186407b912375b35a7</code></p>
</li>
<li><p><strong>-n</strong>: monkey测试的执行次数，默认为1次。e.g.<code>-n 3</code></p>
</li>
<li><p><strong>-d</strong>: 测试报告地址，默认为当前目录下的<strong>smart_monkey_result</strong>文件夹下。e.g.<code>-d ~/my-monkey-test-result</code></p>
</li>
<li><p><strong>-t</strong>: 执行时间，单位为秒。e.g.<code>-t 60</code></p>
</li>
<li><p><strong>-s</strong>: 指向被测app的<strong>.dSYM</strong>文件，若出现crash，解析crash为明文。e.g.<code>-s testapp.dSYM</code></p>
</li>
<li><p><strong>-c</strong>: 自定义的配置集路径，<strong>参数必须为目录</strong>，目录下必须包含<code>custom.js</code>，若使用handler，目录下需存在名为<strong>handler</strong>的文件夹，用于存放相关文件。e.g.<code>-c /my/path/custom_cfg</code></p>
<p><strong>如果使用custom_cfg必须遵守如下目录结构</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">custom_cfg</span><br><span class="line">    ├── custom.js</span><br><span class="line">    └── handler</span><br><span class="line">        ├── buttonHandler.js</span><br><span class="line">        └── wbScrollViewButtonHandler.js</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>–event-number</strong>: 定义Monkey测试的总事件数，默认为50。e.g.<code>--event-number 100</code></p>
</li>
<li><p><strong>–compress-result</strong>: 对测试过程中截取的图片进行压缩，以节省空间开销。e.g.<code>--compress-result 50%</code></p>
</li>
<li><p><strong>–detail-count</strong>: 定义报告详情中记录的事件总数，默认为50，即在报告当中展示最近的50次随机事件，且进行操作示意绘制。e.g.<code>--detail-count 100</code></p>
</li>
<li><p><strong>–show-config</strong>: 打印当前的配置信息，即<strong>custom.js</strong>。e.g.<code>--show-config</code></p>
</li>
<li><p><strong>–drop-useless-img</strong>: 删除除展示在报告当中的其余截图，以节省空间开销，如，一轮Monkey测试共产出截图100张，参数<code>--detail-count</code>设置为20，那么使用<code>--drop-useless-img</code>会删除其余80张截图。e.g.<code>--drop-useless-img</code></p>
</li>
<li><p><strong>–list-app</strong>: 打印当前连接的真机及模拟器中所安装的app。e.g.<code>--list-app</code></p>
</li>
<li><p><strong>–list-devices</strong>: 打印当前所有可用设备。e.g.<code>--list-devices</code></p>
</li>
<li><p><strong>–reset-ios-sim</strong>: 重启模拟器。e.g.<code>--reset-ios-sim</code></p>
</li>
<li><p><strong>–version</strong>: 打印smart_monkey的版本号。e.g.<code>--version</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">⇒  CrashMonkey4IOS/bin/smart_monkey -h</span><br><span class="line">Usage: smart_monkey [options]</span><br><span class="line">    -a app_name                      Bundle ID of the desired target on device(Required)</span><br><span class="line">    -w device                        Target Device UDID(Required)</span><br><span class="line">    -n run_count                     How many times monkeys run(default: 1)</span><br><span class="line">    -d result_dir                    Where to output result(default: ./smart_monkey_result)</span><br><span class="line">    -t time_limit_sec                Time limit of running</span><br><span class="line">    -s dsym_file                     Use .dSYM file to symbolicating crash logs</span><br><span class="line">    -c custom_cfg_path               Indicate confige lib directory path, not a file path.</span><br><span class="line">        --event-number event_number  The monkey event number(default: 50)</span><br><span class="line">        --compress-result compress_rate</span><br><span class="line">                                     compress the screenshot images to save disk space!(example: 50%)</span><br><span class="line">        --detail-count detail_event_count</span><br><span class="line">                                     How many events to show in detail result page(default 50)</span><br><span class="line">        --show-config                Show Current Configuration custom.js</span><br><span class="line">        --drop-useless-img           Delete the un-displayed images of detial page.</span><br><span class="line">        --list-app                   Show List of Installed Apps in iPhone/iPhone Simulator</span><br><span class="line">        --list-devices               Show List of Devices</span><br><span class="line">        --reset-ios-sim              Reset iPhone Simulator</span><br><span class="line">        --version                    print smart monkey version</span><br></pre></td></tr></table></figure>
<h2 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h2><p><a href="https://testerhome.com/photo/2015/c1ff4907cda8b0ae0c13dbffeadd3d87.jpg" target="_blank" rel="noopener"><img src="https://testerhome.com/photo/2015/c1ff4907cda8b0ae0c13dbffeadd3d87.jpg" alt="img"></a></p>
<p><img src="https://testerhome.com/photo/2015/5bf3dea58b56d682b6e35f50f3ce3647.jpg" alt="img"></p>
<p><img src="https://testerhome.com/photo/2015/6acec3f474abad05ed88a2620087ec19.jpg" alt="img"></p>
<p><img src="https://testerhome.com/photo/2015/22c5837f81e8e7bebfe22cee1614159c.jpg" alt="img"></p>
<p><a href="https://testerhome.com/topics/2523?page=2#" target="_blank" rel="noopener">** 48 个赞</a><a href="https://testerhome.com/topics/2523/show_wechat" target="_blank" rel="noopener">**</a></p>
<p>转载文章时务必注明原作者及原始链接，并注明「发表于 TesterHome 」，并不得对作品进行修改。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> smart_monkey </tag>
            
            <tag> 测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Runtime]]></title>
      <url>/2018/04/26/swift-Runtime/</url>
      <content type="html"><![CDATA[<p>都说Runtime是Objective-C中的黑魔法，<a href="https://link.jianshu.com?t=http://www.cocoachina.com/ios/20141031/10105.html" target="_blank" rel="noopener">这里有关于OC Runtime的详细介绍</a>。而我们在用Swift的时候，很多时候也需要用到Runtime，它与在OC中的使用还是有一点点区别的。在解决UIButton重复点击问题时主要用到了Runtime中的关联对象(Associated Objects)和方法交叉(Method Swizzling)。</p>
<p><strong>因为在Swift代码中已经没有了Objective-C的运行时消息机制, 在代码编译时即确定了其实际调用的方法. 所以纯粹的Swift类和对象没有办法使用runtime, 更不存在method swizzling. 那是不是在swift中就不能使用runtime了呢？答案肯定是可以的。要使用runtime，我们需要在想要使用runtime的方法或者属性前面加上**</strong>dynamic关键字。**</p>
<h3 id="Associated-Objects"><a href="#Associated-Objects" class="headerlink" title="Associated Objects"></a>Associated Objects</h3><p>在解决UIButton重复点击问题时，首先我们需要两个变量，一个是点击的间隔时间，另一个是是否需要忽视点击事件的Bool值，那么我们就需要将这两个变量与UIButton关联起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">extension UIButton &#123;</span><br><span class="line">    </span><br><span class="line">    private struct AssociatedKeys &#123;</span><br><span class="line">        static var clickDurationTime = &quot;my_clickDurationTime&quot;</span><br><span class="line">        static var isIgnoreEvent = &quot;my_isIgnoreEvent&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 点击间隔时间</span><br><span class="line">    var clickDurationTime : NSTimeInterval &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            objc_setAssociatedObject(self, &amp;AssociatedKeys.clickDurationTime, newValue as NSTimeInterval, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        get &#123;</span><br><span class="line">            </span><br><span class="line">            if let clickDurationTime = objc_getAssociatedObject(self, &amp;AssociatedKeys.clickDurationTime) as? NSTimeInterval &#123;</span><br><span class="line">                return clickDurationTime</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return defaultDuration</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 是否忽视点击事件</span><br><span class="line">    var isIgnoreEvent : Bool &#123;</span><br><span class="line">        </span><br><span class="line">        set &#123;</span><br><span class="line">            objc_setAssociatedObject(self, &amp;AssociatedKeys.isIgnoreEvent, newValue as Bool, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        get &#123;</span><br><span class="line">            </span><br><span class="line">            if let isIgnoreEvent = objc_getAssociatedObject(self, &amp;AssociatedKeys.isIgnoreEvent) as? Bool &#123;</span><br><span class="line">                return isIgnoreEvent</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>接下来我们需要写一个用来替换UIButton点击事件的方法，在这个方法里来处理重复点击的问题。UIButton继承自UIControl，在传递点击事件是会触发这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public func sendAction(action: Selector, to target: AnyObject?, forEvent event: UIEvent?)</span><br></pre></td></tr></table></figure>
<p>于是我们重写用来交叉的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SwizzledMethod</span><br><span class="line">    func my_sendAction(action: Selector, to target: AnyObject?, forEvent event: UIEvent?) &#123;</span><br><span class="line">        </span><br><span class="line">        if self.isKindOfClass(UIButton) &#123;</span><br><span class="line">            </span><br><span class="line">            clickDurationTime = clickDurationTime == 0 ? defaultDuration : clickDurationTime</span><br><span class="line">            </span><br><span class="line">            if isIgnoreEvent &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125; else if clickDurationTime &gt; 0 &#123;</span><br><span class="line">                isIgnoreEvent = true</span><br><span class="line">                // 在过了我们设置的duration之后，再将isIgnoreEvent置为false</span><br><span class="line">                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(clickDurationTime) * Int64(NSEC_PER_SEC)), dispatch_get_main_queue()) &#123;</span><br><span class="line">                    self.isIgnoreEvent = false</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                my_sendAction(action, to: target, forEvent: event)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            my_sendAction(action, to: target, forEvent: event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就是用我们自己重写的SwizzeldMethod来替换UIButton的OriginalMethod：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// swift现不支持重写+load方法</span><br><span class="line">    override public class func initialize() &#123;</span><br><span class="line">        struct Static &#123;</span><br><span class="line">            static var token: dispatch_once_t = 0</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if self !== UIButton.self &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_once(&amp;Static.token) &#123;</span><br><span class="line">            </span><br><span class="line">            let originalSelector = #selector(UIButton.sendAction(_:to:forEvent:))</span><br><span class="line">            let swizzledSelector = #selector(UIButton.my_sendAction(_:to:forEvent:))</span><br><span class="line">            </span><br><span class="line">            let originalMethod = class_getInstanceMethod(self, originalSelector)</span><br><span class="line">            let swizzledMethod = class_getInstanceMethod(self, swizzledSelector)</span><br><span class="line">            </span><br><span class="line">            // 运行时为类添加我们自己写的my_sendAction(_:to:forEvent:)</span><br><span class="line">            let didAddMethod = class_addMethod(self, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))</span><br><span class="line">            </span><br><span class="line">            if didAddMethod &#123;</span><br><span class="line">                // 如果添加成功，则交换方法</span><br><span class="line">                class_replaceMethod(self, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果添加失败，则交换方法的具体实现</span><br><span class="line">                method_exchangeImplementations(originalMethod, swizzledMethod)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法，就是在运行时将UIButton的sendAction(<em>:to:forEvent:)替换为我们自己写的my_sendAction(</em>:to:forEvent:)。</p>
<h3 id="load-vs-initialize"><a href="#load-vs-initialize" class="headerlink" title="load vs. initialize"></a>load vs. initialize</h3><p>在 Swift 中 load 类方法永远不会被 runtime 调用，因此在+load方法中实现交叉就变成了不可能的事。出于安全性和一致性的考虑，我们必须确保相关的方法交叉在一个 dispatch<em>once 中，这样也是很安全的。还有一种方法，<code>在 app delegate 中实现方法交叉，</code> 不像上面通过类扩展进行方法交叉，而是简单地在 app delegate 的 application(</em>:didFinishLaunchingWithOptions:) 方法调用时中执行相关代码也是可以的。基于对类的修改，这种方法应该就足够确保这些代码会被执行到。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Runtime </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Swift Mirror 快速将类转换为 Json 的方法。]]></title>
      <url>/2018/04/26/%E4%BD%BF%E7%94%A8%20Swift%20Mirror%20%E5%BF%AB%E9%80%9F%E5%B0%86%E7%B1%BB%E8%BD%AC%E6%8D%A2%E4%B8%BA%20Json/</url>
      <content type="html"><![CDATA[<p><a href="https://link.jianshu.com?t=http://chris.eidhof.nl/post/swift-mirrors-and-json/" target="_blank" rel="noopener">Swift Mirrors and JSON</a><br>但是原文已经不适应 Swift 2.2 的版本了，我将修改过的代码贴在这里（还是不少要改的），并附上一些可能需要解释的部分的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//定义的示范用的结构体</span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name: String = &quot;John&quot;</span><br><span class="line">    var age: Int = 50</span><br><span class="line">    var dutch: Bool = false</span><br><span class="line">    var address: Address? = Address(street: &quot;Market St.&quot;)</span><br><span class="line">    var Some: Int = 60</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Address &#123;</span><br><span class="line">    var street: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let john = Person()</span><br><span class="line"></span><br><span class="line">//可以转换为 Json 的协议</span><br><span class="line">protocol JSON &#123;</span><br><span class="line">    func toJSON() throws -&gt; AnyObject?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//没有实现 JSON 协议的错误类型</span><br><span class="line">enum CouldNotSerializeError &#123;</span><br><span class="line">    case NoImplementation(source: Any, type: Mirror)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension CouldNotSerializeError: ErrorType &#123; &#125;</span><br><span class="line"></span><br><span class="line">//使用 extension 对 JSON 添加方法的默认实现</span><br><span class="line">extension JSON &#123;</span><br><span class="line">    func toJSON() throws -&gt; AnyObject? &#123;</span><br><span class="line">        //创建 Mirror 类型</span><br><span class="line">        let mirror = Mirror(reflecting: self)</span><br><span class="line">        //Mirror 的 children 是一个 (label: String?, value: Any) 元组类型，表示该类的所有属性的名字和类型</span><br><span class="line">        if mirror.children.count &gt; 0  &#123;</span><br><span class="line">            var result: [String:AnyObject] = [:]</span><br><span class="line">            for case let (label?, value) in mirror.children &#123;</span><br><span class="line">                //如果这个类型没有实现 JSON 协议，则抛出错误</span><br><span class="line">                if let value = value as? JSON &#123;</span><br><span class="line">                    //递归调用</span><br><span class="line">                    result[label] = try value.toJSON()</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw CouldNotSerializeError.NoImplementation(source: self, type: Mirror(reflecting: value))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result</span><br><span class="line">        &#125;</span><br><span class="line">         //如果没有属性（一般类，String，Int 等），则直接返回</span><br><span class="line">        return self as? AnyObject</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将一般类型都遵从 JSON 协议</span><br><span class="line">extension Person: JSON &#123; &#125;</span><br><span class="line">extension String: JSON &#123; &#125;</span><br><span class="line">extension Int: JSON &#123; &#125;</span><br><span class="line">extension Bool: JSON &#123; &#125;</span><br><span class="line">extension Address: JSON &#123; &#125;</span><br><span class="line"></span><br><span class="line">//Optionai 需要特别对待，原因是如果直接返回，则会是 .Some: [...] </span><br><span class="line">extension Optional: JSON &#123;</span><br><span class="line">    func toJSON() throws -&gt; AnyObject? &#123;</span><br><span class="line">        if let x = self &#123;</span><br><span class="line">            if let value = x as? JSON &#123;</span><br><span class="line">                return try value.toJSON()</span><br><span class="line">            &#125;</span><br><span class="line">            throw CouldNotSerializeError.NoImplementation(source: x, type: Mirror(reflecting: x))</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    print(try john.toJSON())</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(error)</span><br><span class="line">&#125;</span><br><span class="line">//输出：Optional(&#123; Some = 60;  address =  &#123; street = &quot;Market St.&quot; ; &#125;; age = 50; dutch = 0; name = John; &#125;)</span><br></pre></td></tr></table></figure>
<p>是不是非常方便？我自己想了一个更加方便的，只要一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//泛型</span><br><span class="line">func mkJson&lt;T&gt;(a: T?) -&gt; AnyObject? &#123;</span><br><span class="line">    //如果为空，则不将该属性加入 Json</span><br><span class="line">    guard let a = a else &#123; return nil &#125;</span><br><span class="line">    let mirror = Mirror(reflecting: a)</span><br><span class="line">    let num = mirror.children.count</span><br><span class="line">    if num &gt; 0  &#123;</span><br><span class="line">        var result: [String:AnyObject] = [:]</span><br><span class="line">        for case let (label?, value) in mirror.children &#123;</span><br><span class="line">            //这里有点 Trick，如果是一个有值的 Optional（Some），则直接载入warp下的值。</span><br><span class="line">            //后一个条件是防止如果有类型是叫做 Some（一般不会有吧）的属性的情况，见注1</span><br><span class="line">            if label == &quot;Some&quot; &amp;&amp; mirror.children.count == 1 &#123;</span><br><span class="line">                return toJson(value)</span><br><span class="line">            &#125;</span><br><span class="line">            result[label] = toJson(value)</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return a as? AnyObject</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let json = mkJson(john)</span><br><span class="line">print(json)</span><br><span class="line">//得到的结果完全一样</span><br><span class="line">//注1：也就是说，如果你有一个类或者结构体，里面只有一个属性叫做 Some ，那么这个 Some 会被跳过直接读取里面的类型。当然，这种情况微乎其微。</span><br></pre></td></tr></table></figure>
<p>唯一不太好的就是，使用 Mirror 有性能上的损失，我在Xcode上跑了一下测试，用的我自己的一个成员类<br>用时如下：<br>类创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func testInit() &#123;</span><br><span class="line">    self.measureBlock&#123;</span><br><span class="line">        for _ in 1...2000 &#123;</span><br><span class="line">            let _ = User()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//0.400 (0.401) seconds</span><br></pre></td></tr></table></figure>
<p>Mirror：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func testMirror() &#123;</span><br><span class="line">    self.measureBlock &#123;</span><br><span class="line">        let user = User()</span><br><span class="line">        for _ in 1...2000 &#123;</span><br><span class="line">            mkJson(user)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//4.147 (4.147) seconds</span><br><span class="line">//我的天呐</span><br></pre></td></tr></table></figure>
<p>if let 方式加入 dictionary：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func testIfLet() &#123;</span><br><span class="line">    self.measureBlock &#123;</span><br><span class="line">        let user = User()</span><br><span class="line">        for _ in 1...2000 &#123;</span><br><span class="line">            let _ = user.parameters</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension User &#123;</span><br><span class="line"></span><br><span class="line">public var parameters: [String: AnyObject]  &#123;</span><br><span class="line">    var parms:[String : AnyObject] = [ : ]</span><br><span class="line">    if let email = email &#123;</span><br><span class="line">        parms[&quot;email&quot;] = email</span><br><span class="line">    &#125;</span><br><span class="line">    if let nickName = nickName &#123;</span><br><span class="line">        parms[&quot;nickName&quot;] = nickName</span><br><span class="line">    &#125;</span><br><span class="line">    if let phoneNumber = phoneNumber &#123;</span><br><span class="line">        parms[&quot;phoneNumber&quot;] = phoneNumber</span><br><span class="line">    &#125;</span><br><span class="line">    return parms</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//in 0.531 (0.532) seconds</span><br><span class="line">//嗯……</span><br></pre></td></tr></table></figure>
<p>所以说，虽然方便，还是慎用吧。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Data </tag>
            
            <tag> Mirror </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS Swift教程 Core Data （三）Core Data栈 下]]></title>
      <url>/2018/04/24/Core%20Data%20-swift%20-%20ios8/</url>
      <content type="html"><![CDATA[<p>翻译 2014年12月31日 17:56:45</p>
<ul>
<li>标签：</li>
<li><a href="http://so.csdn.net/so/search/s.do?q=ios&amp;t=blog" target="_blank" rel="noopener">ios</a> /</li>
<li><a href="http://so.csdn.net/so/search/s.do?q=%E6%BA%90%E7%A0%81&amp;t=blog" target="_blank" rel="noopener">源码</a> /</li>
<li><a href="http://so.csdn.net/so/search/s.do?q=CoreData&amp;t=blog" target="_blank" rel="noopener">CoreData</a> /</li>
<li><a href="http://so.csdn.net/so/search/s.do?q=Swift&amp;t=blog" target="_blank" rel="noopener">Swift</a></li>
</ul>
<ul>
<li>**2118</li>
</ul>
<p>接下来，我们创建自己的stack object。</p>
<p>创建一个名为CoreDataStack的swift加入到工程中。</p>
<p>转载请注明出处：<a href="http://blog.csdn.net/yamingwu/article/details/42297675" target="_blank" rel="noopener">http://blog.csdn.net/yamingwu/article/details/42297675</a></p>
<p>源代码地址：<a href="https://github.com/dnawym/StudySwift/tree/master/CoreData/Dog%20Walk" target="_blank" rel="noopener">https://github.com/dnawym/StudySwift/tree/master/CoreData/Dog%20Walk</a></p>
<p>定义成员变量：</p>
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>import CoreData  </li>
<li></li>
<li>class CoreDataStack {  </li>
<li>​    let context: NSManagedObjectContext  </li>
<li>​    let psc: NSPersistentStoreCoordinator  </li>
<li>​    let model: NSManagedObjectModel  </li>
<li>​    let store: NSPersistentStore?  </li>
<li>}  </li>
</ol>
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>func saveContext() {  </li>
<li>​    var error: NSError? = nil  </li>
<li>​    if context.hasChanges &amp;&amp; !context.save(&amp;error) {  </li>
<li>​        println(“Could not save: (error), (error?.userInfo)”)s  </li>
<li>​    }  </li>
<li>}  </li>
<li></li>
<li>// 获取应用程序documents diretory的url  </li>
<li>func applicationDocumentsDirectory() -&gt; NSURL {  </li>
<li>​    let fileManager = NSFileManager.defaultManager()  </li>
<li>​      </li>
<li>​    let urls = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask) as [NSURL]  </li>
<li>​      </li>
<li>​    return urls[0]  </li>
<li>}  </li>
</ol>
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>init() {  </li>
<li>​    // 从硬盘加载managed object model，这里通过读取momd目录下的编译后的.xcdatamodeld文件实现  </li>
<li>​    let bundle = NSBundle.mainBundle()  </li>
<li>​    let modelURL = bundle.URLForResource(“Dog Walk”, withExtension: “momd”)  </li>
<li>​    model = NSManagedObjectModel(contentsOfURL: modelURL!)!  </li>
<li>​      </li>
<li>​    // 一旦初始化了NSManagedObjectModel，下一步是创建PSC，PSC用于桥接model和PersistentStore  </li>
<li>​    psc = NSPersistentStoreCoordinator(managedObjectModel: model)  </li>
<li>​      </li>
<li>​    // Context的初始化没有任何参数，我们将psc连接到context上  </li>
<li>​    context = NSManagedObjectContext()  </li>
<li>​    context.persistentStoreCoordinator = psc  </li>
<li>​      </li>
<li>​    // 我们不需要手工创建PS，PSC会帮我们创建它。我们只需要为PSC提供所需的PS类型，一些配置，存放路径即可  </li>
<li>​    let documentsURL = applicationDocumentsDirectory()  </li>
<li>​    let storeURL = documentsURL.URLByAppendingPathComponent(“Dog Walk”)  </li>
<li>​      </li>
<li>​    let options = [NSMigratePersistentStoresAutomaticallyOption: true]  </li>
<li>​      </li>
<li>​    var error: NSError? = nil  </li>
<li>​    store = psc.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: storeURL, options: options, error: &amp;error)  </li>
<li>​      </li>
<li>​    if store == nil {  </li>
<li>​        println(“Error adding persistent store: (error)”)  </li>
<li>​        abort()  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p>修改AppDelegate文件，构造CoreData’Stack并传递给ViewController，同时添加2个函数在应用程序进入后台和即将结束时，保存数据到文件系统中</p>
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>import UIKit  </li>
<li>import CoreData  </li>
<li></li>
<li>@UIApplicationMain  </li>
<li>class AppDelegate: UIResponder, UIApplicationDelegate {  </li>
<li>​                              </li>
<li>​    var window: UIWindow?  </li>
<li>​      </li>
<li>​    lazy var coreDataStack = CoreDataStack()  </li>
<li></li>
<li>​    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {  </li>
<li></li>
<li>​        let navigationController = self.window!.rootViewController as UINavigationController  </li>
<li>​        let viewController = navigationController.topViewController as ViewController  </li>
<li>​          </li>
<li>​        viewController.managedContext = coreDataStack.context  </li>
<li>​          </li>
<li>​        return true  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    func applicationDidEnterBackground(application: UIApplication) {  </li>
<li>​        coreDataStack.saveContext()  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    func applicationWillTerminate(application: UIApplication) {  </li>
<li>​        coreDataStack.saveContext()  </li>
<li>​    }  </li>
<li></li>
<li>}  </li>
</ol>
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>var managedContext: NSManagedObjectContext!  </li>
</ol>
<p>数据建模：</p>
<p>创建名为Dog Walk的CoreData model文件，在其中添加2个entity</p>
<p><img src="https://img-blog.csdn.net/20141231180923874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFtaW5nd3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20141231181001689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFtaW5nd3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>这里，回到Dog Entity界面，创建一个指向walk的relationship</p>
<p><img src="https://img-blog.csdn.net/20141231181153609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFtaW5nd3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>默认情况下，这种关系都是一对一的，这里需要修改为一对多，并且勾选Ordered，这样，数据自动按日期进行排序。</p>
<p><img src="https://img-blog.csdn.net/20141231181416219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFtaW5nd3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>接下来，选择walk entity，创建一个inverse relationship指回dog，这里不用修改成to many，因为一次walk只会关联到一条狗</p>
<p><img src="https://img-blog.csdn.net/20141231181642843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFtaW5nd3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>inverse的作用是让model知道如何找到反向路径。比如，对于一个walk记录，通过relationship可以找到对应的dog，通过inverse，model知道通过walks关系可以回到walk记录。通过选择右下角的按钮来切换视图模式到图像编辑模式。to-one是单箭头，to-many是双箭头。</p>
<p><img src="https://img-blog.csdn.net/20141231184051914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFtaW5nd3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>创建ManagedObjectModel的子类，选择Dog Walk model并选择Dog和Walk这两个entity，最后记得选择swift编程语言，这样会生成Dog.swift和Walk.swift<img src="https://img-blog.csdn.net/20141231184506023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFtaW5nd3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>  然后，修改Dog和Walk数据模型的属性，将Dog改为Dog_Walk.Dog，将Walk改为Dog_Walk.Walk。这一步的目的是连接managed object子类的全名到data model中的entity。</p>
<p><img src="https://img-blog.csdn.net/20141231204244640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFtaW5nd3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>实现对数据的持久存储：</p>
<p>前面我们已经完成了Core Data栈的创建，data model子类的创建，接下来我们修改ViewController来使用Core Data。</p>
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>var currentDog: Dog!  </li>
</ol>
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>override func viewDidLoad() {  </li>
<li>​    super.viewDidLoad()  </li>
<li>​    tableView.registerClass(UITableViewCell.self, forCellReuseIdentifier: “Cell”)  </li>
<li>​      </li>
<li>​    let dogEntity = NSEntityDescription.entityForName(“Dog”, inManagedObjectContext: managedContext)  </li>
<li>​      </li>
<li>​    let dog = Dog(entity: dogEntity!, insertIntoManagedObjectContext: managedContext)  </li>
<li>​      </li>
<li>​    let dogName = “Fido”  </li>
<li>​    let dogFetch = NSFetchRequest(entityName: “Dog”)  </li>
<li>​    dogFetch.predicate = NSPredicate(format: “name == %@”, dogName)  </li>
<li>​      </li>
<li>​    var error: NSError? = nil  </li>
<li>​    let result = managedContext.executeFetchRequest(dogFetch, error: &amp;error) as [Dog]?  </li>
<li>​      </li>
<li>​    if let dogs = result {  </li>
<li>​        if dogs.count == 0 {  </li>
<li>​            currentDog = Dog(entity: dogEntity!, insertIntoManagedObjectContext: managedContext)  </li>
<li>​            currentDog.name = dogName  </li>
<li>​              </li>
<li>​            if !managedContext.save(&amp;error) {  </li>
<li>​                println(“Could not save: (error)”)  </li>
<li>​            }  </li>
<li>​        } else {  </li>
<li>​            currentDog = dogs[0]  </li>
<li>​        }  </li>
<li>​    } else {  </li>
<li>​        println(“Could not fetch: (error)”)  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>@IBAction func add(sender: AnyObject) {  </li>
<li>​      </li>
<li>​    // 插入新的Walk entity到Core Data中  </li>
<li>​    let walkEntity = NSEntityDescription.entityForName(“Walk”, inManagedObjectContext: managedContext)  </li>
<li>​    let walk = Walk(entity: walkEntity!, insertIntoManagedObjectContext: managedContext)  </li>
<li>​      </li>
<li>​    walk.date = NSDate()  </li>
<li>​      </li>
<li>​    // 插入新的walk到dog的walks集合中  </li>
<li>​    var walks = currentDog.walks.mutableCopy() as NSMutableOrderedSet  </li>
<li>​    walks.addObject(walk)  </li>
<li>​    currentDog.walks = walks.copy() as NSOrderedSet  </li>
<li>​      </li>
<li>​    // 保存managed object context  </li>
<li>​    var error: NSError?  </li>
<li>​    if !managedContext.save(&amp;error) {  </li>
<li>​        println(“Could not save: (error)”)  </li>
<li>​    }  </li>
<li>​      </li>
<li>​    tableView.reloadData()  </li>
<li>}  </li>
</ol>
<p>从Core Data中删除数据：</p>
<p>添加下述函数到ViewController：</p>
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/yamingwu/article/details/42297675#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool {  </li>
<li>​    return true  </li>
<li>}  </li>
<li></li>
<li>func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {  </li>
<li>​    if editingStyle == UITableViewCellEditingStyle.Delete {  </li>
<li>​        // 获取要删除的walk对象  </li>
<li>​        let walkToRemove = currentDog.walks[indexPath.row] as Walk  </li>
<li>​          </li>
<li>​        // 类似于添加walk到walks，现获取一个mutable拷贝，然后在拷贝中移除对应的walk，最后将拷贝赋值回dog  </li>
<li>​        let walks = currentDog.walks.mutableCopy() as NSMutableOrderedSet  </li>
<li>​        walks.removeObjectAtIndex(indexPath.row)  </li>
<li>​        currentDog.walks = walks.copy() as NSOrderedSet  </li>
<li>​          </li>
<li>​        // 删除walk对象  </li>
<li>​        managedContext.deleteObject(walkToRemove)  </li>
<li>​          </li>
<li>​        // 保存  </li>
<li>​        var error: NSError?  </li>
<li>​        if !managedContext.save(&amp;error) {  </li>
<li>​            println(“Could not save: (error)”)  </li>
<li>​        }  </li>
<li>​          </li>
<li>​        // 从table view中删除当前行  </li>
<li>​        tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Automatic)  </li>
<li>​    }  </li>
<li>}  </li>
</ol>
<p><img src="https://img-blog.csdn.net/20141231212643577?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFtaW5nd3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>至此，我们就完成了3个实例，遛狗程序。这一节中，我们学习了如何构建自己的Core Data栈，数据模型和managed object子类，以及如何建立实例之间的关系，如何操作关系以及如何从Core Data中删除数据。</p>
<p>接下来，我们会更深入的学习fetch和其它更高级的iOS8 topics，这一节我们学习了基本的操作，但是还有更多需要学习的地方，are you ready？</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Core Data </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift - 集合（Set）使用详解（附样例）]]></title>
      <url>/2018/04/24/%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h2><h3 id="1，集合的作用"><a href="#1，集合的作用" class="headerlink" title="1，集合的作用"></a>1，集合的作用</h3><ul>
<li>集合（Set）是用来存储相同类型、没有确定顺序、且不重复的值。 </li>
<li>也就是说当元素顺序不重要时，或者希望确保每个元素只出现一次时，可以使用集合而不是数组。</li>
</ul>
<h3 id="2，Array、Set、Dictionariy-三者的区别"><a href="#2，Array、Set、Dictionariy-三者的区别" class="headerlink" title="2，Array、Set、Dictionariy 三者的区别"></a>2，Array、Set、Dictionariy 三者的区别</h3><p>Swift 中这三种基本的集合类型都是用来存储集合数据的，它们间的区别如下：</p>
<ul>
<li>数组（Arrays）是有序数据的集。</li>
<li>集合（Sets）是无序无重复数据的集。</li>
<li>字典（Dictionaries）是无序的键值对的集。</li>
</ul>
<p><a href="http://www.hangge.com/blog/cache/detail_1840.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201710/2017103014294695786.png" alt="原文:Swift - 集合（Set）使用详解（附样例）"></a></p>
<h2 id="二、创建集合"><a href="#二、创建集合" class="headerlink" title="二、创建集合"></a>二、创建集合</h2><h3 id="1，创建空集合"><a href="#1，创建空集合" class="headerlink" title="1，创建空集合"></a>1，创建空集合</h3><p>（1）Swift 中 Set 类型被写为 Set<element>，这里的 Element 表示 Set 中允许存储的类型。下面我们通过构造器语法创建一个特定类型的空集合：</element></p>
<p>Set</p>
<h3 id="2，创建带初始值的集合"><a href="#2，创建带初始值的集合" class="headerlink" title="2，创建带初始值的集合"></a>2，创建带初始值的集合</h3><p>（1）下面我们创建一个带有三个 String 类型的初始值的集合。</p>
<p>Set </p>
<h3 id="3，将数组转为集合"><a href="#3，将数组转为集合" class="headerlink" title="3，将数组转为集合"></a>3，将数组转为集合</h3><p><a href="http://www.hangge.com/blog/cache/detail_1840.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201710/201710301729496066.png" alt="原文:Swift - 集合（Set）使用详解（附样例）"></a></p>
<h2 id="三、元素访问与操作"><a href="#三、元素访问与操作" class="headerlink" title="三、元素访问与操作"></a>三、元素访问与操作</h2><h3 id="1，获取元素个数：count"><a href="#1，获取元素个数：count" class="headerlink" title="1，获取元素个数：count"></a>1，获取元素个数：count</h3><p><a href="http://www.hangge.com/blog/cache/detail_1840.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201710/2017103015020156150.png" alt="原文:Swift - 集合（Set）使用详解（附样例）"></a></p>
<h3 id="2，判断集合是否为空：isEmpty"><a href="#2，判断集合是否为空：isEmpty" class="headerlink" title="2，判断集合是否为空：isEmpty"></a>2，判断集合是否为空：isEmpty</h3><h3 id="3，添加一个新元素：insert"><a href="#3，添加一个新元素：insert" class="headerlink" title="3，添加一个新元素：insert()"></a>3，添加一个新元素：insert()</h3><h3 id="4，删除一个元素：remove"><a href="#4，删除一个元素：remove" class="headerlink" title="4，删除一个元素：remove()"></a>4，删除一个元素：remove()</h3><ul>
<li>如果删除值是该 Set 的一个元素，则删除该元素并且返回被删除的元素值。</li>
<li>如果该 Set 不包含该值，则返回 nil。</li>
</ul>
<h3 id="5，删除所有元素：removeAll"><a href="#5，删除所有元素：removeAll" class="headerlink" title="5，删除所有元素：removeAll()"></a>5，删除所有元素：removeAll()</h3><h3 id="6，判断集合中是否包含特定值：contains"><a href="#6，判断集合中是否包含特定值：contains" class="headerlink" title="6，判断集合中是否包含特定值：contains()"></a>6，判断集合中是否包含特定值：contains()</h3><h3 id="7，遍历集合元素"><a href="#7，遍历集合元素" class="headerlink" title="7，遍历集合元素"></a>7，遍历集合元素</h3><p>（1）可以使用 for in 循环遍历一个 Set 中的所有值。</p>
<p>Set </p>
<p>sorted() </p>
<p>&lt;</p>
<h2 id="四、集合的操作"><a href="#四、集合的操作" class="headerlink" title="四、集合的操作"></a>四、集合的操作</h2><h3 id="1，过滤集合元素"><a href="#1，过滤集合元素" class="headerlink" title="1，过滤集合元素"></a>1，过滤集合元素</h3><p>filter </p>
<p>Set</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1840.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201710/2017103017191193819.png" alt="原文:Swift - 集合（Set）使用详解（附样例）"></a></p>
<h3 id="2，两个集合的基本操作"><a href="#2，两个集合的基本操作" class="headerlink" title="2，两个集合的基本操作"></a>2，两个集合的基本操作</h3><p>（1）Set 提供了如下 4 个方法来实现通过现有的两个集合创建一个新的集合：</p>
<ul>
<li>intersection(_:)：根据两个集合中都包含的值创建的一个新的集合。</li>
<li>symmetricDifference(_:)：根据在一个集合中但不在两个集合中的值创建一个新的集合。</li>
<li>union(_:)：根据两个集合的值创建一个新的集合。</li>
<li>subtracting(_:)：根据不在该集合中的值创建一个新的集合。</li>
</ul>
<p><a href="http://www.hangge.com/blog/cache/detail_1840.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201710/2017103016402315045.png" alt="原文:Swift - 集合（Set）使用详解（附样例）"></a></p>
<p>（2）下面是一个简单的使用样例</p>
<h3 id="3，判断两个集合之间的关系"><a href="#3，判断两个集合之间的关系" class="headerlink" title="3，判断两个集合之间的关系"></a>3，判断两个集合之间的关系</h3><p>（1）我们可以通过如下几种方法进行判断：</p>
<ul>
<li>==：判断两个集合是否包含全部相同的值。</li>
<li>isSubset(of:)：判断一个集合中的值是否也被包含在另外一个集合中。</li>
<li>isSuperset(of:)：判断一个集合中包含另一个集合中所有的值。</li>
<li>isStrictSubset(of:)：判断一个集合是否是另外一个集合的子集合，并且两个集合并不相等。</li>
<li>isStrictSuperset(of:)：判断一个集合是否是另外一个集合的父集合，并且两个集合并不相等。</li>
<li>isDisjoint(with:)：判断两个集合是否不含有相同的值（是否没有交集）。</li>
</ul>
<p>（2）下面是一个简单的使用样例</p>
<h2 id="五、集合类型的哈希值"><a href="#五、集合类型的哈希值" class="headerlink" title="五、集合类型的哈希值"></a>五、集合类型的哈希值</h2><h3 id="1，哈希值说明"><a href="#1，哈希值说明" class="headerlink" title="1，哈希值说明"></a>1，哈希值说明</h3><ul>
<li>一个类型如果想要存储在集合中，那么该类型必须是可哈希化的。也就是说，该类型必须提供一个方法来计算它的哈希值。</li>
<li>哈希值是 Int 类型，相等对象的哈希值必须相同。比如：a==b，那么必定有 a.hashValue == b.hashValue。</li>
<li>Swift 的所有基本类型（如 String，Int，Double，Bool）默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值默认也是可哈希化的。</li>
</ul>
<h3 id="2，自定义类型的哈希化"><a href="#2，自定义类型的哈希化" class="headerlink" title="2，自定义类型的哈希化"></a>2，自定义类型的哈希化</h3><p>（1）如果想要自定义的类型作为集合的值类型或者是字典的键类型，那么这个自定义类型必需符合 Swift 标准库中的 Hashable 协议。符合 Hashable 协议的类型需要提供一个类型为 Int 的可读属性 hashValue。</p>
<p>（2）因为 Hashable 协议符合 Equatable 协议，所以遵循该协议的类型也必须提供一个”是否相等”运算符（==）的实现。这个 Equatable 协议要求任何符合 == 实现的实例间都是一种相等的关系。也就是说，对于 a、b、c 三个值来说，== 的实现必须满足下面三种情况：</p>
<ul>
<li>自反性：a == a</li>
<li>对称性：a == b 意味着 b == a</li>
<li>传递性：a == b &amp;&amp; b == c 意味着 a == c</li>
</ul>
<h3 id="3，样例代码"><a href="#3，样例代码" class="headerlink" title="3，样例代码"></a>3，样例代码</h3><p>（1）这里我们自定义一个结构体（User），用来做为 Set 里的值的类型。</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1840.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201710/2017103020071386106.png" alt="原文:Swift - 集合（Set）使用详解（附样例）"></a></p>
<p>原文出自：</p>
<p>www.hangge.com</p>
<p>  转载请保留原文链接：</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1840.html" target="_blank" rel="noopener">http://www.hangge.com/blog/cache/detail_1840.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Set </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift实践：使用CoreData完成上班签到小工具]]></title>
      <url>/2018/04/24/%E8%87%AA%E5%AE%9A%E4%B9%89CoreData%20Stack/</url>
      <content type="html"><![CDATA[<p>转：<a href="https://www.jianshu.com/p/6541b45ee991" target="_blank" rel="noopener">https://www.jianshu.com/p/6541b45ee991</a></p>
<p>之前在前两篇里面实现了一个十分简陋的通讯录，而且都是通过系统默认的方式创建的CoreData。可是实际中哪里有那么好的事情嘛，要是忘记在创建工程的时候勾选了下面这个图怎么办？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2248583-e0cfcfbd3af68761.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="img"></p>
<p>image.png</p>
<p>难道我们要把工程删除，再重新创建嘛？很多时候再开始工程的时候并特么的不知道需要用到数据库啊。更多的时候已经都开始敲代码了，连需求文档都还木有拿到手里，PM只会轻轻的说一句：设计图不是已经有了嘛，先画UI吧。</p>
<p>所以，CoreData Stack是为了解决这个问题诞生的嘛？很遗憾，并不是。看了前面的两篇文章之后，有木有觉得CoreData不怎么好用，还挺麻烦的呐？这时候要祭出CoreData Stack的啦。</p>
<h1 id="1-CoreData-Stack的作用"><a href="#1-CoreData-Stack的作用" class="headerlink" title="1. CoreData Stack的作用"></a>1. CoreData Stack的作用</h1><p>其实这个东西在一篇的时候提到过，不信您看：<a href="https://www.jianshu.com/p/3e793fca6a13" target="_blank" rel="noopener">Swift实践：使用CoreData完成一个通讯录存储</a></p>
<p>一个基本的 Core Data 栈由四个主要部分组成：托管对象 (NSManagedObject)，托管对象上下文 (NSManagedObjectContext)，持久化存储协调器 (NSPersistentStoreCoordinator)，以及持久化存储 (NSPersistentStore)。</p>
<p>CoreDataStack，是自定义的一个CoreData 的栈对象，可以通过它，初始化项目的CoreData，以及获取到Context，对数据库进行增删改查等操作。</p>
<h1 id="2-创建-CoreData-Stack"><a href="#2-创建-CoreData-Stack" class="headerlink" title="2.创建 CoreData Stack"></a>2.创建 CoreData Stack</h1><p>非典型技术宅既然说了这货有四部分组成，那咱们就一个一个来呗。艾玛，因为发现文章会被抄袭，抄袭之后有些人还不署名，搞的只好在文章里面内嵌入一些自己的名字。心酸~~~~</p>
<h2 id="2-1-iOS9"><a href="#2-1-iOS9" class="headerlink" title="2.1 iOS9"></a>2.1 iOS9</h2><p>在iOS9中，CoreData Stack的三个核心类是这样的：</p>
<p>-管理对象上下文NSManagedObjectContext</p>
<ul>
<li>对象模型NSManagedObjectModel</li>
<li>存储调度器NSPersistentStoreCoordinator</li>
</ul>
<p>这个时候存储是在Documents中间。</p>
<h2 id="2-2-iOS10之后"><a href="#2-2-iOS10之后" class="headerlink" title="2.2 iOS10之后"></a>2.2 iOS10之后</h2><p>iOS10之后就有点不一样了, 增加了一个叫做<code>NSPersistentContainer</code>的东西。这个玩意儿作用就是用来管理CoreData Stack，为了能够让大家用起来更爽、更简单。</p>
<p>需要说明的是，<code>NSPersistentContainer</code> 一点都没有向下兼容的意思，完全不兼容iOS9.0，如果非要在iOS9.0里面使用，会直接闪退。</p>
<p>这个时候存储是在Library-&gt;Application Support中。</p>
<h2 id="2-3-来吧，开始创建吧"><a href="#2-3-来吧，开始创建吧" class="headerlink" title="2.3 来吧，开始创建吧"></a>2.3 来吧，开始创建吧</h2><p>宅胖这么懒，怎么还可能再写一个兼容iOS9.0的呐，想太多了~~~哈哈！所以，俺们只写iOS10.0以后的。写到这个时候，连版本号都已经写烦了。</p>
<ul>
<li>Step1:搞一个NSPersistentContainer出来</li>
<li>Step2:创建CoreData Stack</li>
<li>Step3：别忘了还有一个NSManagedObjectContext</li>
<li>Step4：提供一个保存数据的方法</li>
<li>Step5：最后别忘记了在<code>AppDelegate.swift</code>里面应用一下，不然不是白搞了半天嘛</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">lazy var storeContainer: NSPersistentContainer = &#123;</span><br><span class="line">   let container = NSPersistentContainer(name: self.modelName)</span><br><span class="line"></span><br><span class="line">    container.loadPersistentStores(completionHandler: &#123; (storeDescription, error) in</span><br><span class="line">        if let error = error as NSError? &#123;</span><br><span class="line">            debugPrint(&quot;Unclear error\(error)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return container</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">lazy var managedContext: NSManagedObjectContext = &#123;</span><br><span class="line">    return self.storeContainer.viewContext</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">func saveContext() &#123;</span><br><span class="line">    guard managedContext.hasChanges else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        try managedContext.save()</span><br><span class="line">    &#125; catch let error as NSError &#123;</span><br><span class="line">        debugPrint(&quot;Unclear error\(error)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-一对多的关系"><a href="#3-一对多的关系" class="headerlink" title="3. 一对多的关系"></a>3. 一对多的关系</h1><p>CoreData中实体管理关系是有三种的：1V1,1VN,NVN。咱们之前的两个例子都是1V1。但是这个跟生活中不符啊，不能什么事情都是一对一啊，<del>例如一夫一妻制，有的地方还是一妻多夫制呐，还有换妻换夫怎么办？政治不正确啊，非典型技术宅！！注意</del> 例如一个人下了很多订单，订单里面又包含了很多商品。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2248583-c90bc42261c0819d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>image.png</p>
<p>如图所示，Relationships表示管理关系的名称，Destination表示目标表的名字，Inverse表示反向关系。</p>
<p>前面两个都比较好理解，Inverse需要稍微多说一点点。如果没有反向关系，就选择No Inverse，但是苹果官方建议为了保证数据之间的一致性，最好设置反向关系。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2248583-01cc588a83bc71e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/524" alt="img"></p>
<p>image.png</p>
<h1 id="4-完成Demo，了解使用CoreData-Stack"><a href="#4-完成Demo，了解使用CoreData-Stack" class="headerlink" title="4. 完成Demo，了解使用CoreData Stack"></a>4. 完成Demo，了解使用CoreData Stack</h1><p>然后咱们搞个小型本地化纯良心自觉单机版的打卡器。这个打卡器用来管理员工的每次打卡时间。可以增加、删除打卡时间。</p>
<p>完成后的效果图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2248583-483fb9fd28b50367.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/334" alt="img"></p>
<p>attentances.gif</p>
<p>思维导图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2248583-0ac46f3a43ad2f37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>image.png</p>
<h1 id="4-补充：如果创建工程的时候遗忘了勾选使用CoreData怎么办"><a href="#4-补充：如果创建工程的时候遗忘了勾选使用CoreData怎么办" class="headerlink" title="4. 补充：如果创建工程的时候遗忘了勾选使用CoreData怎么办"></a>4. 补充：如果创建工程的时候遗忘了勾选使用CoreData怎么办</h1><p>如果忘选了也没有关系，创建一个新的Data Model文件：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2248583-da84211ca32b7c3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>image.png</p>
<p>设置完数据库之后，按照如下操作：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2248583-07814e13242fca6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>image.png</p>
<p>好啦，就会自动生成文件啦。</p>
<p>所有的源代码都在这里：<br><a href="https://link.jianshu.com/?t=https://github.com/Stanbai/CoreDataDemo.git" target="_blank" rel="noopener">https://github.com/Stanbai/CoreDataDemo.git</a></p>
<hr>
<p><a href="https://www.jianshu.com/p/3e793fca6a13" target="_blank" rel="noopener">Swift之CoreData系列之一：基础存储</a></p>
<p><a href="https://www.jianshu.com/p/a87d29610629" target="_blank" rel="noopener">Swift之CoreData系列之二：存储多种数据类型</a></p>
<p><a href="https://www.jianshu.com/p/6541b45ee991" target="_blank" rel="noopener">Swift之CoreData系列之三：自定义CoreData Stack</a></p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> CoreData </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift中的集合类数据结构]]></title>
      <url>/2018/04/23/Swift%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>假设你有一个需要处理许多数据的应用。你会把收据放在哪儿？你怎么样高效地组织并处理数据呢？</p>
<p>如果你的项目只处理一个数字，你把它存在一个变量中。如果有两个数字你就用两个变量。<br>如果有1000个数字，10，000个字符串或者终极模因库呢（能马上找到一个完美的模因不是很好吗）？在那种情况下，你将会需要一种基本的集合类数据结构。幸运的是，这篇教程就是关于那个主题的。</p>
<p>下面是这篇教程的构成：</p>
<ul>
<li>你将会复习什么是数据结构并学习大O符号。这是用来描述不同的数据结构性能的标准工具。</li>
<li>下一步：通过衡量arrays,disctionaries 以及 sets 这些 Cocoa 开发中最基本的数据结构的性能进行练习。同时这篇文章也会介绍一些基础的性能测试的方法。</li>
<li>继续学习，你将会比较成熟的 Cocoa 数据结构与对应的纯 Swift 结构的性能。</li>
<li>最后，你会简要地复习一下 Cocoa 中提供的一些相关类型。下面关于这些数据结构的内容可能让你很惊讶，但其实都是你常用的那些。</li>
</ul>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/10/data-structures-square-250x250.png" alt="你想让你的数据结构表现出怎样的性能呢？"></p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在你深入探索iOS中使用的数据结构之前，你应该先复习一下他们是什么，以及怎么测量他们的性能这些基本的概念。</p>
<p>有许多集合类数据结构的类型，每一个都代表了一个特定的方法去组织并获取一个数据的集合。集合类型可能会使一些操作变得十分高效，例如添加新的数据，查找最小的数据以及保证不会重复添加数据。</p>
<p>没有集合数据类型，你将会陷入试图一个一个地管理数据的困境中。集合能够让你实现：<br>* 将所有的数据作为一个实体来处理<br>* 给他们设置一些结构<br>* 高效地插入、删除、并检索数据</p>
<h3 id="什么是大O标记"><a href="#什么是大O标记" class="headerlink" title="什么是大O标记"></a>什么是大O标记</h3><p>大O，说的是字母O，而不是数字0，符号是一种描述某种数据结构上的某种操作的效率的方法。有很多种衡量效率的方法：你可以衡量这种数据结构消耗了多少内存，在最坏的情况下消耗的时间，它花费的平均时间是多少等等。</p>
<p>在这篇教程中，你将会衡量一种操作消耗的平均时长。</p>
<p>通常，大量的数据不会使得操作更快。大多数情况下是相反的，但有时候差别很小甚至没有差别。大O标记是一种描述这种情况的精确的方法。你能够写出一个具体的函数式来大概表示基于结构中数据的数量运行时间的变化情况。</p>
<p>当你看到大O标记被写作O(与n相关的函数)，括号中的n就表示数据结构中数据的数量，而”与n相关的函数”则大约表示操作将要消耗的时间。</p>
<p>“大约”，确实有点讽刺，但是它有特定的含义：当n非常大时函数的渐进值。假设n是很大很大的数，当你将参数从n修改为n+1时，考虑一些操作的性能会怎样变化。</p>
<blockquote>
<p>注意：这些都是算法复杂度分析中的一部分，如果你想深入探索的话，就多读些计算机科学类的书籍。你将不再束手无策，你会发现一些分析复杂度的数学方法，不同效率之间的微小差异，关于未知机器模型的更精细化的公式化的假设，以及更多其他你能想到或者想象不到的有趣的东西。</p>
</blockquote>
<p>常见的大O性能测量如下：排列顺序是由最好的性能到到最差的性能</p>
<ul>
<li>O(1)(稳定的时间)：无论数据结构中有多少数据，这个函数都调用同样数量的操作。这是理想的性能。</li>
<li>O(log n)(对数级):这个函数调用的操作数量随着数据结构中的数据量对数级增长。这是很好的性能了，因为相比较数据结构中的数据的数量它的增长速度要慢得多。</li>
<li>O(n)（线性）：函数调用的操作数随着数据结构的数据量线性增长。这是较为合适的性能，但是如果是较大的数据集合就不合适了。</li>
<li>O(n (log n))：这个函数调用操作的数量是由数据结构中的数据量的对数乘以数据结构中的数据量。可以预见的是，这是现实中对性能的最低容忍度。较大的数据结构会执行更多的操作，对于数据量较小的数据结构来说增长是较为合理的。</li>
<li>O(n²)（平方）：这个函数调用操作的数量是数据结构大小的平方 - 是差性能中最好的。即使你是在处理一些很小的数据结构它也会很快就变得特别慢。</li>
<li>O(2^n)（指数）：函数调用的操作数与数据结构是2的n次方的关系。这会导致很差的性能并很快就变得特别慢。</li>
<li>O(n!) (阶乘)：函数调用的操作数与数据结构之间是阶乘的关系。实际上，这是性能最差的情况。例如，在一个有100个数据的结构中，操作的数量的乘积是个158位的数。</li>
</ul>
<p>下面是一个更直观的性能图。当集合中的数据量从1变化至25时，性能会怎么降低：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/09/Screen-Shot-2014-09-14-at-11.54.21-AM-700x460.png" alt="图片"></p>
<p>你有没有发现你几乎看不到绿色的O(log n)线？因为在这个范围内它几乎与理想中的O(1) 重合。那太好了！另一方面， O(n!)和O(2^n)标记的操作性能下降得特别快，当集合中有超过10个数据时操作的数量在图表中飙升了起来。<br>是的！正如图表中清楚展示的，你处理的数据越多，选择正确的数据结构就越重要。</p>
<p>现在你已经知道怎么比较基于某种数据结构的数据操作的性能了。下面我们来复习一下iOS中最常用的三种数据类型以及他们在理论和实践中是如何发挥作用的。</p>
<h2 id="常见iOS数据结构"><a href="#常见iOS数据结构" class="headerlink" title="常见iOS数据结构"></a>常见iOS数据结构</h2><p>iOS中三种最常用的数据结构是arrays，dictionaries 和 sets。首先你要考虑他们与作为基本抽象的完美类型的区别，然后你需要检查iOS提供的代表这些抽象的具体类的性能。（First you’ll consider how they differ in ideal terms as fundamental abstractions, and then you’ll examine the performance of the actual concrete classes which iOS offers for representing those abstractions.）首先你得从字面上去理解他们作为基本的抽象类型的区别，然后你需要检查在 iOS 中这些具体类表现的性能，从而知道 iOS 为啥提供这些抽象命名给它们。</p>
<p>对于这三种主要结构的类型来说，iOS 提供了多种具体的类来支持抽象的结构。除了在 Swift 和Objective-C 中旧的 Foundation 框架中的数据结构，现在又有了新的仅支持 Swift 版本的数据结构与语言紧密结合在一起。</p>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>数组就是以一定顺序排列的一组数据，你可以通过索引来获取每一个数据元素，索引代表数据在排列中的位置。当你在数组变量名称后面的括号中写上索引时，这就叫做下标。</p>
<p>在 Swift 中，如果你用<code>let</code>将数组作为常量来定义，他们就是不可变的，如果用 <code>var</code> 定义为变量他们就是可变的。</p>
<p>作为对比，Foundation 框架中的 <code>NSArray</code> 默认是不可变类型，如果你想在数组创建之后添加、删除或者修改数据，你必须使用可变类 <code>NSMuatbleArray</code>。</p>
<p><code>NSArray</code> 是异质的，那也就意味着他可以包含不同类型的 Cocoa 对象。 Swift 数组是同质的，意味着每一个 Swift 数组都只包含一种类型的对象。</p>
<p>不过，你仍然可以通过将一个类型定义为 <code>AnyObject</code> 类型，使定义的 Swift 数组能够存储可变的 Cocoa 对象类型。</p>
<h3 id="期望性能以及什么时候使用数组"><a href="#期望性能以及什么时候使用数组" class="headerlink" title="期望性能以及什么时候使用数组"></a>期望性能以及什么时候使用数组</h3><p>使用数组来存储变量的一个首要原因是顺序能发挥重要作用。例如，你会通过名或者姓来排列联系人，按日期写一个计划列表，或者任何很需要通过某种顺序来查找或者展示数据的情形。</p>
<p>苹果的文档在<a href="http://www.opensource.apple.com/source/CF/CF-550.13/CFArray.h" target="_blank" rel="noopener">CFArray header</a>一篇中阐明了三种关键的预期：</p>
<ul>
<li>在数组中通过一个特定的索引获取值的时间复杂度最坏是O(log n)，但通常应该是O(1)。</li>
<li>搜索一个未知索引的对象的时间复杂度最坏是O(n (log n))，但一般应该是O(n)。</li>
<li>插入或者删除一个对象最坏的时间复杂度是O(n (log n))，但经常是O(1)。</li>
</ul>
<p>这些保证了数组会基本如你在计算机科学的教材或者是C语言中那样，总是一段连续内存中的数据序列，是一种“理想型”数组。</p>
<p>将它作为一个有效的提醒去查看文档。</p>
<p>实际上，当你考虑下面这些的时候这些预期很有意义：</p>
<ul>
<li>当你已经知道一个数据在哪儿并且需要查找时，那应该是很快的。</li>
<li>如果你不知道某个数据在哪儿，你可能需要将数组从头到尾遍历一遍，查找的过程可能会比较慢。</li>
<li>如果你知道要把某个数据添加到哪里或者从哪儿删除，那不是很困难，虽然后来你可能需要调整数组的剩余部分，那得花费些时间。</li>
</ul>
<p>这些预期与现实是一致的吗？继续往下看：</p>
<h3 id="示例App测试结果"><a href="#示例App测试结果" class="headerlink" title="示例App测试结果"></a>示例App测试结果</h3><p>从这篇教程中下载<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2014/11/DataStructures_Swift_1_22.zip" target="_blank" rel="noopener">示例项目</a>并在 Xcode 中打开。里面有些方法可以创建或者/并且测试数组，并且展示给你执行每个任务消耗的时间。</p>
<p>需要注意的是：在应用中，测试配置会自动将优化选项设置成和发布配置一样的选项。这样当你测试app的时候，你就能获得和真实环境一样的优化选项。</p>
<p>你需要至少1000个数据才可以用示例app进行测试。当你编译运行的时候，滑块会被设置到1000.点击<code>Create Array and Test</code>按钮，你将马上进入测试：<br><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/11/2015-04-21-19.50.12-281x500.png" alt="img"></p>
<p>将滑块向右拖动直到数据达到10，000，000，再次按下<code>Create Array and Test</code>按钮，看看这个明显增大的数组的创建时间与刚才有什么不同：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/11/2015-04-21-19.51.44-281x500.png" alt="img"></p>
<p>这些测试是在 Xcode6.3（内含Swift1.2）,iOS 8.3系统，iPhone6 模拟器上运行的。在数据增加了10，000倍的情况下，创建数组花费的时间只消耗了714倍。</p>
<p>O(n)函数意味着增加10，000倍的数据将会消耗10，000倍的时间，O(log n)函数意味着增加10，000倍的数据将会消耗4倍的时间。这个例子中的性能处于O(log n)和O(n)之间，这是相当稳定的。</p>
<p>这个过去一直都消耗了较长的时间。很久之前写的这篇教程的最初版本，是运行在Xcode6.0 Gold Master版(Swift6.0)，iOS8 Gold Master版，iPhone5 上，测试消耗了相当长的时间：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/09/IMG_5140-281x500.png" alt="图图1"></p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/09/IMG_5139-281x500.png" alt="图图2"></p>
<p>在这个例子中，大约106.5倍的数据，消耗了大约1，417倍的时间去创建数组。</p>
<p>如果要实现O(n)的性能，106.5倍的数据预期消耗时间应该是3.7秒。而以O(n log n)增长，预期消耗时间是33.5秒。以O(n²)增长，预期消耗时间395秒。</p>
<p>所以在这个例子中，Swift 中的 Array 的创建时间大约在O(n log n)和O(n²)之间。如你所见，当你的数据增加数十倍的时候时间消耗就过大了。</p>
<p>这个时间就不容乐观了。不过，更新至 Swift1.2 之后，你创建多大的数组都没有问题！</p>
<p>那么 <code>NSMutableArray</code> 呢？你仍然可以在 Swift 中调用 Foundation 的类而不需要使用<code>Objective-C</code>，你会发现还有一个Swift类叫做 <code>NSArrayManipulator</code> 遵守同样的协议 <code>ArrayManipulator</code>。</p>
<p>正因如此，你可以轻松将 <code>NSMutableArray</code> 替换成 Swift 中的数组。项目代码很简单，你可以尝试修改一行来对比 <code>NSMuatbleArray</code> 的性能。</p>
<p>打开<code>ArrayViewController.swift</code>文件并将第27行由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arrayManipulator: ArrayManipulator = SwiftArrayManipulator()1</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arrayManipulator: ArrayManipulator = NSArrayManipulator()1</span><br></pre></td></tr></table></figure>
<p>再次编译运行，点击 <code>Create Array and Test</code> 测试有1000个数据的<code>NSMutableArray</code> 数组的创建：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/11/2015-04-21-20.20.34.png" alt="img"></p>
<p>然后再次修改数据为10，000，000：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/11/2015-04-21-20.20.45.png" alt="img"></p>
<p>创建操作原始的性能不如 Swift1.2 中的好 - 虽然一部分可能是因为需要在那些可以存储在<code>NSArray</code> 中和他们对应的Swift的类型中的对象之间来回操作。</p>
<p>不管怎样，你创建一个数组只需要一次 - 但是需要经常执行的是其他一些操作例如查找，添加，或者是移除对象。</p>
<p>在更深入的测试中，例如当你使用 Xcode6 中的一些性能测试方法分别调用每一个方法50次，一种模式就开始呈现了：</p>
<ul>
<li>创建一个 Swift 数组和 NSArray 数组消耗相同的时间 - 介于O(log n)和O(n)之间。而至于拥有5，000到25，000个数据的数组，Swift 比 Foundation 花费大约三倍的时间 - 但是都低于0.02秒。</li>
<li>在 Swift 中向一个数组结构的对象的开始或者是中间添加数据，相对于 Foundation 中（大约在O(1)左右）是慢很多的。向 Swift 数组的结尾添加数据（时间少于O(1)）实际上比向 NSArray 的结尾添加数据（多于O(1)）要快。</li>
<li>在 Foundation 和 Swift 数组结构中移除对象操作的性能表现是很相似的：从开头，之间，或者结尾移除一个对象时间大约在O(log n)和O(n)之间。从数组的开头移除数据这一操作在Swift中性能略差，但是时间差异是毫秒级的。</li>
<li>通过索引查找所消耗的时间在Swift数组以及 <code>NSArray</code> 中以相同的速率增长。当你通过索引查找数据，数组很大时，Swift 数组消耗的时间相比使用 NSMutableArray 类型的对象快将近10倍。</li>
</ul>
<blockquote>
<p>注意：你可以在<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/11/performance-test-iPhone-6-iOS-8.3-Swift-1.2.numbers.zip" target="_blank" rel="noopener">iPhone6性能测试</a>电子表格程序中获得将每个方法运行50次的结果（环境：Xcode 6.3 已发布版本，Swift 1.2，iOS 8.3系统，iPhone6）。你也可以尝试运行应用中包含的测试看看每运行10次的平均结果，以及他们在你手机上是如何运行的。</p>
</blockquote>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/08/Screen-Shot-2014-08-12-at-7.48.28-PM-414x320.png" alt="img"></p>
<p>字典是一种不需要特定的顺序且数据都与唯一的键相联系的储值方式。你可以使用键来存储或者是查询一个值。</p>
<p>字典也使用下标语法。当你写<code>dictionary[&quot;hello&quot;]</code>，你就会得到与键<code>hello</code>对应的值。</p>
<p>像数组一样，在 Swift 中你如果用<code>let</code>来声明字典它就是个常量，如果用<code>var</code><br>来声明它就是可变的。在 Foundation 框架方面也是类似的，有 <code>NSDictionary</code> 和 <code>NSMutableDictionary</code> 两种类型供你使用。</p>
<p>与 Swift 数组相似的另外一个特征就是字典也是强类型的（即对于程序里的每一个变量，在使用前必须声明类型，赋值的时候也必须与变量的类型相同），你必须有已知类型的键值对。<code>NSDictionary</code> 类型的对象可以以任何 <code>NSObject</code> 的子类对象作为 <code>key</code>，可以存储任意类型的对象为值。</p>
<p>当你调用某个使用或者返回一个字典类型的 Cocoa 的 API 时，你就会看到它在实际中的样子。在 Swift 中，这个类型以 <code>[NSObject: AnyObject]</code> 这种形式来描述。也就是说这个类型必须以 <code>NSObject</code> 的子类作为键，而值可以是任何兼容 Swift 的对象。</p>
<h3 id="什么时候使用字典"><a href="#什么时候使用字典" class="headerlink" title="什么时候使用字典"></a>什么时候使用字典</h3><p>当你要存储的数据没有特定的顺序，而又有某种意义上的关联的时候，字典是最好的选择。</p>
<p>为了帮你检验字典以及这篇教程中其他的数据结构是如何工作的，通过<code>File…\New\Playground</code>创建一个<code>Playground</code>，并把它命名为 DataStructures。</p>
<p>例如，你需要存储一个数据结构，他们包含了你所有的朋友以及他们的猫的名字，这样你就可以通过你朋友的名字查找他们的猫的名字。这样一来，你就不需要记住猫的名字以获得朋友的亲睐。</p>
<p>首先，你需要存储朋友和猫的字典：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let cats = [ &quot;Ellen&quot; : &quot;Chaplin&quot;, &quot;Lilia&quot; : &quot;George Michael&quot;, &quot;Rose&quot; : &quot;Friend&quot;, &quot;Bettina&quot; : &quot;Pai Mei&quot;]1</span><br></pre></td></tr></table></figure>
<p>由于 Swift 的类型推断，上述类型被定义为 [String: String] - 键值均为字符串类型的字典。</p>
<p>现在尝试在里面获取数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cats[&quot;Ellen&quot;] //returns Chaplin as an optional</span><br><span class="line">cats[&quot;Steve&quot;] //Returns nil12</span><br></pre></td></tr></table></figure>
<p>注意字典中的下标语法返回一个可选类型。如果字典中不包含某个特定键的值，可选类型为<code>nil</code>；如果包含那个键对应的值，你就可以将其解包获取值。</p>
<p>这样一来，使用<code>if let</code>可选类型解包语法从字典中获取值就是个很不错的办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if let ellensCat = cats[&quot;Ellen&quot;] &#123;</span><br><span class="line">    println(&quot;Ellen&apos;s cat is named \(ellensCat).&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    println(&quot;Ellen&apos;s cat&apos;s name not found!&quot;)</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure>
<p>由于确实存在<code>‘Ellen’</code>对应的值，你的 playground 中就会打印<code>‘Ellen’s cat is named Chaplin’</code>。</p>
<h3 id="预期的性能"><a href="#预期的性能" class="headerlink" title="预期的性能"></a>预期的性能</h3><p>苹果再一次在 Cocoa 的<a href="http://opensource.apple.com/source/headerdoc/headerdoc-8.5.10/ExampleHeaders/CFDictionary.h" target="_blank" rel="noopener">CFDictionary.h</a>头文件中概括了字典的期望性能：</p>
<p>1.从字典中获取值的时间复杂度最坏是<code>O(n)</code>，但一般应该是<code>O(1)</code>。<br>2.插入和删除数据的时间复杂度最坏是<code>O(n²)</code>，但由于顶层的优化通常更接近<code>O(1)</code>。</p>
<p>这些没有数组中的性能表现那样明显。由于存储键值对相较于一个有序的数组有更复杂的本质，所以性能不那么好预测。</p>
<h3 id="示例程序测试结果"><a href="#示例程序测试结果" class="headerlink" title="示例程序测试结果"></a>示例程序测试结果</h3><p><code>DictionaryManipulator</code>是跟<code>ArrayManipulator</code>类似的一个协议，它可以测试字典。你可以用它测试Swift<code>Dictionary</code>和<code>NSMutableDictionary</code>在执行相同的操作时的性能。</p>
<p>为了比较 Swift 和 Cocoa 字典，你可以使用与上述数组的测试程序相似的步骤。编译运行app，选择底部的<code>Dictionary</code>标签。</p>
<p>运行几个测试程序 - 你会发现创建一个字典比创建数组消耗的时间要长得多。如果你把数据滑块滑到10，000，000的位置，你可能会收到内存警告甚至内存溢出崩溃！</p>
<p>回到 Xcode 中，打开<code>DictionaryViewController.swift</code>文件并找到<code>dictionaryManipulator</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let dictionaryManipulator: DictionaryManipulator = SwiftDictionaryManipulator()1</span><br></pre></td></tr></table></figure>
<p>用下面的代码替换它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let dictionaryManipulator: DictionaryManipulator = NSDictionaryManipulator()1</span><br></pre></td></tr></table></figure>
<p>现在应用底层将会使用 <code>NSDictionary</code>。再次编译运行app，多进行几次测试。如果你是在 Swift1.2 上运行的，你的发现可能与一些扩展测试中的发现相一致：</p>
<ul>
<li>在时间消耗上来看，创建 Swift 字典比创建 <code>NSMutableDictionaries</code> 要慢得多 - 但性能都以<code>O(n)</code>的速率降低。</li>
<li>向 Swift 字典中添加数据的时间比向 <code>NSMutableDictionaries</code> 类型的对象中添加数据大约快3倍，并且性能如苹果的文档中保证的那样，最好能达到<code>O(1)</code>的速率。</li>
<li>Swift 和 Foundation 的字典都能以大约<code>O(1)</code>的速率进行查找。不像 Swift 数组，字典并不比 Foundation 中的字典性能要好，但是他们非常得接近。</li>
</ul>
<p>现在，进入 iOS 中最后一个主要的数据结构：集合！</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合是一种存储无序的，值唯一的数据结构。当你向一个集合中添加同样的数据时，数据不会被添加。这里的“同样地”即满足方法<code>isEqual()</code>。</p>
<p>Swift 在1.2版本中添加了对原生<code>Set</code>类型的支持 - 早期的Swift版本，你只能获取<code>Foundation</code>框架下的<code>NSSet</code>类型。Swift 集合中的元素，也必须拥有相同的类型。</p>
<p>注意，就像数组和字典那样，对于一个原生的 Swift 集合来说，如果你用<code>let</code>关键字进行声明它就是常量，如果用<code>var</code>声明就是可变的。在 <code>Foundation</code> 方面，也都有 <code>NSSet</code> 和 <code>NSMutableSet</code> 供你使用。</p>
<h3 id="什么时候使用集合"><a href="#什么时候使用集合" class="headerlink" title="什么时候使用集合"></a>什么时候使用集合</h3><p>当数据的唯一性很重要而顺序无所谓时可以使用集合。例如，如果你想从八个名字的数组中随机选出四个名字并且没有重复时，你会选择什么呢？</p>
<p>在你的 <code>Playground</code> 中输入下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let names = [&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Mick&quot;, &quot;Keith&quot;, &quot;Charlie&quot;, &quot;Ronnie&quot;]</span><br><span class="line">var stringSet = Set&lt;String&gt;() // 1</span><br><span class="line">var loopsCount = 0</span><br><span class="line">while stringSet.count &lt; 4 &#123;</span><br><span class="line">    let randomNumber = arc4random_uniform(UInt32(count(names))) //2</span><br><span class="line">    let randomName = names[Int(randomNumber)] //3</span><br><span class="line">    println(randomName) //4</span><br><span class="line">    stringSet.insert(randomName) //5</span><br><span class="line">    ++loopsCount //6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//7</span><br><span class="line">println(&quot;Loops: &quot; + loopsCount.description + &quot;, Set contents: &quot; + stringSet.description)12345678910111213</span><br></pre></td></tr></table></figure>
<p>在这一小段代码中，你在做下面的事情：</p>
<p>1.初始化集合，这样你就可以在里面添加数据。<br>2.在0和名字的个数中间选一个随机值。<br>3.获取所选数字为索引对应的名字。<br>4.打印出选择的名字。<br>5.将选择的名字添加至可变的集合。记住，如果名字已经在集合里面了，集合就不会变化，因为集合不会存储重复的数据。<br>6.loop计数器一直在增加，这样你就可以看到循环执行了多少次。<br>7.一旦循环结束，打印loop计数器的值和可变集合中的内容。</p>
<p>在这个例子中我们使用了一个随机数字生成器，你每次都能获取到一个不同的结果。下面的示例是写这篇教程时的其中一次运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">John</span><br><span class="line">Ringo</span><br><span class="line">John</span><br><span class="line">Ronnie</span><br><span class="line">Ronnie</span><br><span class="line">George</span><br><span class="line">Loops: 6, Set contents: [&quot;Ronnie&quot;, &quot;John&quot;, &quot;Ringo&quot;, &quot;George&quot;]1234567</span><br></pre></td></tr></table></figure>
<p>在这儿，为了得到唯一的名字循环执行了6次。它分别选择了 Ronnie 和 John 两次,但是只在集合中添加了一次。</p>
<p>当你在 playground 中写下这个循环时，你会注意到它一遍一遍地执行，每次循环你都会得到一个不同的数字。每次运行都至少有四次循环，因此集合中必须有四个数据才能跳出循环。</p>
<p>现在你已经看到了一个较小的集合是怎样工作的，下面我们来看看存储较大数据量的集合的性能。</p>
<h3 id="示例应用测试结果"><a href="#示例应用测试结果" class="headerlink" title="示例应用测试结果"></a>示例应用测试结果</h3><p>不像数组和字典，苹果没有概括集合性能的大概的预期（Swift集合文档中对几个方法的性能有预期描述，但是没有 <code>NSMutableSet</code> 对应的预期），所以在这里你只需要观察实际情况中的性能。</p>
<p>Swift1.2 版本的示例项目在 <code>SetViewController</code> 类中有 <code>NSSetManipulator</code> 和<code>SwiftSetManipulator</code> 对象，这与 <code>Array</code> 和 <code>Dictionary</code> 的视图控制器中的配置类似，并且也可以以同样地方式进行替换。</p>
<p>在这两种情况下，如果你追求纯粹的速度，使用<code>Set</code> 可能不能令你满意。<code>Set</code> 和 <code>NSSet</code> 相较于 <code>Array</code> 和 <code>NSMutableArray</code> ，你会发现集合的时间要慢得多 - 这就是你为了检查每一个数据在数据结构中是否是唯一所付出的代价。</p>
<p>进一步的测试显示由于 Swift 的集合相对于数组和字典来说，处理数据花费的时间要多一些，他的性能以及执行大多数操作所消耗的时间都与 <code>NSSet</code> 非常的相似：创建，移除，以及查找操作对于 <code>Foundation</code> 和 <code>Swift</code> 来说消耗的时间几乎是相同的。</p>
<p>在 <code>Swift</code> 和 <code>Foundation</code> 中创建一个集合类型的对象消耗时间大约都以<code>O(n)</code>增长 - 这与预期相符，因为集合中的每一个数据被添加进来之前都要检查是否与已有数据相等。</p>
<p>在 <code>Swift</code> 和 <code>Foundation</code> 中删除和查找操作的性能大约是<code>O(1)</code>。这种情况是很稳定的，因为集合结构使用哈希值来检查是否相等，而哈希值可以以某个顺序进行计算和存储。这就使得查找操作明显比数组中的查找要快。</p>
<p><code>NSMutableSet</code> 和 Swift 原生的 <code>Set</code> 性能上主要的差异在于添加对象的操作。</p>
<p>总之，向一个 <code>NSSet</code> 中添加对象时间复杂度约为<code>O(1)</code>，而在 Swift 的 <code>Set</code> 结构下可能就高于<code>O(n)</code>了。</p>
<p>Swift 在它短暂的公众生涯中，已经在集合类数据结构的性能方面有了很大的提升，并且随着 Swift 的进化还有可能继续看到他们的变化。</p>
<h2 id="鲜为人知的Foundation数据结构"><a href="#鲜为人知的Foundation数据结构" class="headerlink" title="鲜为人知的Foundation数据结构"></a>鲜为人知的<code>Foundation</code>数据结构</h2><p>数组，字典和集合肩负着数据处理的重任。然而，Cocoa 提供了许多了解的人很少甚至不被欣赏的集合类型。如果字典，数组，集合都不能胜任某个功能，那么你可以试试这些是否管用。</p>
<h3 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h3><p>使用 <code>NSCache</code> 与使用 <code>NSMutableDictionary</code> 是类似的 - 就是通过键来添加和获取值。区别在于 <code>NSCache</code> 是用来暂时存储一些你总是可以重新计算和生成的东西。如果可用内存降低，<code>NSCache</code> 可能会移除一些对象。他们是线程安全的，但是苹果的文档提示：</p>
<blockquote>
<p>如果缓存被要求释放内存，它就会自动执行异步的更新操作。</p>
</blockquote>
<p>从根本上说，<code>NSCache</code> 和 <code>NSMutableDictionary</code> 很像，除了<code>NSCache</code>可以在你的代码没有做任何事情的时候从另一个线程中移除一些对象。这对于管理缓存所使用的内存来说是很好的，但是如果你试图使用一个突然消失的对象，那么就会出问题了。</p>
<p><code>NSCache</code>对键采取弱引用而不是强引用。</p>
<h3 id="NSCountedSet"><a href="#NSCountedSet" class="headerlink" title="NSCountedSet"></a>NSCountedSet</h3><p><code>NSCountedSet</code> 可以检测到你向某个集合中添加某个对象操作执行的次数。它继承自<code>NSMutableSet</code>，所以如果你再次向集合中添加同样的对象，集合中也只会有一个那样的对象。</p>
<p>不管怎样，在一个 <code>NSCountedSet</code> 类型的对象中，集合记录下对象被添加了多少次。你可以通过<code>countForObject()</code>查看某个对象被添加的次数。</p>
<p>注意当你调用 <code>NSMutableSet</code> 的 <code>count</code> 属性时，它只返回唯一对象的数量，而不是所有被添加到集合中的元素的数量。</p>
<p>例如，在你的 <code>Playground</code> 中，使用你之前做 <code>NSMutableSet</code> 的测试时，创建的数组的名字，将每个名字都向 <code>NSCountedSet</code> 对象中添加两次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let countedMutable = NSCountedSet()</span><br><span class="line">for name in names &#123;</span><br><span class="line">    countedMutable.addObject(name)</span><br><span class="line">    countedMutable.addObject(name)</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure>
<p>然后，打印集合，看看“Ringo”被添加了多少次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ringos = countedMutable.countForObject(&quot;Ringo&quot;)</span><br><span class="line">println(&quot;Counted Mutable set: \(countedMutable)) with count for Ringo: \(ringos)&quot;)12</span><br></pre></td></tr></table></figure>
<p>你的打印结果应该是：</p>
<blockquote>
<p>Counted Mutable set: {(<br>George,<br>John,<br>Ronnie,<br>Mick,<br>Keith,<br>Charlie,<br>Paul,<br>Ringo<br>)}) with count for Ringo: 2</p>
</blockquote>
<p>注意集合中元素的顺序可能不同，但是你应该看到“Ringo”在名字列表中出现了一次，即使你看到它是被添加了两次的。</p>
<h3 id="NSOrderedSet"><a href="#NSOrderedSet" class="headerlink" title="NSOrderedSet"></a>NSOrderedSet</h3><p><code>NSOrderedSet</code> 以及它对应的可变类型 <code>NSMutableOrderedSet</code>，是一种允许你以特定顺序存储一组不重复的对象的数据结构。<br>“特定顺序” - 天哪，这听起来很像数组对不对？苹果简单总结了你为什么会使用<code>NSOrderedSet</code> 而不是数组：</p>
<blockquote>
<p>当元素顺序以及测试某个元素是否存在于集合中的性能需要被考虑在内时，你可以使用有序的集合作为数组的备选项。</p>
</blockquote>
<p>因此，当你需要存储一组有序的数据而数据又不能重复时使用<code>NSOrderedSet</code>是最好的。</p>
<blockquote>
<p>注意：由于 <code>NSCountedSet</code> 继承自 <code>NSMutableSet</code>，因此 <code>NSOrderedSet</code> 也继承自 <code>NSObject</code> 。这个例子很好地表明了苹果命名一个类是基于他们的功能，而不一定是基于他们在底层是如何工作的。</p>
</blockquote>
<h3 id="NSHashTable-and-NSMapTable"><a href="#NSHashTable-and-NSMapTable" class="headerlink" title="NSHashTable and NSMapTable"></a>NSHashTable and NSMapTable</h3><p><code>NSHashTable</code> 是另外一种与集合类似的数据结构，但是与 <code>NSMutableSet</code> 有几处关键的不同之处。</p>
<p>你可以使用任意指针类型而不仅仅是对象来搭建一个 <code>NSHashTable</code> 类型对象，所以你可以向 <code>NSHashTable</code> 中添加结构体和非对象类型的数据。你也可以使用 <code>NSHashTableOptions</code> 枚举值来设置内存管理和相等的条件等。</p>
<p><code>NSMapTable</code> 是一种类字典的数据结构，但是在内存管理方面与 <code>NSHashTable</code> 有着相似的行为。</p>
<p>像 <code>NSCache</code> 那样，<code>NSMapTable</code> 对键是弱引用。然而，不管什么时候键被释放它都能够自动删除与那个键对应的数据。这些选项都可以在 <code>NSMapTableOptions</code> 枚举值中进行设置。</p>
<h3 id="NSIndexSet"><a href="#NSIndexSet" class="headerlink" title="NSIndexSet"></a>NSIndexSet</h3><p><code>NSIndexSet</code> 是一个不可变的集合，用来存储唯一的无符号整数，来表示数组的索引值。</p>
<p>如果你有一个拥有十个数据的数组，而你通常需要使用其中某几个固定位置的数据，你就可以将索引存储在 <code>NSIndexSet</code> 对象中，并使用 NSArray 的 <code>objectsAtIndexes</code> 来直接获取那些对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let items : NSArray = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;ten&quot;]</span><br><span class="line"></span><br><span class="line">let indexSet = NSMutableIndexSet()</span><br><span class="line">indexSet.addIndex(3)</span><br><span class="line">indexSet.addIndex(8)</span><br><span class="line">indexSet.addIndex(9)</span><br><span class="line"></span><br><span class="line">items.objectsAtIndexes(indexSet) // returns [&quot;four&quot;, &quot;nine&quot;, &quot;ten&quot;]12345678</span><br></pre></td></tr></table></figure>
<p>你所指定的某个“数据”现在是一个数组了，Swift 数组没有对应的方法可以通过 <code>NSIndexSet</code> 或者别的什么类来获取多个数据。</p>
<p><code>NSIndexSet</code> 保留了 <code>NSSet</code> 中只允许某个值出现一次的特性。因此，你不能用它来存储任意一组数据，除非这组数据没有重复值。</p>
<p>有了 <code>NSIndexSet</code>，你就可以将索引按一定的顺序存储，这比仅仅存储一个整数数组效率更高。</p>
<h3 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h3><p>已经学到了这里，下面这个小测试是关于你想用哪种数据结构来存储某种类型的数据的，你可以通过小测试来检测你的记忆。</p>
<p>为了做下面的测试，假设你有一个可以在图书馆展示数据的应用程序。</p>
<blockquote>
<p>Q:你会用什么来创建图书馆中所有作者的列表？</p>
</blockquote>
<p>答案：集合！它会自动移除重复的数据，也就是说你可以任意输入作者的名字，多少次都可以，但是你只会有一次录入 - 除非你输错了作者的名字！</p>
<blockquote>
<p>Q:你怎么按字母排序的方式存储一个多产作者的所有作品的标题？</p>
</blockquote>
<p>答案：用数组！这种情况下你有许多相似的数据对象（所有的标题都是字符串类型的），并且他们有顺序（标题必须按照字母顺序排列），这绝对是使用数组的最佳场景。</p>
<p>Q:你怎样存储每个作者最受欢迎的作品？</p>
<p>答案：字典！如果你使用作者的名字作为键，使用作者最受欢迎的作品为值，你可以以下面的方式获取这个作者最受欢迎的作品：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mostPopularBooks[&quot;Gillian Flynn&quot;] //Returns &quot;Gone Girl&quot;1</span><br></pre></td></tr></table></figure>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p>我想特别感谢我的一个同事<a href="http://www.raywenderlich.com/about#cwagner" target="_blank" rel="noopener">Chris Wagner</a>，在我们接触到 Swift 之前他写了这篇教程的 OC 版本，为了可以使用他的笔记和示例项目，把那篇教程也放在这里。</p>
<p>我也要感谢苹果公司的 Swift 团队 - 尽管在原生的数据结构方面还有很大的提升空间，我已经很享受用 Swift 编码和测试了。一段时间内我可能还会使用 Foundation 下的数据结构，但也可能开发一些 Swift 小插件。</p>
<p>不管怎样，如果你想学习更多 iOS 的数据结构，这儿有一些很棒的资源： </p>
<ul>
<li><a href="http://nshipster.com/" target="_blank" rel="noopener">NSHipster</a>是一个很棒的资源，可以让你去探索Cocoa的包括数据结构在内的一些鲜为人知的API。 </li>
<li><a href="http://pspdfkit.com/" target="_blank" rel="noopener">PSPDFKit</a>公司的Peter Steinberger的最著名的关于Foundation 数据结构的<a href="http://www.objc.io/issue-7/collections.html" target="_blank" rel="noopener">excellent article in ObjC.io issue 7</a>。<br>* 前任UIKit工程师Andy Matuschak的一篇关于 Swift 中基于结构的数据结构的文章<a href="http://www.objc.io/issue-16/swift-classes-vs-structs.html" target="_blank" rel="noopener">article in ObjC.io issue 16</a>。 </li>
<li><a href="http://airspeedvelocity.net/" target="_blank" rel="noopener">AirspeedVelocity</a>，一个研究Swift本质特征的博客 - 由于在标题中引用了Monty Python的台词而获得了加分（Monty Python 1975年有一个电影 叫 Monty Python and the Holy Grail，里面有一个角色叫bridgekeeper ，他有一句台词：What… is the air-speed velocity of an unladen swallow? ）。<br>* 一篇很棒的文章<a href="http://ciechanowski.me/blog/2014/03/05/exposing-NSMutableArray/" target="_blank" rel="noopener">deep dive into the internals of NSMutableArray</a>深入研究了<code>NSMutableArray</code>，以及修改<code>NSMutableArray</code>中的数据对内存的影响。<br>* 一篇关于<a href="http://ridiculousfish.com/blog/posts/array.html" target="_blank" rel="noopener">NSArray and CFArray performance changes with extremely large data sets</a>很棒的研究。这篇文章进一步证明了苹果对类的命名并不是基于类在后台的行为，而是他们于开发者的行为。<br>* 如果你想学习更多的算法复杂度分析<a href="http://mitpress.mit.edu/books/introduction-algorithms" target="_blank" rel="noopener">Introduction to Algorithms</a>会教你比你在实际应用中可能了解到的还要多的内容，但能使你顺利通过工作面试。</li>
</ul>
<p>如果你想仔细分析呈现在这篇文章中的数据，你可以自己下载<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/11/performance-test-iPhone-6-iOS-8.3-Swift-1.2.numbers.zip" target="_blank" rel="noopener">the numbers spreadsheet used to track all the testing runs with Swift 1.2</a>分析数据。</p>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> Cocoa </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift实现异步操作串行]]></title>
      <url>/2018/04/23/Swift%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%B8%B2%E8%A1%8C/</url>
      <content type="html"><![CDATA[<p>提起异步操作的序列执行，指的是有一系列的异步操作（比如网络请求）的执行有前后的依赖关系，前一个请求执行完毕后，才能执行下一个请求。</p>
<h2 id="异步操作的定义"><a href="#异步操作的定义" class="headerlink" title="异步操作的定义"></a>异步操作的定义</h2><p>我们定义一般异步操作都是如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func asyncOperation(complete : ()-&gt; Void)&#123;</span><br><span class="line">    //..do something</span><br><span class="line"></span><br><span class="line">    complete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常规的异步操作都会接受一个闭包作为参数，用于操作执行完毕后的回调。</p>
<p>那异步操作的序列化会有什么问题呢？ 看如下的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func asyncOperation(complete : ()-&gt; Void)&#123;</span><br><span class="line">    //..do something</span><br><span class="line">    print(&quot;fst executed&quot;)</span><br><span class="line">    complete()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func asyncOperation1(complete : ()-&gt; Void)&#123;</span><br><span class="line">    //..do something</span><br><span class="line">    print(&quot;snd executed&quot;)</span><br><span class="line"></span><br><span class="line">    complete()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func asyncOperation2(complete : ()-&gt; Void)&#123;</span><br><span class="line">    //..do something</span><br><span class="line">    print(&quot;third executed&quot;)</span><br><span class="line"></span><br><span class="line">    complete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了三个操作asyncOperation,asyncOperation1 和 asyncOperation2，现在我们想序列执行三个操作，然后在执行完后输出 all executed。 按照常规，我们就写下了如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asyncOperation &#123; </span><br><span class="line">    asyncOperation1(&#123; </span><br><span class="line">        asyncOperation2(&#123; </span><br><span class="line">            print(&quot;all executed&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，明明才三层，代码似乎就有点复杂了，而我们真正关心的代码却只有 print(“all executed”) 这一行。但为了遵从前后依赖的时许关系，我们不得不小心的处理回调，以防搞错层级。如果层级多了就有可能像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asyncOperation &#123; </span><br><span class="line">    asyncOperation1(&#123; </span><br><span class="line">        asyncOperation2(&#123;</span><br><span class="line">            asyncOperation3&#123;</span><br><span class="line">                asyncOperation4&#123;</span><br><span class="line">                    asyncOperation5&#123;</span><br><span class="line">                        print(&quot;all executed&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是传说中的callback hell, 而且这还只是最clean的情况，实际情况中还会耦合很多的逻辑代码，更加无法维护。</p>
<h2 id="用reduce来实现异步操作的串行"><a href="#用reduce来实现异步操作的串行" class="headerlink" title="用reduce来实现异步操作的串行"></a>用reduce来实现异步操作的串行</h2><p>那是否有解决办法呢？ 答案是有的。很多FRP的框架都提供了类似的实现，有兴趣的读者可以自行查看Promise、 ReactiveCocoa 和 RxSwift中的实现。</p>
<p>然后正如本节的标题所说，Swift提供了两个函数式的特性：</p>
<ul>
<li>函数是一等公民（可以像变量一样传来传去，可以做函数参数、返回值</li>
<li>高阶函数，比如 map 和 reduce</li>
</ul>
<p>接下来我们就用这两个特性，实现一个更加优雅的方式来做异步操作串行。</p>
<h4 id="1-定义类型"><a href="#1-定义类型" class="headerlink" title="1. 定义类型"></a>1. 定义类型</h4><p>为了方便书写，我们先定义一下异步操作的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typealias AsyncFunc = (()-&gt;Void) -&gt; Void</span><br></pre></td></tr></table></figure>
<p>AsyncFunc 代表了一个函数类型，这样的函数有一个闭包参数（其实就是上面 asyncOperation 的类型）</p>
<h4 id="2-从串行两个操作开始"><a href="#2-从串行两个操作开始" class="headerlink" title="2. 从串行两个操作开始"></a>2. 从串行两个操作开始</h4><p>我们先化简问题，假设我们只需要串行两个异步操作呢？ 有没有办法把两个异步操作串行成一个异步操作呢？ 想到这里，我们可以YY出这样一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func concat(left : AsyncFunc , right : AsyncFunc) -&gt; AsyncFunc&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>concat函数，顾名思义，是连接的意思。指的是将两个异步操作：left和right串行起来，并返回一个新的异步操作。</p>
<p>那现在，我们来思考如何实现concat函数，既然返回的是AsyncFunc 也就是一个函数，那我们可以先YY出这样的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func concat(left : AsyncFunc , right : AsyncFunc) -&gt; AsyncFunc&#123;</span><br><span class="line">    return &#123; complete in</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细回忆 AsyncFunc 的类型： (()-&gt;Void) -&gt; Void，所以闭包参数complete就对应前面的参数。</p>
<p>架子已经写好了，我们来思考要实现如何实现最终返回这个函数。根据concat的定义我们可以知道，我们最终返回的是一个 <strong>接受一个闭包作为参数， 先执行left，成功后执行right，成功后再执行传入的闭包</strong>。</p>
<p>你看，这样一分析，逻辑就非常清晰了，闭包参数就是complete. 我们抽丝剥茧，找到了问题的本质，于是很容易可以写出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func concat(left : AsyncFunc , right : AsyncFunc) -&gt; AsyncFunc&#123;</span><br><span class="line">    return &#123; complete in</span><br><span class="line">        left&#123;</span><br><span class="line">            right&#123;</span><br><span class="line">                complete()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心逻辑和我们最原始的版本其实并没有区别，区别就是不论再多个串行，我们都不需要写更多的嵌套了。</p>
<p>基于最开始的例子，我们测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let concatedFunction = concat(asyncOperation, </span><br><span class="line">                               right: asyncOperation1)</span><br><span class="line">concatedFunction &#123; </span><br><span class="line">    print(&quot;all executed&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们以及成功的实现了把两个异步操作合并成一个串行的异步操作。</p>
<h4 id="3-串行任意个异步操作"><a href="#3-串行任意个异步操作" class="headerlink" title="3. 串行任意个异步操作"></a>3. 串行任意个异步操作</h4><p>让我们回过头去，再审视一个我们concact的签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func concat(left : AsyncFunc , right : AsyncFunc) -&gt; AsyncFunc&#123;</span><br></pre></td></tr></table></figure>
<p>我们忘记什么函数，什么闭包，什么异步。就来看签名：他接收两个相同类型的参数，最后返回一个结果，结果的类型和参数一致。</p>
<p>像什么？像雾像雨又像风？ 还是像加法像减法又像乘法？总之我们可以把他看做是某种运算，具备如下性质：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; b -&gt; c =  concact(a,b) -&gt; c       (-&gt; 代表异步地串行执行)</span><br></pre></td></tr></table></figure>
<p>说得这里，我们可以想到我们可以拿我们刚才实现的concat函数来reduce一组异步操作。继续用刚才的例子，我们先写下如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let reducedFunction = [asyncOperation,asyncOperation1,asyncOperation2].</span><br><span class="line">                                   reduce(【初始值】, combine: concat)</span><br></pre></td></tr></table></figure>
<p>我们把刚才定义的三个异步函数扔到列表里，然后用concat来reduce他，但此时似乎又面临另外一个问题，【初始值】填什么？</p>
<p>每次思考reduce的初始值都是一个哲学问题，大多数情况下我们不希望他参与运算，但又不得不让他参与运算（因为combine是个二元函数），所以我们希望reduce的初始值(记为initial)具备如下性质：</p>
<ul>
<li>combine(initial,x) = x</li>
</ul>
<p>这种性质，大家应该能联想到一个类似的东西叫 CGAffineTransformIdentity,往深了讲，这其实是一个代数问题，不过这里暂时不讨论。</p>
<p>在本例，我们的initial可以定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let identityFunc:AsyncFunc = &#123;f in f()&#125;</span><br></pre></td></tr></table></figure>
<p>它是这样的一个函数，接受闭包作为参数，然后什么都不做，马上调用闭包。这里大家简单感受一下。<em>(:зゝ∠)</em></p>
<p>于是，我们完整的reduce版本可以定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let identityFunc:AsyncFunc = &#123;f in f()&#125;</span><br><span class="line"></span><br><span class="line">let reducedFunction = [asyncOperation,asyncOperation1,asyncOperation2,asyncOperation3,asyncOperation4,asyncOperation5].</span><br><span class="line">                       reduce(identityFunc, combine: concat)</span><br><span class="line"></span><br><span class="line">reducedFunction &#123; </span><br><span class="line">    print(&quot;all executed&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先定义了identityFunc作为初始值，然后把我们开头定义的几个异步操作reduce成一个：reducedFunction，然后调用了它，可以观察输出结果，和我们最开始写的嵌套版本是一样的。</p>
<h2 id="引申的话题"><a href="#引申的话题" class="headerlink" title="引申的话题"></a>引申的话题</h2><h4 id="带参数的串行"><a href="#带参数的串行" class="headerlink" title="带参数的串行"></a>带参数的串行</h4><p>真实世界里，当我们需要串行异步操作的时候，一般后一个操作都需要前一个操作的执行结果。比如我们可能需要先请求新闻的列表，拿到新闻的id之后，再请求新闻的一些具体的信息，前后操作有数据上的依赖关系。（当然一般不这么搞，这里只是举个例子）</p>
<p>抽象的来看，我们要处理一组串行的操作，为了方便处理，我们希望函数的签名是一样的，偷懒的做法可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typealias AsyncFunc = (info : AnyObject,complete:(AnyObject)-&gt;Void) -&gt; Void</span><br></pre></td></tr></table></figure>
<p>定义闭包的类型为AnyObject-&gt;Void ，同时异步函数也接受一个AnyObject的参数，这样在各个异步函数中通过把参数cast成字典，提取信息，操作完毕后把结果的值传到回调的闭包中。具体实现见一下节</p>
<p>如果嫌AnyObject太丑的话也可以针对串行操作的场景设计一个protocol，然后用protocol作为参数的类型来传递信息。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>我们最终将一组异步操作，reduce成了一个异步操作，那如果中间某个操作出错了，我们该怎么知道呢？ 其中一种实现，可以是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typealias AsyncFunc = (info : AnyObject,complete:(AnyObject?,NSError?)-&gt;Void) -&gt; Void</span><br></pre></td></tr></table></figure>
<p>对比之前带参数的例子，唯一的区别就是在闭包的参数里加了一个NSError？，以及把AnyObject改成了optional，因为这里的AnyObject代表的是结果，如果失败了，结果自然就是nil.</p>
<p>于是，我们的核心，concat函数可以变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func concat(left : AsyncFunc , right : AsyncFunc) -&gt; AsyncFunc&#123;</span><br><span class="line">    return &#123; info , complete in</span><br><span class="line">        left(info: info)&#123; result,error in</span><br><span class="line">            guard error == nil else&#123;</span><br><span class="line">                complete(nil,error)</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            right(info: info)&#123;result,error in</span><br><span class="line">                complete(result,error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑也是很直接的，我们首先尝试执行left，在left的回调中查看error是否是nil，如果是，则立刻执行complete，并且带上这个error。否则再执行right，并将right的结果调用complete。</p>
<h4 id="一个稍微异步一点的例子"><a href="#一个稍微异步一点的例子" class="headerlink" title="一个稍微异步一点的例子"></a>一个稍微异步一点的例子</h4><p>随便建一个single view application，修改viewDidLoad为如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line">    typealias AsyncFunc = (info : AnyObject,complete:(AnyObject?,NSError?)-&gt;Void) -&gt; Void</span><br><span class="line"></span><br><span class="line">    func concat(left : AsyncFunc , right : AsyncFunc) -&gt; AsyncFunc&#123;</span><br><span class="line">        return &#123; info , complete in</span><br><span class="line">            left(info: info)&#123; result,error in</span><br><span class="line"></span><br><span class="line">                guard error == nil else&#123;</span><br><span class="line">                    complete(nil,error)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                right(info: info)&#123;result,error in</span><br><span class="line">                    complete(result,error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let identity:AsyncFunc = &#123;info,complete in complete(nil,nil)&#125;</span><br><span class="line"></span><br><span class="line">    func dispatchSecond(afterSecond : Int, block:dispatch_block_t)&#123;</span><br><span class="line">        let time = dispatch_time(DISPATCH_TIME_NOW, Int64(afterSecond) * Int64(NSEC_PER_SEC))</span><br><span class="line">        dispatch_after(time, dispatch_get_main_queue(), block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let async1: AsyncFunc = &#123; info, complete in</span><br><span class="line">        dispatchSecond(2, block: &#123;</span><br><span class="line">            print(&quot;oh, im first one&quot;)</span><br><span class="line">            complete(nil, nil)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let async2: AsyncFunc = &#123; info, complete in</span><br><span class="line">        dispatchSecond(2, block: &#123;</span><br><span class="line">            print(&quot;oh, im second one&quot;)</span><br><span class="line">            complete(nil, nil)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let async3: AsyncFunc = &#123; info, complete in</span><br><span class="line">        dispatchSecond(2, block: &#123;</span><br><span class="line">            print(&quot;shit, im third one&quot;)</span><br><span class="line">            complete(nil, nil)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let async4: AsyncFunc = &#123; info, complete in</span><br><span class="line">        dispatchSecond(2, block: &#123;</span><br><span class="line">            print(&quot;fuck, im fourth one&quot;)</span><br><span class="line">            complete(nil, nil)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let asyncDaddy = [async1,async2,async3,async4].reduce(identity, combine: concat)</span><br><span class="line">    asyncDaddy(info: 0) &#123; (o, e) in</span><br><span class="line">        print(&quot;okay, im deadly a last one&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序后，会每两秒有一个输出。：）</p>
<p>本文旨在抛砖引玉，其实swift的functional特性已经非常丰富，稍微探索一下是可以做出很多fancy的应用出来的。</p>
<blockquote>
<p>在函数式编程的世界里，我们定义的 identity加上concat 就是一种monoid，常见的monoid还有：</p>
<p>加法： identity 就是 0 ， concat就对应 +<br>乘法：identity 就是 1 ， concat就对应 *</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> swift </tag>
            
            <tag> GCD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[队列顺序执行DispatchGroup]]></title>
      <url>/2018/04/23/%E9%98%9F%E5%88%97%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8CDispatchGroup/</url>
      <content type="html"><![CDATA[<p>// 创建一个队列组</p>
<p>​        let group = DispatchGroup()</p>
<p>​        // A任务入组</p>
<p>​        group.enter()</p>
<p>​        // A任务异步操作</p>
<p>​        DispatchQueue.global().async(group: group, execute: DispatchWorkItem(block: {</p>
<p>​            print(“download task A ..async.”)</p>
<p>​            self.delay(4, {</p>
<p>​                print(“download task A …”)</p>
<p>​            })</p>
<p>​           </p>
<p>​            // 出组</p>
<p>​            group.leave()</p>
<p>​        }))</p>
<p>​        // B任务入组</p>
<p>​        group.enter()</p>
<p>​        // B任务异步操作</p>
<p>​        DispatchQueue.global().async(group: group, execute: DispatchWorkItem(block: {</p>
<p>​            print(“download task B ..async.”)</p>
<p>​            self.delay(3, {</p>
<p>​                print(“download task B …”)</p>
<p>​            })</p>
<p>​            </p>
<p>​            // 出组</p>
<p>​            group.leave()</p>
<p>​        }))</p>
<p>​        // 主线程监听，只有当队列组中没有任务，才会执行闭包。如果多次调用该方法，每次都会去检查队列组中是否有任务，如果没有任务才执行</p>
<p>​        group.notify(queue: DispatchQueue.main) {</p>
<p>​            print(“手动任务组的任务都已经执行完毕啦！”)</p>
<p>​        }</p>
<p>func delay(<em> delay: Int,</em> block: @escaping ()-&gt;() ) -&gt; () {</p>
<p>​        DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + DispatchTimeInterval.milliseconds(delay)) {</p>
<p>​            block()</p>
<p>​        }</p>
<p>​    }</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift 的 flatMap 和 zip 函数]]></title>
      <url>/2018/04/23/Swift%20%E7%9A%84%20flatMap%20%E5%92%8C%20zip%20%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>Swift 的语法很适合写函数式程序。函数式“三板斧” map、filter、reduce 都应该很熟悉了。另外 flatMap 和 zip 也很常用。</p>
<h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><strong>flatMap</strong></h2><p>flatMap 一个常见用法是在 map 的基础上，剔除掉空值。比如下面代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var images = [UIImage]()</span><br><span class="line">for i in 1 ..&lt; 10 &#123;</span><br><span class="line">    if let image = UIImage(named: &quot;icon-\(i).png&quot;) &#123;</span><br><span class="line">        images.append(image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以改写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let images = (1 ..&lt; 10).flatMap &#123; i in</span><br><span class="line">    UIImage(named: &quot;icon-\(i).png&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flapMap 另一个常见的用法是插入额外元素。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3, 4, 5, 6]</span><br><span class="line">let b = a.flatMap &#123; num in</span><br><span class="line">    return [num, num]</span><br><span class="line">&#125;</span><br><span class="line">// b = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6]</span><br></pre></td></tr></table></figure>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a><strong>zip</strong></h2><p>zip 是将两个序列的元素，一一对应合并成元组，生成一个新序列。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3, 4]</span><br><span class="line">let b = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line">let c = zip(a, b).map &#123; $0 &#125;</span><br><span class="line">// c = [(1, &quot;a&quot;), (2, &quot;b&quot;), (3, &quot;c&quot;), (4, &quot;d&quot;)]</span><br></pre></td></tr></table></figure>
<p>生成的序列，如同原始两个序列的相互咬合，因此函数的名字为 zip。zip 的英文有拉链的意思。生成的序列 count 为原始序列的最小值。</p>
<p>zip 生成的序列通常会进行下一步处理。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func loadColors(colors: [UIColor]) &#123;</span><br><span class="line">    zip(self.colorButtons, colors).forEach &#123; (bt, color) in</span><br><span class="line">        bt.color = color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段的语句，为颜色按钮分别赋予颜色值。相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func loadColors(colors: [UIColor]) &#123;</span><br><span class="line">    let minCount = min(colors.count, self.colorButtons.count)</span><br><span class="line">    for i in 0 ..&lt; minCount &#123;</span><br><span class="line">        self.colorButtons[i].color = colors[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举一段代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let colors = [UIColor.red, UIColor.blue, UIColor.white]</span><br><span class="line">let buttons = zip(0 ..&lt; colors.count, colors).map &#123; (i, color) in</span><br><span class="line">    let button = ColorButton(color: color)</span><br><span class="line">    button.tag = i</span><br><span class="line">    return button</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，创建了颜色按钮，并用索引设置了对应的 tag。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>这些简单的函数，配合起来可以达到一些高级的功能。比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br><span class="line">let b = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</span><br><span class="line">let c = zip(a, b).flapMap &#123; [$0, $1] &#125;</span><br><span class="line">// c = [&quot;a&quot;, &quot;A&quot;, &quot;b&quot;, &quot;B&quot;, &quot;c&quot;, &quot;C&quot;, &quot;d&quot;, &quot;D&quot;]</span><br></pre></td></tr></table></figure>
<p>这里将两个序列的元素，间隔地插入，合并成一个序列。</p>
<p>第一次看这种代码，可能会看不懂。有些人可能会觉得太复杂了，为什么不直接写循环呢，这样每个人都可以看懂。其实这种风格的程序反而是简单的。按照我理解，简单并不一定是直观的，简单更多意味着统一。有些写法并不一定第一次就能看懂，可能需要经过一定努力才能学会，但一旦学会了，就可以无差别地统一处理一大批问题。既直观又统一当然最好，但两者不可兼得，我会优先取统一而非直观，这样反而更简单些，不用处理额外情况。</p>
<p>比如 zip 函数，当两个序列的 count 不相等时，会取 count 的最小值。这种两个序列 count 不相等，就属于额外情况。当自己手写循环时，很可能就忘记处理了。</p>
<p>另外时不时就遇到 Swift 一些诡异的 bugs。比如这段代码就编译不过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = [UIView(), UIView(), UIView()]</span><br><span class="line">let b = a.map &#123; view in</span><br><span class="line">    let rt : CGRect = view.frame</span><br><span class="line">    return rt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这样写就可以编译通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [UIView(), UIView(), UIView()]</span><br><span class="line">let b = a.map &#123; view in</span><br><span class="line">    return view.frame</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遇到这些 bugs, 就需要手动添加变量类型。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[swift中map和flatMap的使用]]></title>
      <url>/2018/04/23/swift%E4%B8%ADmap%E5%92%8CflatMap%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><blockquote>
<p>map和flatMap是swift中两个常用的函数，它们提现了swift中很多特性。</p>
</blockquote>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>1、map的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1,2,3,4]</span><br><span class="line">let result = numbers.map &#123; $0 + 2 &#125;</span><br><span class="line">print(result)    //输出：3，4，5，6</span><br></pre></td></tr></table></figure>
<p>大家可以看一下，map方法接受的是一个闭包参数，然后它会遍历整个numbers数组，并对数组中每一个元素执行闭包中定义的操作。相当于对数组中的所有元素做了一个映射。<br>这个例子就是对numbers数组的所有元素进行了加2。</p>
<p>再看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let array1 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">let array2 = array1.map &#123; &quot;NO.\($0)&quot; &#125;</span><br><span class="line">print(array2)    //输出：NO.a，NO.b，NO.c，NO.d</span><br></pre></td></tr></table></figure>
<p>2、flatMap的使用<br><code>map</code> 可以理解为对一个集合类型的所有元素做了一个映射操作，那么<code>flatMap</code>呢？</p>
<p>让我们来看一下下面的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = numbers.flatMap&#123; $0 + 2 &#125;      //输出：3,4,5,6</span><br></pre></td></tr></table></figure>
<p>我们对同样的数组使用了<code>flatMap</code>进行处理，得到了相同的结果。那么这两个到底有什么区别呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let array1 = [[1,2,3],[4,5,6]]</span><br><span class="line">var arr = array1.map&#123; $0.map&#123; $0 + 1 &#125; &#125;</span><br><span class="line">//输出：[[2,3,4],[5,6,7]]</span><br><span class="line"></span><br><span class="line">var arr2 = array1.flatMap&#123; $0.map&#123; $0 + 1 &#125; &#125;</span><br><span class="line">//输出：[2,3,4,5,6,7]</span><br></pre></td></tr></table></figure>
<p>看到这两个数组的输出就看出差别来了，对于二维数组，<code>map</code>和<code>flatMap</code>的结果就不同了。</p>
<p><code>flatMap</code> 会遍历数组的元素，并对这些元素执行闭包中定义的操作。 但唯一和<code>map</code>不同的是，它对最终的结果进行了所谓的 “降维” 操作。 本来原始数组是一个二维的， 但经过 <code>flatMap</code> 之后，它变成一维的了。</p>
<p>大家再来看看flatMap的第二个作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let optionalArray: [String?] = [&quot;AA&quot;,&quot;BB&quot;,nil,&quot;CC&quot;]</span><br><span class="line">print(optionalArray)   </span><br><span class="line">//输出：[Optional(&quot;AA&quot;), Optional(&quot;BB&quot;), nil, Optional(&quot;CC&quot;)]</span><br><span class="line"></span><br><span class="line">var flatMapArray = optionalArray.flatMap&#123; $0 &#125;</span><br><span class="line">print(flatMapArray)</span><br><span class="line">//输出：[&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;]</span><br></pre></td></tr></table></figure>
<p>大家可以看到，在<code>flatMap</code> 的返回结果中， 成功的将原数组中的 nil 值过滤掉了。 再仔细观察，你会发现更多。 使用 flatMap 调用之后， 数组中的所有元素都被解包了。也就是说原始数组的类型是 <code>[String?]</code>, 而 <code>flatMap</code> 调用后变成了 <code>[String]</code>。 这也是<code>flatMap</code> 和 <code>map</code> 的一个重大区别。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[MarqueeLabel.swift]]></title>
      <url>/2018/04/19/MarqueeLabel/</url>
      <content type="html"><![CDATA[<p>//</p>
<p>//  Created by Charles Powell on 8/6/14.</p>
<p>//  Copyright (c) 2015 Charles Powell. All rights reserved.</p>
<p>//</p>
<p>import UIKit</p>
<p>import QuartzCore</p>
<p>@IBDesignable</p>
<p>open class MarqueeLabel: UILabel, CAAnimationDelegate {</p>
<p>​<br><a id="more"></a><br>​    /**</p>
<p>​     An enum that defines the types of <code>MarqueeLabel</code> scrolling</p>
<p>​     </p>
<p>​     - Left: Scrolls left after the specified delay, and does not return to the original position.</p>
<p>​     - LeftRight: Scrolls left first, then back right to the original position.</p>
<p>​     - Right: Scrolls right after the specified delay, and does not return to the original position.</p>
<p>​     - RightLeft: Scrolls right first, then back left to the original position.</p>
<p>​     - Continuous: Continuously scrolls left (with a pause at the original position if animationDelay is set).</p>
<p>​     - ContinuousReverse: Continuously scrolls right (with a pause at the original position if animationDelay is set).</p>
<p>​     */</p>
<p>​    public enum MarqueeType {</p>
<p>​        case left</p>
<p>​        case leftRight</p>
<p>​        case right</p>
<p>​        case rightLeft</p>
<p>​        case continuous</p>
<p>​        case continuousReverse</p>
<p>​    }</p>
<p>​    </p>
<p>​    //</p>
<p>​    // MARK: - Public properties</p>
<p>​    //</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Defines the direction and method in which the <code>MarqueeLabel</code> instance scrolls.</p>
<p>​     <code>MarqueeLabel</code> supports six default types of scrolling: <code>Left</code>, <code>LeftRight</code>, <code>Right</code>, <code>RightLeft</code>, <code>Continuous</code>, and <code>ContinuousReverse</code>.</p>
<p>​     </p>
<p>​     Given the nature of how text direction works, the options for the <code>type</code> property require specific text alignments</p>
<p>​     and will set the textAlignment property accordingly.</p>
<p>​     </p>
<p>​     - <code>LeftRight</code> and <code>Left</code> types are ONLY compatible with a label text alignment of <code>NSTextAlignmentLeft</code>.</p>
<p>​     - <code>RightLeft</code> and <code>Right</code> types are ONLY compatible with a label text alignment of <code>NSTextAlignmentRight</code>.</p>
<p>​     - <code>Continuous</code> does not require a text alignment (it is effectively centered).</p>
<p>​     - <code>ContinuousReverse</code> does not require a text alignment (it is effectively centered).</p>
<p>​     </p>
<p>​     Defaults to <code>Continuous</code>.</p>
<p>​     </p>
<p>​     - SeeAlso: textAlignment</p>
<p>​     */</p>
<p>​    open var type: MarqueeType = .continuous {</p>
<p>​        didSet {</p>
<p>​            if type == oldValue {</p>
<p>​                return</p>
<p>​            }</p>
<p>​            updateAndScroll()</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     An optional custom scroll “sequence”, defined by an array of <code>ScrollStep</code> or <code>FadeStep</code> instances. A sequence</p>
<p>​     defines a single scroll/animation loop, which will continue to be automatically repeated like the default types.</p>
<p>​     </p>
<p>​     A <code>type</code> value is still required when using a custom sequence. The <code>type</code> value defines the <code>home</code> and <code>away</code></p>
<p>​     values used in the <code>ScrollStep</code> instances, and the <code>type</code> value determines which way the label will scroll.</p>
<p>​     </p>
<p>​     When a custom sequence is not supplied, the default sequences are used per the defined <code>type</code>.</p>
<p>​     </p>
<p>​     <code>ScrollStep</code> steps are the primary step types, and define the position of the label at a given time in the sequence.</p>
<p>​     <code>FadeStep</code> steps are secondary steps that define the edge fade state (leading, trailing, or both) around the <code>ScrollStep</code></p>
<p>​     steps.</p>
<p>​     </p>
<p>​     Defaults to nil.</p>
<p>​     </p>
<p>​     - Attention: Use of the <code>scrollSequence</code> property requires understanding of how MarqueeLabel works for effective</p>
<p>​     use. As a reference, it is suggested to review the methodology used to build the sequences for the default types.</p>
<p>​     </p>
<p>​     - SeeAlso: type</p>
<p>​     - SeeAlso: ScrollStep</p>
<p>​     - SeeAlso: FadeStep</p>
<p>​     */</p>
<p>​    open var scrollSequence: Array<marqueestep>?</marqueestep></p>
<p>​    </p>
<p>​    /**</p>
<p>​     Specifies the animation curve used in the scrolling motion of the labels.</p>
<p>​     Allowable options:</p>
<p>​     </p>
<p>​     - <code>UIViewAnimationOptionCurveEaseInOut</code></p>
<p>​     - <code>UIViewAnimationOptionCurveEaseIn</code></p>
<p>​     - <code>UIViewAnimationOptionCurveEaseOut</code></p>
<p>​     - <code>UIViewAnimationOptionCurveLinear</code></p>
<p>​     </p>
<p>​     Defaults to <code>UIViewAnimationOptionCurveEaseInOut</code>.</p>
<p>​     */</p>
<p>​    open var animationCurve: UIViewAnimationCurve = .linear</p>
<p>​    </p>
<p>​    /**</p>
<p>​     A boolean property that sets whether the <code>MarqueeLabel</code> should behave like a normal <code>UILabel</code>.</p>
<p>​     </p>
<p>​     When set to <code>true</code> the <code>MarqueeLabel</code> will behave and look like a normal <code>UILabel</code>, and  will not begin any scrolling animations.</p>
<p>​     Changes to this property take effect immediately, removing any in-flight animation as well as any edge fade. Note that <code>MarqueeLabel</code></p>
<p>​     will respect the current values of the <code>lineBreakMode</code> and <code>textAlignment</code>properties while labelized.</p>
<p>​     </p>
<p>​     To simply prevent automatic scrolling, use the <code>holdScrolling</code> property.</p>
<p>​     </p>
<p>​     Defaults to <code>false</code>.</p>
<p>​     </p>
<p>​     - SeeAlso: holdScrolling</p>
<p>​     - SeeAlso: lineBreakMode</p>
<p>​     - Note: The label will not automatically scroll when this property is set to <code>true</code>.</p>
<p>​     - Warning: The UILabel default setting for the <code>lineBreakMode</code> property is <code>NSLineBreakByTruncatingTail</code>, which truncates</p>
<p>​     the text adds an ellipsis glyph (…). Set the <code>lineBreakMode</code> property to <code>NSLineBreakByClipping</code> in order to avoid the</p>
<p>​     ellipsis, especially if using an edge transparency fade.</p>
<p>​     */</p>
<p>​    @IBInspectable open var labelize: Bool = false {</p>
<p>​        didSet {</p>
<p>​            if labelize != oldValue {</p>
<p>​                updateAndScroll()</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     A boolean property that sets whether the <code>MarqueeLabel</code> should hold (prevent) automatic label scrolling.</p>
<p>​     </p>
<p>​     When set to <code>true</code>, <code>MarqueeLabel</code> will not automatically scroll even its text is larger than the specified frame,</p>
<p>​     although the specified edge fades will remain.</p>
<p>​     </p>
<p>​     To set <code>MarqueeLabel</code> to act like a normal UILabel, use the <code>labelize</code> property.</p>
<p>​     </p>
<p>​     Defaults to <code>false</code>.</p>
<p>​     </p>
<p>​     - Note: The label will not automatically scroll when this property is set to <code>true</code>.</p>
<p>​     - SeeAlso: labelize</p>
<p>​     */</p>
<p>​    @IBInspectable open var holdScrolling: Bool = false {</p>
<p>​        didSet {</p>
<p>​            if holdScrolling != oldValue {</p>
<p>​                if oldValue == true &amp;&amp; !(awayFromHome || labelize || tapToScroll ) &amp;&amp; labelShouldScroll() {</p>
<p>​                    updateAndScroll(true)</p>
<p>​                }</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     A boolean property that sets whether the <code>MarqueeLabel</code> should only begin a scroll when tapped.</p>
<p>​     </p>
<p>​     If this property is set to <code>true</code>, the <code>MarqueeLabel</code> will only begin a scroll animation cycle when tapped. The label will</p>
<p>​     not automatically being a scroll. This setting overrides the setting of the <code>holdScrolling</code> property.</p>
<p>​     </p>
<p>​     Defaults to <code>false</code>.</p>
<p>​     </p>
<p>​     - Note: The label will not automatically scroll when this property is set to <code>false</code>.</p>
<p>​     - SeeAlso: holdScrolling</p>
<p>​     */</p>
<p>​    @IBInspectable open var tapToScroll: Bool = false {</p>
<p>​        didSet {</p>
<p>​            if tapToScroll != oldValue {</p>
<p>​                if tapToScroll {</p>
<p>​                    let tapRecognizer = UITapGestureRecognizer(target: self, action: #selector(MarqueeLabel.labelWasTapped(_:)))</p>
<p>​                    self.addGestureRecognizer(tapRecognizer)</p>
<p>​                    isUserInteractionEnabled = true</p>
<p>​                } else {</p>
<p>​                    if let recognizer = self.gestureRecognizers!.first as UIGestureRecognizer? {</p>
<p>​                        self.removeGestureRecognizer(recognizer)</p>
<p>​                    }</p>
<p>​                    isUserInteractionEnabled = false</p>
<p>​                }</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     A read-only boolean property that indicates if the label’s scroll animation has been paused.</p>
<p>​     </p>
<p>​     - SeeAlso: pauseLabel</p>
<p>​     - SeeAlso: unpauseLabel</p>
<p>​     */</p>
<p>​    open var isPaused: Bool {</p>
<p>​        return (sublabel.layer.speed == 0.0)</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     A boolean property that indicates if the label is currently away from the home location.</p>
<p>​     </p>
<p>​     The “home” location is the traditional location of <code>UILabel</code> text. This property essentially reflects if a scroll animation is underway.</p>
<p>​     */</p>
<p>​    open var awayFromHome: Bool {</p>
<p>​        if let presentationLayer = sublabel.layer.presentation() {</p>
<p>​            return !(presentationLayer.position.x == homeLabelFrame.origin.x)</p>
<p>​        }</p>
<p>​        </p>
<p>​        return false</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     The <code>MarqueeLabel</code> scrolling speed may be defined by one of two ways:</p>
<p>​     - Rate(CGFloat): The speed is defined by a rate of motion, in units of points per second.</p>
<p>​     - Duration(CGFloat): The speed is defined by the time to complete a scrolling animation cycle, in units of seconds.</p>
<p>​     </p>
<p>​     Each case takes an associated <code>CGFloat</code> value, which is the rate/duration desired.</p>
<p>​     */</p>
<p>​    public enum SpeedLimit {</p>
<p>​        case rate(CGFloat)</p>
<p>​        case duration(CGFloat)</p>
<p>​        </p>
<p>​        var value: CGFloat {</p>
<p>​            switch self {</p>
<p>​            case .rate(let rate):</p>
<p>​                return rate</p>
<p>​            case .duration(let duration):</p>
<p>​                return duration</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Defines the speed of the <code>MarqueeLabel</code> scrolling animation.</p>
<p>​     </p>
<p>​     The speed is set by specifying a case of the <code>SpeedLimit</code> enum along with an associated value.</p>
<p>​     </p>
<p>​     - SeeAlso: SpeedLimit</p>
<p>​     */</p>
<p>​    open var speed: SpeedLimit = .duration(7.0) {</p>
<p>​        didSet {</p>
<p>​            switch (speed, oldValue) {</p>
<p>​            case (.rate(let a), .rate(let b)) where a == b:</p>
<p>​                return</p>
<p>​            case (.duration(let a), .duration(let b)) where a == b:</p>
<p>​                return</p>
<p>​            default:</p>
<p>​                updateAndScroll()</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    @available(*, deprecated : 2.6, message : “Use speed property instead”)</p>
<p>​    @IBInspectable open var scrollDuration: CGFloat {</p>
<p>​        get {</p>
<p>​            switch speed {</p>
<p>​            case .duration(let duration): return duration</p>
<p>​            case .rate(_): return 0.0</p>
<p>​            }</p>
<p>​        }</p>
<p>​        set {</p>
<p>​            speed = .duration(newValue)</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    @available(*, deprecated : 2.6, message : “Use speed property instead”)</p>
<p>​    @IBInspectable open var scrollRate: CGFloat {</p>
<p>​        get {</p>
<p>​            switch speed {</p>
<p>​            case .duration(_): return 0.0</p>
<p>​            case .rate(let rate): return rate</p>
<p>​            }</p>
<p>​        }</p>
<p>​        set {</p>
<p>​            speed = .rate(newValue)</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     A buffer (offset) between the leading edge of the label text and the label frame.</p>
<p>​     </p>
<p>​     This property adds additional space between the leading edge of the label text and the label frame. The</p>
<p>​     leading edge is the edge of the label text facing the direction of scroll (i.e. the edge that animates</p>
<p>​     offscreen first during scrolling).</p>
<p>​     </p>
<p>​     Defaults to <code>0</code>.</p>
<p>​     </p>
<p>​     - Note: The value set to this property affects label positioning at all times (including when <code>labelize</code> is set to <code>true</code>),</p>
<p>​     including when the text string length is short enough that the label does not need to scroll.</p>
<p>​     - Note: For Continuous-type labels, the smallest value of <code>leadingBuffer</code>, <code>trailingBuffer</code>, and <code>fadeLength</code></p>
<p>​     is used as spacing between the two label instances. Zero is an allowable value for all three properties.</p>
<p>​     </p>
<p>​     - SeeAlso: trailingBuffer</p>
<p>​     */</p>
<p>​    @IBInspectable open var leadingBuffer: CGFloat = 0.0 {</p>
<p>​        didSet {</p>
<p>​            if leadingBuffer != oldValue {</p>
<p>​                updateAndScroll()</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     A buffer (offset) between the trailing edge of the label text and the label frame.</p>
<p>​     </p>
<p>​     This property adds additional space (buffer) between the trailing edge of the label text and the label frame. The</p>
<p>​     trailing edge is the edge of the label text facing away from the direction of scroll (i.e. the edge that animates</p>
<p>​     offscreen last during scrolling).</p>
<p>​     </p>
<p>​     Defaults to <code>0</code>.</p>
<p>​     </p>
<p>​     - Note: The value set to this property has no effect when the <code>labelize</code> property is set to <code>true</code>.</p>
<p>​     </p>
<p>​     - Note: For Continuous-type labels, the smallest value of <code>leadingBuffer</code>, <code>trailingBuffer</code>, and <code>fadeLength</code></p>
<p>​     is used as spacing between the two label instances. Zero is an allowable value for all three properties.</p>
<p>​     </p>
<p>​     - SeeAlso: leadingBuffer</p>
<p>​     */</p>
<p>​    @IBInspectable open var trailingBuffer: CGFloat = 0.0 {</p>
<p>​        didSet {</p>
<p>​            if trailingBuffer != oldValue {</p>
<p>​                updateAndScroll()</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     The length of transparency fade at the left and right edges of the frame.</p>
<p>​     </p>
<p>​     This propery sets the size (in points) of the view edge transparency fades on the left and right edges of a <code>MarqueeLabel</code>. The</p>
<p>​     transparency fades from an alpha of 1.0 (fully visible) to 0.0 (fully transparent) over this distance. Values set to this property</p>
<p>​     will be sanitized to prevent a fade length greater than 1/2 of the frame width.</p>
<p>​     </p>
<p>​     Defaults to <code>0</code>.</p>
<p>​     */</p>
<p>​    @IBInspectable open var fadeLength: CGFloat = 0.0 {</p>
<p>​        didSet {</p>
<p>​            if fadeLength != oldValue {</p>
<p>​                applyGradientMask(fadeLength, animated: true)</p>
<p>​                updateAndScroll()</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    </p>
<p>​    /**</p>
<p>​     The length of delay in seconds that the label pauses at the completion of a scroll.</p>
<p>​     */</p>
<p>​    @IBInspectable open var animationDelay: CGFloat = 1.0</p>
<p>​    </p>
<p>​    </p>
<p>​    /** The read-only/computed duration of the scroll animation (not including delay).</p>
<p>​     </p>
<p>​     The value of this property is calculated from the value set to the <code>speed</code> property. If a duration-type speed is</p>
<p>​     used to set the label animation speed, <code>animationDuration</code> will be equivalent to that value.</p>
<p>​     */</p>
<p>​    public var animationDuration: CGFloat {</p>
<p>​        switch self.speed {</p>
<p>​        case .rate(let rate):</p>
<p>​            return CGFloat(fabs(self.awayOffset) / rate)</p>
<p>​        case .duration(let duration):</p>
<p>​            return duration</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    //</p>
<p>​    // MARK: - Class Functions and Helpers</p>
<p>​    //</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Convenience method to restart all <code>MarqueeLabel</code> instances that have the specified view controller in their next responder chain.</p>
<p>​    </p>
<p>​     - Parameter controller: The view controller for which to restart all <code>MarqueeLabel</code> instances.</p>
<p>​    </p>
<p>​     - Warning: View controllers that appear with animation (such as from underneath a modal-style controller) can cause some <code>MarqueeLabel</code> text</p>
<p>​     position “jumping” when this method is used in <code>viewDidAppear</code> if scroll animations are already underway. Use this method inside <code>viewWillAppear:</code></p>
<p>​     instead to avoid this problem.</p>
<p>​    </p>
<p>​     - Warning: This method may not function properly if passed the parent view controller when using view controller containment.</p>
<p>​    </p>
<p>​     - SeeAlso: restartLabel</p>
<p>​     - SeeAlso: controllerViewDidAppear:</p>
<p>​     - SeeAlso: controllerViewWillAppear:</p>
<p>​     */</p>
<p>​    open class func restartLabelsOfController(_ controller: UIViewController) {</p>
<p>​        MarqueeLabel.notifyController(controller, message: .Restart)</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Convenience method to restart all <code>MarqueeLabel</code> instances that have the specified view controller in their next responder chain.</p>
<p>​     </p>
<p>​     Alternative to <code>restartLabelsOfController</code>. This method is retained for backwards compatibility and future enhancements.</p>
<p>​     </p>
<p>​     - Parameter controller: The view controller that will appear.</p>
<p>​     - SeeAlso: restartLabel</p>
<p>​     - SeeAlso: controllerViewDidAppear</p>
<p>​     */</p>
<p>​    open class func controllerViewWillAppear(_ controller: UIViewController) {</p>
<p>​        MarqueeLabel.restartLabelsOfController(controller)</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Convenience method to restart all <code>MarqueeLabel</code> instances that have the specified view controller in their next responder chain.</p>
<p>​     </p>
<p>​     Alternative to <code>restartLabelsOfController</code>. This method is retained for backwards compatibility and future enhancements.</p>
<p>​     </p>
<p>​     - Parameter controller: The view controller that did appear.</p>
<p>​     - SeeAlso: restartLabel</p>
<p>​     - SeeAlso: controllerViewWillAppear</p>
<p>​     */</p>
<p>​    open class func controllerViewDidAppear(_ controller: UIViewController) {</p>
<p>​        MarqueeLabel.restartLabelsOfController(controller)</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Labelizes all <code>MarqueeLabel</code> instances that have the specified view controller in their next responder chain.</p>
<p>​    </p>
<p>​     The <code>labelize</code> property of all recognized <code>MarqueeLabel</code> instances will be set to <code>true</code>.</p>
<p>​     </p>
<p>​     - Parameter controller: The view controller for which all <code>MarqueeLabel</code> instances should be labelized.</p>
<p>​     - SeeAlso: labelize</p>
<p>​     */</p>
<p>​    open class func controllerLabelsLabelize(_ controller: UIViewController) {</p>
<p>​        MarqueeLabel.notifyController(controller, message: .Labelize)</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     De-labelizes all <code>MarqueeLabel</code> instances that have the specified view controller in their next responder chain.</p>
<p>​     </p>
<p>​     The <code>labelize</code> property of all recognized <code>MarqueeLabel</code> instances will be set to <code>false</code>.</p>
<p>​     </p>
<p>​     - Parameter controller: The view controller for which all <code>MarqueeLabel</code> instances should be de-labelized.</p>
<p>​     - SeeAlso: labelize</p>
<p>​     */</p>
<p>​    open class func controllerLabelsAnimate(_ controller: UIViewController) {</p>
<p>​        MarqueeLabel.notifyController(controller, message: .Animate)</p>
<p>​    }</p>
<p>​    </p>
<p>​    //</p>
<p>​    // MARK: - Initialization</p>
<p>​    //</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Returns a newly initialized <code>MarqueeLabel</code> instance with the specified scroll rate and edge transparency fade length.</p>
<p>​    </p>
<p>​     - Parameter frame: A rectangle specifying the initial location and size of the view in its superview’s coordinates. Text (for the given font, font size, etc.) that does not fit in this frame will automatically scroll.</p>
<p>​     - Parameter pixelsPerSec: A rate of scroll for the label scroll animation. Must be non-zero. Note that this will be the peak (mid-transition) rate for ease-type animation.</p>
<p>​     - Parameter fadeLength: A length of transparency fade at the left and right edges of the <code>MarqueeLabel</code> instance’s frame.</p>
<p>​     - Returns: An initialized <code>MarqueeLabel</code> object or nil if the object couldn’t be created.</p>
<p>​     - SeeAlso: fadeLength</p>
<p>​     */</p>
<p>​    public init(frame: CGRect, rate: CGFloat, fadeLength fade: CGFloat) {</p>
<p>​        speed = .rate(rate)</p>
<p>​        fadeLength = CGFloat(min(fade, frame.size.width/2.0))</p>
<p>​        super.init(frame: frame)</p>
<p>​        setup()</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Returns a newly initialized <code>MarqueeLabel</code> instance with the specified scroll rate and edge transparency fade length.</p>
<p>​     </p>
<p>​     - Parameter frame: A rectangle specifying the initial location and size of the view in its superview’s coordinates. Text (for the given font, font size, etc.) that does not fit in this frame will automatically scroll.</p>
<p>​     - Parameter scrollDuration: A scroll duration the label scroll animation. Must be non-zero. This will be the duration that the animation takes for one-half of the scroll cycle in the case of left-right and right-left marquee types, and for one loop of a continuous marquee type.</p>
<p>​     - Parameter fadeLength: A length of transparency fade at the left and right edges of the <code>MarqueeLabel</code> instance’s frame.</p>
<p>​     - Returns: An initialized <code>MarqueeLabel</code> object or nil if the object couldn’t be created.</p>
<p>​     - SeeAlso: fadeLength</p>
<p>​     */</p>
<p>​    public init(frame: CGRect, duration: CGFloat, fadeLength fade: CGFloat) {</p>
<p>​        speed = .duration(duration)</p>
<p>​        fadeLength = CGFloat(min(fade, frame.size.width/2.0))</p>
<p>​        super.init(frame: frame)</p>
<p>​        setup()</p>
<p>​    }</p>
<p>​    </p>
<p>​    required public init?(coder aDecoder: NSCoder) {</p>
<p>​        super.init(coder: aDecoder)</p>
<p>​        setup()</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Returns a newly initialized <code>MarqueeLabel</code> instance.</p>
<p>​     </p>
<p>​     The default scroll duration of 7.0 seconds and fade length of 0.0 are used.</p>
<p>​     </p>
<p>​     - Parameter frame: A rectangle specifying the initial location and size of the view in its superview’s coordinates. Text (for the given font, font size, etc.) that does not fit in this frame will automatically scroll.</p>
<p>​     - Returns: An initialized <code>MarqueeLabel</code> object or nil if the object couldn’t be created.</p>
<p>​    */</p>
<p>​    convenience public override init(frame: CGRect) {</p>
<p>​        self.init(frame: frame, duration:7.0, fadeLength:0.0)</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func setup() {</p>
<p>​        // Create sublabel</p>
<p>​        sublabel = UILabel(frame: self.bounds)</p>
<p>​        sublabel.tag = 700</p>
<p>​        sublabel.layer.anchorPoint = CGPoint.zero</p>
<p>​        // Add sublabel</p>
<p>​        addSubview(sublabel)</p>
<p>​        </p>
<p>​        // Configure self</p>
<p>​        super.clipsToBounds = true</p>
<p>​        super.numberOfLines = 1</p>
<p>​        </p>
<p>​        // Add notification observers</p>
<p>​        // Custom class notifications</p>
<p>​        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.restartForViewController(_:)), name: NSNotification.Name(rawValue: MarqueeKeys.Restart.rawValue), object: nil)</p>
<p>​        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.labelizeForController(_:)), name: NSNotification.Name(rawValue: MarqueeKeys.Labelize.rawValue), object: nil)</p>
<p>​        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.animateForController(_:)), name: NSNotification.Name(rawValue: MarqueeKeys.Animate.rawValue), object: nil)</p>
<p>​        // UIApplication state notifications</p>
<p>​        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.restartLabel), name: NSNotification.Name.UIApplicationDidBecomeActive, object: nil)</p>
<p>​        NotificationCenter.default.addObserver(self, selector: #selector(MarqueeLabel.shutdownLabel), name: NSNotification.Name.UIApplicationDidEnterBackground, object: nil)</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open func awakeFromNib() {</p>
<p>​        super.awakeFromNib()</p>
<p>​        forwardPropertiesToSublabel()</p>
<p>​    }</p>
<p>​    </p>
<p>​    @available(iOS 8.0, *)</p>
<p>​    override open func prepareForInterfaceBuilder() {</p>
<p>​        super.prepareForInterfaceBuilder()</p>
<p>​        forwardPropertiesToSublabel()</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func forwardPropertiesToSublabel() {</p>
<p>​        /*</p>
<p>​        Note that this method is currently ONLY called from awakeFromNib, i.e. when</p>
<p>​        text properties are set via a Storyboard. As the Storyboard/IB doesn’t currently</p>
<p>​        support attributed strings, there’s no need to “forward” the super attributedString value.</p>
<p>​        */</p>
<p>​        </p>
<p>​        // Since we’re a UILabel, we actually do implement all of UILabel’s properties.</p>
<p>​        // We don’t care about these values, we just want to forward them on to our sublabel.</p>
<p>​        let properties = [“baselineAdjustment”, “enabled”, “highlighted”, “highlightedTextColor”,</p>
<p>​                          “minimumFontSize”, “shadowOffset”, “textAlignment”,</p>
<p>​                          “userInteractionEnabled”, “adjustsFontSizeToFitWidth”,</p>
<p>​                          “lineBreakMode”, “numberOfLines”, “contentMode”]</p>
<p>​        </p>
<p>​        // Iterate through properties</p>
<p>​        sublabel.text = super.text</p>
<p>​        sublabel.font = super.font</p>
<p>​        sublabel.textColor = super.textColor</p>
<p>​        sublabel.backgroundColor = super.backgroundColor ?? UIColor.clear</p>
<p>​        sublabel.shadowColor = super.shadowColor</p>
<p>​        sublabel.shadowOffset = super.shadowOffset</p>
<p>​        for prop in properties {</p>
<p>​            let value = super.value(forKey: prop)</p>
<p>​            sublabel.setValue(value, forKeyPath: prop)</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    //</p>
<p>​    // MARK: - MarqueeLabel Heavy Lifting</p>
<p>​    //</p>
<p>​    override open func layoutSubviews() {</p>
<p>​        super.layoutSubviews()</p>
<p>​        </p>
<p>​        updateAndScroll(true)</p>
<p>​    }</p>
<p>​    override open func willMove(toWindow newWindow: UIWindow?) {</p>
<p>​        if newWindow == nil {</p>
<p>​            shutdownLabel()</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open func didMoveToWindow() {</p>
<p>​        if self.window == nil {</p>
<p>​            shutdownLabel()</p>
<p>​        } else {</p>
<p>​            updateAndScroll()</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func updateAndScroll() {</p>
<p>​        updateAndScroll(true)</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func updateAndScroll(_ shouldBeginScroll: Bool) {</p>
<p>​        // Check if scrolling can occur</p>
<p>​        if !labelReadyForScroll() {</p>
<p>​            return</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Calculate expected size</p>
<p>​        let expectedLabelSize = sublabelSize()</p>
<p>​        </p>
<p>​        // Invalidate intrinsic size</p>
<p>​        invalidateIntrinsicContentSize()</p>
<p>​        </p>
<p>​        // Move label to home</p>
<p>​        returnLabelToHome()</p>
<p>​        </p>
<p>​        // Check if label should scroll</p>
<p>​        // Note that the holdScrolling propery does not affect this</p>
<p>​        if !labelShouldScroll() {</p>
<p>​            // Set text alignment and break mode to act like a normal label</p>
<p>​            sublabel.textAlignment = super.textAlignment</p>
<p>​            sublabel.lineBreakMode = super.lineBreakMode</p>
<p>​            </p>
<p>​            let labelFrame: CGRect</p>
<p>​            switch type {</p>
<p>​            case .continuousReverse, .rightLeft:</p>
<p>​                labelFrame = bounds.divided(atDistance: leadingBuffer, from: CGRectEdge.maxXEdge).remainder.integral</p>
<p>​            default:</p>
<p>​                labelFrame = CGRect(x: leadingBuffer, y: 0.0, width: bounds.size.width - leadingBuffer, height: bounds.size.height).integral</p>
<p>​            }</p>
<p>​            </p>
<p>​            homeLabelFrame = labelFrame</p>
<p>​            awayOffset = 0.0</p>
<p>​            </p>
<p>​            // Remove an additional sublabels (for continuous types)</p>
<p>​            repliLayer?.instanceCount = 1;</p>
<p>​            </p>
<p>​            // Set the sublabel frame to calculated labelFrame</p>
<p>​            sublabel.frame = labelFrame</p>
<p>​            </p>
<p>​            // Remove fade, as by definition none is needed in this case</p>
<p>​            removeGradientMask()</p>
<p>​            </p>
<p>​            return</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Label DOES need to scroll</p>
<p>​        </p>
<p>​        // Spacing between primary and second sublabel must be at least equal to leadingBuffer, and at least equal to the fadeLength</p>
<p>​        let minTrailing = max(max(leadingBuffer, trailingBuffer), fadeLength)</p>
<p>​        </p>
<p>​        // Determine positions and generate scroll steps</p>
<p>​        let sequence: [MarqueeStep]</p>
<p>​        </p>
<p>​        switch type {</p>
<p>​        case .continuous, .continuousReverse:</p>
<p>​            if (type == .continuous) {</p>
<p>​                homeLabelFrame = CGRect(x: leadingBuffer, y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral</p>
<p>​                awayOffset = -(homeLabelFrame.size.width + minTrailing)</p>
<p>​            } else { // .ContinuousReverse</p>
<p>​                homeLabelFrame = CGRect(x: bounds.size.width - (expectedLabelSize.width + leadingBuffer), y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral</p>
<p>​                awayOffset = (homeLabelFrame.size.width + minTrailing)</p>
<p>​            }</p>
<p>​            </p>
<p>​            // Find when the lead label will be totally offscreen</p>
<p>​            let offsetDistance = awayOffset</p>
<p>​            let offscreenAmount = homeLabelFrame.size.width</p>
<p>​            let startFadeFraction = fabs(offscreenAmount / offsetDistance)</p>
<p>​            // Find when the animation will hit that point</p>
<p>​            let startFadeTimeFraction = timingFunctionForAnimationCurve(animationCurve).durationPercentageForPositionPercentage(startFadeFraction, duration: (animationDelay + animationDuration))</p>
<p>​            let startFadeTime = startFadeTimeFraction * animationDuration</p>
<p>​            </p>
<p>​            sequence = scrollSequence ?? [</p>
<p>​                ScrollStep(timeStep: 0.0, position: .home, edgeFades: .trailing),                   // Starting point, at home, with trailing fade</p>
<p>​                ScrollStep(timeStep: animationDelay, position: .home, edgeFades: .trailing),        // Delay at home, maintaining fade state</p>
<p>​                FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                          // 0.2 sec after scroll start, fade leading edge in as well</p>
<p>​                FadeStep(timeStep: (startFadeTime - animationDuration),                             // Maintain fade state until just before reaching end of scroll animation</p>
<p>​                         edgeFades: [.leading, .trailing]),</p>
<p>​                ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,             // Ending point (back at home), with animationCurve transition, with trailing fade</p>
<p>​                           position: .away, edgeFades: .trailing)</p>
<p>​            ]</p>
<p>​            </p>
<p>​            // Set frame and text</p>
<p>​            sublabel.frame = homeLabelFrame</p>
<p>​            </p>
<p>​            // Configure replication</p>
<p>​            repliLayer?.instanceCount = 2</p>
<p>​            repliLayer?.instanceTransform = CATransform3DMakeTranslation(-awayOffset, 0.0, 0.0)</p>
<p>​            </p>
<p>​        case .leftRight, .left, .rightLeft, .right:</p>
<p>​            if (type == .leftRight || type == .left) {</p>
<p>​                homeLabelFrame = CGRect(x: leadingBuffer, y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral</p>
<p>​                awayOffset = bounds.size.width - (expectedLabelSize.width + leadingBuffer + trailingBuffer)</p>
<p>​                // Enforce text alignment for this type</p>
<p>​                sublabel.textAlignment = NSTextAlignment.left</p>
<p>​            } else {</p>
<p>​                homeLabelFrame = CGRect(x: bounds.size.width - (expectedLabelSize.width + leadingBuffer), y: 0.0, width: expectedLabelSize.width, height: bounds.size.height).integral</p>
<p>​                awayOffset = (expectedLabelSize.width + trailingBuffer + leadingBuffer) - bounds.size.width</p>
<p>​                // Enforce text alignment for this type</p>
<p>​                sublabel.textAlignment = NSTextAlignment.right</p>
<p>​            }</p>
<p>​            // Set frame and text</p>
<p>​            sublabel.frame = homeLabelFrame</p>
<p>​            </p>
<p>​            // Remove any replication</p>
<p>​            repliLayer?.instanceCount = 1</p>
<p>​            </p>
<p>​            if (type == .leftRight || type == .rightLeft) {</p>
<p>​                sequence = scrollSequence ?? [</p>
<p>​                    ScrollStep(timeStep: 0.0, position: .home, edgeFades: .trailing),               // Starting point, at home, with trailing fade</p>
<p>​                    ScrollStep(timeStep: animationDelay, position: .home, edgeFades: .trailing),    // Delay at home, maintaining fade state</p>
<p>​                    FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                      // 0.2 sec after delay ends, fade leading edge in as well</p>
<p>​                    FadeStep(timeStep: -0.2, edgeFades: [.leading, .trailing]),                     // Maintain fade state until 0.2 sec before reaching away position</p>
<p>​                    ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,         // Away position, using animationCurve transition, with only leading edge faded in</p>
<p>​                        position: .away, edgeFades: .leading),</p>
<p>​                    ScrollStep(timeStep: animationDelay, position: .away, edgeFades: .leading),     // Delay at away, maintaining fade state (leading only)</p>
<p>​                    FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                      // 0.2 sec after delay ends, fade trailing edge back in as well</p>
<p>​                    FadeStep(timeStep: -0.2, edgeFades: [.leading, .trailing]),                     // Maintain fade state until 0.2 sec before reaching home position</p>
<p>​                    ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,         // Ending point, back at home, with only trailing fade</p>
<p>​                        position: .home, edgeFades: .trailing)</p>
<p>​                ]</p>
<p>​            } else { // .left or .right</p>
<p>​                sequence = scrollSequence ?? [</p>
<p>​                    ScrollStep(timeStep: 0.0, position: .home, edgeFades: .trailing),               // Starting point, at home, with trailing fade</p>
<p>​                    ScrollStep(timeStep: animationDelay, position: .home, edgeFades: .trailing),    // Delay at home, maintaining fade state</p>
<p>​                    FadeStep(timeStep: 0.2, edgeFades: [.leading, .trailing]),                      // 0.2 sec after delay ends, fade leading edge in as well</p>
<p>​                    FadeStep(timeStep: -0.2, edgeFades: [.leading, .trailing]),                     // Maintain fade state until 0.2 sec before reaching away position</p>
<p>​                    ScrollStep(timeStep: animationDuration, timingFunction: animationCurve,         // Away position, using animationCurve transition, with only leading edge faded in</p>
<p>​                        position: .away, edgeFades: .leading),</p>
<p>​                    ScrollStep(timeStep: animationDelay, position: .away, edgeFades: .leading),     // “Delay” at away, maintaining fade state</p>
<p>​                ]</p>
<p>​            }</p>
<p>​        }</p>
<p>​        </p>
<p>​        </p>
<p>​        </p>
<p>​        // Configure gradient for current condition</p>
<p>​        applyGradientMask(fadeLength, animated: !self.labelize)</p>
<p>​        </p>
<p>​        if !tapToScroll &amp;&amp; !holdScrolling &amp;&amp; shouldBeginScroll {</p>
<p>​            beginScroll(sequence)</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func sublabelSize() -&gt; CGSize {</p>
<p>​        // Bound the expected size</p>
<p>​        let maximumLabelSize = CGSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)</p>
<p>​        // Calculate the expected size</p>
<p>​        var expectedLabelSize = sublabel.sizeThatFits(maximumLabelSize)</p>
<p>​        </p>
<p>​        #if os(tvOS)</p>
<p>​            // Sanitize width to 16384.0 (largest width a UILabel will draw on tvOS)</p>
<p>​            expectedLabelSize.width = min(expectedLabelSize.width, 16384.0)</p>
<p>​        #else</p>
<p>​            // Sanitize width to 5461.0 (largest width a UILabel will draw on an iPhone 6S Plus)</p>
<p>​            expectedLabelSize.width = min(expectedLabelSize.width, 5461.0)</p>
<p>​        #endif</p>
<p>​        // Adjust to own height (make text baseline match normal label)</p>
<p>​        expectedLabelSize.height = bounds.size.height</p>
<p>​        return expectedLabelSize</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open func sizeThatFits(_ size: CGSize) -&gt; CGSize {</p>
<p>​        var fitSize = sublabel.sizeThatFits(size)</p>
<p>​        fitSize.width += leadingBuffer</p>
<p>​        return fitSize</p>
<p>​    }</p>
<p>​    </p>
<p>​    //</p>
<p>​    // MARK: - Animation Handling</p>
<p>​    //</p>
<p>​    </p>
<p>​    open func labelShouldScroll() -&gt; Bool {</p>
<p>​        // Check for nil string</p>
<p>​        if sublabel.text == nil {</p>
<p>​            return false</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Check for empty string</p>
<p>​        if sublabel.text!.isEmpty {</p>
<p>​            return false</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Check if the label string fits</p>
<p>​        let labelTooLarge = (sublabelSize().width + leadingBuffer) &gt; self.bounds.size.width + CGFloat.ulpOfOne</p>
<p>​        let animationHasDuration = speed.value &gt; 0.0</p>
<p>​        return (!labelize &amp;&amp; labelTooLarge &amp;&amp; animationHasDuration)</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func labelReadyForScroll() -&gt; Bool {</p>
<p>​        // Check if we have a superview</p>
<p>​        if superview == nil {</p>
<p>​            return false</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Check if we are attached to a window</p>
<p>​        if window == nil {</p>
<p>​            return false</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Check if our view controller is ready</p>
<p>​        let viewController = firstAvailableViewController()</p>
<p>​        if viewController != nil {</p>
<p>​            if !viewController!.isViewLoaded {</p>
<p>​                return false</p>
<p>​            }</p>
<p>​        }</p>
<p>​        </p>
<p>​        return true</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func returnLabelToHome() {</p>
<p>​        // Remove any gradient animation</p>
<p>​        maskLayer?.removeAllAnimations()</p>
<p>​        </p>
<p>​        // Remove all sublabel position animations</p>
<p>​        sublabel.layer.removeAllAnimations()</p>
<p>​        </p>
<p>​        // Remove completion block</p>
<p>​        scrollCompletionBlock = nil</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func beginScroll(_ sequence: [MarqueeStep]) {</p>
<p>​        let scroller = generateScrollAnimation(sequence)</p>
<p>​        let fader = generateGradientAnimation(sequence, totalDuration: scroller.duration)</p>
<p>​        </p>
<p>​        scroll(scroller, fader: fader)</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func scroll(_ scroller: MLAnimation, fader: MLAnimation?) {</p>
<p>​        // Check for conditions which would prevent scrolling</p>
<p>​        if !labelReadyForScroll() {</p>
<p>​            return</p>
<p>​        }</p>
<p>​        // Convert fader to var</p>
<p>​        var fader = fader</p>
<p>​        </p>
<p>​        // Call pre-animation hook</p>
<p>​        labelWillBeginScroll()</p>
<p>​        </p>
<p>​        // Start animation transactions</p>
<p>​        CATransaction.begin()</p>
<p>​        CATransaction.setAnimationDuration(TimeInterval(scroller.duration))</p>
<p>​        </p>
<p>​        // Create gradient animation, if needed</p>
<p>​        let gradientAnimation: CAKeyframeAnimation?</p>
<p>​        // Check for IBDesignable</p>
<p>​        #if !TARGET_INTERFACE_BUILDER</p>
<p>​            if fadeLength &gt; 0.0 {</p>
<p>​                // Remove any setup animation, but apply final values</p>
<p>​                if let setupAnim = maskLayer?.animation(forKey: “setupFade”) as? CABasicAnimation, let finalColors = setupAnim.toValue as? [CGColor] {</p>
<p>​                    maskLayer?.colors = finalColors</p>
<p>​                }</p>
<p>​                maskLayer?.removeAnimation(forKey: “setupFade”)</p>
<p>​                </p>
<p>​                // Generate animation if needed</p>
<p>​                if let previousAnimation = fader?.anim {</p>
<p>​                    gradientAnimation = previousAnimation</p>
<p>​                } else {</p>
<p>​                    gradientAnimation = nil</p>
<p>​                }</p>
<p>​                </p>
<p>​                // Apply fade animation</p>
<p>​                maskLayer?.add(gradientAnimation!, forKey: “gradient”)</p>
<p>​            } else {</p>
<p>​                // No animation needed</p>
<p>​                fader = nil</p>
<p>​            }</p>
<p>​        #else</p>
<p>​            fader = nil;</p>
<p>​        #endif</p>
<p>​        </p>
<p>​        scrollCompletionBlock = { [weak self] (finished: Bool) -&gt; () in</p>
<p>​            guard finished else {</p>
<p>​                // Do not continue into the next loop</p>
<p>​                return</p>
<p>​            }</p>
<p>​            </p>
<p>​            guard (self != nil) else {</p>
<p>​                return</p>
<p>​            }</p>
<p>​            </p>
<p>​            // Call returned home function</p>
<p>​            self!.labelReturnedToHome(true)</p>
<p>​            </p>
<p>​            // Check to ensure that:</p>
<p>​            // 1) We don’t double fire if an animation already exists</p>
<p>​            // 2) The instance is still attached to a window - this completion block is called for</p>
<p>​            //    many reasons, including if the animation is removed due to the view being removed</p>
<p>​            //    from the UIWindow (typically when the view controller is no longer the “top” view)</p>
<p>​            guard self!.window != nil else {</p>
<p>​                return</p>
<p>​            }</p>
<p>​            </p>
<p>​            guard self!.sublabel.layer.animation(forKey: “position”) == nil else {</p>
<p>​                return</p>
<p>​            }</p>
<p>​            </p>
<p>​            // Begin again, if conditions met</p>
<p>​            if (self!.labelShouldScroll() &amp;&amp; !self!.tapToScroll &amp;&amp; !self!.holdScrolling) {</p>
<p>​                // Perform completion callback</p>
<p>​                self!.scroll(scroller, fader: fader)</p>
<p>​            }</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Perform scroll animation</p>
<p>​        scroller.anim.setValue(true, forKey: MarqueeKeys.CompletionClosure.rawValue)</p>
<p>​        scroller.anim.delegate = self</p>
<p>​        if type == .left || type == .right {</p>
<p>​            // Make it stay at away permanently</p>
<p>​            scroller.anim.isRemovedOnCompletion = false</p>
<p>​            scroller.anim.fillMode = kCAFillModeForwards</p>
<p>​        }</p>
<p>​        sublabel.layer.add(scroller.anim, forKey: “position”)</p>
<p>​        </p>
<p>​        CATransaction.commit()</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func generateScrollAnimation(_ sequence: [MarqueeStep]) -&gt; MLAnimation {</p>
<p>​        // Create scroller, which defines the animation to perform</p>
<p>​        let homeOrigin = homeLabelFrame.origin</p>
<p>​        let awayOrigin = offsetCGPoint(homeLabelFrame.origin, offset: awayOffset)</p>
<p>​        </p>
<p>​        let scrollSteps = sequence.filter({ $0 is ScrollStep }) as! [ScrollStep]</p>
<p>​        let totalDuration = scrollSteps.reduce(0.0) { $0 + $1.timeStep }</p>
<p>​        </p>
<p>​        // Build scroll data</p>
<p>​        var totalTime: CGFloat = 0.0</p>
<p>​        var scrollKeyTimes = <a href="">NSNumber</a></p>
<p>​        var scrollKeyValues = <a href="">NSValue</a></p>
<p>​        var scrollTimingFunctions = <a href="">CAMediaTimingFunction</a></p>
<p>​        </p>
<p>​        for (offset, step) in scrollSteps.enumerated() {</p>
<p>​            // Scroll Times</p>
<p>​            totalTime += step.timeStep</p>
<p>​            scrollKeyTimes.append(NSNumber(value:Float(totalTime/totalDuration)))</p>
<p>​            </p>
<p>​            // Scroll Values</p>
<p>​            let scrollPosition: CGPoint</p>
<p>​            switch step.position {</p>
<p>​            case .home:</p>
<p>​                scrollPosition = homeOrigin</p>
<p>​            case .away:</p>
<p>​                scrollPosition = awayOrigin</p>
<p>​            case .partial(let frac):</p>
<p>​                scrollPosition = offsetCGPoint(homeOrigin, offset: awayOffset*frac)</p>
<p>​            }</p>
<p>​            scrollKeyValues.append(NSValue(cgPoint:scrollPosition))</p>
<p>​            </p>
<p>​            // Scroll Timing Functions</p>
<p>​            // Only need n-1 timing functions, so discard the first value as it’s unused</p>
<p>​            if offset == 0 { continue }</p>
<p>​            scrollTimingFunctions.append(timingFunctionForAnimationCurve(step.timingFunction))</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Create animation</p>
<p>​        let animation = CAKeyframeAnimation(keyPath: “position”)</p>
<p>​        // Set values</p>
<p>​        animation.keyTimes = scrollKeyTimes</p>
<p>​        animation.values = scrollKeyValues</p>
<p>​        animation.timingFunctions = scrollTimingFunctions</p>
<p>​        </p>
<p>​        return (anim: animation, duration: totalDuration)</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func generateGradientAnimation(_ sequence: [MarqueeStep], totalDuration: CGFloat) -&gt; MLAnimation {</p>
<p>​        // Setup</p>
<p>​        var totalTime: CGFloat = 0.0</p>
<p>​        var stepTime: CGFloat = 0.0</p>
<p>​        var fadeKeyValues = <a href="">[CGColor]</a></p>
<p>​        var fadeKeyTimes = <a href="">NSNumber</a></p>
<p>​        var fadeTimingFunctions = <a href="">CAMediaTimingFunction</a></p>
<p>​        let transp = UIColor.clear.cgColor</p>
<p>​        let opaque = UIColor.black.cgColor</p>
<p>​        </p>
<p>​        // Filter to get only scroll steps and valid precedent/subsequent fade steps</p>
<p>​        let fadeSteps = sequence.enumerated().filter { (arg: (offset: Int, element: MarqueeStep)) -&gt; Bool in</p>
<p>​            let (offset, element) = arg</p>
<p>​            </p>
<p>​            // Include all Scroll Steps</p>
<p>​            if element is ScrollStep { return true }</p>
<p>​            </p>
<p>​            // Include all Fade Steps that have a directly preceding or subsequent Scroll Step</p>
<p>​            // Exception: Fade Step cannot be first step</p>
<p>​            if offset == 0 { return false }</p>
<p>​            </p>
<p>​            // Subsequent step if 1) positive/zero time step and 2) follows a Scroll Step</p>
<p>​            let subsequent = element.timeStep &gt;= 0 &amp;&amp; (sequence[max(0, offset - 1)] is ScrollStep)</p>
<p>​            // Precedent step if 1) negative time step and 2) precedes a Scroll Step</p>
<p>​            let precedent = element.timeStep &lt; 0 &amp;&amp; (sequence[min(sequence.count - 1, offset + 1)] is ScrollStep)</p>
<p>​            </p>
<p>​            return (precedent || subsequent)</p>
<p>​        }</p>
<p>​        </p>
<p>​        for (offset, step) in fadeSteps {</p>
<p>​            // Fade times</p>
<p>​            if (step is ScrollStep) {</p>
<p>​                totalTime += step.timeStep</p>
<p>​                stepTime = totalTime</p>
<p>​            } else {</p>
<p>​                if step.timeStep &gt;= 0 {</p>
<p>​                    // Is a Subsequent</p>
<p>​                    stepTime = totalTime + step.timeStep</p>
<p>​                } else {</p>
<p>​                    // Is a Precedent, grab next step</p>
<p>​                    stepTime = totalTime + fadeSteps[offset + 1].element.timeStep + step.timeStep</p>
<p>​                }</p>
<p>​            }</p>
<p>​            fadeKeyTimes.append(NSNumber(value:Float(stepTime/totalDuration)))</p>
<p>​            </p>
<p>​            // Fade Values</p>
<p>​            let values: [CGColor]</p>
<p>​            let leading = step.edgeFades.contains(.leading) ? transp : opaque</p>
<p>​            let trailing = step.edgeFades.contains(.trailing) ? transp : opaque</p>
<p>​            switch type {</p>
<p>​            case .leftRight, .left, .continuous:</p>
<p>​                values = [leading, opaque, opaque, trailing]</p>
<p>​            case .rightLeft, .right, .continuousReverse:</p>
<p>​                values = [trailing, opaque, opaque, leading]</p>
<p>​            }</p>
<p>​            fadeKeyValues.append(values)</p>
<p>​            </p>
<p>​            // Fade Timing Function</p>
<p>​            // Only need n-1 timing functions, so discard the first value as it’s unused</p>
<p>​            if offset == 0 { continue }</p>
<p>​            fadeTimingFunctions.append(timingFunctionForAnimationCurve(step.timingFunction))</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Create new animation</p>
<p>​        let animation = CAKeyframeAnimation(keyPath: “colors”)</p>
<p>​        </p>
<p>​        animation.values = fadeKeyValues</p>
<p>​        animation.keyTimes = fadeKeyTimes</p>
<p>​        animation.timingFunctions = fadeTimingFunctions</p>
<p>​        </p>
<p>​        return (anim: animation, duration: max(totalTime,totalDuration))</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func applyGradientMask(_ fadeLength: CGFloat, animated: Bool, firstStep: MarqueeStep? = nil) {</p>
<p>​        // Remove any in-flight animations</p>
<p>​        maskLayer?.removeAllAnimations()</p>
<p>​        </p>
<p>​        // Check for zero-length fade</p>
<p>​        if (fadeLength &lt;= 0.0) {</p>
<p>​            removeGradientMask()</p>
<p>​            return</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Configure gradient mask without implicit animations</p>
<p>​        CATransaction.begin()</p>
<p>​        CATransaction.setDisableActions(true)</p>
<p>​        </p>
<p>​        // Determine if gradient mask needs to be created</p>
<p>​        let gradientMask: CAGradientLayer</p>
<p>​        if let currentMask = self.maskLayer {</p>
<p>​            // Mask layer already configured</p>
<p>​            gradientMask = currentMask</p>
<p>​        } else {</p>
<p>​            // No mask exists, create new mask</p>
<p>​            gradientMask = CAGradientLayer()</p>
<p>​            gradientMask.shouldRasterize = true</p>
<p>​            gradientMask.rasterizationScale = UIScreen.main.scale</p>
<p>​            gradientMask.startPoint = CGPoint(x:0.0, y:0.5)</p>
<p>​            gradientMask.endPoint = CGPoint(x:1.0, y:0.5)</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Check if there is a mask to layer size mismatch</p>
<p>​        if gradientMask.bounds != self.layer.bounds {</p>
<p>​            // Adjust stops based on fade length</p>
<p>​            let leftFadeStop = fadeLength/self.bounds.size.width</p>
<p>​            let rightFadeStop = 1.0 - fadeLength/self.bounds.size.width</p>
<p>​            gradientMask.locations = [0.0, leftFadeStop, rightFadeStop, 1.0].map { NSNumber(value: Float($0)) }</p>
<p>​        }</p>
<p>​        </p>
<p>​        gradientMask.bounds = self.layer.bounds</p>
<p>​        gradientMask.position = CGPoint(x:self.bounds.midX, y:self.bounds.midY)</p>
<p>​        </p>
<p>​        // Set up colors</p>
<p>​        let transparent = UIColor.clear.cgColor</p>
<p>​        let opaque = UIColor.black.cgColor</p>
<p>​        </p>
<p>​        // Set mask</p>
<p>​        self.layer.mask = gradientMask</p>
<p>​        </p>
<p>​        // Determine colors for non-scrolling label (i.e. at home)</p>
<p>​        let adjustedColors: [CGColor]</p>
<p>​        let trailingFadeNeeded = self.labelShouldScroll()</p>
<p>​        </p>
<p>​        switch (type) {</p>
<p>​        case .continuousReverse, .rightLeft:</p>
<p>​            adjustedColors = [(trailingFadeNeeded ? transparent : opaque), opaque, opaque, opaque]</p>
<p>​        </p>
<p>​        // .Continuous, .LeftRight</p>
<p>​        default:</p>
<p>​            adjustedColors = [opaque, opaque, opaque, (trailingFadeNeeded ? transparent : opaque)]</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Check for IBDesignable</p>
<p>​        #if TARGET_INTERFACE_BUILDER</p>
<p>​            gradientMask.colors = adjustedColors</p>
<p>​            CATransaction.commit()</p>
<p>​            return</p>
<p>​        #endif</p>
<p>​        </p>
<p>​        if (animated) {</p>
<p>​            // Finish transaction</p>
<p>​            CATransaction.commit()</p>
<p>​            </p>
<p>​            // Create animation for color change</p>
<p>​            let colorAnimation = GradientSetupAnimation(keyPath: “colors”)</p>
<p>​            colorAnimation.fromValue = gradientMask.colors</p>
<p>​            colorAnimation.toValue = adjustedColors</p>
<p>​            colorAnimation.fillMode = kCAFillModeForwards</p>
<p>​            colorAnimation.isRemovedOnCompletion = false</p>
<p>​            colorAnimation.delegate = self</p>
<p>​            gradientMask.add(colorAnimation, forKey: “setupFade”)</p>
<p>​        } else {</p>
<p>​            gradientMask.colors = adjustedColors</p>
<p>​            CATransaction.commit()</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func removeGradientMask() {</p>
<p>​        self.layer.mask = nil</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func timingFunctionForAnimationCurve(_ curve: UIViewAnimationCurve) -&gt; CAMediaTimingFunction {</p>
<p>​        let timingFunction: String?</p>
<p>​        </p>
<p>​        switch curve {</p>
<p>​        case .easeIn:</p>
<p>​            timingFunction = kCAMediaTimingFunctionEaseIn</p>
<p>​        case .easeInOut:</p>
<p>​            timingFunction = kCAMediaTimingFunctionEaseInEaseOut</p>
<p>​        case .easeOut:</p>
<p>​            timingFunction = kCAMediaTimingFunctionEaseOut</p>
<p>​        default:</p>
<p>​            timingFunction = kCAMediaTimingFunctionLinear</p>
<p>​        }</p>
<p>​        </p>
<p>​        return CAMediaTimingFunction(name: timingFunction!)</p>
<p>​    }</p>
<p>​    </p>
<p>​    private func transactionDurationType(_ labelType: MarqueeType, interval: CGFloat, delay: CGFloat) -&gt; TimeInterval {</p>
<p>​        switch (labelType) {</p>
<p>​        case .leftRight, .rightLeft:</p>
<p>​            return TimeInterval(2.0 * (delay + interval))</p>
<p>​        default:</p>
<p>​            return TimeInterval(delay + interval)</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    public func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {</p>
<p>​        if let setupAnim = anim as? GradientSetupAnimation {</p>
<p>​            if let finalColors = setupAnim.toValue as? [CGColor] {</p>
<p>​                maskLayer?.colors = finalColors</p>
<p>​            }</p>
<p>​            // Remove regardless, since we set removeOnCompletion = false</p>
<p>​            maskLayer?.removeAnimation(forKey: “setupFade”)</p>
<p>​        } else {</p>
<p>​            scrollCompletionBlock?(flag)</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    </p>
<p>​    //</p>
<p>​    // MARK: - Private details</p>
<p>​    //</p>
<p>​    </p>
<p>​    private var sublabel = UILabel()</p>
<p>​    </p>
<p>​    fileprivate var homeLabelFrame = CGRect.zero</p>
<p>​    fileprivate var awayOffset: CGFloat = 0.0</p>
<p>​    </p>
<p>​    override open class var layerClass: AnyClass {</p>
<p>​        return CAReplicatorLayer.self</p>
<p>​    }</p>
<p>​    </p>
<p>​    fileprivate weak var repliLayer: CAReplicatorLayer? {</p>
<p>​        return self.layer as? CAReplicatorLayer</p>
<p>​    }</p>
<p>​    </p>
<p>​    fileprivate weak var maskLayer: CAGradientLayer? {</p>
<p>​        return self.layer.mask as! CAGradientLayer?</p>
<p>​    }</p>
<p>​    </p>
<p>​    fileprivate var scrollCompletionBlock: MLAnimationCompletionBlock?</p>
<p>​    </p>
<p>​    override open func draw(_ layer: CALayer, in ctx: CGContext) {</p>
<p>​        // Do NOT call super, to prevent UILabel superclass from drawing into context</p>
<p>​        // Label drawing is handled by sublabel and CAReplicatorLayer layer class</p>
<p>​        </p>
<p>​        // Draw only background color</p>
<p>​        if let bgColor = backgroundColor {</p>
<p>​            ctx.setFillColor(bgColor.cgColor);</p>
<p>​            ctx.fill(layer.bounds);</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    fileprivate enum MarqueeKeys: String {</p>
<p>​        case Restart = “MLViewControllerRestart”</p>
<p>​        case Labelize = “MLShouldLabelize”</p>
<p>​        case Animate = “MLShouldAnimate”</p>
<p>​        case CompletionClosure = “MLAnimationCompletion”</p>
<p>​    }</p>
<p>​    </p>
<p>​    class fileprivate func notifyController(_ controller: UIViewController, message: MarqueeKeys) {</p>
<p>​        NotificationCenter.default.post(name: Notification.Name(rawValue: message.rawValue), object: nil, userInfo: [“controller” : controller])</p>
<p>​    }</p>
<p>​    </p>
<p>​    @objc public func restartForViewController(_ notification: Notification) {</p>
<p>​        if let controller = (notification as NSNotification).userInfo?[“controller”] as? UIViewController {</p>
<p>​            if controller === self.firstAvailableViewController() {</p>
<p>​                self.restartLabel()</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    @objc public func labelizeForController(_ notification: Notification) {</p>
<p>​        if let controller = (notification as NSNotification).userInfo?[“controller”] as? UIViewController {</p>
<p>​            if controller === self.firstAvailableViewController() {</p>
<p>​                self.labelize = true</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    @objc public func animateForController(_ notification: Notification) {</p>
<p>​        if let controller = (notification as NSNotification).userInfo?[“controller”] as? UIViewController {</p>
<p>​            if controller === self.firstAvailableViewController() {</p>
<p>​                self.labelize = false</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    </p>
<p>​    //</p>
<p>​    // MARK: - Label Control</p>
<p>​    //</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Overrides any non-size condition which is preventing the receiver from automatically scrolling, and begins a scroll animation.</p>
<p>​    </p>
<p>​     Currently the only non-size conditions which can prevent a label from scrolling are the <code>tapToScroll</code> and <code>holdScrolling</code> properties. This</p>
<p>​     method will not force a label with a string that fits inside the label bounds (i.e. that would not automatically scroll) to begin a scroll</p>
<p>​     animation.</p>
<p>​    </p>
<p>​     Upon the completion of the first forced scroll animation, the receiver will not automatically continue to scroll unless the conditions</p>
<p>​     preventing scrolling have been removed.</p>
<p>​    </p>
<p>​     - Note: This method has no effect if called during an already in-flight scroll animation.</p>
<p>​    </p>
<p>​     - SeeAlso: restartLabel</p>
<p>​    */</p>
<p>​    public func triggerScrollStart() {</p>
<p>​        if labelShouldScroll() &amp;&amp; !awayFromHome {</p>
<p>​            updateAndScroll()</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Immediately resets the label to the home position, cancelling any in-flight scroll animation, and restarts the scroll animation if the appropriate conditions are met.</p>
<p>​     </p>
<p>​     - SeeAlso: resetLabel</p>
<p>​     - SeeAlso: triggerScrollStart</p>
<p>​     */</p>
<p>​    @objc public func restartLabel() {</p>
<p>​        // Shutdown the label</p>
<p>​        shutdownLabel()</p>
<p>​        // Restart scrolling if appropriate</p>
<p>​        if labelShouldScroll() &amp;&amp; !tapToScroll &amp;&amp; !holdScrolling {</p>
<p>​            updateAndScroll()</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Resets the label text, recalculating the scroll animation.</p>
<p>​     </p>
<p>​     The text is immediately returned to the home position, and the scroll animation positions are cleared. Scrolling will not resume automatically after</p>
<p>​     a call to this method. To re-initiate scrolling, use either a call to <code>restartLabel</code> or make a change to a UILabel property such as text, bounds/frame,</p>
<p>​     font, font size, etc.</p>
<p>​     </p>
<p>​     - SeeAlso: restartLabel</p>
<p>​     */</p>
<p>​    public func resetLabel() {</p>
<p>​        returnLabelToHome()</p>
<p>​        homeLabelFrame = CGRect.null</p>
<p>​        awayOffset = 0.0</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Immediately resets the label to the home position, cancelling any in-flight scroll animation.</p>
<p>​     </p>
<p>​     The text is immediately returned to the home position. Scrolling will not resume automatically after a call to this method.</p>
<p>​     To re-initiate scrolling use a call to <code>restartLabel</code> or <code>triggerScrollStart</code>, or make a change to a UILabel property such as text, bounds/frame,</p>
<p>​     font, font size, etc.</p>
<p>​     </p>
<p>​     - SeeAlso: restartLabel</p>
<p>​     - SeeAlso: triggerScrollStart</p>
<p>​     */</p>
<p>​    @objc public func shutdownLabel() {</p>
<p>​        // Bring label to home location</p>
<p>​        returnLabelToHome()</p>
<p>​        // Apply gradient mask for home location</p>
<p>​        applyGradientMask(fadeLength, animated: false)</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Pauses the text scrolling animation, at any point during an in-progress animation.</p>
<p>​     </p>
<p>​     - Note: This method has no effect if a scroll animation is NOT already in progress. To prevent automatic scrolling on a newly-initialized label prior to its presentation onscreen, see the <code>holdScrolling</code> property.</p>
<p>​     </p>
<p>​     - SeeAlso: holdScrolling</p>
<p>​     - SeeAlso: unpauseLabel</p>
<p>​     */</p>
<p>​    public func pauseLabel() {</p>
<p>​        // Prevent pausing label while not in scrolling animation, or when already paused</p>
<p>​        guard (!isPaused &amp;&amp; awayFromHome) else {</p>
<p>​            return</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Pause sublabel position animations</p>
<p>​        let labelPauseTime = sublabel.layer.convertTime(CACurrentMediaTime(), from: nil)</p>
<p>​        sublabel.layer.speed = 0.0</p>
<p>​        sublabel.layer.timeOffset = labelPauseTime</p>
<p>​        </p>
<p>​        // Pause gradient fade animation</p>
<p>​        let gradientPauseTime = maskLayer?.convertTime(CACurrentMediaTime(), from:nil)</p>
<p>​        maskLayer?.speed = 0.0</p>
<p>​        maskLayer?.timeOffset = gradientPauseTime!</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Un-pauses a previously paused text scrolling animation. This method has no effect if the label was not previously paused using <code>pauseLabel</code>.</p>
<p>​     </p>
<p>​     - SeeAlso: pauseLabel</p>
<p>​     */</p>
<p>​    public func unpauseLabel() {</p>
<p>​        // Only unpause if label was previously paused</p>
<p>​        guard (isPaused) else {</p>
<p>​            return</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Unpause sublabel position animations</p>
<p>​        let labelPausedTime = sublabel.layer.timeOffset</p>
<p>​        sublabel.layer.speed = 1.0</p>
<p>​        sublabel.layer.timeOffset = 0.0</p>
<p>​        sublabel.layer.beginTime = 0.0</p>
<p>​        sublabel.layer.beginTime = sublabel.layer.convertTime(CACurrentMediaTime(), from:nil) - labelPausedTime</p>
<p>​        </p>
<p>​        // Unpause gradient fade animation</p>
<p>​        let gradientPauseTime = maskLayer?.timeOffset</p>
<p>​        maskLayer?.speed = 1.0</p>
<p>​        maskLayer?.timeOffset = 0.0</p>
<p>​        maskLayer?.beginTime = 0.0</p>
<p>​        maskLayer?.beginTime = maskLayer!.convertTime(CACurrentMediaTime(), from:nil) - gradientPauseTime!</p>
<p>​    }</p>
<p>​    </p>
<p>​    @objc public func labelWasTapped(_ recognizer: UIGestureRecognizer) {</p>
<p>​        if labelShouldScroll() &amp;&amp; !awayFromHome {</p>
<p>​            updateAndScroll()</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Called when the label animation is about to begin.</p>
<p>​     </p>
<p>​     The default implementation of this method does nothing. Subclasses may override this method in order to perform any custom actions just as</p>
<p>​     the label animation begins. This is only called in the event that the conditions for scrolling to begin are met.</p>
<p>​     */</p>
<p>​    open func labelWillBeginScroll() {</p>
<p>​        // Default implementation does nothing - override to customize</p>
<p>​        return</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     Called when the label animation has finished, and the label is at the home position.</p>
<p>​     </p>
<p>​     The default implementation of this method does nothing. Subclasses may override this method in order to perform any custom actions jas as</p>
<p>​     the label animation completes, and before the next animation would begin (assuming the scroll conditions are met).</p>
<p>​     </p>
<p>​     - Parameter finished: A Boolean that indicates whether or not the scroll animation actually finished before the completion handler was called.</p>
<p>​     </p>
<p>​     - Warning: This method will be called, and the <code>finished</code> parameter will be <code>NO</code>, when any property changes are made that would cause the label</p>
<p>​     scrolling to be automatically reset. This includes changes to label text and font/font size changes.</p>
<p>​     */</p>
<p>​    open func labelReturnedToHome(_ finished: Bool) {</p>
<p>​        // Default implementation does nothing - override to customize</p>
<p>​        return</p>
<p>​    }</p>
<p>​    </p>
<p>​    //</p>
<p>​    // MARK: - Modified UILabel Functions/Getters/Setters</p>
<p>​    //</p>
<p>​    </p>
<p>​    #if os(iOS)</p>
<p>​    override open func forBaselineLayout() -&gt; UIView {</p>
<p>​        // Use subLabel view for handling baseline layouts</p>
<p>​        return sublabel</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var forLastBaselineLayout: UIView {</p>
<p>​        // Use subLabel view for handling baseline layouts</p>
<p>​        return sublabel</p>
<p>​    }</p>
<p>​    #endif</p>
<p>​    override open var text: String? {</p>
<p>​        get {</p>
<p>​            return sublabel.text</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            if sublabel.text == newValue {</p>
<p>​                return</p>
<p>​            }</p>
<p>​            sublabel.text = newValue</p>
<p>​            updateAndScroll()</p>
<p>​            super.text = text</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var attributedText: NSAttributedString? {</p>
<p>​        get {</p>
<p>​            return sublabel.attributedText</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            if sublabel.attributedText == newValue {</p>
<p>​                return</p>
<p>​            }</p>
<p>​            sublabel.attributedText = newValue</p>
<p>​            updateAndScroll()</p>
<p>​            super.attributedText = attributedText</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var font: UIFont! {</p>
<p>​        get {</p>
<p>​            return sublabel.font</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            if sublabel.font == newValue {</p>
<p>​                return</p>
<p>​            }</p>
<p>​            sublabel.font = newValue</p>
<p>​            super.font = newValue</p>
<p>​            </p>
<p>​            updateAndScroll()</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var textColor: UIColor! {</p>
<p>​        get {</p>
<p>​            return sublabel.textColor</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            sublabel.textColor = newValue</p>
<p>​            super.textColor = newValue</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var backgroundColor: UIColor? {</p>
<p>​        get {</p>
<p>​            return sublabel.backgroundColor</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            sublabel.backgroundColor = newValue</p>
<p>​            super.backgroundColor = newValue</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var shadowColor: UIColor? {</p>
<p>​        get {</p>
<p>​            return sublabel.shadowColor</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            sublabel.shadowColor = newValue</p>
<p>​            super.shadowColor = newValue</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var shadowOffset: CGSize {</p>
<p>​        get {</p>
<p>​            return sublabel.shadowOffset</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            sublabel.shadowOffset = newValue</p>
<p>​            super.shadowOffset = newValue</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var highlightedTextColor: UIColor? {</p>
<p>​        get {</p>
<p>​            return sublabel.highlightedTextColor</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            sublabel.highlightedTextColor = newValue</p>
<p>​            super.highlightedTextColor = newValue</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var isHighlighted: Bool {</p>
<p>​        get {</p>
<p>​            return sublabel.isHighlighted</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            sublabel.isHighlighted = newValue</p>
<p>​            super.isHighlighted = newValue</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var isEnabled: Bool {</p>
<p>​        get {</p>
<p>​            return sublabel.isEnabled</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            sublabel.isEnabled = newValue</p>
<p>​            super.isEnabled = newValue</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var numberOfLines: Int {</p>
<p>​        get {</p>
<p>​            return super.numberOfLines</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            // By the nature of MarqueeLabel, this is 1</p>
<p>​            super.numberOfLines = 1</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var adjustsFontSizeToFitWidth: Bool {</p>
<p>​        get {</p>
<p>​            return super.adjustsFontSizeToFitWidth</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            // By the nature of MarqueeLabel, this is false</p>
<p>​            super.adjustsFontSizeToFitWidth = false</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var minimumScaleFactor: CGFloat {</p>
<p>​        get {</p>
<p>​            return super.minimumScaleFactor</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            super.minimumScaleFactor = 0.0</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var baselineAdjustment: UIBaselineAdjustment {</p>
<p>​        get {</p>
<p>​            return sublabel.baselineAdjustment</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            sublabel.baselineAdjustment = newValue</p>
<p>​            super.baselineAdjustment = newValue</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var intrinsicContentSize: CGSize {</p>
<p>​        var content = sublabel.intrinsicContentSize</p>
<p>​        content.width += leadingBuffer</p>
<p>​        return content</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var tintColor: UIColor! {</p>
<p>​        get {</p>
<p>​            return sublabel.tintColor</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            sublabel.tintColor = newValue</p>
<p>​            super.tintColor = newValue</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open func tintColorDidChange() {</p>
<p>​        super.tintColorDidChange()</p>
<p>​        sublabel.tintColorDidChange()</p>
<p>​    }</p>
<p>​    </p>
<p>​    override open var contentMode: UIViewContentMode {</p>
<p>​        get {</p>
<p>​            return sublabel.contentMode</p>
<p>​        }</p>
<p>​        </p>
<p>​        set {</p>
<p>​            super.contentMode = contentMode</p>
<p>​            sublabel.contentMode = newValue</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    open override var isAccessibilityElement: Bool {</p>
<p>​        didSet {</p>
<p>​            sublabel.isAccessibilityElement = self.isAccessibilityElement</p>
<p>​        }</p>
<p>​    }</p>
<p>​    //</p>
<p>​    // MARK: - Support</p>
<p>​    //</p>
<p>​    </p>
<p>​    fileprivate func offsetCGPoint(_ point: CGPoint, offset: CGFloat) -&gt; CGPoint {</p>
<p>​        return CGPoint(x: point.x + offset, y: point.y)</p>
<p>​    }</p>
<p>​    </p>
<p>​    //</p>
<p>​    // MARK: - Deinit</p>
<p>​    //</p>
<p>​    </p>
<p>​    deinit {</p>
<p>​        NotificationCenter.default.removeObserver(self)</p>
<p>​    }</p>
<p>​    </p>
<p>}</p>
<p>//</p>
<p>// MARK: - Support</p>
<p>//</p>
<p>public protocol MarqueeStep {</p>
<p>​    var timeStep: CGFloat { get }</p>
<p>​    var timingFunction: UIViewAnimationCurve { get }</p>
<p>​    var edgeFades: EdgeFade { get }</p>
<p>}</p>
<p>/**</p>
<p> <code>ScrollStep</code> types define the label position at a specified time delta since the last <code>ScrollStep</code> step, as well as</p>
<p> the animation curve to that position and edge fade state at the position</p>
<p> */</p>
<p>public struct ScrollStep: MarqueeStep {</p>
<p>​    /**</p>
<p>​     An enum that provides the possible positions defined by a ScrollStep</p>
<p>​     - <code>home</code>: The starting, default position of the label</p>
<p>​     - <code>away</code>: The calculated position that results in the entirety of the label scrolling past.</p>
<p>​     - <code>partial(CGFloat)</code>: A fractional value, specified by the associated CGFloat value, between the <code>home</code> and <code>away</code> positions (must be between 0.0 and 1.0).</p>
<p>​     </p>
<p>​     The <code>away</code> position depends on the MarqueeLabel <code>type</code> value.</p>
<p>​     - For <code>left</code>, <code>leftRight</code>, <code>right</code>, and <code>rightLeft</code> types, the <code>away</code> position means the trailing edge of the label</p>
<p>​        is visible. For <code>leftRight</code> and <code>rightLeft</code> default types, the scroll animation reverses direction after reaching</p>
<p>​        this point and returns to the <code>home</code> position.</p>
<p>​     - For <code>continuous</code> and <code>continuousReverse</code> types, the <code>away</code> position is the location such that if the scroll is completed</p>
<p>​        at this point (i.e. the animation is removed), there will be no visible change in the label appearance.</p>
<p>​     */</p>
<p>​    public enum Position {</p>
<p>​        case home</p>
<p>​        case away</p>
<p>​        case partial(CGFloat)</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     The desired time between this step and the previous <code>ScrollStep</code> in a sequence.</p>
<p>​    */</p>
<p>​    public let timeStep: CGFloat</p>
<p>​    </p>
<p>​    /**</p>
<p>​     The animation curve to utilize between the previous <code>ScrollStep</code> in a sequence and this step.</p>
<p>​     </p>
<p>​     - Note: The animation curve value for the first <code>ScrollStep</code> in a sequence has no effect.</p>
<p>​     */</p>
<p>​    public let timingFunction: UIViewAnimationCurve</p>
<p>​    </p>
<p>​    /**</p>
<p>​     The position of the label for this scroll step.</p>
<p>​     - SeeAlso: Position</p>
<p>​     */</p>
<p>​    public let position: Position</p>
<p>​    </p>
<p>​    /**</p>
<p>​     The option set defining the edge fade state for this scroll step.</p>
<p>​     </p>
<p>​     Possible options include <code>.leading</code> and <code>.trailing</code>, corresponding to the leading edge of the label scrolling (i.e. </p>
<p>​     the direction of scroll) and trailing edge of the label.</p>
<p>​    */</p>
<p>​    public let edgeFades: EdgeFade</p>
<p>​    </p>
<p>​    public init(timeStep: CGFloat, timingFunction: UIViewAnimationCurve = .linear, position: Position, edgeFades: EdgeFade) {</p>
<p>​        self.timeStep = timeStep</p>
<p>​        self.position = position</p>
<p>​        self.edgeFades = edgeFades</p>
<p>​        self.timingFunction = timingFunction</p>
<p>​    }</p>
<p>}</p>
<p>/**</p>
<p> <code>FadeStep</code> types allow additional edge fade state definitions, around the states defined by the <code>ScrollStep</code> steps of</p>
<p> a sequence. <code>FadeStep</code> steps are defined by the time delta to the preceding or subsequent <code>ScrollStep</code> step and the timing</p>
<p> function to their edge fade state.</p>
<ul>
<li><p>Note: A <code>FadeStep</code> cannot be the first step in a sequence. A <code>FadeStep</code> defined as such will be ignored.</p>
<p>*/</p>
</li>
</ul>
<p>public struct FadeStep: MarqueeStep {</p>
<p>​    /**</p>
<p>​     The desired time between this <code>FadeStep</code> and the preceding or subsequent <code>ScrollStep</code> in a sequence.</p>
<p>​     </p>
<p>​     <code>FadeSteps</code> with a negative <code>timeStep</code> value will be associated <em>only</em> with an immediately-subsequent <code>ScrollStep</code> step</p>
<p>​     in the sequence.</p>
<p>​     </p>
<p>​     <code>FadeSteps</code> with a positive <code>timeStep</code> value will be associated <em>only</em> with an immediately-prior <code>ScrollStep</code> step in the</p>
<p>​     sequence.</p>
<p>​     </p>
<p>​     - Note: A <code>FadeStep</code> with a <code>timeStep</code> value of 0.0 will have no effect, and is the same as defining the fade state with</p>
<p>​     a <code>ScrollStep</code>.</p>
<p>​     */</p>
<p>​    public let timeStep: CGFloat</p>
<p>​    </p>
<p>​    /**</p>
<p>​     The animation curve to utilize between the previous fade state in a sequence and this step.</p>
<p>​     */</p>
<p>​    public let timingFunction: UIViewAnimationCurve</p>
<p>​    </p>
<p>​    /**</p>
<p>​     The option set defining the edge fade state for this fade step.</p>
<p>​     </p>
<p>​     Possible options include <code>.leading</code> and <code>.trailing</code>, corresponding to the leading edge of the label scrolling (i.e.</p>
<p>​     the direction of scroll) and trailing edge of the label.</p>
<p>​     </p>
<p>​     As an Option Set type, both edge fade states may be defined using an array literal: <code>[.leading, .trailing]</code>.</p>
<p>​     */</p>
<p>​    public let edgeFades: EdgeFade</p>
<p>​    </p>
<p>​    public init(timeStep: CGFloat, timingFunction: UIViewAnimationCurve = .linear, edgeFades: EdgeFade) {</p>
<p>​        self.timeStep = timeStep</p>
<p>​        self.timingFunction = timingFunction</p>
<p>​        self.edgeFades = edgeFades</p>
<p>​    }</p>
<p>}</p>
<p>public struct EdgeFade : OptionSet {</p>
<p>​    public let rawValue: Int</p>
<p>​    public static let leading  = EdgeFade(rawValue: 1 &lt;&lt; 0)</p>
<p>​    public static let trailing = EdgeFade(rawValue: 1 &lt;&lt; 1)</p>
<p>​    </p>
<p>​    public init(rawValue: Int) {</p>
<p>​        self.rawValue = rawValue;</p>
<p>​    }</p>
<p>}</p>
<p>// Define helpful typealiases</p>
<p>fileprivate typealias MLAnimationCompletionBlock = (_ finished: Bool) -&gt; ()</p>
<p>fileprivate typealias MLAnimation = (anim: CAKeyframeAnimation, duration: CGFloat)</p>
<p>fileprivate class GradientSetupAnimation: CABasicAnimation {</p>
<p>}</p>
<p>fileprivate extension UIResponder {</p>
<p>​    // Thanks to Phil M</p>
<p>​    // <a href="http://stackoverflow.com/questions/1340434/get-to-uiviewcontroller-from-uiview-on-iphone" target="_blank" rel="noopener">http://stackoverflow.com/questions/1340434/get-to-uiviewcontroller-from-uiview-on-iphone</a></p>
<p>​    </p>
<p>​    func firstAvailableViewController() -&gt; UIViewController? {</p>
<p>​        // convenience function for casting and to “mask” the recursive function</p>
<p>​        return self.traverseResponderChainForFirstViewController()</p>
<p>​    }</p>
<p>​    </p>
<p>​    func traverseResponderChainForFirstViewController() -&gt; UIViewController? {</p>
<p>​        if let nextResponder = self.next {</p>
<p>​            if nextResponder is UIViewController {</p>
<p>​                return nextResponder as? UIViewController</p>
<p>​            } else if nextResponder is UIView {</p>
<p>​                return nextResponder.traverseResponderChainForFirstViewController()</p>
<p>​            } else {</p>
<p>​                return nil</p>
<p>​            }</p>
<p>​        }</p>
<p>​        return nil</p>
<p>​    }</p>
<p>}</p>
<p>fileprivate extension CAMediaTimingFunction {</p>
<p>​    </p>
<p>​    func durationPercentageForPositionPercentage(_ positionPercentage: CGFloat, duration: CGFloat) -&gt; CGFloat {</p>
<p>​        // Finds the animation duration percentage that corresponds with the given animation “position” percentage.</p>
<p>​        // Utilizes Newton’s Method to solve for the parametric Bezier curve that is used by CAMediaAnimation.</p>
<p>​        </p>
<p>​        let controlPoints = self.controlPoints()</p>
<p>​        let epsilon: CGFloat = 1.0 / (100.0 * CGFloat(duration))</p>
<p>​        </p>
<p>​        // Find the t value that gives the position percentage we want</p>
<p>​        let t_found = solveTforY(positionPercentage, epsilon: epsilon, controlPoints: controlPoints)</p>
<p>​        </p>
<p>​        // With that t, find the corresponding animation percentage</p>
<p>​        let durationPercentage = XforCurveAt(t_found, controlPoints: controlPoints)</p>
<p>​        </p>
<p>​        return durationPercentage</p>
<p>​    }</p>
<p>​    </p>
<p>​    func solveTforY(_ y_0: CGFloat, epsilon: CGFloat, controlPoints: [CGPoint]) -&gt; CGFloat {</p>
<p>​        // Use Newton’s Method: <a href="http://en.wikipedia.org/wiki/Newton&#39;s_method" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Newton&#39;s_method</a></p>
<p>​        // For first guess, use t = y (i.e. if curve were linear)</p>
<p>​        var t0 = y_0</p>
<p>​        var t1 = y_0</p>
<p>​        var f0, df0: CGFloat</p>
<p>​        </p>
<p>​        for _ in 0..&lt;15 {</p>
<p>​            // Base this iteration of t1 calculated from last iteration</p>
<p>​            t0 = t1</p>
<p>​            // Calculate f(t0)</p>
<p>​            f0 = YforCurveAt(t0, controlPoints:controlPoints) - y_0</p>
<p>​            // Check if this is close (enough)</p>
<p>​            if (fabs(f0) &lt; epsilon) {</p>
<p>​                // Done!</p>
<p>​                return t0</p>
<p>​            }</p>
<p>​            // Else continue Newton’s Method</p>
<p>​            df0 = derivativeCurveYValueAt(t0, controlPoints:controlPoints)</p>
<p>​            // Check if derivative is small or zero ( <a href="http://en.wikipedia.org/wiki/Newton&#39;s_method#Failure_analysis" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Newton&#39;s_method#Failure_analysis</a> )</p>
<p>​            if (fabs(df0) &lt; 1e-6) {</p>
<p>​                break</p>
<p>​            }</p>
<p>​            // Else recalculate t1</p>
<p>​            t1 = t0 - f0/df0</p>
<p>​        }</p>
<p>​        </p>
<p>​        // Give up - shouldn’t ever get here…I hope</p>
<p>​        print(“MarqueeLabel: Failed to find t for Y input!”)</p>
<p>​        return t0</p>
<p>​    }</p>
<p>​    </p>
<p>​    func YforCurveAt(_ t: CGFloat, controlPoints:[CGPoint]) -&gt; CGFloat {</p>
<p>​        let P0 = controlPoints[0]</p>
<p>​        let P1 = controlPoints[1]</p>
<p>​        let P2 = controlPoints[2]</p>
<p>​        let P3 = controlPoints[3]</p>
<p>​        </p>
<p>​        // Per <a href="http://en.wikipedia.org/wiki/Bezier_curve#Cubic_B.C3.A9zier_curves" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Bezier_curve#Cubic_B.C3.A9zier_curves</a></p>
<p>​        let y0 = (pow((1.0 - t),3.0) * P0.y)</p>
<p>​        let y1 = (3.0 <em> pow(1.0 - t, 2.0) </em> t * P1.y)</p>
<p>​        let y2 = (3.0 <em> (1.0 - t) </em> pow(t, 2.0) * P2.y)</p>
<p>​        let y3 = (pow(t, 3.0) * P3.y)</p>
<p>​        </p>
<p>​        return y0 + y1 + y2 + y3</p>
<p>​    }</p>
<p>​    </p>
<p>​    func XforCurveAt(_ t: CGFloat, controlPoints: [CGPoint]) -&gt; CGFloat {</p>
<p>​        let P0 = controlPoints[0]</p>
<p>​        let P1 = controlPoints[1]</p>
<p>​        let P2 = controlPoints[2]</p>
<p>​        let P3 = controlPoints[3]</p>
<p>​        </p>
<p>​        // Per <a href="http://en.wikipedia.org/wiki/Bezier_curve#Cubic_B.C3.A9zier_curves" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Bezier_curve#Cubic_B.C3.A9zier_curves</a></p>
<p>​        </p>
<p>​        let x0 = (pow((1.0 - t),3.0) * P0.x)</p>
<p>​        let x1 = (3.0 <em> pow(1.0 - t, 2.0) </em> t * P1.x)</p>
<p>​        let x2 = (3.0 <em> (1.0 - t) </em> pow(t, 2.0) * P2.x)</p>
<p>​        let x3 = (pow(t, 3.0) * P3.x)</p>
<p>​        </p>
<p>​        return x0 + x1 + x2 + x3</p>
<p>​    }</p>
<p>​    </p>
<p>​    func derivativeCurveYValueAt(_ t: CGFloat, controlPoints: [CGPoint]) -&gt; CGFloat {</p>
<p>​        let P0 = controlPoints[0]</p>
<p>​        let P1 = controlPoints[1]</p>
<p>​        let P2 = controlPoints[2]</p>
<p>​        let P3 = controlPoints[3]</p>
<p>​        </p>
<p>​        let dy0 = (P0.y + 3.0 <em> P1.y + 3.0 </em> P2.y - P3.y) * -3.0</p>
<p>​        let dy1 = t <em> (6.0 </em> P0.y + 6.0 * P2.y)</p>
<p>​        let dy2 = (-3.0 <em> P0.y + 3.0 </em> P1.y)</p>
<p>​        return dy0 * pow(t, 2.0) + dy1 + dy2</p>
<p>​    }</p>
<p>​    </p>
<p>​    func controlPoints() -&gt; [CGPoint] {</p>
<p>​        // Create point array to point to</p>
<p>​        var point: [Float] = [0.0, 0.0]</p>
<p>​        var pointArray = <a href="">CGPoint</a></p>
<p>​        for i in 0…3 {</p>
<p>​            self.getControlPoint(at: i, values: &amp;point)</p>
<p>​            pointArray.append(CGPoint(x: CGFloat(point[0]), y: CGFloat(point[1])))</p>
<p>​        }</p>
<p>​        </p>
<p>​        return pointArray</p>
<p>​    }</p>
<p>}</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[应用程序启动时所有方法的调用顺序分析]]></title>
      <url>/2018/04/19/%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%97%B6%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="对应用程序启动时所有方法的调用顺序分析"><a href="#对应用程序启动时所有方法的调用顺序分析" class="headerlink" title="对应用程序启动时所有方法的调用顺序分析"></a><a href="http://www.cnblogs.com/dsxniubility/p/4322525.html" target="_blank" rel="noopener">对应用程序启动时所有方法的调用顺序分析</a></h1><p>一个应用程序的启动过程要包括代理的创建，控制器的加载和控制器view的加载，这其中有很多关于生命周期的方法，每个方法都是有先后顺序的，如果调用顺序拿不准，或者某段代码写的方法不恰当，就会遇到各种奇葩问题。本文不怕麻烦的在几乎所有启动时要调用的方法里都用了 <strong>FUNCTION</strong> 打印。结果还有有些地方出人意料的</p>
<p>如果你不是在董铂然博客园看到本文，<a href="http://www.cnblogs.com/dsxniubility/p/4322525.html" target="_blank" rel="noopener">请点击查看原文</a></p>
<h2 id="首先回顾一下应用程序的启动过程"><a href="#首先回顾一下应用程序的启动过程" class="headerlink" title="首先回顾一下应用程序的启动过程"></a>首先回顾一下应用程序的启动过程</h2><p>①.先加载Main函数</p>
<p>②.在Main函数里的 UIApplicationMain方法中，创建Application对象 创建Application的Delegate对象</p>
<p>③.创建主循环，代理对象开始监听事件</p>
<p>④.启动完毕会调用 didFinishLaunching方法，并在这个方法中创建UIWindow</p>
<p>⑤.设置UIWindow的根控制器是谁</p>
<p>⑥.如果有storyboard，会根据info.plist中找到应用程序的入口storyboard并加载箭头所指的控制器</p>
<p>⑦.显示窗口</p>
 <a id="more"></a>
<p>本文考虑的时步骤③之后到步骤⑦结束时将要调用的方法</p>
<p>其中有AppDelegate,ViewController,MainView（控制器的View）,ChildView（子控件的View）的18个方法</p>
<p><strong>AppDelegate中的：</strong></p>
<p><strong>1.application:didFinishLaunchingWithOptions:</strong></p>
<p><strong>2.applicationDidBecomeActive:</strong></p>
<p><strong>ViewController中的：</strong></p>
<p><strong>3.loadView</strong></p>
<p><strong>4.viewDidLoad</strong></p>
<p><strong>5.load</strong></p>
<p><strong>6.initialize</strong></p>
<p><strong>7.viewWillAppear</strong></p>
<p><strong>8.viewWillLayoutSubviews</strong></p>
<p><strong>9.viewDidLayoutSubviews</strong></p>
<p><strong>10.viewDidAppear</strong></p>
<p><strong>MainView（控制器的View）中的：</strong></p>
<p><strong>11.initWithCoder（如果没有storyboard就会调用initWithFrame，这里两种方法视为一种）</strong></p>
<p><strong>12.awakeFromNib</strong></p>
<p><strong>13.layoutSubviews</strong></p>
<p><strong>14.drawRect</strong></p>
<p><strong>ChildView（子控件View）中的：</strong></p>
<p><strong>15.initWithCoder（如果没有storyboard就会调用initWithFrame，这里两种方法视为一种）</strong></p>
<p><strong>16.awakeFromNib</strong></p>
<p><strong>17.layoutSubviews</strong></p>
<p><strong>18.drawRect</strong></p>
<hr>
<p><strong>那么问题来了，不往下看你可以把上面的十八个方法排个顺序么？</strong></p>
<p><strong><img src="https://images0.cnblogs.com/blog2015/717809/201503/082258059303957.png" alt="img"></strong></p>
<p>下面的图是Xcode6.3的beta2版  </p>
<p>有时有变化也就是最后两个方法有点出入</p>
<p><strong><img src="https://images0.cnblogs.com/blog2015/717809/201503/082248533203331.png" alt="img"></strong></p>
<h2 id="我更倾向于Xcode-6-1-觉得更科学-下面就是对各个方法的整理"><a href="#我更倾向于Xcode-6-1-觉得更科学-下面就是对各个方法的整理" class="headerlink" title="我更倾向于Xcode 6.1 觉得更科学 下面就是对各个方法的整理"></a>我更倾向于Xcode 6.1 觉得更科学 下面就是对各个方法的整理</h2><p> 1.这是应用程序启动就会调用的方法，在这个方法里写的代码最先调用(董铂然原创)</p>
<p> 2.这个是需要用到本类时才调用，这个方法里一般写 设置导航控制器的主题啊 之类的，如果在后面的方法设置导航栏主题就晚了！（当然在上面的方法里也能写）</p>
<p>3.这个方法里面会创建UIWindow，设置根控制器并展现，比如某些应用程序要加载授权页面也是在这加，也可以设置观察者，监听到通知切换根控制器</p>
<p>4.这里反正我是万万没想到，childView的initwithcoder会在MainView的方法之前调用，父的都还没出来，就先整子控件？ 有了解比较透彻的博友恳请告诉我谢谢。</p>
<p>5.就是关于应用程序的数据存储后的解档操作。</p>
<p>6.在这个方法里设置view的背景等一系列普通操作，不要写关于frame的还不准，在使用IB的时候才会涉及到此方法的使用，当.nib文件被加载的时候，会发送一个awakeFromNib的消息到.nib文件中的每个对象，每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。 </p>
<p>7.子控件也有本方法，重写父类的方法。基本用法同上 </p>
<p> 8.创建视图的层次结构，这里需要注意，在没有创建控制器的view的情况下不能直接写 self.view 因为self.view的底层是：</p>
<p>if（_view == nil）{</p>
<p>　　_view = [self loadView]</p>
<p>}</p>
<p>所以这么写会直接造成死循环。</p>
<p>如果重写这个loadView方法里面什么都不写，会显示黑屏。</p>
<p>如果写了[super view]还要看前面的控制器在创建时是写的initWithNibName（指定了xib名字），还是写的普通的init。 如果是后者还是黑屏。</p>
<p>如果不在这个方法中，init的底层是会调用initWithNibName的，如果名字是MainViewController，会先在项目中找MainView.xib 找不到会再找MainViewController.xib。 </p>
<p>9.卧槽，这个方法是当年用的最多的方法，但是在之后的开发中就会发现越来越不靠谱，很多东西都还没加载完毕，各种取值都不准确，很少在这里面写东西了。 这里只是把视图元件加载完成，还没有开始布局不要设置关于 frame 之类的属性！有时可能会出现差20个像素点等状况。</p>
<p>10.视图将要出现，这个方法用的非常多，比如如果要设置导航栏的setNavigationBarHiden:animate: 就必须要在这里写，才能完美契合，不卡跳。 还有很多比如监听屏幕旋转啦，</p>
<p>viewWillTransitionToSize:可能要在本方法里再调一次，或者就是新到这个界面要reloadData或是自动下拉刷新等 都是写在本方法里。</p>
<p>11.视图将要布局子视图，苹果建议的设置界面布局属性的方法，这个方法和viewWillAppear里，系统的底层都是没有写任何代码的，也就是说这里面不写super 也是可以的</p>
<p>12.在这个方法里一般设置子控件的frame，因为这里相当于是布局基本完成了，设置时取到的frame或者是self.bounds才最准，如果在awakeFromeNib里写会不准确 。还有这里要切记千万不能把super layoutSubviews忘了，可能最后都很难找到这个bug</p>
<p>13.这个方法我也是玩玩没想到，控制器的view的子控件还没有布局好呢，怎么这个控制器就已经说布局全部完成了？那后边的布局就不等了？ 有独到见解的也恳请你告诉我，这其中苹果的意思到底是什么。 </p>
<p>14.控制器的子控件里的子控件的布局就在这里写了。 </p>
<p>\15. 因为默认所有额UI控件都是画上去的，在这一步就是把所有的东西画上去，有时候需要用到Quartz2D的知识的时候都是在这个方法里话，但也是要注意别忘了写super，不然系统原本的东西就都画不上来了，这里要建议尽可能使用贝塞尔路径画图形，因为系统默认的那个上下文画法有时可能会内存泄露。drawRect方法只能在加载时调用一次，如果后面还需要调用，比如下载进度的圆弧，需要一直刷帧，就要使用setNeedsDisplay来定时多次调用本方法</p>
<p>16.view的子控件内部的画图方法，有时可以自己自定义label 中间带个删除线的（用来写打折前的原价） 就是在这里画根线 。</p>
<p>17.把上面的画图都画完了，这里就会显示，视图完全加载完成。在这里的操作可能就是设置页面的一些动画,或者是设置tableView，collectionView，QQ聊天页面啥的滚动到底部scrollToIndexPath之类的代码操作。</p>
<p> 18.最后这是AppDelegate的应用程序获取焦点方法，真正到了这里，才是所有东西全部加载完毕，应用程序整装待发保持最佳状态等待用户操作。这个方法中一般会写关于弹出键盘的方法，比如有的用户登录界面为了更好的用户体验，就让你在刚打开程序来到登录界面的时候，光标的焦点就自动在账号的文本框里闪烁，也就是设置账号文本框为第一响应者。键盘在页面加载完毕后从下方弹出，这种代码一般就在本方法写。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[IB可视化属性调节视图-@IBDesignable/@IBInspectable的使用]]></title>
      <url>/2018/04/19/Swift%E4%B8%AD@IBDesignable:@IBInspectable%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>##IB可视化属性调节视图-@IBDesignable/@IBInspectable的使用**</p>
<p>@IBDesignable //要使用这个才可以直接在在IB中设置属性 相当于OC中的IB_DESIGNABLE(宏)</p>
<p>示例代码如下：</p>
<blockquote>
<p>class TXView: UIView {<br>@IBInspectable var cornerRadius:CGFloat = 0.0{     //前面的为属性名字 初始值<br>didSet{              //【需要学习:属性监控器willset监控属性改变值之前做点什么，didSet监控改变后做些什么，通常直接跟在属性后 详情学习：           学习参考：<a href="http://www.hangge.com/blog/cache/detail_519.html】" target="_blank" rel="noopener">http://www.hangge.com/blog/cache/detail_519.html】</a><br>layer.cornerRadius=cornerRadius //设置属性 【？？layar干嘛的】<br>layer.masksToBounds = true//允许剪切<br>}<br>}<br>//边框颜色<br>@IBInspectable var borderColor:UIColor=UIColor(){<br>didSet{<br>layer.borderColor = borderColor.CGColor<br>}<br>}<br>//设置边框宽度<br>@IBInspectable var borderWidth:CGFloat=0.0{<br>didSet{<br>layer.borderWidth = borderWidth<br>}<br>}</p>
<p>\1. 怎样将矩形按钮控件变成圆型<br>\2. 将属性设置为为可视化改变，并且可以实时查看。<br>\3. willSet与didSet的作用。<br>\4. 提示：很多OC中的代码（如某些宏的定义）在swift中用@前缀使用</p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[利用sort方法对对象数组按照对象属性进行排序**]]></title>
      <url>/2018/04/18/%E5%88%A9%E7%94%A8sort%E6%96%B9%E6%B3%95%E5%AF%B9%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%8C%89%E7%85%A7%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>var userList = <a href="">UserInfo</a><br>userList.append(UserInfo(name: “张三”, phone: “4234”))<br>userList.append(UserInfo(name: “李四”, phone: “1212”))<br>userList.append(UserInfo(name: “航歌”, phone: “3525”))</p>
<p>let addressBkeys  = addressBookDict.sorted(by: { (t1, t2) -&gt; Bool in<br>return t1.0 &lt; t2.0 ? true:false<br>})</p>
<p>t1.0 = userList.name<br>t1.1 = userList.phone</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[下载功能测试]]></title>
      <url>/2018/04/16/%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p> <a href="/download/xx.xls&quot;">点击下载</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS被遗忘的近距离通讯利器-MultipeerConnectivity]]></title>
      <url>/2018/04/13/iOS%E8%A2%AB%E9%81%97%E5%BF%98%E7%9A%84%E8%BF%91%E8%B7%9D%E7%A6%BB%E9%80%9A%E8%AE%AF%E5%88%A9%E5%99%A8-MultipeerConnectivity/</url>
      <content type="html"><![CDATA[<p> 转<a href="https://www.jianshu.com/p/662dd49d82b6" target="_blank" rel="noopener">https://www.jianshu.com/p/662dd49d82b6</a></p>
<p><a href="https://www.jianshu.com/u/57d9688d4e1f" target="_blank" rel="noopener">卖报的小画家Sure</a></p>
<p><strong>Multipeer connectivity</strong>是一个使附近设备通过Wi-Fi网络、P2P Wi-Fi以及蓝牙个人局域网进行通信的框架。互相链接的节点可以安全地传递信息、流或是其他文件资源。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1767950-75b223abb22710e6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="img"></p>
<p>图片发自简书App</p>
<p>废话少说，我们来集成MultipeerConnectivity的功能。<br>首先引入系统框架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;MultipeerConnectivity/MultipeerConnectivity.h&gt;</span><br></pre></td></tr></table></figure>
<p>依次声明如下属性，这里都给予了详细的备注，就不赘述了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  表示为一个用户，亦可认为是当前设备</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic,strong)MCPeerID * peerID;</span><br><span class="line">/**</span><br><span class="line"> *  数据流，启用和管理Multipeer连接会话中的所有人之间的沟通。 通过Sesion，给别人发送数据。类似于Scoket</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic,strong)MCSession * session;</span><br><span class="line">/**</span><br><span class="line"> *  可以接收，并处理用户请求连接的响应。没有回调，会弹出默认的提示框，并处理连接。</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic,strong)MCAdvertiserAssistant * advertiser;</span><br><span class="line">/**</span><br><span class="line"> *  用于搜索附近的用户，并可以对搜索到的用户发出邀请加入某个会话中。</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic,strong)MCNearbyServiceBrowser * brower;</span><br><span class="line">/**</span><br><span class="line"> *  附近用户列表</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic,strong)MCBrowserViewController * browserViewController;</span><br><span class="line">/**</span><br><span class="line"> *  存储连接</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic,strong)NSMutableArray * sessionArray;</span><br></pre></td></tr></table></figure>
<p>接下来我们将当前设备初始化，并开启附近用户搜索等功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  连接设置</span><br><span class="line"> */</span><br><span class="line">- (void)createMC&#123;</span><br><span class="line">    //获取设备名称</span><br><span class="line">    NSString * name = [UIDevice currentDevice].name;</span><br><span class="line">    //用户</span><br><span class="line">    _peerID = [[MCPeerID alloc]initWithDisplayName:name];</span><br><span class="line">    //为用户建立连接</span><br><span class="line">    _session = [[MCSession alloc]initWithPeer:_peerID];</span><br><span class="line">    //设置代理</span><br><span class="line">    _session.delegate = self;</span><br><span class="line">    //设置广播服务(发送方)</span><br><span class="line">    _advertiser = [[MCAdvertiserAssistant alloc]initWithServiceType:@&quot;type&quot; discoveryInfo:nil session:_session];</span><br><span class="line">    //开始广播</span><br><span class="line">    [_advertiser start];</span><br><span class="line">    //设置发现服务(接收方)</span><br><span class="line">    _brower = [[MCNearbyServiceBrowser alloc]initWithPeer:_peerID serviceType:@&quot;type&quot;];</span><br><span class="line">    //设置代理</span><br><span class="line">    _brower.delegate = self;</span><br><span class="line">    [_brower startBrowsingForPeers];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不要忘记添加其协议，如下<br><strong>MCSessionDelegate</strong>，<strong>MCBrowserViewControllerDelegate</strong>，<strong>MCNearbyServiceBrowserDelegate</strong>。<br>最后实现其对应的代理方法即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#pragma MC相关代理方法</span><br><span class="line">/**</span><br><span class="line"> *  发现附近用户</span><br><span class="line"> *</span><br><span class="line"> *  @param browser 搜索附近用户</span><br><span class="line"> *  @param peerID  附近用户</span><br><span class="line"> *  @param info    详情</span><br><span class="line"> */</span><br><span class="line">- (void)browser:(MCNearbyServiceBrowser *)browser foundPeer:(MCPeerID *)peerID withDiscoveryInfo:(NSDictionary *)info&#123;</span><br><span class="line">    NSLog(@&quot;发现附近用户%@&quot;,peerID.displayName);</span><br><span class="line">    if (_browserViewController == nil) &#123;</span><br><span class="line">        _browserViewController = [[MCBrowserViewController alloc]initWithServiceType:@&quot;type&quot; session:_session];</span><br><span class="line">        _browserViewController.delegate = self;</span><br><span class="line">        /**</span><br><span class="line">         *  跳转发现界面</span><br><span class="line">         */</span><br><span class="line">        [self presentViewController:_browserViewController animated:YES completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *  附近某个用户消失了</span><br><span class="line"> *</span><br><span class="line"> *  @param browser 搜索附近用户</span><br><span class="line"> *  @param peerID  用户</span><br><span class="line"> */</span><br><span class="line">- (void)browser:(MCNearbyServiceBrowser *)browser lostPeer:(MCPeerID *)peerID&#123;</span><br><span class="line">    NSLog(@&quot;附近用户%@离开了&quot;,peerID.displayName);</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark BrowserViewController附近用户列表视图相关代理方法</span><br><span class="line">/**</span><br><span class="line"> *  选取相应用户</span><br><span class="line"> *</span><br><span class="line"> *  @param browserViewController 用户列表</span><br><span class="line"> */</span><br><span class="line">- (void)browserViewControllerDidFinish:(MCBrowserViewController *)browserViewController&#123;</span><br><span class="line">    [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">    _browserViewController = nil;</span><br><span class="line">    //关闭广播服务，停止其他人发现</span><br><span class="line">    [_advertiser stop];</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *  用户列表关闭</span><br><span class="line"> *</span><br><span class="line"> *  @param browserViewController 用户列表</span><br><span class="line"> */</span><br><span class="line">- (void)browserViewControllerWasCancelled:(MCBrowserViewController *)browserViewController&#123;</span><br><span class="line">    [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">    _browserViewController = nil;</span><br><span class="line">    [_advertiser stop];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark MCSession代理方法</span><br><span class="line">/**</span><br><span class="line"> *  当检测到连接状态发生改变后进行存储</span><br><span class="line"> *</span><br><span class="line"> *  @param session MC流</span><br><span class="line"> *  @param peerID  用户</span><br><span class="line"> *  @param state   连接状态</span><br><span class="line"> */</span><br><span class="line">- (void)session:(MCSession *)session peer:(MCPeerID *)peerID didChangeState:(MCSessionState)state&#123;</span><br><span class="line">    //判断如果连接</span><br><span class="line">    if (state == MCSessionStateConnected) &#123;</span><br><span class="line">        //保存这个连接</span><br><span class="line">        if (![_sessionArray containsObject:session]) &#123;</span><br><span class="line">            //如果不存在 保存</span><br><span class="line">            [_sessionArray addObject:session];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *  接收到消息</span><br><span class="line"> *</span><br><span class="line"> *  @param session MC流</span><br><span class="line"> *  @param data    传入的二进制数据</span><br><span class="line"> *  @param peerID  用户</span><br><span class="line"> */</span><br><span class="line">- (void)session:(MCSession *)session didReceiveData:(NSData *)data fromPeer:(MCPeerID *)peerID&#123;</span><br><span class="line">    NSString * message = [NSString stringWithFormat:@&quot;%@:%@&quot;,peerID.displayName,[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]];</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [_dataArray addObject:message];</span><br><span class="line">        NSIndexPath * indexPath = [NSIndexPath indexPathForRow:_dataArray.count - 1 inSection:0];</span><br><span class="line">        [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop];</span><br><span class="line">        [_tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionTop animated:YES];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *  接收数据流</span><br><span class="line"> *</span><br><span class="line"> *  @param session    MC流</span><br><span class="line"> *  @param stream     数据流</span><br><span class="line"> *  @param streamName 数据流名称（标示）</span><br><span class="line"> *  @param peerID     用户</span><br><span class="line"> */</span><br><span class="line">- (void)session:(MCSession *)session didReceiveStream:(NSInputStream *)stream withName:(NSString *)streamName fromPeer:(MCPeerID *)peerID&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *  开始接收资源</span><br><span class="line"> */</span><br><span class="line">- (void)session:(MCSession *)session didStartReceivingResourceWithName:(NSString *)resourceName fromPeer:(MCPeerID *)peerID withProgress:(NSProgress *)progress&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *  资源接收结束</span><br><span class="line"> */</span><br><span class="line">- (void)session:(MCSession *)session didFinishReceivingResourceWithName:(NSString *)resourceName fromPeer:(MCPeerID *)peerID atURL:(NSURL *)localURL withError:(NSError *)error&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1767950-3497cb396e1789ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>1_发现附近设备.png</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1767950-93c379c3562fc251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>2_连接设备成功.png</p>
<p>选定后点击Done即可完成连接。<br>代理方法中具有监听附近设备，连接，接收流程等流程。<br>对于发送数据，可以简单搭建一个页面来进行。比如在textField点击Return时触发。对于发送的数据类型具有两种形式，对应的即为socket中的UDP与TCP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)textFieldShouldReturn:(UITextField *)textField&#123;</span><br><span class="line">    if (textField.text.length &gt; 0) &#123;</span><br><span class="line">        /**</span><br><span class="line">         *  两种类型</span><br><span class="line">         MCSessionSendDataUnreliable 类似于UDP连接方式</span><br><span class="line">         MCSessionSendDataReliable 类似于TCP连接方式</span><br><span class="line">         */</span><br><span class="line">        [_session sendData:[textField.text dataUsingEncoding:NSUTF8StringEncoding] toPeers:_session.connectedPeers withMode:MCSessionSendDataUnreliable error:nil];</span><br><span class="line">        //UI操作</span><br><span class="line">        [_dataArray addObject:textField.text];</span><br><span class="line">        NSIndexPath * indexPath = [NSIndexPath indexPathForRow:_dataArray.count - 1 inSection:0];</span><br><span class="line">        [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop];</span><br><span class="line">        [_tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionTop animated:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1767950-c6326bdfb121378a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>3_传输数据.jpeg</p>
<p>这里测试的话可以使用两台设备，模拟器、真机均可。当其中一个设备检测到附近设备后会弹起附近设备列表，点击选取后即可进行通讯操作。用例里模拟的是发送字符串操作，也可以替换为文件，因为都传递的为二进制嘛。相信你会察觉到其飞一样的速度的，就写到这里。</p>
<h6 id="demo下载链接"><a href="#demo下载链接" class="headerlink" title="demo下载链接"></a>demo下载链接</h6><p><a href="https://link.jianshu.com/?t=https://github.com/LSure/MultipeerConnectivityDemo" target="_blank" rel="noopener">iOS被遗忘的近距离通讯利器demo🔗</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[CoreServicesLayer]]></title>
      <url>/2018/04/13/CoreServicesLayer/</url>
      <content type="html"><![CDATA[<p><code>Gain access to fundamental iOS services with the frameworks in the Core Services layer. With these services, access files, low-level data types, Bonjour services, network sockets, and more. Use the frameworks in this layer if those in the Cocoa Touch and Media layers aren&#39;t sufficient for your needs. When you use the technologies at the Core Services layer, you&#39;ll automatically take advantage of the Core OS layer without getting into its details.</code></p>
<p>使用CoreServicesLayer下的frameworks可以帮你使用比较底层的基础iOS服务. 这些服务让你可以访问文件,低层次的数据类型,WTF? Bonjour services,网络接口等.并且能满足一些你所需要但CocoaTouchLayer和MediaLayer无法满足的需求.当你使用CoreServicesLayer中的技术时可以让你在不了解CoreOSLayer的情况下使用它们.<br>⚠️Bonjour services是什么鬼?</p>
<hr>
<a id="more"></a>
<h3 id="1Accounts"><a href="#1Accounts" class="headerlink" title="1Accounts"></a>1Accounts</h3><p><code>Manage the user&#39;s external accounts using the Accounts framework. You can also use this framework to simplify the authorization process when using external APIs, such as the Twitter API.</code><br>Accounts用于管理用户的外部账户.你还可以使用这个框架简化一些外部API使用时的授权过程,比如Twitter的API.</p>
<h3 id="2AdSupport"><a href="#2AdSupport" class="headerlink" title="2AdSupport"></a>2AdSupport</h3><p><code>Access the advertising identifier and a flag indicating whether the user has chosen to limit ad tracking.</code><br>AdSupport用于获取广告标识符,以及用于表明用户是否选择了限制广告追踪的标识.</p>
<h3 id="3AddressBook"><a href="#3AddressBook" class="headerlink" title="3AddressBook"></a>3AddressBook</h3><p><code>Use the Address Book framework to gain access to the centralized database for storing a user&#39;s contacts. The database, known as Address Book, is used by applications such as Mail and Messages to present information about known and unknown persons.</code><br>AddressBook用于获取对于保存了用户联系人的集中数据库的访问. 这个数据库(也就是AddressBook)被其他应用使用.例如邮件和信息应用根据这个数据库来显示已知或未知的联系人信息.</p>
<h3 id="4CFNetwork"><a href="#4CFNetwork" class="headerlink" title="4CFNetwork"></a>4CFNetwork</h3><p><code>Gain access to network services and handle changes in network configurations. The CFNetwork framework provides a library of abstractions for network protocols that make it easy to perform a variety of network tasks, such as working with BSD sockets, working with HTTP and FTP servers, and managing Bonjour services.</code><br>CFNetwork用于获取对网络服务的访问以及处理网络配置的改变.该库提供了一个网络协议的抽象库,从而使得操作多样的网络任务(例如使用BSD socket, 使用HTTP和FTP服务,以及管理Bonjour服务)变得简单.</p>
<h3 id="5CloudKit"><a href="#5CloudKit" class="headerlink" title="5CloudKit"></a>5CloudKit</h3><p><code>Manage the transfer of data to and from iCloud using CloudKit.</code><br>CloudKit在使用iCloud时的数据传输和使用.</p>
<h3 id="6CloudKit-JS"><a href="#6CloudKit-JS" class="headerlink" title="6CloudKit JS"></a>6CloudKit JS</h3><p><code>Access your CloudKit app’s containers and databases from your web app.</code><br>CloudKit JS可以让你的webApp访问你的CloudKit类应用的容器和数据库.</p>
<h3 id="7Contacts"><a href="#7Contacts" class="headerlink" title="7Contacts"></a>7Contacts</h3><p><code>Gain access to the centralized database for storing a user&#39;s contacts. The database is used by apps such as Mail and Messages to present information about known and unknown persons.</code><br>Contacts用于获取对于保存了用户联系人的集中数据库的访问. 这个数据库被其他应用使用.例如邮件和信息应用根据这个数据库来显示已知或未知的联系人信息.</p>
<h3 id="8CoreData"><a href="#8CoreData" class="headerlink" title="8CoreData"></a>8CoreData</h3><p><code>Create generalized and automated solutions to common tasks associated with object life-cycle and object graph management, including persistence.</code><br>CoreData用于创建并自动解决一些通用任务,通过关联对象的生命周期以及对象的状态管理,包括持久化.</p>
<h3 id="9CoreFoundation"><a href="#9CoreFoundation" class="headerlink" title="9CoreFoundation"></a>9CoreFoundation</h3><p><code>Use the Core Foundation framework for system services fundamental to all iOS applications. Core Foundation provides abstractions for common data types, it facilitates internationalization with Unicode string storage, and it offers a suite of utilities such as plug-in support, XML property lists, URL resource access, and preferences.</code><br>CoreFoundation时所有app使用的系统服务的基础框架.它提供了常见的抽象数据类型,通过Unicode字符串存储促进了国际化,并且它提供了一套实用功能,如插件支持,XML属性列表,URL资源访问和偏好。</p>
<h3 id="10CoreLocation"><a href="#10CoreLocation" class="headerlink" title="10CoreLocation"></a>10CoreLocation</h3><p><code>Determine the current latitude and longitude of a device and configure and schedule the delivery of location-related events with the Core Location framework. Core Location uses the available hardware to triangulate the user&#39;s position based on nearby signal information.</code><br>CoreLocation用于确定设备的纬度和经度,以及配置和调度一些与位置相关的事件.它使用一些可用的硬件并基于附近的信号信息来三角定位用户的位置.</p>
<h3 id="11CoreMedia"><a href="#11CoreMedia" class="headerlink" title="11CoreMedia"></a>11CoreMedia</h3><p><code>Represent time-based audio-visual assets with the essential data types in the Core Media framework.</code><br>???</p>
<h3 id="12CoreMotion"><a href="#12CoreMotion" class="headerlink" title="12CoreMotion"></a>12CoreMotion</h3><p><code>Receive and handle accelerometer and other motion events with the Core Motion framework.</code><br>CoreMotion用于接收和处理加速器及其他移动移动事件.</p>
<h3 id="13CoreSpotlight"><a href="#13CoreSpotlight" class="headerlink" title="13CoreSpotlight"></a>13CoreSpotlight</h3><p><code>Index the content in your app and enable users to deep-link to that content from Spotlight and Safari search results with the Core Spotlight framework. Core Spotlight is designed for apps that handle persistent user data, such as documents, photos, and other types of content created by or on behalf of users. Use Core Spotlight APIs to add, retrieve, update, and delete items that represent searchable app content.</code><br>???</p>
<h3 id="14CoreTelephony"><a href="#14CoreTelephony" class="headerlink" title="14CoreTelephony"></a>14CoreTelephony</h3><p><code>Gain access to cellular telephone call status and cellular service provider information with the Core Telephony framework.</code><br>CoreTelephony用于获得对电话拨打状态以及运营商信息的访问.</p>
<h3 id="15EventKit"><a href="#15EventKit" class="headerlink" title="15EventKit"></a>15EventKit</h3><p><code>Read and write calendar data with the EventKit framework.</code><br>EventKit用于读写日历数据.</p>
<h3 id="16Foundation"><a href="#16Foundation" class="headerlink" title="16Foundation"></a>16Foundation</h3><p><code>Use the Foundation framework for the &quot;nuts and bolts&quot; classes for Objective-C programming. This framework provides essential Objective-C classes, most importantly the root class, NSObject, which defines basic object behavior. It includes classes for objects representing basic data types, collections, and operating-system services. Foundation also introduces several design patterns and mechanisms that contribute to the robustness and efficiency of Objective-C programs. Along with UIKit, the Foundation framework provides the basic tools and infrastructure you need to implement graphical, event-driven iOS applications.</code><br>Foundation用于类似于”螺母与螺栓”的OC类编程.它提供了一些必不可少的OC类,最重要的是根类-NSObject. NSObject定义了基本的对象行为. 它包括表示基本数据类型的类对象,集合,和操作系统服务。它也包含了一些设计模式和机制,用于提高OC程序的健壮性和效率.Foundation和UIKit一起提供了用于实现一个图形化,事件驱动的iOS应用程序所需要的基本的工具和基础资源.</p>
<h3 id="17GameCenter"><a href="#17GameCenter" class="headerlink" title="17GameCenter"></a>17GameCenter</h3><p><code>Create social game experiences with the GameCenter framework. Add leaderboards, achievements, matchmaking, challenges and more, so that players keep coming back to your game.</code><br>GameCenter用于创建一个社交化的游戏体验.通过游戏排行榜,成就,安排比赛,挑战以及更多的方式来增加用户的粘性。</p>
<h3 id="18GameplayKit"><a href="#18GameplayKit" class="headerlink" title="18GameplayKit"></a>18GameplayKit</h3><p><code>Implement common game play behaviors using the GameplayKit framework. GameplayKit provides random number generation with characteristics that are appropriate for games and provides infrastructure for implementing behavior for entities within your game.</code><br>GameplayKit用于实现一些通用的游戏行为.提供适用于游戏特性的随机数生成以及实现实体行为的基础资源.<br><code>Tips: OC框架 前缀GK 提供能够进行点对点的网络通信的API</code></p>
<h3 id="19HealthKit"><a href="#19HealthKit" class="headerlink" title="19HealthKit"></a>19HealthKit</h3><p><code>Record and track important health information from multiple sources with the HealthKit framework.</code><br>HealthKit用于记录及追踪从多种数据源获取到的总要健康信息.</p>
<h3 id="20HomeKit"><a href="#20HomeKit" class="headerlink" title="20HomeKit"></a>20HomeKit</h3><p><code>Communicate with and control connected devices in a user’s home with the HomeKit framework. HomeKit provides seamless integration between accessories that support Apple&#39;s Home Automation Protocol and iOS devices, allowing for new advances in home automation.</code><br>HomeKit用于实现与用户家中的设备的互通及控制.提供与支持苹果家庭自动化协议设备的无缝连接,从而使更好的家庭自动化成为可能.</p>
<h3 id="21JavaScriptCore"><a href="#21JavaScriptCore" class="headerlink" title="21JavaScriptCore"></a>21JavaScriptCore</h3><p><code>Evaluate JavaScript programs from within a Swift or Objective-C app and provide support for JavaScript scripting of your app with the JavaScriptCore framework.</code><br>JavaScriptCore用于执行你的应用中的JS程序,提供了对js脚本的支持.</p>
<h3 id="22MobileCoreServices"><a href="#22MobileCoreServices" class="headerlink" title="22MobileCoreServices"></a>22MobileCoreServices</h3><p><code>Gain access to standard types and constants with the Mobile Core Services framework. Use it in conjunction with other frameworks that rely on UTI type information.</code><br>MobileCoreServices用于获取对标准类型和常量的访问.用于与其他应用使用UTI类型信息结合时.</p>
<h3 id="23MultipeerConnectivity"><a href="#23MultipeerConnectivity" class="headerlink" title="23MultipeerConnectivity"></a>23MultipeerConnectivity</h3><p><code>Support peer-to-peer connectivity and the discovery of nearby devices using the Multipeer Connectivity framework.</code><br>MultipeerConnectivity用于对点对点连接和发现附近设备提供支持.</p>
<h3 id="24NewsstandKit"><a href="#24NewsstandKit" class="headerlink" title="24NewsstandKit"></a>24NewsstandKit</h3><p><code>Download and process magazine issues or other Newsstand content using the NewsstandKit framework. You can also use this framework to manage downloaded issues.</code><br>NewsstandKit用于下载和处理杂志问题以及其他报刊内容.也可以用于管理下载问题.</p>
<h3 id="25PassKit"><a href="#25PassKit" class="headerlink" title="25PassKit"></a>25PassKit</h3><p><code>Create, distribute, and update passes with the PassKit framework. You can also use this framework to interact with the user&#39;s pass library.</code><br>PassKit用于创建,发布和更新passes. 也可以用于与用户的pass库交互. ???</p>
<h3 id="26PushKit"><a href="#26PushKit" class="headerlink" title="26PushKit"></a>26PushKit</h3><p><code>Reduce battery impact and deliver a better experience by using PushKit to register for and receive notifications for VoIP apps.</code><br>PushKit用于在注册和接收VoIP信息时,减低电量消耗及提高用户体验.</p>
<h3 id="27QuickLook"><a href="#27QuickLook" class="headerlink" title="27QuickLook"></a>27QuickLook</h3><p><code>Display view-based previews of items with the Quick Look framework.</code><br>QuickLook提供基于界面的预览功能.</p>
<h3 id="28SafariServices"><a href="#28SafariServices" class="headerlink" title="28SafariServices"></a>28SafariServices</h3><p><code>Integrate Safari behaviors into your iOS app using the Safari Services framework.</code><br>SafariServices用于集成Safari行为到你的app中.</p>
<h3 id="29Social"><a href="#29Social" class="headerlink" title="29Social"></a>29Social</h3><p><code>Send requests to a supported social networking service to perform operations on behalf of your users, integrating their social networking accounts with your app.</code><br>Social用于向支持社交网络的服务器发送用户的操作的请求,集成他们的网络账户到你的app中.</p>
<h3 id="30StoreKit"><a href="#30StoreKit" class="headerlink" title="30StoreKit"></a>30StoreKit</h3><p><code>Embed a store in your app using the StoreKit framework. Use it to process the financial transactions associated with the purchase of content and services from your application.</code><br>StoreKit用于在你的应用中嵌入商店.用它来处理一些与你应用的内容及服务相关的金融交易.</p>
<h3 id="31SystemConfiguration"><a href="#31SystemConfiguration" class="headerlink" title="31SystemConfiguration"></a>31SystemConfiguration</h3><p><code>Determine network availability and state on a device using the System Configuration framework, which declares the functions, types, and constants related to network reachability.</code><br>SystemConfiguration用于确定设备的网络是否可用及状态.它声明了一些函数,类型,以及与网络连通性相关的常量.</p>
<h3 id="32UIAutomation"><a href="#32UIAutomation" class="headerlink" title="32UIAutomation"></a>32UIAutomation</h3><p><code>Automate integration tests that drive your app&#39;s UI with the UI Automation framework.</code><br>UIAutomation用于自动集成用于应用UI测试的资源.</p>
<h3 id="33WatchConnectivity"><a href="#33WatchConnectivity" class="headerlink" title="33WatchConnectivity"></a>33WatchConnectivity</h3><p><code>Coordinate activities between your iOS app and your corresponding Watch app using the Watch Connectivity framework.</code><br>WatchConnectivity用于协调你的iOS应用与Watch应用之间的活动及交互.</p>
<h3 id="34WebKit"><a href="#34WebKit" class="headerlink" title="34WebKit"></a>34WebKit</h3><p><code>Display web content in windows and implement browser features such as following links when clicked by the user, managing a back-forward list, and managing a history of pages recently visited.</code><br>WebKit用于在窗口中显示web内容,以及实现一些类似于浏览器特性的功能,例如当用户点击时回到前面列表,管理一个前进后退列表,以及最近的访问历史.</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[NEHotspotConfigurationManager]]></title>
      <url>/2018/04/13/NEHotspotConfigurationManager/</url>
      <content type="html"><![CDATA[<p>配置管理器，应用并删除Wi-Fi网络的热点配置。</p>
<p>SDK</p>
<ul>
<li>iOS 11.0+</li>
</ul>
<p>骨架</p>
<ul>
<li>网络扩展</li>
</ul>
<p>在本页<a href="https://developer.apple.com/documentation/networkextension/nehotspotconfigurationmanager#overview" target="_blank" rel="noopener">概观</a><a href="https://developer.apple.com/documentation/networkextension/nehotspotconfigurationmanager#topics" target="_blank" rel="noopener">主题</a><a href="https://developer.apple.com/documentation/networkextension/nehotspotconfigurationmanager#relationships" target="_blank" rel="noopener">关系</a><a href="https://developer.apple.com/documentation/networkextension/nehotspotconfigurationmanager#see-also" target="_blank" rel="noopener">也可以看看</a></p>
<h2 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h2><p>当您的应用使用Wi-Fi网络创建新的热点配置并将其应用于Wi-Fi网络或尝试更新先前配置的网络时，设备会提示用户进行审批。没有明确的用户同意，您的应用程序无法进行配置更改。<a href="https://developer.apple.com/documentation/networkextension/nehotspotconfiguration" target="_blank" rel="noopener"><code>NEHotspotConfiguration</code></a></p>
<p>您的应用可以使用或删除已添加的配置，但不能使用其他应用或用户添加的配置。用户还可以使用设置&gt; Wi-Fi删除已配置的网络。<a href="https://developer.apple.com/documentation/networkextension/nehotspotconfigurationmanager/2866709-removeconfiguration" target="_blank" rel="noopener"><code>removeConfiguration(forHS20DomainName:)</code></a><a href="https://developer.apple.com/documentation/networkextension/nehotspotconfigurationmanager/2866727-removeconfiguration" target="_blank" rel="noopener"><code>removeConfiguration(forSSID:)</code></a></p>
<p>当您的应用程序被卸载时，它所配置的所有网络的配置将被删除，包括它们的钥匙串条目。</p>
<p>热点配置管理器错误列在中。<a href="https://developer.apple.com/documentation/networkextension/nehotspotconfigurationerror" target="_blank" rel="noopener"><code>NEHotspotConfigurationError</code></a></p>
<p>重要要使用该类，您必须在Xcode中启用热点配置功能。请参阅<a href="http://help.apple.com/xcode/mac/current/#/dev88ff319e7" target="_blank" rel="noopener">向目标添加功能</a>。<code>NEHotspotConfigurationManager</code></p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><h3 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h3><p><code>func apply(NEHotspotConfiguration, completionHandler: ((Error?) -&gt; Void)? = nil)</code></p>
<p>在提示用户许可后添加或更新Wi-Fi网络配置，然后在特定条件下尝试加入网络。</p>
<h3 id="获取当前配置"><a href="#获取当前配置" class="headerlink" title="获取当前配置"></a>获取当前配置</h3><p><code>func getConfiguredSSIDs(completionHandler: ([String]) -&gt; Void)</code></p>
<p>返回您的应用配置的Wi-Fi热点域的SSID或名称，并调用可选的完成处理程序。</p>
<h3 id="删除域名配置"><a href="#删除域名配置" class="headerlink" title="删除域名配置"></a>删除域名配置</h3><p><code>func removeConfiguration(forHS20DomainName: String)</code></p>
<p>删除由热点2.0域名标识的Wi-Fi热点配置，您的应用以前添加的配置。</p>
<h3 id="删除SSID配置"><a href="#删除SSID配置" class="headerlink" title="删除SSID配置"></a>删除SSID配置</h3><p><code>func removeConfiguration(forSSID: String)</code></p>
<p>移除您的应用以前添加的由SSID标识的Wi-Fi配置。</p>
<h3 id="共享配置"><a href="#共享配置" class="headerlink" title="共享配置"></a>共享配置</h3><p><code>class var shared: NEHotspotConfigurationManager</code></p>
<p>实例化为单例，因此可以共享。<a href="https://developer.apple.com/documentation/networkextension/nehotspotconfigurationmanager" target="_blank" rel="noopener"><code>NEHotspotConfigurationManager</code></a></p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="继承自"><a href="#继承自" class="headerlink" title="继承自"></a>继承自</h3><p><a href="https://developer.apple.com/documentation/objectivec/nsobject" target="_blank" rel="noopener"><code>NSObject</code></a></p>
<h3 id="符合"><a href="#符合" class="headerlink" title="符合"></a>符合</h3><ul>
<li><a href="https://developer.apple.com/documentation/swift/cvararg" target="_blank" rel="noopener"><code>CVarArg</code></a>， </li>
<li><a href="https://developer.apple.com/documentation/swift/equatable" target="_blank" rel="noopener"><code>Equatable</code></a>， </li>
<li><a href="https://developer.apple.com/documentation/swift/hashable" target="_blank" rel="noopener"><code>Hashable</code></a></li>
</ul>
<h2 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h2><h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><h2 id="class-NEHotspotConfiguration"><a href="#class-NEHotspotConfiguration" class="headerlink" title="class NEHotspotConfiguration"></a><code>class NEHotspotConfiguration</code></h2><p>Wi-Fi网络热点的配置设置。</p>
<h2 id="概观-1"><a href="#概观-1" class="headerlink" title="概观"></a>概观</h2><p>本类包含连接到Wi-Fi网络所需的配置属性和证书。<code>NEHotspotConfiguration</code></p>
<h2 id="主题-1"><a href="#主题-1" class="headerlink" title="主题"></a>主题</h2><h3 id="创建一个热点配置"><a href="#创建一个热点配置" class="headerlink" title="创建一个热点配置"></a>创建一个热点配置</h3><p>为开放式，WEP，WPA / WPA2个人，WPA / WPA企业和Hotspot 2.0 Wi-Fi网络创建新的热点配置。</p>
<p><code>init(ssid: String)</code></p>
<p>为一个开放的Wi-Fi网络创建一个由SSID标识的新热点配置。</p>
<p><code>init(ssid: String, passphrase: String, isWEP: Bool)</code></p>
<p>为受保护的WEP或WPA / WPA2个人Wi-Fi网络创建一个由SSID标识的新热点配置。</p>
<p><code>init(ssid: String, eapSettings: NEHotspotEAPSettings)</code></p>
<p>为具有EAP设置的WPA / WPA2企业Wi-Fi网络创建由SSID标识的新热点配置。</p>
<p><code>init(hs20Settings: NEHotspotHS20Settings, eapSettings: NEHotspotEAPSettings)</code></p>
<p>为具有HS 2.0和EAP设置的Hotspot 2.0 Wi-Fi网络创建一个由域名标识的新热点配置。</p>
<h3 id="热点配置属性"><a href="#热点配置属性" class="headerlink" title="热点配置属性"></a>热点配置属性</h3><p><code>var ssid: String</code></p>
<p>开放，WEP，WPA / WPA2个人或WPA / WPA2企业Wi-Fi网络的SSID。</p>
<p><code>var lifeTimeInDays: NSNumber</code></p>
<p>网络保留相关配置的天数。</p>
<p><code>var joinOnce: Bool</code></p>
<p>将配置的生命周期限制为创建它的应用的运行状态。</p>
<h2 id="class-NEHotspotEAPSettings"><a href="#class-NEHotspotEAPSettings" class="headerlink" title="class NEHotspotEAPSettings"></a><code>class NEHotspotEAPSettings</code></h2><p>用于配置WPA和WPA2企业Wi-Fi网络的可扩展身份验证协议（EAP）设置。</p>
<h3 id="配置EAP握手"><a href="#配置EAP握手" class="headerlink" title="配置EAP握手"></a>配置EAP握手</h3><p><code>var isTLSClientCertificateRequired: Bool</code></p>
<p>一个布尔值，指示网络是否需要双因素身份验证或允许零因素身份验证。</p>
<p><code>var trustedServerNames: [String]</code></p>
<p>用于验证服务器证书的服务器证书公用名字符串数组。</p>
<p><code>var supportedEAPTypes: [NSNumber]</code></p>
<p>支持的EAP类型的数组。</p>
<p><code>enum NEHotspotEAPSettings.EAPType</code></p>
<p>可以在中指定的EAP类型。<a href="https://developer.apple.com/documentation/networkextension/nehotspoteapsettings/2866648-supportedeaptypes" target="_blank" rel="noopener"><code>supportedEAPTypes</code></a></p>
<p><code>var username: String</code></p>
<p>EAP认证的用户名字符串，编码为UTF-8。</p>
<p><code>var password: String</code></p>
<p>IEEE 802.1X身份验证凭证的密码组件。</p>
<p><code>var preferredTLSVersion: NEHotspotEAPSettings.TLSVersion</code></p>
<p>在TLS身份验证握手期间使用的传输层安全（TLS）版本。</p>
<p><code>enum NEHotspotEAPSettings.TLSVersion</code></p>
<p>EAPTLS版本标识符可以通过。<a href="https://developer.apple.com/documentation/networkextension/nehotspoteapsettings/2866697-preferredtlsversion" target="_blank" rel="noopener"><code>preferredTLSVersion</code></a></p>
<p><code>var outerIdentity: String</code></p>
<p>外部EAP认证期间在EAP-Identity / Response数据包中使用的身份字符串。</p>
<p><code>var ttlsInnerAuthenticationType: NEHotspotEAPSettings.TTLSInnerAuthenticationType</code></p>
<p>TTLS模块使用的内层认证协议。</p>
<p><code>enum NEHotspotEAPSettings.TTLSInnerAuthenticationType</code></p>
<p>TTLS内部认证类型可以通过。<a href="https://developer.apple.com/documentation/networkextension/nehotspoteapsettings.ttlsinnerauthenticationtype" target="_blank" rel="noopener"><code>NEHotspotEAPSettings.TTLSInnerAuthenticationType</code></a></p>
<h3 id="设置验证值"><a href="#设置验证值" class="headerlink" title="设置验证值"></a>设置验证值</h3><p><code>func setIdentity(SecIdentity)</code></p>
<p>设置EAP认证的客户端标识。</p>
<p><code>func setTrustedServerCertificates([Any])</code></p>
<p>为企业Wi-Fi或Hotspot 2.0网络设置可信的EAP服务器证书。</p>
<h2 id="class-NEHotspotHS20Settings"><a href="#class-NEHotspotHS20Settings" class="headerlink" title="class NEHotspotHS20Settings"></a><code>class NEHotspotHS20Settings</code></h2><p>配置Hotspot 2.0 Wi-Fi网络的设置。</p>
<p><code>init(domainName: String, roamingEnabled: Bool)</code></p>
<p>创建传统Hotspot或HS 2.0 Wi-Fi网络的新热点配置。启用可选的漫游功能。</p>
<h3 id="热点2-0属性"><a href="#热点2-0属性" class="headerlink" title="热点2.0属性"></a>热点2.0属性</h3><p><code>var domainName: String</code></p>
<p>Hotspot 2.0 Wi-Fi网络的域名。</p>
<p><code>var isRoamingEnabled: Bool</code></p>
<p>一个布尔值，指示是否在Hotspot 2.0 Wi-Fi网络上启用漫游。</p>
<p><code>var mccAndMNCs: [String]</code></p>
<p>用于Wi-Fi热点2.0协商的一组移动国家代码（MCC）和移动网络代码（MNC）对。</p>
<p><code>var naiRealmNames: [String]</code></p>
<p>用于Wi-Fi热点2.0协商的一组网络访问标识符（NAI）领域名称字符串。</p>
<p><code>var roamingConsortiumOIs: [String]</code></p>
<p>用于Wi-Fi热点2.0协商的一组漫游联盟组织（RCO）标识符。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[NEHotspotConfigurationManager使用]]></title>
      <url>/2018/04/13/NEHotspotConfigurationManager%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>NEHotspotConfigurationManager 是IOS 11刚刚推出的用户获取WiFi信息的框架。</p>
<p>初次使用时，如果没有做响应的设置，会提示NEHotspotConfigurationHelper failed to communicate to helper server.一个原因是工程配置有问题。</p>
<p>NEHotspotConfigurationManager 加入已经密码的wifi网络多用于物联网。设备配置加入互联网。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1972390-59becfc0fb36674b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>35295D1A-69EF-4AC5-886F-E0842F2E46D6.png</p>
<p>2.创建工程在Capabilities 中勾选Hotspot configuration</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1972390-d2c8b5f93b883a67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680" alt="img"></p>
<p>7CBBF69E-5C62-47E7-957E-158A716FDF3C.png</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1972390-bd67498d7ab0a5ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/677" alt="img"></p>
<p>4B49C6A7-5D14-4FB5-8660-CE750E43025C.png</p>
<p>下面开始使用<br>1.在使用的地方加入头文件 #import <networkextension nehotspotconfigurationmanager.h=""></networkextension></p>
<ol>
<li>NEHotspotConfiguration* configuration = [[NEHotspotConfiguration alloc]initWithSSID:@”wifi名” passphrase:@”wifi密码” isWEP:NO]; //加入有密码的wifi</li>
</ol>
<p>//    NEHotspotConfiguration* configuration = [[NEHotspotConfiguration alloc]initWithSSID:@”wifi名”]; //加入没有密码的wifi</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[NEHotspotConfigurationManager sharedManager] applyConfiguration:configuration completionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">    if([[self currentIphoneConnectedWifiName]isEqualToString:@&quot;NET&quot;]) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog(@&quot;加入网络成功&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这个方法存在一个问题，如果你加入一个不存在的WiFi，会弹出无法加入WiFi的弹框，但是本方法的回调error没有值。在这里，我是通过判断当前wifi是否是我要加入的wifi来解决这个问题的。</p>
<p>后面是辅助的方法 查看手机当前连接的wifi 先要导入头文件</p>
<h1 id="import"><a href="#import" class="headerlink" title="import "></a>import <systemconfiguration captivenetwork.h=""></systemconfiguration></h1><p>/<em>* 获取当前手机连接到到Wi-Fi 的名字 </em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(NSString *)currentIphoneConnectedWifiName&#123;</span><br><span class="line"></span><br><span class="line">NSString *wifiName = nil;</span><br><span class="line"></span><br><span class="line">CFArrayRef wifiInterfaces = CNCopySupportedInterfaces();</span><br><span class="line"></span><br><span class="line">if (!wifiInterfaces)return nil;</span><br><span class="line"></span><br><span class="line">NSArray *interfaces = (__bridge NSArray *)wifiInterfaces;</span><br><span class="line"></span><br><span class="line">for (NSString *interfaceName in interfaces)&#123;</span><br><span class="line"></span><br><span class="line">    CFDictionaryRef dictRef = CNCopyCurrentNetworkInfo((__bridge CFStringRef)(interfaceName));</span><br><span class="line"></span><br><span class="line">    if (dictRef)&#123;</span><br><span class="line"></span><br><span class="line">        NSDictionary *networkInfoDic = (__bridge NSDictionary *)dictRef;</span><br><span class="line"></span><br><span class="line">        wifiName = [networkInfoDic objectForKey:(__bridge NSString *)kCNNetworkInfoKeySSID];</span><br><span class="line">        CFRelease(dictRef);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CFRelease(wifiInterfaces);</span><br><span class="line"></span><br><span class="line">return wifiName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[IJKPlayer获取实时数据（上）- 添加外部接口]]></title>
      <url>/2018/04/13/IJKPlayer%E8%8E%B7%E5%8F%96%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8A%EF%BC%89-%20%E6%B7%BB%E5%8A%A0%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>一、添加接口</p>
<h5 id="1、在IJKMediaPlayBack-h添加三个方法"><a href="#1、在IJKMediaPlayBack-h添加三个方法" class="headerlink" title="1、在IJKMediaPlayBack.h添加三个方法"></a>1、在IJKMediaPlayBack.h添加三个方法</h5><p><img src="https://upload-images.jianshu.io/upload_images/3440053-23aa8037c6cbc1d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/410" alt="img"></p>
<p>image.png</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (CVPixelBufferRef)framePixelbuffer;</span><br><span class="line">- (void)framePixelbufferLock;</span><br><span class="line">- (void)framePixelbufferUnlock;</span><br></pre></td></tr></table></figure>
<h5 id="2、在ff-ffplay-def-h-的-FFPlayer-数据结构中添加如下"><a href="#2、在ff-ffplay-def-h-的-FFPlayer-数据结构中添加如下" class="headerlink" title="2、在ff_ffplay_def.h 的 FFPlayer 数据结构中添加如下:"></a>2、在ff_ffplay_def.h 的 FFPlayer 数据结构中添加如下:</h5><p><img src="https://upload-images.jianshu.io/upload_images/3440053-b1fe34f7c7f69a4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/383" alt="img"></p>
<p>image.png</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 引入头文件</span><br><span class="line">#include &lt;CoreVideo/CoreVideo.h&gt;</span><br><span class="line">  </span><br><span class="line">CVPixelBufferRef szt_pixelbuffer;</span><br><span class="line">pthread_mutex_t szt_pixelbuffer_mutex;</span><br></pre></td></tr></table></figure>
<h5 id="3、在ijkplayer-h中添加："><a href="#3、在ijkplayer-h中添加：" class="headerlink" title="3、在ijkplayer.h中添加："></a>3、在ijkplayer.h中添加：</h5><p><img src="https://upload-images.jianshu.io/upload_images/3440053-aa70d2457f67f558.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/645" alt="img"></p>
<p>image.png</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 引入头文件</span><br><span class="line">#include &lt;CoreVideo/CoreVideo.h&gt;</span><br><span class="line"></span><br><span class="line">CVPixelBufferRef ijkmp_get_pixelbuffer(IjkMediaPlayer *mp);</span><br><span class="line">int ijkmp_pixelbuffer_mutex_init(IjkMediaPlayer *mp);</span><br><span class="line">int ijkmp_pixelbuffer_mutex_lock(IjkMediaPlayer *mp);</span><br><span class="line">int ijkmp_pixelbuffer_mutex_unlock(IjkMediaPlayer *mp);</span><br></pre></td></tr></table></figure>
<h5 id="4、在ijkplayer-c添加"><a href="#4、在ijkplayer-c添加" class="headerlink" title="4、在ijkplayer.c添加:"></a>4、在ijkplayer.c添加:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CVPixelBufferRef ijkmp_get_pixelbuffer(IjkMediaPlayer *mp)</span><br><span class="line">&#123;</span><br><span class="line">    return mp-&gt;ffplayer-&gt;szt_pixelbuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ijkmp_pixelbuffer_mutex_init(IjkMediaPlayer *mp)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = ffp_pixelbuffer_mutex_init(mp-&gt;ffplayer);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ijkmp_pixelbuffer_mutex_lock(IjkMediaPlayer *mp)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = ffp_pixelbuffer_lock(mp-&gt;ffplayer);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ijkmp_pixelbuffer_mutex_unlock(IjkMediaPlayer *mp)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = ffp_pixelbuffer_unlock(mp-&gt;ffplayer);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5、在ff-ffplay-h添加"><a href="#5、在ff-ffplay-h添加" class="headerlink" title="5、在ff_ffplay.h添加:"></a>5、在ff_ffplay.h添加:</h5><p><img src="https://upload-images.jianshu.io/upload_images/3440053-da63d6a3514450dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/489" alt="img"></p>
<p>image.png</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int       ffp_pixelbuffer_mutex_init(FFPlayer *ffp);</span><br><span class="line">int       ffp_pixelbuffer_lock(FFPlayer *ffp);</span><br><span class="line">int       ffp_pixelbuffer_unlock(FFPlayer *ffp);</span><br></pre></td></tr></table></figure>
<h5 id="6、在ff-ffplay-c添加"><a href="#6、在ff-ffplay-c添加" class="headerlink" title="6、在ff_ffplay.c添加:"></a>6、在ff_ffplay.c添加:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ffp_pixelbuffer_mutex_init(FFPlayer *ffp)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = pthread_mutex_init(&amp;ffp-&gt;szt_pixelbuffer_mutex, NULL);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">int ffp_pixelbuffer_lock(FFPlayer *ffp)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = pthread_mutex_lock(&amp;ffp-&gt;szt_pixelbuffer_mutex);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">int ffp_pixelbuffer_unlock(FFPlayer *ffp)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = pthread_mutex_unlock(&amp;ffp-&gt;szt_pixelbuffer_mutex);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7、在IJKFFMoviePlayerController-h添加"><a href="#7、在IJKFFMoviePlayerController-h添加" class="headerlink" title="7、在IJKFFMoviePlayerController.h添加:"></a>7、在IJKFFMoviePlayerController.h添加:</h5><p><img src="https://upload-images.jianshu.io/upload_images/3440053-a909e9517bd3fd71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/421" alt="img"></p>
<p>image.png</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (CVPixelBufferRef)framePixelbuffer;</span><br><span class="line">- (void)framePixelbufferLock;</span><br><span class="line">- (void)framePixelbufferUnlock;</span><br></pre></td></tr></table></figure>
<h5 id="8、在IJKFFMoviePlayerController-m添加"><a href="#8、在IJKFFMoviePlayerController-m添加" class="headerlink" title="8、在IJKFFMoviePlayerController.m添加:"></a>8、在IJKFFMoviePlayerController.m添加:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (CVPixelBufferRef)framePixelbuffer</span><br><span class="line">&#123;</span><br><span class="line">    if (_mediaPlayer)</span><br><span class="line">    &#123;</span><br><span class="line">        return ijkmp_get_pixelbuffer(_mediaPlayer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)framePixelbufferLock</span><br><span class="line">&#123;</span><br><span class="line">    if (_mediaPlayer)</span><br><span class="line">    &#123;</span><br><span class="line">        ijkmp_pixelbuffer_mutex_lock(_mediaPlayer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)framePixelbufferUnlock</span><br><span class="line">&#123;</span><br><span class="line">    if (_mediaPlayer)</span><br><span class="line">    &#123;</span><br><span class="line">        ijkmp_pixelbuffer_mutex_unlock(_mediaPlayer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、如何使用："><a href="#二、如何使用：" class="headerlink" title="二、如何使用："></a>二、如何使用：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.ijkplayer framePixelbufferLock];</span><br><span class="line">CVPixelBufferRef pixelBuffer = [self.ijkplayer framePixelbuffer];</span><br><span class="line">[self.ijkplayer framePixelbufferUnlock];</span><br></pre></td></tr></table></figure>
<p>小礼物走一走，来简书关注我</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 图片去除特像素色]]></title>
      <url>/2018/04/12/iOS%20%E5%9B%BE%E7%89%87%E5%8E%BB%E9%99%A4%E7%89%B9%E5%83%8F%E7%B4%A0%E8%89%B2/</url>
      <content type="html"><![CDATA[<p>//颜色替换</p>
<p>- (UIImage<em>) imageToTransparent:(UIImage</em>) image</p>
<p>{</p>
<p>​    // 分配内存</p>
<p>​    const int imageWidth = image.size.width;</p>
<p>​    const int imageHeight = image.size.height;</p>
<p>​    size_t      bytesPerRow = imageWidth * 4;</p>
<p>​    uint32_t<em> rgbImageBuf = (uint32_t</em>)malloc(bytesPerRow * imageHeight);</p>
<p>​    // 创建context</p>
<p>​    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</p>
<p>​    CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipLast);</p>
<p>​    CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage);</p>
<a id="more"></a>
<p>​    // 遍历像素</p>
<p>​    int pixelNum = imageWidth * imageHeight;   </p>
<p>​    uint32_t* pCurPtr = rgbImageBuf;   </p>
<p>​    for (int i = 0; i &lt; pixelNum; i++, pCurPtr++)</p>
<p>​    {</p>
<p>​        uint8_t<em> ptr = (uint8_t</em>)pCurPtr;</p>
<p>​        if (ptr[1] &gt; 226 &amp;&amp; ptr[2] &gt; 226 &amp;&amp; ptr[3] &gt; 226) {</p>
<p>​            //当RGB值都大于240则比较接近白色的都将透明度设为0.—–即接近白色的都设置为透明。某些白色背景具有杂质就会去不干净，用这个方法可以去干净</p>
<p>​            ptr[0] = 0;</p>
<p>​        }else if (ptr[1] &lt; 30 &amp;&amp; ptr[2] &lt; 30 &amp;&amp; ptr[3] &lt; 30){</p>
<p>​            ptr[3] = 0; //0~255</p>
<p>​            ptr[2] = 255;</p>
<p>​            ptr[1] = 0;</p>
<p>​        }</p>
<p>​    }</p>
<p>​    // 将内存转成image</p>
<p>​    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData);</p>
<p>​    CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpace, kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, NULL, true, kCGRenderingIntentDefault);</p>
<p>​    CGDataProviderRelease(dataProvider);</p>
<p>​    UIImage* resultUIImage = [UIImage imageWithCGImage:imageRef];</p>
<p>​    // 释放</p>
<p>​    CGImageRelease(imageRef);</p>
<p>​    CGContextRelease(context);</p>
<p>​    CGColorSpaceRelease(colorSpace);</p>
<p>​    // free(rgbImageBuf) 创建dataProvider时已提供释放函数，这里不用free</p>
<p>​    return resultUIImage;</p>
<p>}</p>
<p>/<em>* 颜色变化 </em>/</p>
<p>void ProviderReleaseData (void <em>info, const void </em>data, size_t size)</p>
<p>{</p>
<p>​    free((void*)data);</p>
<p>}</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[NSURLSession]]></title>
      <url>/2018/04/12/NSURLSession%20/</url>
      <content type="html"><![CDATA[<p>转<a href="https://www.jianshu.com/p/b0ddadd34037" target="_blank" rel="noopener">https://www.jianshu.com/p/b0ddadd34037</a></p>
<p>由于傲娇的苹果在 iOS9 之后已经放弃了 <a href="https://www.jianshu.com/p/70bff73f0500" target="_blank" rel="noopener">NSURLConnection</a>，所以在现在的实际开发中，除了大家常见的 AFN 框架，一般使用的是 iOS7 之后推出的 NSURLSession，作为一名 iOS 开发人员，如果你只知道 AFN 框架来进行网络请求，那就只能说是 too young too simple,sometimes naive。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol>
<li>NSURLSession 的优势</li>
<li>NSURLSessionTask 的子类</li>
<li>NSURLSessionDataTask 发送 GET 请求</li>
<li>NSURLSessionDataTask 发送 POST 请求</li>
<li>NSURLSessionDataTask 设置代理发送请求</li>
<li>设置代理之后的强引用问题</li>
<li>NSURLSessionDataTask 简单下载</li>
<li>NSURLSessionDownloadTask 简单下载</li>
<li>dataTask 和 downloadTask 下载对比</li>
<li>写在最后</li>
<li><a href="https://www.jianshu.com/p/b63217ff7287" target="_blank" rel="noopener">【补充】NSURLSession 详解离线断点下载的实现</a></li>
</ol>
<h4 id="1"> NSURLSession 的优势 </h4><br><a id="more"></a><br>- NSURLSession 支持 http2.0 协议<br>- 在处理下载任务的时候可以直接把数据下载到磁盘<br>- 支持后台下载|上传<br>- 同一个 session 发送多个请求，只需要建立一次连接（复用了TCP）<br>- 提供了全局的 session 并且可以统一配置，使用更加方便<br>- 下载的时候是多线程异步处理，效率更高<br><br><h4 id="2"> NSURLSessionTask 的子类 </h4>

<ul>
<li><p>NSURLSessionTask 是一个抽象类，如果要使用那么只能使用它的子类</p>
</li>
<li><p>NSURLSessionTask 有两个子类</p>
<ul>
<li><p>NSURLSessionDataTask,可以用来处理一般的网络请求，如 GET | POST 请求等</p>
<ul>
<li>NSURLSessionDataTask 有一个子类为 NSURLSessionUploadTask,用于处理上传请求的时候有优势</li>
</ul>
</li>
<li><p>NSURLSessionDownloadTask,主要用于处理下载请求，有很大的优势</p>
<p>​</p>
<p>​</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2997426-7e7b79022303d11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>NSURLSession 的子类</p>
</li>
</ul>
</li>
</ul>
<h4 id="3"> NSURLSessionDataTask 发送 GET 请求 </h4><br>发送 GET 请求的步骤非常简单，只需要两步就可以完成：<br><br>1. 使用 NSURLSession 对象创建 Task<br><br>2. 执行 Task<br><br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><br>//确定请求路径<br>NSURL <em>url = [NSURL URLWithString:@”<a href="https://link.jianshu.com?t=http://120.25.226.186:32812/login?username=520&amp;pwd=520&amp;type=JSON" target="_blank" rel="noopener">http://120.25.226.186:32812/login?username=520&amp;pwd=520&amp;type=JSON</a>“];<br>//创建 NSURLSession 对象<br>NSURLSession </em>session = [NSURLSession sharedSession];<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 根据对象创建 Task 请求</span><br><span class="line"> </span><br><span class="line"> url  方法内部会自动将 URL 包装成一个请求对象（默认是 GET 请求）</span><br><span class="line"> completionHandler  完成之后的回调（成功或失败）</span><br><span class="line"> </span><br><span class="line"> param data     返回的数据（响应体）</span><br><span class="line"> param response 响应头</span><br><span class="line"> param error    错误信息</span><br><span class="line"> */</span><br><span class="line">NSURLSessionDataTask *dataTask = [session dataTaskWithURL:url completionHandler:</span><br><span class="line">            ^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">    </span><br><span class="line">    //解析服务器返回的数据</span><br><span class="line">    NSLog(@&quot;%@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);</span><br><span class="line">    //默认在子线程中解析数据</span><br><span class="line">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">//发送请求（执行Task）</span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4 id=&apos;4&apos;&gt; NSURLSessionDataTask 发送 POST 请求 &lt;/h4&gt;</span><br><span class="line">发送 POST 请求的步骤与发送 GET 请求一样：</span><br><span class="line"></span><br><span class="line">1. 使用 NSURLSession 对象创建 Task</span><br><span class="line">2. 执行 Task</span><br><span class="line"></span><br><span class="line">    ```objective-c</span><br><span class="line">//确定请求路径</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login&quot;];</span><br><span class="line">    //创建可变请求对象</span><br><span class="line">    NSMutableURLRequest *requestM = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">    //修改请求方法</span><br><span class="line">    requestM.HTTPMethod = @&quot;POST&quot;;</span><br><span class="line">    //设置请求体</span><br><span class="line">    requestM.HTTPBody = [@&quot;username=520&amp;pwd=520&amp;type=JSON&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    //创建会话对象</span><br><span class="line">    NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">    //创建请求 Task</span><br><span class="line">    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:requestM completionHandler:</span><br><span class="line">                ^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        </span><br><span class="line">        //解析返回的数据</span><br><span class="line">        NSLog(@&quot;%@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);</span><br><span class="line">    &#125;];</span><br><span class="line">    //发送请求</span><br><span class="line">    [dataTask resume];</span><br></pre></td></tr></table></figure><br><br><h4 id="5"> NSURLSessionDataTask 设置代理发送请求 </h4>

<ol>
<li><p>创建 NSURLSession 对象设置代理</p>
</li>
<li><p>使用 NSURLSession 对象创建 Task</p>
</li>
<li><p>执行 Task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>//确定请求路径<br>NSURL <em>url = [NSURL URLWithString:@”<a href="http://120.25.226.186:32812/login" target="_blank" rel="noopener">http://120.25.226.186:32812/login</a>“];<br>//创建可变请求对象<br>NSMutableURLRequest requestM = [NSMutableURLRequest requestWithURL:url];<br>//设置请求方法<br>requestM.HTTPMethod = @”POST”;<br>//设置请求体<br>requestM.HTTPBody = [@”username=520&amp;pwd=520&amp;type=JSON” dataUsingEncoding:NSUTF8StringEncoding];<br>//创建会话对象，设置代理<br>/</em><br>第一个参数：配置信息<br>第二个参数：设置代理<br>第三个参数：队列，如果该参数传递nil 那么默认在子线程中执行<br><em>/<br>NSURLSession </em>session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]<br>delegate:self delegateQueue:nil];<br>//创建请求 Task<br>NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:requestM];<br>//发送请求<br>[dataTask resume];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">4. 遵守协议，实现代理方法（常用的有三种代理方法）</span><br><span class="line"></span><br><span class="line">    ```objective-c</span><br><span class="line">-(void)URLSession:(NSURLSession *)session dataTask:(nonnull NSURLSessionDataTask *)dataTask </span><br><span class="line">didReceiveResponse:(nonnull NSURLResponse *)response </span><br><span class="line">completionHandler:(nonnull void (^)(NSURLSessionResponseDisposition))completionHandler &#123;</span><br><span class="line">        //子线程中执行</span><br><span class="line">        NSLog(@&quot;接收到服务器响应的时候调用 -- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">        self.dataM = [NSMutableData data];</span><br><span class="line">        //默认情况下不接收数据</span><br><span class="line">        //必须告诉系统是否接收服务器返回的数据</span><br><span class="line">        completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">&#125;</span><br><span class="line">-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    </span><br><span class="line">        NSLog(@&quot;接受到服务器返回数据的时候调用,可能被调用多次&quot;);</span><br><span class="line">        //拼接服务器返回的数据</span><br><span class="line">        [self.dataM appendData:data];</span><br><span class="line">&#125;</span><br><span class="line">-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123;</span><br><span class="line">    </span><br><span class="line">        NSLog(@&quot;请求完成或者是失败的时候调用&quot;);</span><br><span class="line">        //解析服务器返回数据</span><br><span class="line">        NSLog(@&quot;%@&quot;, [[NSString alloc] initWithData:self.dataM encoding:NSUTF8StringEncoding]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6"> 设置代理之后的强引用问题 </h4>

<ul>
<li><p>NSURLSession 对象在使用的时候，如果设置了代理，那么 session 会对代理对象保持一个强引用，在合适的时候应该主动进行释放</p>
</li>
<li><p>可以在控制器调用 viewDidDisappear 方法的时候来进行处理，可以通过调用 invalidateAndCancel 方法或者是 finishTasksAndInvalidate 方法来释放对代理对象的强引用</p>
<ul>
<li><p>invalidateAndCancel 方法直接取消请求然后释放代理对象</p>
</li>
<li><p>finishTasksAndInvalidate 方法等请求完成之后释放代理对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>[self.session finishTasksAndInvalidate];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7"> NSURLSessionDataTask 简单下载 </h4><br>在前面请求数据的时候就相当于一个简单的下载过程，NSURLSessionDataTask 下载文件具体的步骤与上类似：<br><br>1. 使用 NSURLSession 对象创建一个 Task 请求<br><br>2. 执行请求<br><br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><br>[[[NSURLSession sharedSession] dataTaskWithURL:[NSURL URLWithString:<br>@”<a href="https://link.jianshu.com?t=http://120.25.226.186:32812/resources/images/minion_01.png" target="_blank" rel="noopener">http://120.25.226.186:32812/resources/images/minion_01.png</a>“]<br>completionHandler:^(NSData <em> _Nullable data, NSURLResponse </em> _Nullable response, NSError * _Nullable error) {<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    //解析数据</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">    //回到主线程设置图片</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        self.imageView.image = image;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;] resume];</span><br></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4 id=&apos;8&apos;&gt; NSURLSessionDownloadTask 简单下载 &lt;/h4&gt;</span><br><span class="line">1. 使用 NSURLSession 对象创建下载请求</span><br><span class="line">2. 在下载请求中移动文件到指定位置</span><br><span class="line">3. 执行请求</span><br><span class="line"></span><br><span class="line">    ```objective-c</span><br><span class="line">//确定请求路径</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/images/minion_02.png&quot;];</span><br><span class="line">    //创建请求对象</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">    //创建会话对象</span><br><span class="line">    NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">    //创建会话请求</span><br><span class="line">    //优点：该方法内部已经完成了边接收数据边写沙盒的操作，解决了内存飙升的问题</span><br><span class="line">    NSURLSessionDownloadTask *downTask = [session downloadTaskWithRequest:request </span><br><span class="line">        completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        </span><br><span class="line">        //默认存储到临时文件夹 tmp 中，需要剪切文件到 cache</span><br><span class="line">        NSLog(@&quot;%@&quot;, location);//目标位置</span><br><span class="line">        NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]  </span><br><span class="line">                            stringByAppendingPathComponent:response.suggestedFilename];</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         fileURLWithPath:有协议头</span><br><span class="line">         URLWithString:无协议头</span><br><span class="line">         */</span><br><span class="line">        [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:fullPath] error:nil];</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    //发送请求</span><br><span class="line">    [downTask resume];</span><br></pre></td></tr></table></figure><br><br>以上方法无法监听下载进度，如要获取下载进度，可以使用代理的方式进行下载。<br><br><h4 id="9"> dataTask 和 downloadTask 下载对比 </h4>

<ul>
<li>NSURLSessionDataTask<ul>
<li>下载文件可以实现离线断点下载，但是代码相对复杂</li>
</ul>
</li>
<li>NSURLSessionDownloadTask<ul>
<li>下载文件可以实现断点下载，但不能离线断点下载</li>
<li>内部已经完成了边接收数据边写入沙盒的操作</li>
<li>解决了下载大文件时的内存飙升问题</li>
</ul>
</li>
</ul>
<h4 id="10"> 写在最后 </h4>

<blockquote>
<p>关于使用 NSURLSession 进行上传文件操作，我只想说真的很麻烦，建议大家时间充沛且有兴趣的可以研究一下，如果不想研究也是可以的，继续使用我们伟大的 AFN 框架就好。至于 AFN 框架的使用，这里就不赘述了，后期如果有时间会更新一些常用的 AFN 使用方法，敬请期待。</p>
</blockquote>
<p><strong>附：使用 NSURLSession 上传文件主要步骤及注意点</strong></p>
<ul>
<li><p>主要步骤：</p>
<ol>
<li>确定上传请求的路径（ NSURL ）</li>
<li>创建可变的请求对象（ NSMutableURLRequest ）</li>
<li>修改请求方法为 POST</li>
<li>设置请求头信息（告知服务器端这是一个文件上传请求）</li>
<li>按照固定的格式拼接要上传的文件等参数</li>
<li>根据请求对象创建会话对象（ NSURLSession 对象）</li>
<li>根据 session 对象来创建一个 uploadTask 上传请求任务</li>
<li>执行该上传请求任务（调用 resume 方法）</li>
<li>得到服务器返回的数据，解析数据（上传成功 | 上传失败）</li>
</ol>
</li>
<li><p>注意点：</p>
<ol>
<li><p>创建可变的请求对象，因为需要修改请求方法为 POST，设置请求头信息</p>
</li>
<li><p>设置请求头这个步骤可能会被遗漏</p>
</li>
<li><p>要处理上传参数的时候，一定要按照固定的格式来进行拼接</p>
</li>
<li><p>需要采用合适的方法来获得上传文件的二进制数据类型（ MIMEType，获取方式如下）</p>
<ul>
<li><p><a href="https://link.jianshu.com?t=http://www.w3school.com.cn/media/media_mimeref.asp" target="_blank" rel="noopener">点击这里搜索</a></p>
</li>
<li><p>对着该文件发送一个网络请求，接收到该请求响应的时候，可以通过响应头信息中的 MIMEType 属性得到</p>
</li>
<li><p>使用通用的二进制数据类型表示任意的二进制数据  application/octet-stream</p>
</li>
<li><p>调用 C 语言的 API 来获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>[self mimeTypeForFileAtPath:@”此处为上传文件的路径”]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h4 id="NSURLSessionDataTask-大文件离线断点下载"><a href="#NSURLSessionDataTask-大文件离线断点下载" class="headerlink" title="NSURLSessionDataTask 大文件离线断点下载"></a>NSURLSessionDataTask 大文件离线断点下载</h4><ul>
<li>主要内容<ol>
<li>实现文件下载</li>
<li>监听文件的下载进度</li>
<li>解决内存飙升问题</li>
<li>常用操作：开始 | 暂停 | 取消 | 恢复</li>
<li>断点下载</li>
<li>离线断点下载</li>
<li>实现源码</li>
</ol>
</li>
</ul>
<h6 id="1-实现文件下载"><a href="#1-实现文件下载" class="headerlink" title="1. 实现文件下载"></a>1. 实现文件下载</h6><ul>
<li><p>对于文件下载的实现这里就不再赘述，如果记不太清的话可以参考篇头提到的文章，里面有详细介绍，这里我就上代码了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>//01 确定请求路径<br>NSURL <em>URL = [NSURL URLWithString:@”<a href="https://link.jianshu.com?t=http://sony.it168.com/data/attachment/forum/201410/20/2154195j037033ujs7cio0.jpg" target="_blank" rel="noopener">http://sony.it168.com/data/attachment/forum/201410/20/2154195j037033ujs7cio0.jpg</a>“];<br>//02 创建会话对象 设置代理<br>NSURLSession </em>session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]<br>delegate:self delegateQueue:[NSOperationQueue mainQueue]];<br>//03 创建请求 发送请求<br>[[session dataTaskWithURL:URL] resume];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">###### 2. 监听文件的下载进度</span><br><span class="line">- 利用代理来监听文件下载进度</span><br><span class="line">- 计算文件的下载进度 = 已经下载的 / 文件的总大小</span><br><span class="line"></span><br><span class="line">    ```objective-c</span><br><span class="line">-(void)URLSession:(NSURLSession *)session dataTask:(nonnull NSURLSessionDataTask *)dataTask </span><br><span class="line">didReceiveResponse:(nonnull NSURLResponse *)response </span><br><span class="line">completionHandler:(nonnull void (^)(NSURLSessionResponseDisposition))completionHandler &#123;</span><br><span class="line">        //子线程中执行</span><br><span class="line">        NSLog(@&quot;接收到服务器响应的时候调用 -- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">        //得到请求文件的数据大小</span><br><span class="line">        self.totalLength = response.expectedContentLength;</span><br><span class="line">        //默认情况下不接收数据</span><br><span class="line">        //必须告诉系统是否接收服务器返回的数据</span><br><span class="line">        completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">&#125;</span><br><span class="line">-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    </span><br><span class="line">        NSLog(@&quot;接受到服务器返回数据的时候调用,可能被调用多次&quot;);</span><br><span class="line">        //拼接服务器返回的数据</span><br><span class="line">        [self.fileData appendData:data];</span><br><span class="line">        //计算文件的下载进度 = 已经下载的 / 文件的总大小</span><br><span class="line">        self.progressView.progress = 1.0 * self.fileData.length / self.totalLength;</span><br><span class="line">&#125;</span><br><span class="line">-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123;</span><br><span class="line">    </span><br><span class="line">        //保存数据 -&gt; 沙盒</span><br><span class="line">        NSString *fileName = task.response.suggestedFilename;</span><br><span class="line">        NSString *cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">        NSString *fullPath = [cachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">    </span><br><span class="line">        [self.fileData writeToFile:fullPath atomically:YES];</span><br><span class="line">        self.fileData = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做完以上两步之后就可以实现文件的下载操作和监听下载进度，但是此时会有很多问题，比如：<strong>内存飙升</strong>、<strong>下载进度错乱</strong>、<strong>无法控制下载状态</strong>等等，对于这些存在的问题，我们下面将一一进行解决。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2997426-bf22d69f1f245f82.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/699" alt="img"></p>
<p>初步实现效果（存在问题）</p>
<h6 id="3-解决内存飙升问题"><a href="#3-解决内存飙升问题" class="headerlink" title="3. 解决内存飙升问题"></a>3. 解决内存飙升问题</h6><ul>
<li><p>产生的原因：在下载文件的过程中，系统会先把文件保存在内存中，等到文件下载完毕之后再写入到磁盘</p>
</li>
<li><p>解决方案：在下载文件时，一边下载一边写入到磁盘，减小内存使用</p>
</li>
<li><p>在 iOS 中常用的有两种方法可以实现：</p>
<ul>
<li>NSFileHandle 文件句柄</li>
<li>NSOutputStream 输出流</li>
</ul>
</li>
<li><p><strong>方案一：NSFileHandle 文件句柄</strong>，大致分为四个步骤</p>
<ul>
<li><p>对代理方法进行改良</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>-(void)URLSession:(NSURLSession <em>)session dataTask:(nonnull NSURLSessionDataTask </em>)dataTask<br>didReceiveResponse:(nonnull NSURLResponse <em>)response<br>completionHandler:(nonnull void (^)(NSURLSessionResponseDisposition))completionHandler {<br>//接受到响应的时候 告诉系统如何处理服务器返回的数据<br>completionHandler(NSURLSessionResponseAllow);<br>//得到请求文件的数据大小<br>self.totalLength = response.expectedContentLength;<br>//拼接文件的全路径<br>NSString </em>fileName = response.suggestedFilename;<br>NSString <em>cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];<br>NSString </em>fullPath = [cachePath stringByAppendingPathComponent:fileName];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//【1】在沙盒中创建一个空的文件</span><br><span class="line">[[NSFileManager defaultManager] createFileAtPath:fullPath contents:nil attributes:nil];</span><br><span class="line">//【2】创建一个文件句柄指针指向该文件（默认指向文件开头）</span><br><span class="line">self.handle = [NSFileHandle fileHandleForWritingAtPath:fullPath];</span><br></pre></td></tr></table></figure>
<p>}<br>-(void)URLSession:(NSURLSession <em>)session dataTask:(NSURLSessionDataTask </em>)dataTask didReceiveData:(NSData <em>)data {<br>//【3】使用文件句柄指针来写数据（边写边移动）<br>[self.handle writeData:data];<br>//累加已经下载的文件数据大小<br>self.currentLength += data.length;<br>//计算文件的下载进度 = 已经下载的 / 文件的总大小<br>self.progressView.progress = 1.0 </em> self.currentLength / self.totalLength;<br>}<br>-(void)URLSession:(NSURLSession <em>)session task:(NSURLSessionTask </em>)task didCompleteWithError:(NSError *)error {<br>//【4】关闭文件句柄<br>[self.handle closeFile];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方案二：NSOutputStream 输出流</strong>，大致分为三个步骤</p>
<ul>
<li><p>对代理方法的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>-(void)URLSession:(NSURLSession <em>)session dataTask:(nonnull NSURLSessionDataTask </em>)dataTask<br>didReceiveResponse:(nonnull NSURLResponse <em>)response<br>completionHandler:(nonnull void (^)(NSURLSessionResponseDisposition))completionHandler {<br>//接受到响应的时候 告诉系统如何处理服务器返回的数据<br>completionHandler(NSURLSessionResponseAllow);<br>//得到请求文件的数据大小<br>self.totalLength = response.expectedContentLength;<br>//拼接文件的全路径<br>NSString </em>fileName = response.suggestedFilename;<br>NSString <em>cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];<br>NSString </em>fullPath = [cachePath stringByAppendingPathComponent:fileName];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//（1）创建输出流，并打开</span><br><span class="line">self.outStream = [[NSOutputStream alloc] initToFileAtPath:fullPath append:YES];</span><br><span class="line">[self.outStream open];</span><br></pre></td></tr></table></figure>
<p>}<br>-(void)URLSession:(NSURLSession <em>)session dataTask:(NSURLSessionDataTask </em>)dataTask didReceiveData:(NSData <em>)data {<br>//（2）使用输出流写数据<br>[self.outStream write:data.bytes maxLength:data.length];<br>//累加已经下载的文件数据大小<br>self.currentLength += data.length;<br>//计算文件的下载进度 = 已经下载的 / 文件的总大小<br>self.progressView.progress = 1.0 </em> self.currentLength / self.totalLength;<br>}<br>-(void)URLSession:(NSURLSession <em>)session task:(NSURLSessionTask </em>)task didCompleteWithError:(NSError *)error {<br>//（3）关闭输出流<br>[self.outStream close];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2997426-0aeed458d71933be.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/594" alt="img"></p>
<p>解决内存飙升</p>
<h6 id="4-常用操作：开始-暂停-取消-恢复"><a href="#4-常用操作：开始-暂停-取消-恢复" class="headerlink" title="4. 常用操作：开始 | 暂停 | 取消 | 恢复"></a>4. 常用操作：开始 | 暂停 | 取消 | 恢复</h6><ul>
<li><p>对于下载状态的控制（dataTask 为定义的下载任务属性，将创建任务的代码写到懒加载中）</p>
<ul>
<li><p>开始下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>[self.dataTask resume];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 暂停下载</span><br><span class="line">    </span><br><span class="line">    ```objective-c</span><br><span class="line">[self.dataTask suspend];</span><br></pre></td></tr></table></figure>
<ul>
<li><p>恢复下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>[self.dataTask resume];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 取消下载</span><br><span class="line">    </span><br><span class="line">    ```objective-c</span><br><span class="line">[self.dataTask cancel];</span><br><span class="line">//默认情况下取消下载不能进行恢复，若要取消之后还可以恢复，可以清空下载任务，再新建</span><br><span class="line">self.dataTask = nil;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2997426-bb456e259e804de3.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/631" alt="img"></p>
<p>下载控制效果</p>
<h6 id="5-断点下载"><a href="#5-断点下载" class="headerlink" title="5. 断点下载"></a>5. 断点下载</h6><ul>
<li><p>在上面的效果图中，我们已经看到可以控制下载的状态，但是到最后又有了一个新的问题：下载进度值发生跳跃错乱</p>
</li>
<li><p>原因分析：在前面计算进度值的时候，我们一直使用的方法是用已经下载的数据 / 文件的总数据，在第一个代理方法中，我们得到的文件大小并不是真正的文件大小，而是剩余未下载的大小，所以在第一次开始下载时，可以得到正确的数据，但是在下载过程中执行其他操作，就会使得到的数据大小发生变化，从而导致下载进度值出现问题</p>
</li>
<li><p>解决方案：文件总大小 = 已经下载的数据 + 剩余未下载的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>self.totalLength = response.expectedContentLength + self.currentLength;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 优化性能（以文件句柄方式为例，输出流同理）：只有第一次接收到响应的时候才需要创建空的文件</span><br><span class="line">  </span><br><span class="line">    ```objective-c</span><br><span class="line">if(self.currentLength == 0) &#123;</span><br><span class="line">        //在沙盒中创建一个空的文件</span><br><span class="line">        [[NSFileManager defaultManager] createFileAtPath:fullPath contents:nil attributes:nil];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>实现断点续传</p>
<ol>
<li><p>在创建文件句柄后，更改文件句柄指向文件的末尾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>[self.handle seekToEndOfFile];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2. 在请求头信息中添加需要请求的数据范围（从当前已经下载的数据末尾开始，到整个文件的末尾）</span><br><span class="line">    </span><br><span class="line">    ```objective-c</span><br><span class="line">NSString *rangeString = [NSString stringWithFormat:@&quot;bytes=%zd-&quot;,self.currentLength];</span><br><span class="line">[request setValue:rangeString forHTTPHeaderField:@&quot;Range&quot;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2997426-dc19891d820c96cb.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/582" alt="img"></p>
<p>断点下载效果</p>
<h6 id="6-离线断点下载"><a href="#6-离线断点下载" class="headerlink" title="6. 离线断点下载"></a>6. 离线断点下载</h6><ul>
<li><p>在用户日常使用的过程中，可能会出现下载文件到一半的时候，网络断开导致下载失败，为了避免重复下载，就要用到离线下载的功能</p>
</li>
<li><p>做离线断点下载的主要步骤就是要到沙盒中获取到之前已经下载好的数据和数据的大小，因此发送请求开始下载之前，要先在 viewDidLoad 中做一些处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>//获得之前已经下载的文件数据大小 =&gt; 获得沙盒中已经存在的文件数据大小<br>//获得某个路径对应文件的属性<br>NSDictionary *fileInfo = [[NSFileManager defaultManager] attributesOfItemAtPath:fullPath error:nil];<br>self.currentLength = [fileInfo fileSize];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 此时离线断点下载的功能也已经做好，但是仍有一些小问题需要处理</span><br><span class="line">- 优化：再次打开程序时，进度条为空，开始下载时会直接跳到当前进度值，造成用户体验不好</span><br><span class="line">- 解决步骤：</span><br><span class="line">    1. 在第一个代理方法中将文件的总大小写入到磁盘</span><br><span class="line">    </span><br><span class="line">        ```objective-c</span><br><span class="line">    [[[NSString stringWithFormat:@&quot;%zd&quot;,self.totalLength] dataUsingEncoding:NSUTF8StringEncoding] writeToFile:SizefullPath atomically:YES];</span><br></pre></td></tr></table></figure>
<pre><code>2. 在 viewDidLoad 中做处理

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//显示文件的进度信息 = 已经下载文件数据大小(self.currentLength) / 文件的总大小</span><br><span class="line">NSData *totalSize = [NSData dataWithContentsOfFile:SizefullPath];</span><br><span class="line">self.totalLength = [[[NSString alloc]initWithData:totalSize encoding:NSUTF8StringEncoding] integerValue];</span><br><span class="line">if (self.totalLength != 0) &#123;</span><br><span class="line">        self.progressView.progress = 1.0 * self.currentLength/self.totalLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2997426-f83e29a81892ce7f.gif?imageMogr2/auto-orient/strip" alt="离线断点下载效果"></p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><blockquote>
<p>以上就是使用 NSURLSession 实现离线断点下载的全部过程，由于个人水平有限，如有错误，敬请指正！如果觉得这篇文章对您有所帮助，请点击下方的喜欢或关注本人，谢谢您的支持！</p>
</blockquote>
<ul>
<li>实现源码地址：<a href="https://github.com/mortal-master/BWOfflineDownload" target="_blank" rel="noopener">https://github.com/mortal-master/BWOfflineDownload</a><br>```</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[NSURLSession的下载和断点继传以及后台下载功能]]></title>
      <url>/2018/04/12/NSURLSession%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%92%8C%E6%96%AD%E7%82%B9%E7%BB%A7%E4%BC%A0%E4%BB%A5%E5%8F%8A%E5%90%8E%E5%8F%B0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h1 id="转载https-blog-csdn-net-u014523377-article-details-51849808"><a href="#转载https-blog-csdn-net-u014523377-article-details-51849808" class="headerlink" title="转载https://blog.csdn.net/u014523377/article/details/51849808/"></a>转载<a href="https://blog.csdn.net/u014523377/article/details/51849808/" target="_blank" rel="noopener">https://blog.csdn.net/u014523377/article/details/51849808/</a></h1><h2 id="一-大体步骤"><a href="#一-大体步骤" class="headerlink" title="一.大体步骤"></a>一.大体步骤</h2><p>NSURLSession始于ios7.它具有访问接口,上传/下载数据,断点继传和后台下载等功能: 其使用步骤:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 1. 创建session指定其configuration</span><br><span class="line"> 2. 由session执行任务得到task</span><br><span class="line"> 3. task调用resume,启动网络请求</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<h2 id="二-task分类"><a href="#二-task分类" class="headerlink" title="二.task分类"></a>二.task分类</h2><p>session的任务有四种:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 1. 数据任务 Data task</span><br><span class="line"> 2. 下载任务 Download task</span><br><span class="line"> 3. 上传任务 Upload task</span><br><span class="line"> 4. 流任务 Stream task ios9之后出现的,用于TCP/IP流</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="三-configuration类型"><a href="#三-configuration类型" class="headerlink" title="三. configuration类型"></a>三. configuration类型</h2><p>configuration的类型有三种:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 1. 默认配置 Default sessions:</span><br><span class="line">    使用磁盘缓存,用将证书存在用户的钥匙串</span><br><span class="line"> 2. 及时配置 Ephemeral sessions:</span><br><span class="line">    不使用磁盘缓存,也存储证书,它的信息存于RAM中,如果session被invalidate,这些信息也被清理掉</span><br><span class="line"> 3. 后台配置 Background sessions:</span><br><span class="line">     配置上同默认配置,但是有一个独立进程来操作上传/下载</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>
<h2 id="四-session生成task方式"><a href="#四-session生成task方式" class="headerlink" title="四.session生成task方式"></a>四.session生成task方式</h2><p>对于生成每种task的方法,共有4种方式,举downloadTask为例子</p>
<p>1.用urlrequest请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public func downloadTaskWithRequest(request: NSURLRequest) -&gt;</span><br><span class="line">   NSURLSessionDownloadTask 12</span><br></pre></td></tr></table></figure>
<p>2.用url请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public func downloadTaskWithURL(url: NSURL) -&gt; NSURLSessionDownloadTask1</span><br></pre></td></tr></table></figure>
<p>3.带handler的URLRequest请求,注意,如果写了handler,就不会进入代理方法,即使设置了代理也没用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public func downloadTaskWithRequest(request: NSURLRequest, completionHandler: (NSURL?, NSURLResponse?, NSError?) -&gt; Void) -&gt; NSURLSessionDownloadTask1</span><br></pre></td></tr></table></figure>
<p>4.带handler的URL请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public func downloadTaskWithURL(url: NSURL, completionHandler: (NSURL?, NSURLResponse?, NSError?) -&gt; Void) -&gt; NSURLSessionDownloadTask</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<h2 id="五-task分类讲解"><a href="#五-task分类讲解" class="headerlink" title="五.task分类讲解"></a>五.task分类讲解</h2><p>下面讲解每种task的具体使用方法</p>
<p>NSURLSession的代理继承关系如图:<br>NSURLSessionDelegate<br>|<br>NSURLSessionTaskDelegate<br>| | |<br>NSURLSessionDataDelegate NSURLSessionDownloadDelegate NSURLSessionStreamDelegate</p>
<h2 id="1-数据任务-Data-task"><a href="#1-数据任务-Data-task" class="headerlink" title="1. 数据任务 Data task"></a>1. 数据任务 Data task</h2><p>使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let config = NSURLSessionConfiguration.defaultSessionConfiguration()</span><br><span class="line">let url = NSURL(string:datadUrlNeighbor)</span><br><span class="line">task.resume()123</span><br></pre></td></tr></table></figure>
<p>进入代理方法顺序:</p>
<p>1.首先进入NSURLSessionDataDelegate的didReceiveResponse方法.我们要手动在这里调用completionHandler(.Allow).系统才会继续进入下一步的代理方法,否则到此就结束了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveResponse response: NSURLResponse, completionHandler: (NSURLSessionResponseDisposition) -&gt; Void) &#123;</span><br><span class="line"></span><br><span class="line">//这个方法,只有在session的task是datatask的时候才会进入</span><br><span class="line"> completionHandler(.Allow)</span><br><span class="line"></span><br><span class="line">&#125;123456</span><br></pre></td></tr></table></figure>
<p>2.然后进入didReceiveData方法,获得json数据,可以做业务操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) &#123;</span><br><span class="line">    print(&quot;did receive data&quot;)</span><br><span class="line">    let dic = try? NSJSONSerialization.JSONObjectWithData(data, options: .MutableContainers)</span><br><span class="line">    print(&quot;get dic:\(dic!)&quot;)</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure>
<p>3.然后进入didCompleteWithError方法,它是NSURLSessionTaskDelegate的方法,表示请求结束了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func URLSession(session: NSURLSession, task: NSURLSessionTask,  error: NSError?) &#123;</span><br><span class="line">    print(&quot;did complete&quot;)</span><br><span class="line">&#125;123</span><br></pre></td></tr></table></figure>
<h2 id="2-下载任务-Download-task"><a href="#2-下载任务-Download-task" class="headerlink" title="2. 下载任务 Download task"></a>2. 下载任务 Download task</h2><p>使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let config = NSURLSessionConfiguration.defaultSessionConfiguration()</span><br><span class="line">let session = NSURLSession(configuration: config,delegate: self, delegateQueue: NSOperationQueue.mainQueue())</span><br><span class="line"></span><br><span class="line">//方式一 :不使用handler 会进入代理方法</span><br><span class="line">let url = NSURL(string:datadUrlNeighbor)</span><br><span class="line">let downloadTask = session.downloadTaskWithURL(url!)</span><br><span class="line">downloadTask.resume()1234567</span><br></pre></td></tr></table></figure>
<p>进入代理方法顺序:</p>
<p>1.NSURLSessionDownloadDelegate的didWriteData,数据正在写入沙盒的tmp文件夹,就会调用这个方法.它是分批次写入的,每写入一段数据就调用这个方法一次,所以会被多次调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数解释:</span><br><span class="line">bytesWritten是本次写入的数据长度</span><br><span class="line">totalBytesWritten是已经写在磁盘上的长度</span><br><span class="line">totalBytesExpectedToWrite是数据本来的长度</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) &#123;</span><br><span class="line">    print(&quot;didwrite:\(bytesWritten), \(totalBytesWritten), \(totalBytesWritten), \(totalBytesExpectedToWrite)&quot;)</span><br><span class="line">&#125;123</span><br></pre></td></tr></table></figure>
<p>2.NSURLSessionDownloadDelegate的didFinishDownloadingToURL方法,当数据下载完成后,此时的文件是一个以tmp结尾的文件,命名类似于:<br><img src="https://img-blog.csdn.net/20160707160007809" alt="tmp文件"></p>
<p>3.进入这个方法didFinishDownloadingToURL.在这里必须执对tmp文件的转移处理,否则当除了这个方法后,tmp文件就被删除了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) &#123;</span><br><span class="line">    print(&quot;download to url:\(location)&quot;)</span><br><span class="line"></span><br><span class="line">    self.moveToCache(location, name: &quot;ivy.zip&quot;)</span><br><span class="line">    self.tintLabel.text = &quot;download to url&quot;</span><br><span class="line">&#125;123456</span><br></pre></td></tr></table></figure>
<p>4.进入didCompleteWithError方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?)&#123;</span><br><span class="line">&#125;12</span><br></pre></td></tr></table></figure>
<h2 id="三-上传"><a href="#三-上传" class="headerlink" title="三. 上传"></a>三. 上传</h2><p>由于上传本人研究不深入,暂时不写,以后更新本节</p>
<h2 id="四-断点继传"><a href="#四-断点继传" class="headerlink" title="四. 断点继传"></a>四. 断点继传</h2><p>使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line">1. 这里和下载的区别是:task设置为成员变量了,因为在中断的时候,需要这个task来调用cancelByProducingResumeData</span><br><span class="line">2. session也设置为了成员变量,因为在继传的时候,需要用这个session来调用downloadTaskWithResumeData,开启一个新的downloadtask</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//经测试这里写backgroundconfig和defaultconfig都可以</span><br><span class="line">//let config = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier(backgroundId)</span><br><span class="line">let config = NSURLSessionConfiguration.defaultSessionConfiguration()</span><br><span class="line"></span><br><span class="line">downloadSession = NSURLSession(configuration: config,delegate: self, delegateQueue: NSOperationQueue.mainQueue())</span><br><span class="line"></span><br><span class="line">let url = NSURL(string:downloadUrlNeighbor)</span><br><span class="line">downloadSessionTask = downloadSession!.downloadTaskWithURL(url!)</span><br><span class="line">downloadSessionTask!.resume()123456789</span><br></pre></td></tr></table></figure>
<p>顺序:</p>
<h2 id="1-按下中止按钮"><a href="#1-按下中止按钮" class="headerlink" title="1. 按下中止按钮:"></a>1. 按下中止按钮:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在回调块中,保存  self.resumeData,便于在继传时使用</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">downloadSessionTask?.cancelByProducingResumeData(&#123; (data:NSData?) in</span><br><span class="line">    self.resumeData = data</span><br><span class="line">    self.downloadSessionTask = nil //downloadSessionTask已经没用了 要置为nil,因为下次继传时会由session新开一个task</span><br><span class="line">&#125;)1234</span><br></pre></td></tr></table></figure>
<p>如果不按下中止按钮,它进入代理方法的顺序和正常下载是完全一样的.即先进入didWriteData,然后进入didFinishDownloadingToURL,最后didCompleteWithError</p>
<p>如果按下中止按钮,会发生:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 进入didWriteData,毕竟也是写了一些数据的</span><br><span class="line">2. 会进cancelByProducingResumeData的回调,在回调里,我们要记录下resumedata,这是继传时要传入的参数,还要设置成员downloadSessionTask为nil,因为下次的继传会由session创建一个新的task,通过调用downloadTaskWithResumeData</span><br><span class="line">3. 进入代理didCompleteWithError方法</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<h2 id="2-继传"><a href="#2-继传" class="headerlink" title="2. 继传"></a>2. 继传</h2><p>比如我们用一个按钮来启动继传,其中的代码如下:<br>就是保存的成员变量task 调用downloadTaskWithResumeData方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func clickGoOn(sender: AnyObject) &#123;</span><br><span class="line">    guard self.resumeData != nil else&#123;</span><br><span class="line">        return</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //这样写可以进入代理:1 didFinishDownloadingToURL 2 didCompleteWithError</span><br><span class="line">    downloadSessionTask = downloadSession?.downloadTaskWithResumeData(self.resumeData!)</span><br><span class="line">    downloadSessionTask?.resume()</span><br><span class="line">&#125;123456789</span><br></pre></td></tr></table></figure>
<p>由于downloadTaskWithResumeData也有2种方式,带handler和不带handler的,如果调用了带有handler的那个,则不进入代理方法</p>
<p>进入代理方法的顺序:<br>1.didResumeAtOffset</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didResumeAtOffset fileOffset: Int64, expectedTotalBytes: Int64) &#123;</span><br><span class="line">    print(&quot;didresume:\(fileOffset),total:\(expectedTotalBytes)&quot;)</span><br><span class="line">&#125;123</span><br></pre></td></tr></table></figure>
<p>2.didWriteData 又开始写入磁盘了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) &#123;</span><br><span class="line">    print(&quot;didwrite:\(bytesWritten), \(totalBytesWritten), \(totalBytesExpectedToWrite)&quot;)</span><br><span class="line">&#125;123</span><br></pre></td></tr></table></figure>
<p>3.didFinishDownloadingToURL 这个比较重要,一次下载可以多次中止,但是只有全部写入成功后才会进入这个代理, 在这里将 下载的文件转移走,不然出了这个方法会被删除的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) &#123;</span><br><span class="line">    print(&quot;download to url:\(location)&quot;)</span><br><span class="line"></span><br><span class="line">    self.resumeUrl = location</span><br><span class="line">    self.moveToCache(self.resumeUrl, name: &quot;ivy.zip&quot;)</span><br><span class="line"></span><br><span class="line">    self.tintLabel.text = &quot;download to url&quot;</span><br><span class="line">    &#125;12345678</span><br></pre></td></tr></table></figure>
<p>4.didCompleteWithError 这回是真的下载完成了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?)&#123;</span><br><span class="line">    print(&quot;did complete&quot;)</span><br><span class="line">&#125;123</span><br></pre></td></tr></table></figure>
<h2 id="四-后台下载"><a href="#四-后台下载" class="headerlink" title="四. 后台下载"></a>四. 后台下载</h2><p>在下载过程中,如果按home键将app切换到后台,只要不杀死程序,session还能保持其下载能力,完成后,通知到appdelegate的handleEventsForBackgroundURLSession方法.<br>.虽然app不会因此回到前端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line">    1. 后台config必须使用backgroundSessionConfigurationWithIdentifier,要传入一个唯一的标识符</span><br><span class="line"></span><br><span class="line">    2. 有几个下载任务就要创建几个config和session.每个任务都需要一个独立标示的config,以及session</span><br><span class="line"></span><br><span class="line">    3. session必须设置delegate</span><br><span class="line"></span><br><span class="line">    4. 只支持HTTP/HTTPS模式</span><br><span class="line"></span><br><span class="line">    5. 只支持从文件上传,不支持从data上传</span><br><span class="line">(也就是只能用这个函数:func uploadTaskWithRequest(request: NSURLRequest, fromFile fileURL: NSURL, completionHandler: (NSData?, NSURLResponse?, NSError?) -&gt; Void) -&gt; NSURLSessionUploadTask</span><br><span class="line"></span><br><span class="line">    而不能用这个函数:func uploadTaskWithRequest(request: NSURLRequest, fromFile fileURL: NSURL, completionHandler: (NSData?, NSURLResponse?, NSError?) -&gt; Void) -&gt; NSURLSessionUploadTask)</span><br><span class="line"></span><br><span class="line">    6. 请用真机调试,模拟器按下home键之后不会有效果,而是会一直在delegate里下载直到完成为止</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let config = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier(backgroundId)</span><br><span class="line">let session = NSURLSession(configuration:config, delegate:self, delegateQueue: NSOperationQueue.mainQueue())</span><br><span class="line">let url = NSURL(string:downloadUrlNeighbor)</span><br><span class="line">let task = session.downloadTaskWithURL(url!)</span><br><span class="line"></span><br><span class="line">task.resume()123456</span><br></pre></td></tr></table></figure>
<p>进入代理顺序:<br>1.开始下载时<br>NSURLSessionDownloadDelegate代理的didWriteData方法</p>
<p>2.按下home,APP进入后台<br>代理的didWriteData方法不再被进入,而是程序后台静默下载</p>
<p>3.下载完成后</p>
<p>第一步:进入AppDelegate的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: () -&gt; Void) &#123;</span><br><span class="line"></span><br><span class="line">    //self.downloadCompletionHandler = completionHandler</span><br><span class="line"></span><br><span class="line">    print(&quot;----application hadle event&quot;)</span><br><span class="line">    let config = NSURLSessionConfiguration.backgroundSessionConfiguration(identifier)</span><br><span class="line"></span><br><span class="line">    //The new session is automatically reassociated with ongoing background activity.</span><br><span class="line">    //这个session被自动绑定到了后台运行的app</span><br><span class="line">    let session = NSURLSession(configuration: config , delegate:self.mySessionDelegate, delegateQueue:NSOperationQueue.mainQueue())</span><br><span class="line"></span><br><span class="line">        //去使用的类里面注册一个handler, 直接传过去也可以的,其实self.window.rootViewController = xxx也可以的</span><br><span class="line">                                       self.mySessionDelegate.addCompletionHandler(completionHandler, identifier: identifier)</span><br><span class="line">&#125;1234567891011121314</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解释: </span><br><span class="line">     1. 保存handler的方式是多种的, 可以给AppDelegate设置一个dictionary的属性.也可以传入session的delegate的dictionary属性,我选择了后者</span><br><span class="line">     2. 要创建一个session,文档说这个session会被自动绑定到后台的activity</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<p>第二步:</p>
<p>进入NSURLSessionDownloadDelegate的didFinishDownloadingToURL方法,请在这里 搬运下载好的tmp文件</p>
<p>第三步:进入didCompleteWithError</p>
<p>第四步:进入NSURLSessionDelegate的URLSessionDidFinishEventsForBackgroundURLSession方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession)</span><br><span class="line">&#123;</span><br><span class="line">    print(&quot;did finish events&quot;)</span><br><span class="line">    if (session.configuration.identifier != nil) &#123;</span><br><span class="line"></span><br><span class="line">    let handler = self.completionHandlerDictionary![session.configuration.identifier!]</span><br><span class="line">    guard handler != nil else &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    handler!()</span><br><span class="line"></span><br><span class="line">    //移除 dictionary中的数据</span><br><span class="line">                    self.completionHandlerDictionary?.removeValueForKey(session.configuration.identifier!)</span><br><span class="line"></span><br><span class="line">    self.tintLabel.text = &quot;finish event&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819</span><br></pre></td></tr></table></figure>
<p>在第三步或第四步里面, 把从appdelegate里面获取到的handler执行一下,这么做的目的,文档告诉我们是为了让操作系统知道程序可以被继续安全的挂起.</p>
<p>参考文档:<br><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html#//apple_ref/doc/uid/TP40013509-SW44" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html#//apple_ref/doc/uid/TP40013509-SW44</a></p>
<p>demo: <a href="https://github.com/ivychenyucong/TestNSURLSession" target="_blank" rel="noopener">https://github.com/ivychenyucong/TestNSURLSession</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[GPUImage详细解析]]></title>
      <url>/2018/04/12/GPUImage%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>假设我们自定义一个OpenGL ES程序来处理图片，那么会有以下几个步骤：</p>
<p>1、初始化OpenGL ES环境，编译、链接顶点着色器和片元着色器；</p>
<p>2、缓存顶点、纹理坐标数据，传送图像数据到GPU；</p>
<p>3、绘制图元到特定的帧缓存；</p>
<p>4、在帧缓存取出绘制的图像。</p>
<p><code>GPUImageFilter</code>负责的是第一、二、三步。</p>
<p><code>GPUImageFramebuffer</code>负责是第四步。<br><a id="more"></a><br>一、GPUImageFilter解析</p>
<p>GPUImageFilter和响应链的其他元素实现了<code>GPUImageInput</code>协议，他们都可以提供纹理参与响应链，或者从响应链的前面接收并处理纹理。响应链的下一个对象是target，响应链可能有多个分支（添加多个targets）。</p>
<blockquote>
<p>Filters and other subsequent elements in the chain conform to the GPUImageInput protocol, which lets them take in the supplied or processed texture from the previous link in the chain and do something with it. Objects one step further down the chain are considered targets, and processing can be branched by adding multiple targets to a single output or filter.</p>
</blockquote>
<ul>
<li>获取纹理坐标</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (const GLfloat *)textureCoordinatesForRotation:(GPUImageRotationMode)rotationMode;</span><br></pre></td></tr></table></figure>
<ul>
<li>绘制结果输出<br>绘制的结果后输入到<code>outputframebuffer</code>指定的缓存</li>
</ul>
<p><code>usingNextFrameForImageCapture</code>代表着输出的结果会被用于获取图像，所以在绘制之前要加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (usingNextFrameForImageCapture)</span><br><span class="line">&#123;</span><br><span class="line">    [outputFramebuffer lock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>绑定纹理<br><code>glBindTexture(GL_TEXTURE_2D, [firstInputFramebuffer texture]);</code><br>绑定输入纹理，OpenGL ES才能确定要处理纹理数据</li>
<li>绑定顶点和纹理坐标并绘制图元</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(filterPositionAttribute, 2, GL_FLOAT, 0, 0, vertices);</span><br><span class="line">glVertexAttribPointer(filterTextureCoordinateAttribute, 2, GL_FLOAT, 0, 0, textureCoordinates);</span><br><span class="line">glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);</span><br></pre></td></tr></table></figure>
<p><code>GL_TRIANGLE_STRIP</code>模式用于绘制三角形带。<a href="https://link.jianshu.com?t=http://blog.csdn.net/onafioo/article/details/39454233" target="_blank" rel="noopener">这里有介绍</a></p>
<ul>
<li>纹理解锁<br><code>[firstInputFramebuffer unlock];</code> 输入纹理使用完毕，解锁。在调用这个解锁之前必须确定之前已经调用加锁，否则会报错。<br><code>GPUImageFramebuffer</code>使用引用计数来管理缓存，当引用计数小于0的时候会回收缓存。</li>
<li>信号量<br>如果设置了<code>usingNextFrameForImageCapture</code>，则会通过GCD信号量来通知仍在等待绘制完成的函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (usingNextFrameForImageCapture)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_signal(imageCaptureSemaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通知targets<br><code>- (void)informTargetsAboutNewFrameAtTime:(CMTime)frameTime;</code><br>当self的帧绘制完成后，通知自己的targets，并将自己的输出设置为targets的输入纹理:<br><code>[self setInputFramebufferForTarget:currentTarget atIndex:textureIndex];</code><br>然后解锁自己使用的输出缓冲区<code>[[self framebufferForOutput] unlock];</code><br>（在上一个函数已经lock了这个缓冲区，所以这里的unlock不会马上回收内存，等到targets使用完自己的纹理后调用unlock，缓存会被回收）<br>在设置完缓冲区后，self会通知所有targets（除了设置忽略的）<br><code>[currentTarget newFrameReadyAtTime:frameTime atIndex:textureIndex];</code></li>
</ul>
<ul>
<li><strong>等待渲染完成</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (dispatch_semaphore_wait(imageCaptureSemaphore, convertedTimeout) != 0)</span><br><span class="line">&#123;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一系列setter<br><code>- (void)setInteger:(GLint)newInteger forUniformName:(NSString *)uniformName;</code><br>这些函数是设置GLSL里面的变量</li>
</ul>
<h3 id="二、GPUImageFramebuffer"><a href="#二、GPUImageFramebuffer" class="headerlink" title="二、GPUImageFramebuffer"></a>二、GPUImageFramebuffer</h3><p>管理纹理缓存格式、帧缓存的buffer。</p>
<ul>
<li>纹理格式<br>默认的纹理格式<code>defaultTextureOptions</code></li>
<li>缓存创建<br><code>generateTexture</code>会创建对应的纹理缓存<br><code>generateFramebuffer</code>会创建对应的帧缓存<br>注意：iOS5.0以上会使用<code>CVOpenGLESTextureCache</code><br>否则会使用<code>glTexImage2D()</code>，这个我们更熟悉的函数来传送CPU图像数据到GPU</li>
<li>指定渲染目标<br><code>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _texture, 0);</code><br>把渲染目标指定为图像</li>
<li>调整视口大小<br>先绑定自己的帧缓存，再调整视口大小。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)activateFramebuffer;</span><br><span class="line">&#123;</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);</span><br><span class="line">    glViewport(0, 0, (int)_size.width, (int)_size.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解锁<br>当引用计数小于1的时候，会调用下面的函数把自己放回缓存管理cache。（注意这个和 destroyFramebuffer不一样，一个是回收再利用，一个是销毁）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[GPUImageContext sharedFramebufferCache] returnFramebufferToCache:self];</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从帧缓存中读取图片</strong><br>在<code>newCGImageFromFramebufferContents</code>函数获取图像数据。<br><code>CVPixelBufferGetBaseAddress</code> 和  <code>glReadPixels</code>都可以获得图像数据，根据iOS版本不同调用不同函数。<br>最后通过CGImageCreate，创建 CGImageRef，然后返回。</li>
<li>CVPixelBuffer<br>CV像素缓存是一个主内存的图像缓存，应用在渲染帧、压缩解压视频、使用CoreImage都会用到CV像素缓存。<br>在访问CPU的像素数据之前，必须调用CVPixelBufferLockBaseAddress，并在访问后调用CVPixelBufferUnlockBaseAddress。如果lockFLags带有kCVPixelBufferLock_ReadOnly参数，那么unlocking 的时候也需要。</li>
</ul>
<blockquote>
<p>A Core Video pixel buffer is an image buffer that holds pixels in main memory. Applications generating frames, compressing or decompressing video, or using Core Image can all make use of Core Video pixel buffers.</p>
</blockquote>
<ul>
<li>CVOpenGLESTextureCache<br>缓存和管理CVOpenGLESTextureRef纹理，这些纹理缓存提供了一个直接读写多种颜色格式缓存的方式。</li>
</ul>
<blockquote>
<p>Core Video OpenGLES texture caches are used to cache and manage CVOpenGLESTextureRef textures. These texture caches provide you with a way to directly read and write buffers with various pixel formats, such as 420v or BGRA, from GLES.</p>
</blockquote>
<ul>
<li>CVOpenGLESTexture<br>CV纹理是纹理图像缓存，提供OpenGL图像数据</li>
</ul>
<blockquote>
<p>Core Video OpenGLES textures are texture-based image buffers used for supplying source image data to OpenGL.</p>
</blockquote>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>GPUImage的四大输入基础类，都可以作为响应链的起点。这些基础类会把图像作为纹理，传给OpenGL ES处理，然后把纹理传递给响应链的下一个对象。<br><code>GPUImageVideoCamera</code> 摄像头-视频流<br><code>GPUImageStillCamera</code> 摄像头-照相<br><code>GPUImagePicture</code> 图片<br><code>GPUImageMovie</code> 视频<br>响应链，先要理解帧缓存的概念，这在<a href="https://www.jianshu.com/p/1193b98634a2" target="_blank" rel="noopener">OpenGL ES教程-帧缓存</a>有提到过。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用一句话来解释GPUImageFilter就是用来接收源图像，通过自定义的顶点、片元着色器来渲染新的图像，并在绘制完成后通知响应链的下一个对象。<br>GPUImageFramebuffer就是用来管理纹理缓存的格式与读写帧缓存的buffer。</p>
<p>上一篇介绍的是<code>GPUImageFramebuffer</code>和<code>GPUImageFilter</code>。<br>简单回顾一下：</p>
<ul>
<li><code>GPUImageFilter</code>就是用来接收源图像，通过自定义的顶点、片元着色器来渲染新的图像，并在绘制完成后通知响应链的下一个对象。</li>
<li><code>GPUImageFramebuffer</code>就是用来管理纹理缓存的格式与读写帧缓存的buffer。</li>
</ul>
<p>这一篇介绍的是<code>GPUImageVideoCamera</code>和<code>GPUImageView</code>。</p>
<h3 id="GPUImageVideoCamera"><a href="#GPUImageVideoCamera" class="headerlink" title="GPUImageVideoCamera"></a>GPUImageVideoCamera</h3><p>GPUImageVideoCamera是GPUImageOutput的子类，提供来自摄像头的图像数据作为源数据，一般是响应链的源头。</p>
<h4 id="1、视频图像采集-：AVCaptureSession"><a href="#1、视频图像采集-：AVCaptureSession" class="headerlink" title="1、视频图像采集 ：AVCaptureSession"></a>1、视频图像采集 ：AVCaptureSession</h4><p>GPUImage使用<strong>AVFoundation框架</strong>来获取视频。<br>AVCaptureSession类从AV输入设备的采集数据到制定的输出。<br>为了实现实时的图像捕获，要实现AVCaptureSession类，添加合适的输入（AVCaptureDeviceInput）和输出（比如 AVCaptureMovieFileOutput）<br>调用<code>startRunning</code>开始输入到输出的数据流，调用<code>stopRunning</code>停止数据流。<br><strong>需要注意的是startRunning函数会花费一定的时间，所以不能在主线程（UI线程）调用，防止卡顿。</strong><br>sessionPreset 属性可以自定义一些设置。<br>特殊的选项比如说高帧率，可以通过 AVCaptureDevice来设置。<br>AVCaptureSession使用的简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_captureSession = [[AVCaptureSession alloc] init];</span><br><span class="line">    [_captureSession beginConfiguration];</span><br><span class="line">// 中间可以实现关于session属性的设置</span><br><span class="line">    [_captureSession commitConfiguration];</span><br></pre></td></tr></table></figure>
<ul>
<li>AVCaptureVideoDataOutput<br><code>AVCaptureVideoDataOutput</code>是<code>AVCaptureOutput</code>的子类，用来处理从摄像头采集的未压缩或者压缩过的图像帧。<br>通过<code>captureOutput:didOutputSampleBuffer:fromConnection: delegate</code>，可以访问图像帧。<br>通过下面这个方法，可以设置delegate。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSampleBufferDelegate:</span><br><span class="line">(id&lt;AVCaptureVideoDataOutputSampleBufferDelegate&gt;)sampleBufferDelegate </span><br><span class="line">queue:(dispatch_queue_t)sampleBufferCallbackQueue;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，当一个新的视频图像帧被采集后，它会被传送到output，调用这里设置的delegate。所有的delegate函数会在这个queue中调用。<strong>如果队列被阻塞</strong>，新的图像帧到达后会被自动丢弃(默认alwaysDiscardsLateVideoFrames = YES)。这允许app处理当前的图像帧，不需要去管理不断增加的内存，<strong>因为处理速度跟不上采集的速度，等待处理的图像帧会占用内存，并且不断增大</strong>。<br>必须使用<strong>同步队列</strong>处理图像帧，保证帧的序列是顺序的。</p>
<ul>
<li>frameRenderingSemaphore 帧渲染的信号量<br>下面有一个这样的调用，用于等待处理完一帧后，再接着处理下一帧。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (dispatch_semaphore_wait(frameRenderingSemaphore, DISPATCH_TIME_NOW) != 0)</span><br><span class="line">&#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">runAsynchronouslyOnVideoProcessingQueue(^&#123;</span><br><span class="line">      dispatch_semaphore_signal(frameRenderingSemaphore);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>rotateCamera<br>前后摄像头翻转：更改videoInput的设置。</li>
</ul>
<h4 id="2、颜色空间：YUV"><a href="#2、颜色空间：YUV" class="headerlink" title="2、颜色空间：YUV"></a>2、颜色空间：YUV</h4><p>YUV是被欧洲电视系统所采用的一种颜色编码方法。<br>采用YUV色彩空间的重要性是它的<strong>亮度信号Y</strong>和<strong>色度信号U、V</strong>是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就是黑白灰度图像。彩色电视采用YUV空间正是为了用亮度信号Y解决彩色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信号。</p>
<p>YCbCr或Y’CbCr有的时候会被写作：YCBCR或是Y’CBCR，是色彩空间的一种，通常会用于影片中的影像连续处理，或是数字摄影系统中。Y’为颜色的亮度(luma)成分、而CB和CR则为蓝色和红色的浓度偏移量成份。<br>YUV主要用于优化彩色视频信号的传输，使其向后相容老式黑白电视。与RGB视频信号传输相比，它最大的优点在于只需占用极少的频宽（RGB要求三个独立的视频信号同时传输）。</p>
<p>CbCr 则是在世界数字组织视频标准研制过程中作为ITU - R BT.601 建议的一部分，其实是YUV经过缩放和偏移的翻版。其中Y与YUV 中的Y含义一致,Cb,Cr 同样都指色彩，只是在表示方法上不同而已。在YUV 家族中，YCbCr 是在计算机系统中应用最多的成员，其应用领域很广泛，JPEG、MPEG均采用此格式。一般人们所讲的YUV大多是指YCbCr。YCbCr 有许多取样格式，如4∶4∶4,4∶2∶2,4∶1∶1 和4∶2∶0。<br><a href="https://link.jianshu.com?t=http://baike.baidu.com/link?url=_FuHtNrUEbNvpMLpluwQ4qKxSrmJRyTQjcUH2R7eTiqLZd5-xyl2A09sMYeEuPVpI4FVhe6bI7JmG_nWLlX19q" target="_blank" rel="noopener">百度百科的介绍</a><br><a href="https://link.jianshu.com?t=http://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html" target="_blank" rel="noopener">YUV数据格式-图文详解</a><br><strong>GPUImage中的YUV</strong><br><code>GLProgram *yuvConversionProgram;</code> 将YUV颜色空间转换成RGB颜色空间的GLSL。<br><code>CVPixelBufferGetPlaneCount()</code>返回缓冲区的平面数。<br>通过<code>CVOpenGLESTextureCacheCreateTextureFromImage()</code>创建两个纹理luminanceTextureRef（亮度纹理）和chrominanceTextureRef（色度纹理）。<br><code>convertYUVToRGBOutput()</code>把YUV颜色空间的纹理转换成RGB颜色空间的纹理<br>顶点着色器-通用<code>kGPUImageVertexShaderString</code><br>片元着色器：<br>1、<code>kGPUImageYUVFullRangeConversionForLAFragmentShaderString</code><br>2、<code>kGPUImageYUVVideoRangeConversionForLAFragmentShaderString</code><br>区别在不同的格式<br>video-range (luma=[16,235] chroma=[16,240])<br>full-range (luma=[0,255] chroma=[1,255])</p>
<h3 id="3、纹理绘制"><a href="#3、纹理绘制" class="headerlink" title="3、纹理绘制"></a>3、纹理绘制</h3><p>glActiveTextue 并不是激活纹理单元，而是选择当前活跃的纹理单元。每一个纹理单元都有GL_TEXTURE_1D, 2D, 3D 和 CUBE_MAP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line">glGenTextures(1, &amp;_texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, _texture);</span><br></pre></td></tr></table></figure>
<p><a href="https://link.jianshu.com?t=http://stackoverflow.com/questions/8866904/differences-and-relationship-between-glactivetexture-and-glbindtexture" target="_blank" rel="noopener">SO的详细介绍</a></p>
<h3 id="GPUImageView"><a href="#GPUImageView" class="headerlink" title="GPUImageView"></a>GPUImageView</h3><p>GPUImageView是响应链的终点，一般用于显示GPUImage的图像。</p>
<h4 id="1、填充模式"><a href="#1、填充模式" class="headerlink" title="1、填充模式"></a>1、填充模式</h4><p><code>GPUImageFillModeType fillMode</code>图像的填充模式。<br><code>sizeInPixels</code> 像素区域大小。<br><code>recalculateViewGeometry()</code> 重新计算图像顶点位置数据。<br><code>AVMakeRectWithAspectRatioInsideRect()</code> 在保证宽高比不变的前提下，得到一个尽可能大的矩形。<br>如果是kGPUImageFillModeStretch<br>图像拉伸，直接使宽高等于1.0即可，原图像会直接铺满整个屏幕。</p>
<p>如果是kGPUImageFillModePreserveAspectRatio<br>保持原宽高比，并且图像不超过屏幕。那么以当前屏幕大小为准。<br><code>widthScaling = insetRect.size.width / currentViewSize.width;</code></p>
<p>如果是kGPUImageFillModePreserveAspectRatioAndFill<br>保持原宽高比，并且图像要铺满整个屏幕。那么图像大小为准。<br><code>widthScaling = currentViewSize.height / insetRect.size.height;</code></p>
<p>imageVertices存放着顶点数据，上面的修改都会存放在这个数组。</p>
<h3 id="2、OpenGL-ES绘制"><a href="#2、OpenGL-ES绘制" class="headerlink" title="2、OpenGL ES绘制"></a>2、OpenGL ES绘制</h3><p><code>- (void)newFrameReadyAtTime:(CMTime)frameTime atIndex:(NSInteger)textureIndex;</code>源图像已经准备好，开始绘制。<br><code>setDisplayFramebuffer()</code>会绑定GPUImageView的帧缓存，同时调试视口大小为view的大小。<br><code>glActiveTexture</code>上面已经介绍过，是选择一个纹理单元。先选择纹理单元4，然后把源图像数据绑定到GL_TEXTURE_2D的位置上。最后告诉片元着色器，纹理单元是4。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE4);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, [inputFramebufferForDisplay texture]);</span><br><span class="line">glUniform1i(displayInputTextureUniform, 4);</span><br></pre></td></tr></table></figure>
<p>这两行是分别绑定顶点坐标数据和纹理坐标数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(displayPositionAttribute, 2, GL_FLOAT, 0, 0, imageVertices);</span><br><span class="line">glVertexAttribPointer(displayTextureCoordinateAttribute, 2, GL_FLOAT, 0, 0, [GPUImageView textureCoordinatesForRotation:inputRotation]);</span><br></pre></td></tr></table></figure>
<p>这两行是设定输入的源图像数据缓存，并且对缓存加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputFramebufferForDisplay = newInputFramebuffer;</span><br><span class="line">[inputFramebufferForDisplay lock];</span><br></pre></td></tr></table></figure>
<p>在准备好着色器、纹理data、顶点位置坐标和纹理坐标后，就可以调用<br><code>glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);</code>绘制图像。</p>
<ul>
<li><code>GPUImageFilter</code>就是用来接收源图像，通过自定义的顶点、片元着色器来渲染新的图像，并在绘制完成后通知响应链的下一个对象。</li>
<li><code>GPUImageFramebuffer</code>就是用来管理纹理缓存的格式与读写帧缓存的buffer。</li>
<li><code>GPUImageVideoCamera</code>是<code>GPUImageOutput</code>的子类，提供来自摄像头的图像数据作为源数据，一般是响应链的源头。</li>
<li><code>GPUImageView</code>是响应链的终点，一般用于显示GPUImage的图像。</li>
</ul>
<p><a href="https://www.jianshu.com/users/131423baa3c6" target="_blank" rel="noopener">琨君</a>的<a href="https://www.jianshu.com/p/945fc806a9b4" target="_blank" rel="noopener">基于GPUImage的实时美颜滤镜</a>对GPUImage实现美颜滤镜的原理和思路做了详细介绍。<br>本文以<a href="https://link.jianshu.com?t=https://github.com/Guikunzhi/BeautifyFaceDemo" target="_blank" rel="noopener">琨君的代码</a>为demo，结合前两篇解析，探究美颜过程中的GPUImage实现。</p>
<h3 id="GPUImage类介绍"><a href="#GPUImage类介绍" class="headerlink" title="GPUImage类介绍"></a>GPUImage类介绍</h3><h4 id="1、GPUImageFilterGroup"><a href="#1、GPUImageFilterGroup" class="headerlink" title="1、GPUImageFilterGroup"></a>1、GPUImageFilterGroup</h4><p><code>GPUImageFilterGroup</code>是多个filter的集合，<code>terminalFilter</code>为最终的filter，<code>initialFilters</code>为filter数组。<code>GPUImageFilterGroup</code>本身不绘制图像，对<code>GPUImageFilterGroup</code>添加删除Target操作的操作都会转为<code>terminalFilter</code>的操作。</p>
<h4 id="2、GPUImageTwoInputFilter"><a href="#2、GPUImageTwoInputFilter" class="headerlink" title="2、GPUImageTwoInputFilter"></a>2、GPUImageTwoInputFilter</h4><p><code>GPUImageTwoInputFilter</code>是<code>GPUImageFilter</code>的子类，对两个输入纹理进行通用的处理，需要继承它并准备自己的片元着色器。<br>两个输入纹理默认为<code>inputImageTexture</code>和<code>inputImageTexture2</code>。</p>
<ul>
<li>重写了下面的函数，修改<code>GPUImageFilter</code>绘制的逻辑。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)renderToTextureWithVertices:(const GLfloat *)vertices</span><br><span class="line"> textureCoordinates:(const GLfloat *)textureCoordinates;</span><br></pre></td></tr></table></figure>
<p>下面这部分是核心的绘制逻辑：<br><code>glActiveTexture()</code>是选择纹理单元，<code>glBindTexture()</code>是把纹理单元和<code>firstInputFramebuffer</code>、<code>secondInputFramebuffer</code>管理的纹理内存绑定。<code>glUniform1i()</code>告诉GLSL选择的纹理单元是2。<br>这部分在上一篇介绍也有提到，再详细阐述：<code>glActiveTexture()</code>选择的是纹理单元，和<code>glGenTextures()</code>返回的数字没有关系，可以在纹理单元2上面绑定纹理12。<br><code>glGenTextures()</code>返回的纹理可以是<code>GL_TEXTURE_2D</code>类型也可以是<code>GL_TEXTURE_CUBE_MAP</code>类型，取决于<code>glBindTexture()</code>第一次绑定纹理的是<code>GL_TEXTURE_2D</code>还是<code>GL_TEXTURE_CUBE_MAP</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE2);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, [firstInputFramebuffer texture]);</span><br><span class="line">glUniform1i(filterInputTextureUniform, 2);    </span><br><span class="line"></span><br><span class="line">glActiveTexture(GL_TEXTURE3);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, [secondInputFramebuffer texture]);</span><br><span class="line">glUniform1i(filterInputTextureUniform2, 3);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>nextAvailableTextureIndex</code>用于获取下一个纹理索引</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)nextAvailableTextureIndex;</span><br><span class="line">&#123;</span><br><span class="line">    if (hasSetFirstTexture)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setInputFramebuffer: atIndex:</code>会根据上面获取的<code>textureIndex</code>设置<code>firstInputFramebuffer</code>和<code>secondInputFramebuffer</code>。如果是<code>textureIndex = 0</code>，设置<code>hasSetFirstTexture</code>表示已经设置第一个纹理。</p>
<h4 id="3、GPUImageThreeInputFilter"><a href="#3、GPUImageThreeInputFilter" class="headerlink" title="3、GPUImageThreeInputFilter"></a>3、GPUImageThreeInputFilter</h4><p><code>GPUImageThreeInputFilter</code>的逻辑与<code>GPUImageTwoInputFilter</code>类似，增加了<code>thirdInputFramebuffer</code>作为第三个纹理<code>inputImageTexture3</code>的输入。</p>
<h4 id="4、GPUImageBeautifyFilter"><a href="#4、GPUImageBeautifyFilter" class="headerlink" title="4、GPUImageBeautifyFilter"></a>4、GPUImageBeautifyFilter</h4><p><code>GPUImageBeautifyFilter</code>是<a href="https://www.jianshu.com/p/945fc806a9b4" target="_blank" rel="noopener">基于GPUImage的实时美颜滤镜</a>中的美颜滤镜，包括<code>GPUImageBilateralFilter</code>、<code>GPUImageCannyEdgeDetectionFilter</code>、<code>GPUImageCombinationFilter</code>、<code>GPUImageHSBFilter</code>。</p>
<h3 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h3><p><img src="http://upload-images.jianshu.io/upload_images/1049769-0ee35b29d82b7799.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>绘制流程图</p>
<ul>
<li>1、<code>GPUImageVideoCamera</code>捕获摄像头图像<br>调用<code>newFrameReadyAtTime: atIndex:</code>通知<code>GPUImageBeautifyFilter</code>；</li>
<li>2、<code>GPUImageBeautifyFilter</code>调用<code>newFrameReadyAtTime: atIndex:</code><br>通知<code>GPUImageBilateralFliter</code>输入纹理已经准备好；</li>
<li>3、<code>GPUImageBilateralFliter</code> 绘制图像后在<code>informTargetsAboutNewFrameAtTime()</code>，<br>调用<code>setInputFramebufferForTarget: atIndex:</code><br>把绘制的图像设置为<code>GPUImageCombinationFilter</code>输入纹理，<br>并通知<code>GPUImageCombinationFilter</code>纹理已经绘制完毕；</li>
<li>4、<code>GPUImageBeautifyFilter</code>调用<code>newFrameReadyAtTime: atIndex:</code><br>通知 <code>GPUImageCannyEdgeDetectionFilter</code>输入纹理已经准备好；</li>
<li>5、同3，<code>GPUImageCannyEdgeDetectionFilter</code> 绘制图像后，<br>把图像设置为<code>GPUImageCombinationFilter</code>输入纹理；</li>
<li>6、<code>GPUImageBeautifyFilter</code>调用<code>newFrameReadyAtTime: atIndex:</code><br>通知 <code>GPUImageCombinationFilter</code>输入纹理已经准备好；</li>
<li>7、<code>GPUImageCombinationFilter</code>判断是否有三个纹理，三个纹理都已经准备好后<br>调用<code>GPUImageThreeInputFilter</code>的绘制函数<code>renderToTextureWithVertices: textureCoordinates:</code>，<br>图像绘制完后，把图像设置为<code>GPUImageHSBFilter</code>的输入纹理,<br>通知<code>GPUImageHSBFilter</code>纹理已经绘制完毕；</li>
<li>8、<code>GPUImageHSBFilter</code>调用<code>renderToTextureWithVertices: textureCoordinates:</code>绘制图像，<br>完成后把图像设置为<code>GPUImageView</code>的输入纹理，并通知<code>GPUImageView</code>输入纹理已经绘制完毕；</li>
<li>9、<code>GPUImageView</code>把输入纹理绘制到自己的帧缓存，然后通过<br><code>[self.context presentRenderbuffer:GL_RENDERBUFFER];</code>显示到<code>UIView</code>上。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>GPUImageFilter<br>GPUImageFramebuffer<br>GPUImageVideoCamera<br>GPUImageView<br>GPUImageFilterGroup<br>GPUImageTwoInputFilter<br>GPUImageThreeInputFilter<br>这是学习这个demo需要了解的7个类。<br>在绘制流程图的过程中，对GPUImage的响应链有了更清晰的认识。</p>
<p>这次介绍的<code>GPUImageContext</code>、<code>GPUImageFramebufferCache</code>和<code>GPUImagePicture</code>。</p>
<h3 id="GPUImageContext"><a href="#GPUImageContext" class="headerlink" title="GPUImageContext"></a>GPUImageContext</h3><p>GPUImageContext是GPUImage对OpenGL ES上下文的封装，添加了GPUImage相关的上下文，比如说Program的使用缓存，处理队列，CV纹理缓存等。</p>
<h4 id="1、属性介绍"><a href="#1、属性介绍" class="headerlink" title="1、属性介绍"></a>1、属性介绍</h4><p><code>contextQueue</code>                       统一处理队列<br><code>currentShaderProgram</code>         正在使用的program<br><code>context</code>                   OpenGL ES的上下文<br><code>coreVideoTextureCache</code>       CV纹理缓存<br><code>framebufferCache</code>                GPUImageBuffer缓存<br><code>shaderProgramCache</code>               Program的缓存<br><code>shaderProgramUsageHistory</code>    Program的使用历史</p>
<h4 id="2、方法介绍"><a href="#2、方法介绍" class="headerlink" title="2、方法介绍"></a>2、方法介绍</h4><ul>
<li><code>useAsCurrentContext()</code> 在useAsCurrentContext设置当前上下文的时候，会先判断上下文是否是当前context，不是再设置（为了避免上下文切换的性能消耗，即使设置的上下文是同一个上下文也会消耗性能）</li>
<li><code>sizeThatFitsWithinATextureForSize()</code> 会调整纹理大小，如果超过最大的纹理，会调整为不超过最大的纹理宽高。</li>
<li><code>(GLProgram*)programForVertexShaderString:fragmentShaderString:;</code><br>shaderProgramCache 是program的缓存，由顶点shader和片元shader字符串拼接起来做key。</li>
<li><code>- (void)useSharegroup:(EAGLSharegroup *)sharegroup;</code><br>EAGLSharegroup类管理一个或者多个EAGLContext的OpenGLES资源；这个是一个封闭的类，没有开发者API。负责管理纹理缓存、顶点缓存、帧缓存、颜色缓存。（textures, buffers, framebuffers, and render buffers）</li>
<li><code>- (EAGLContext *)context;</code>返回OpenGL ES2.0的上下文，同时设置<code>glDisable(GL_DEPTH_TEST);</code>，图像处理管道默认不允许使用深度缓存。</li>
</ul>
<h3 id="GPUImageFramebufferCache"><a href="#GPUImageFramebufferCache" class="headerlink" title="GPUImageFramebufferCache"></a>GPUImageFramebufferCache</h3><p>GPUImageFramebufferCache是GPUImageFrameBuffer的管理类</p>
<h4 id="1、属性介绍-1"><a href="#1、属性介绍-1" class="headerlink" title="1、属性介绍"></a>1、属性介绍</h4><p><code>CacheframebufferCache</code> 缓存字典<br><code>framebufferTypeCounts</code> 缓存数量字典<br><code>activeImageCaptureList</code> 正在读取Image数据的GPUImageFrameBuffer列表<br><code>framebufferCacheQueue</code> 缓存队列</p>
<h4 id="2、方法介绍-1"><a href="#2、方法介绍-1" class="headerlink" title="2、方法介绍"></a>2、方法介绍</h4><ul>
<li><code>- (NSString *)hashForSize: textureOptions:onlyTexture:;</code><br>根据size、textureOptions和onlyTexture，创建缓存字符串。<br>缓存字符串+当前缓存数量形成framebufferCache缓存的key。<br>如果找不到framebufferCache对应的数量，会创建新的缓存。</li>
<li><code>- (void)returnFramebufferToCache:;</code>回收缓存。根据size、textureOptions和onlyTexture，创建缓存字符串，缓存字符串+当前缓存数量形成framebufferCache缓存的key。（之所以会加上数量，是因为缓存字符串不唯一）</li>
<li><code>- (void)addFramebufferToActiveImageCaptureList:;</code><br><code>- (void)removeFramebufferFromActiveImageCaptureList:</code><br>这两个方法主要用于，当<code>newCGImageFromFramebufferContents()</code>读取帧缓存图像数据时，保持GPUImageFramebuffer的引用。并且读取完数据后，在<code>dataProviderUnlockCallback()</code>方法释放。</li>
</ul>
<h3 id="GPUImagePicture"><a href="#GPUImagePicture" class="headerlink" title="GPUImagePicture"></a>GPUImagePicture</h3><p>GPUImagePicture是PGUImage的图像处理类，继承GPUImageOutput，一般作为响应链的源头。</p>
<h4 id="1、属性介绍-2"><a href="#1、属性介绍-2" class="headerlink" title="1、属性介绍"></a>1、属性介绍</h4><p>pixelSizeOfImage 图像的像素大小。<br>hasProcessedImage 图像是否已处理。<br>imageUpdateSemaphore 图像处理的GCD信号量。</p>
<h4 id="2、方法介绍-2"><a href="#2、方法介绍-2" class="headerlink" title="2、方法介绍"></a>2、方法介绍</h4><ul>
<li><code>- (id)initWithCGImage:smoothlyScaleOutput:</code> 用源图像newImageSource和是否采用mipmaps来初始化GPUImagePicture。<br>如果图像大小超过OpenGL ES最大纹理宽高，或者使用mipmaps，或者图像数据是浮点型、颜色空间不对等都会采用CoreGraphics重新绘制图像。<br>然后通过glTexImage2D把图像数据发送给GPU，最后释放掉CPU的图像数据。</li>
<li><code>- (BOOL)processImageWithCompletionHandler:;</code> 通知targets处理图像，并在完成后调用complete代码块。在处理开始时，会标记hasProcessedImage为YES，并调用<code>dispatch_semaphore_wait()</code>，确定上次处理已经完成，否则取消这次处理。</li>
</ul>
<ul>
<li><p><code>- (void)addTarget: atTextureLocation:;</code>添加target到响应链。如果hasProcessedImage为YES，表示图像已经处理完毕，直接设置targets的InputSize，并调用<code>newFrameReadyAtTime()</code>通知target。</p>
<p>​</p>
</li>
</ul>
<p>将GPUImageView设置为self.view，根据face.png，设置GPUImagePicture，然后添加GPUImageTiltShiftFilter到响应链，再把GPUImageView作为响应链的终点，最后调用processImage，开始处理图像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GPUImageView *primaryView = [[GPUImageView alloc] initWithFrame:self.view.frame];</span><br><span class="line">self.view = primaryView;</span><br><span class="line">UIImage *inputImage = [UIImage imageNamed:@&quot;face.png&quot;];</span><br><span class="line">_sourcePicture = [[GPUImagePicture alloc] initWithImage:inputImage];</span><br><span class="line">_sepiaFilter = [[GPUImageTiltShiftFilter alloc] init];</span><br><span class="line">_sepiaFilter.blurRadiusInPixels = 40.0;</span><br><span class="line">[_sepiaFilter forceProcessingAtSize:primaryView.sizeInPixels];</span><br><span class="line">[_sourcePicture addTarget:_sepiaFilter];</span><br><span class="line">[_sepiaFilter addTarget:primaryView];</span><br><span class="line">[_sourcePicture processImage];</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>最近因为直播用户增长太快，忙着优化原来的逻辑，研读源代码的时间变少。<br>同时为了写这篇文章，查了一些关于图像资料，末尾附上。<br>下一篇文章可能会介绍今年大火的直播APP的一种速成方案，也可能会是GPUImageMovie的介绍。<br>喜欢的点一下关注，不迷路。</p>
<p><a href="https://link.jianshu.com?t=http://www.cppblog.com/wc250en007/archive/2011/08/06/152653.html" target="_blank" rel="noopener">MIPMAP</a></p>
<blockquote>
<p>Mipmap纹理技术是目前解决纹理分辨率与视点距离关系的最有效途径,它会先将图片压缩成很多逐渐缩小的图片,例如一张64<em>64的图片,会产生64</em>64,32<em>32,16</em>16,8<em>8,4</em>4,2<em>2,1</em>1的7张图片,当屏幕上需要绘制像素点为20<em>20 时，程序只是利用 32</em>32 和 16<em>16 这两张图片来计算出即将显示为 20</em>20 大小的一个图片，这比单独利用 32*32 的那张原始片计算出来的图片效果要好得多，速度也更快.</p>
</blockquote>
<p><a href="https://link.jianshu.com?t=http://www.tuicool.com/articles/77nQbyr" target="_blank" rel="noopener">图像数据格式</a></p>
<blockquote>
<p>kCGImageAlphaLast：alpha 分量存储在每个像素中的低位，如RGBA。<br>kCGImageAlphaFirst：alpha 分量存储在每个像素中的高位，如ARGB。<br>kCGImageAlphaPremultipliedLast：alpha 分量存储在每个像素中的低位，同时颜色分量已经乘以了 alpha 值。<br>kCGImageAlphaPremultipliedFirst：alpha 分量存储在每个像素中的高位，同时颜色分量已经乘以了 alpha 值。<br>kCGImageAlphaNoneSkipLast：没有 alpha 分量。如果像素的总大小大于颜色空间中颜色分量数目所需要的空间，则低位将被忽略。<br>kCGImageAlphaNoneSkipFirst：没有 alpha 分量。如果像素的总大小大于颜色空间中颜色分量数目所需要的空间，则高位将被忽略。</p>
</blockquote>
<p><a href="https://link.jianshu.com/?t=https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage1D.xml" target="_blank" rel="noopener">图像颜色空间</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift - 使用ijkplayer框架播放直播视频1——（RTMP/HTTP视频流播放）]]></title>
      <url>/2018/04/11/Swift%20-%20%E4%BD%BF%E7%94%A8ijkplayer%E6%A1%86%E6%9E%B6%E6%92%AD%E6%94%BE%E7%9B%B4%E6%92%AD%E8%A7%86%E9%A2%911%E2%80%94%E2%80%94RTMP:HTTP%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/</url>
      <content type="html"><![CDATA[<p>转载 2017年03月10日 11:53:03</p>
<ul>
<li>**868</li>
</ul>
<p>最近在研究IOS下播放RTSP RTMP等视频流，目前已测试成功。</p>
<p>转载地址：<a href="http://www.hangge.com/blog/cache/detail_1326.html" target="_blank" rel="noopener">http://www.hangge.com/blog/cache/detail_1326.html</a></p>
<p><strong>BiliBili</strong>（简称B站），想必大家都不陌生。<strong>Ijkplayer </strong>框架是B站提供了一个开源的流媒体解决方案，集成了 <strong>ffmpeg</strong>，还支持硬解码(需 <strong>iOS8 </strong>以上版本)。使用 <strong>Ijkplayer </strong>框架我们可以很方便地实现视频直播功能（<strong>Http</strong>/<strong>RTMP</strong>/<strong>RTSP </strong>这几种直播源都支持）。</p>
<p>本文主要介绍如何使用 <strong>Ijkplayer </strong>框架播放在线直播视频（当然其本地播放能力也很强大）。对于几种直播流不太清楚地，可以参考我前面写的这篇文章：<a href="http://www.hangge.com/blog/cache/detail_1325.html" target="_blank" rel="noopener">RTMP、RTSP、HTTP视频协议详解（附：直播流地址、播放软件）</a></p>
<p>一，环境部署</p>
<p>在使用 <strong>Ijkplayer </strong>前，我们需要先搭建运行环境。</p>
<p>1，在“终端”中运行如下命令，安装homebrew, git, yasm等环境。</p>
<p><strong>2，将Ijkplayer项目下载到本地</strong></p>
<p><strong>GitHub</strong></p>
<p>地址：<br><a id="more"></a><br><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">https://github.com/Bilibili/ijkplayer</a></p>
<p>或者在“终端”中使用 </p>
<p><strong>git </strong></p>
<p>命令下载到本地：</p>
<p><strong>3，将ffmpeg集成到ijkplayer中</strong></p>
<p>运行如下命令，进入项目文件夹并集成 </p>
<p><strong>ffmpeg</strong></p>
<p>。</p>
<p><strong>二、运行样例</strong></p>
<p><strong>Ijkplayer </strong></p>
<p>工程目录中自带了一个 </p>
<p><strong>demo </strong></p>
<p>样例，我们可以先运行下看看效果。</p>
<p>1，打开ios文件夹下的IJKMediaDemo工程</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081117283895816.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>2，运行后界面如下</p>
<p>可以选择播放本地文件，或者输入视频地址来播放。同时 <strong>demo </strong>中还自带了一些视频源，可以直接点击播放。</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081210384997901.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>3，在Input URL页面中输入视频地址即可播放</p>
<p>不过程序默认做了限制，只能播放 <strong>http</strong>/<strong>https </strong>视频流。</p>
<p>我们这里可以修改下，放开限制。让其也能支持其它协议视频播放（比如 <strong>RTMP </strong>协议）。</p>
<p>将 <strong>IJKDemoInputURLViewController.m</strong> 中的相关判断给注释掉即可。</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081210435476945.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>三、将Ijkplayer集成到我们的项目中来</p>
<p>下面我们通过一个样例演示在我们项目中如何通过 <strong>ijkplayer </strong>来播放视频流。官方提供的 <strong>demo </strong>用的是 <strong>OC</strong>，这里我使用 <strong>Swift </strong>来实现。</p>
<p>1，制作framework</p>
<p>首先我们要将 <strong>IJKMediaPlayer </strong>编译成 <strong>framework</strong>，这样不仅体积小，而且使用起来也更加方便。</p>
<p>（1）打开 <strong>IJKMediaPlayer.xcodeproj</strong>（<strong>ios</strong>/<strong>IJKMediaPlayer </strong>文件夹下）</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081213455324170.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>（2）点击<strong> IJKMediaFramework </strong>出现选择框，选择 <strong>edit scheme</strong></p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081213473781299.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>（3）将 <strong>build configuration </strong>改为 <strong>Release</strong></p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081213495029381.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>（4）分别在模拟器和真机(<strong>Generic iOS Device </strong>也可以)上编译</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081213513624889.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081213514438049.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>（5）我们打开生成 <strong>framework </strong>的目录</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081213541149023.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>（6）可以看到这里生成了两个 <strong>framework</strong>。看名字就知道一个是给模拟器使用，一个是给真机使用。这个根据个人的运行需求选择对应的 <strong>framework</strong>。</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081213554199381.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p><strong>framework </strong></p>
<p>我们进入 <strong>Products </strong>目录，输入如下 <strong>lipo </strong>命令将二者合并输出：</p>
<p>（8）接着将合并后的 </p>
<p><strong>framework </strong></p>
<p>拷贝到 </p>
<p><strong>Release-iphoneos/IJKMediaFramework.framework </strong></p>
<p>中</p>
<p>（9）我们可以通过 </p>
<p><strong>lipo -info IJKMediaFramework</strong></p>
<p> 命令查看 </p>
<p><strong>framework </strong></p>
<p>支持情况。可看到现在这个真机、模拟器都是支持的。</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081214073244678.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>2，项目配置</p>
<p>（1）我们将前面制作好的 <strong>framework</strong>（<strong>Release-iphoneos/IJKMediaFramework.framework</strong>）添加到我们项目中来。</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081214132973365.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>AudioToolbox.framework<br>AVFoundation.framework<br>CoreGraphics.framework<br>CoreMedia.framework<br>CoreVideo.framework<br>libbz2.tbd<br>libz.tbd<br>MediaPlayer.framework<br>MobileCoreServices.framework<br>OpenGLES.framework<br>QuartzCore.framework<br>UIKit.framework<br>VideoToolbox.framework</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081214195443318.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>四、测试样例</p>
<p>项目配置完毕后，接下来写一个简单的样例演示如何使用 <strong>ijkplayer</strong>。</p>
<p>1，样例效果图</p>
<p>程序启动后会自动播放一个采用 <strong>RTMP </strong>协议的直播，并全屏显示。</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081214401968319.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>同时播放视图会自适应手机横、竖两种状态。</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html#" target="_blank" rel="noopener"><img src="http://www.hangge.com/blog_uploads/201608/2016081214403018188.png" alt="原文:Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放）"></a></p>
<p>2，样例代码</p>
<p>原文出自：</p>
<p>www.hangge.com</p>
<p>  转载请保留原文链接：</p>
<p><a href="http://www.hangge.com/blog/cache/detail_1326.html" target="_blank" rel="noopener">http://www.hangge.com/blog/cache/detail_1326.html</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[AppIcon和LaunchImage尺寸]]></title>
      <url>/2018/04/10/AppIcon%E5%92%8CLaunchImage%E5%B0%BA%E5%AF%B8/</url>
      <content type="html"><![CDATA[<p>1、AppIcon 尺寸</p>
<p>iPhone Notification iOS 7-10 20pt                             2x( 40x40 )  3x( 60x60 )</p>
<p>iPhone、Spotlight iOS 5,6 、Settings iOS 5-10  29pt   2x( 58x58 )  3x( 87x87 )</p>
<p>iPhone Spotlight iOS 7-10 40pt                                 2x( 80x80 )   3x( 120x120 )</p>
<p>iPhone APP iOS 7-10 60pt                                        2x( 120x120 )  3x( 180x180 )</p>
<p>iPad Notifications 7-10 20pt                                      1x( 20x20 )  2x( 40x40 )</p>
<p>iPad Settings 5-10 29pt                                            1x( 29x29 )  2x( 58x58 )</p>
<p>iPad Spotlight iOS 7-10 40pt                                     1x( 40x40 )  2x( 80x80 )</p>
<p>iPad App iOS 7-10 76pt                                            1x( 76x76 )  2x( 152x152 )</p>
<p>iPad Pro App iOS 9-10 83.5                                      2x( 167x167 )</p>
<p>2、LaunchImage尺寸</p>
<p>iPhone X  1125 * 2436  必要</p>
<p>iPhone Portrait  iOS 5,6        1x( 320x480 )  2x( 640x960 ) Retina4( 640x1136 )</p>
<p>iPhone Portrait iOS 8,9         Retina HD 5.5( 1242x2208 )  Retina HD 4.7( 750x1334 )  必要</p>
<p>iPhone Portrait iOS 7-9        2x( 640x960 )  Retina4( 640x1136 )  必要(没有的话 在5上边有问题)</p>
<p>iPhone Landscape iOS 8,9    Retina HD 5.5( 2208x1242 )</p>
<p>iPad Portrait iOS 5,6            1x( 768x1024 )  2x( 1536x2048 )</p>
<p>iPad Portait iOS 7-9            1x( 768x1024 )  2x( 1536x2048 )</p>
<p>iPad Landscape iOS 5,6       1x( 1024x768 )  2x( 2048x1536 )</p>
<p>iPad Landscape 7-9            1x( 1024x768 )  2x( 2048x1536 )</p>
<p>iPad Portrait Without Status Bar iOS 5,6           1x( 768x1004 )  2x( 1536x2008 )</p>
<p>iPad Landscape Without Status Bar iOS 5,6      1x( 1024x748 )  2x( 2048x1496 )<br><a id="more"></a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[iPhone通过usb与windows实现通信]]></title>
      <url>/2018/04/10/iPhone%E9%80%9A%E8%BF%87usb%E4%B8%8Ewindows%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>之前没怎么接触过这方面知识，最近有个需求需要实现这方面功能。于是上网查找资料，写了个小程序，实现了iPhone端和windows端的互联通信，原理基本上是这样的：windows端运行一个叫做usbmuxd的多路复用守护进程，该进程的作用是建立本地端口和远程端口的转发，实现usb到tcp的转换服务。window端通过本地127.0.0.1:27015连接到usb，然后指定和iPhone进行通信的端口（例如2345）。同样，iPhone端也指定对应连接地址127.0.0.1:2345。根据相关usb协议，客户端将请求包发送到usbmuxd进程，通过usbmuxd转发到对方设备，实现tcp连接。实现过程如下：</p>
<p><strong>1、安装服务</strong></p>
<p>windows端首先要安装苹果公司提供的相关服务，才能实现通信功能。服务名称为：AppleApplicationSupport和AppleMobileDeviceSupport</p>
<p><strong>2、协议内容</strong><br><a id="more"></a><br>enum usbmuxd_result{</p>
<p>RESULT_OK = 0,</p>
<p>RESULT_BADCOMMAND = 1,</p>
<p>RESULT_BADDEV = 2,</p>
<p>RESULT_CONNREFUSED = 3,</p>
<p>//??</p>
<p>//??</p>
<p>RESULT_BADVERSION = 6,</p>
<p>};</p>
<p>enum usbmuxd_msgtype{</p>
<p>MESSAGE_RESULT = 1,</p>
<p>MESSAGE_CONNECT = 2,</p>
<p>MESSAGE_LISTEN = 3,</p>
<p>MESSAGE_DEVICE_ADD = 4,</p>
<p>MESSAGE_DEVICE_REMOVE = 5,</p>
<p>//??</p>
<p>//??</p>
<p>MESSAGE_PLIST = 8,</p>
<p>};</p>
<p>enum usbmuxd_header{</p>
<p>uint32_t length; // length of message, including header</p>
<p>uint32_t version; // protocol version</p>
<p>uint32_t message; // message type</p>
<p>uint32_t tag; // responses to this query will echo back</p>
<p>};</p>
<p><strong>3、运行程序</strong></p>
<p>windows端和iPhone分别运行客户端程序，指定ip地址和端口，就可以进行通信了</p>
<p><strong>4、本人参考代码</strong></p>
<p>window端：<a href="https://github.com/Polyfun/libimobiledevice-windows" target="_blank" rel="noopener">https://github.com/Polyfun/libimobiledevice-windows</a></p>
<p>iPhone端：<a href="https://github.com/rsms/peertalk" target="_blank" rel="noopener">https://github.com/rsms/peertalk</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS：GPUImage强大的图像处理框架]]></title>
      <url>/2018/04/09/GPUImage%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%5D/</url>
      <content type="html"><![CDATA[<p>附一张GPUImage的结构图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2348494-7f030c0295b0fc7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>GPUImage.png</p>
<h5 id="GPUImage中的几个概念"><a href="#GPUImage中的几个概念" class="headerlink" title="GPUImage中的几个概念"></a>GPUImage中的几个概念</h5><p><code>output</code>为输出源<br><code>input</code>为输入源<br><code>filter</code>为滤镜</p>
<h5 id="GPUImage的四大输入基础类"><a href="#GPUImage的四大输入基础类" class="headerlink" title="GPUImage的四大输入基础类"></a>GPUImage的四大输入基础类</h5><p><code>GPUImageVideoCamera</code> 摄像头-视频流<br><code>GPUImageStillCamera</code> 摄像头-照相<br><code>GPUImagePicture</code> 图片<br><code>GPUImageMovie</code> 视频<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">  #import &quot;GPUImageBrightnessFilter.h&quot;                //  亮度 </span><br><span class="line">  #import &quot;GPUImageExposureFilter.h&quot;                  //曝光  </span><br><span class="line">  #import &quot;GPUImageContrastFilter.h&quot;                  //对比度： </span><br><span class="line">  #import &quot;GPUImageSaturationFilter.h&quot;                //饱和度 </span><br><span class="line">  #import &quot;GPUImageGammaFilter.h&quot;                     //gamma：要应用的灰度调整（0.0 - 3.0，默认为1.0）</span><br><span class="line">  #import &quot;GPUImageColorInvertFilter.h&quot;               //反色</span><br><span class="line">  #import &quot;GPUImageSepiaFilter.h&quot;                     //褐色（怀旧）</span><br><span class="line">  #import &quot;GPUImageLevelsFilter.h&quot;                    //色阶</span><br><span class="line">  #import &quot;GPUImageGrayscaleFilter.h&quot;                 //灰度</span><br><span class="line">  #import &quot;GPUImageHistogramFilter.h&quot;                 //色彩直方图，显示在图片上</span><br><span class="line">  #import &quot;GPUImageHistogramGenerator.h&quot;              //色彩直方图</span><br><span class="line">  #import &quot;GPUImageRGBFilter.h&quot;                       //RGB</span><br><span class="line">  #import &quot;GPUImageToneCurveFilter.h&quot;                 //色调曲线</span><br><span class="line">  #import &quot;GPUImageMonochromeFilter.h&quot;                //单色</span><br><span class="line">  #import &quot;GPUImageOpacityFilter.h&quot;                   //不透明度</span><br><span class="line">  #import &quot;GPUImageHighlightShadowFilter.h&quot;           //提亮阴影</span><br><span class="line">  #import &quot;GPUImageFalseColorFilter.h&quot;                //色彩替换（替换亮部和暗部色彩）</span><br><span class="line">  #import &quot;GPUImageHueFilter.h&quot;                       //色度</span><br><span class="line">  #import &quot;GPUImageChromaKeyFilter.h&quot;                 //色度键</span><br><span class="line">  #import &quot;GPUImageWhiteBalanceFilter.h&quot;              //白平横</span><br><span class="line">  #import &quot;GPUImageAverageColor.h&quot;                    //像素平均色值</span><br><span class="line">  #import &quot;GPUImageSolidColorGenerator.h&quot;             //纯色</span><br><span class="line">  #import &quot;GPUImageLuminosity.h&quot;                      //亮度平均</span><br><span class="line">  #import &quot;GPUImageAverageLuminanceThresholdFilter.h&quot; //像素色值亮度平均，图像黑白（有类似漫画效果） </span><br><span class="line">  #import &quot;GPUImageLookupFilter.h&quot;                    //lookup 色彩调整</span><br><span class="line">  #import &quot;GPUImageAmatorkaFilter.h&quot;                  //Amatorka lookup</span><br><span class="line">  #import &quot;GPUImageMissEtikateFilter.h&quot;               //MissEtikate lookup</span><br><span class="line">  #import &quot;GPUImageSoftEleganceFilter.h&quot;              //SoftElegance lookup</span><br><span class="line"></span><br><span class="line">  #pragma mark - 图像处理 Handle Image</span><br><span class="line"> </span><br><span class="line">  #import &quot;GPUImageCrosshairGenerator.h&quot;              //十字</span><br><span class="line">  #import &quot;GPUImageLineGenerator.h&quot;                   //线条</span><br><span class="line">  #import &quot;GPUImageTransformFilter.h&quot;                 //形状变化</span><br><span class="line">  #import &quot;GPUImageCropFilter.h&quot;                      //剪裁</span><br><span class="line">  #import &quot;GPUImageSharpenFilter.h&quot;                   //锐化</span><br><span class="line">  #import &quot;GPUImageUnsharpMaskFilter.h&quot;               //反遮罩锐化 </span><br><span class="line"> #import &quot;GPUImageFastBlurFilter.h&quot;                  //模糊</span><br><span class="line">  #import &quot;GPUImageGaussianBlurFilter.h&quot;              //高斯模糊</span><br><span class="line">  #import &quot;GPUImageGaussianSelectiveBlurFilter.h&quot;     //高斯模糊，选择部分清晰</span><br><span class="line">  #import &quot;GPUImageBoxBlurFilter.h&quot;                   //盒状模糊</span><br><span class="line">  #import &quot;GPUImageTiltShiftFilter.h&quot;                 //条纹模糊，中间清晰，上下两端模糊</span><br><span class="line">  #import &quot;GPUImageMedianFilter.h&quot;                    //中间值，有种稍微模糊边缘的效果</span><br><span class="line">  #import &quot;GPUImageBilateralFilter.h&quot;                 //双边模糊</span><br><span class="line">  #import &quot;GPUImageErosionFilter.h&quot;                   //侵蚀边缘模糊，变黑白</span><br><span class="line">  #import &quot;GPUImageRGBErosionFilter.h&quot;                //RGB侵蚀边缘模糊，有色彩</span><br><span class="line">  #import &quot;GPUImageDilationFilter.h&quot;                  //扩展边缘模糊，变黑白</span><br><span class="line">  #import &quot;GPUImageRGBDilationFilter.h&quot;               //RGB扩展边缘模糊，有色彩</span><br><span class="line">  #import &quot;GPUImageOpeningFilter.h&quot;                   //黑白色调模糊</span><br><span class="line">  #import &quot;GPUImageRGBOpeningFilter.h&quot;                //彩色模糊</span><br><span class="line">  #import &quot;GPUImageClosingFilter.h&quot;                   //黑白色调模糊，暗色会被提亮</span><br><span class="line">  #import &quot;GPUImageRGBClosingFilter.h&quot;                //彩色模糊，暗色会被提亮</span><br><span class="line">  #import &quot;GPUImageLanczosResamplingFilter.h&quot;         //Lanczos重取样，模糊效果</span><br><span class="line">  #import &quot;GPUImageNonMaximumSuppressionFilter.h&quot;     //非最大抑制，只显示亮度最高的像素，其他为黑</span><br><span class="line">  #import &quot;GPUImageThresholdedNonMaximumSuppressionFilter.h&quot; //与上相比，像素丢失更多 </span><br><span class="line">  #import &quot;GPUImageSobelEdgeDetectionFilter.h&quot;        //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)</span><br><span class="line">  #import &quot;GPUImageCannyEdgeDetectionFilter.h&quot;        //Canny边缘检测算法（比上更强烈的黑白对比度）</span><br><span class="line">  #import &quot;GPUImageThresholdEdgeDetectionFilter.h&quot;    //阈值边缘检测（效果与上差别不大）</span><br><span class="line">  #import &quot;GPUImagePrewittEdgeDetectionFilter.h&quot;      //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)</span><br><span class="line">  #import &quot;GPUImageXYDerivativeFilter.h&quot;              //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色</span><br><span class="line">  #import &quot;GPUImageHarrisCornerDetectionFilter.h&quot;     //Harris角点检测，会有绿色小十字显示在图片角点处</span><br><span class="line">  #import &quot;GPUImageNobleCornerDetectionFilter.h&quot;      //Noble角点检测，检测点更多</span><br><span class="line">  #import &quot;GPUImageShiTomasiFeatureDetectionFilter.h&quot; //ShiTomasi角点检测，与上差别不大</span><br><span class="line">  #import &quot;GPUImageMotionDetector.h&quot;                  //动作检测</span><br><span class="line">  #import &quot;GPUImageHoughTransformLineDetector.h&quot;      //线条检测</span><br><span class="line"> #import &quot;GPUImageParallelCoordinateLineTransformFilter.h&quot; //平行线检测 </span><br><span class="line"> #import &quot;GPUImageLocalBinaryPatternFilter.h&quot;        //图像黑白化，并有大量噪点 </span><br><span class="line"> #import &quot;GPUImageLowPassFilter.h&quot;                   //用于图像加亮</span><br><span class="line"> #import &quot;GPUImageHighPassFilter.h&quot;                  //图像低于某值时显示为黑</span><br><span class="line"> #pragma mark - 视觉效果 Visual Effect</span><br><span class="line"> #import &quot;GPUImageSketchFilter.h&quot;                    //素描</span><br><span class="line">#import &quot;GPUImageThresholdSketchFilter.h&quot;           //阀值素描，形成有噪点的素描</span><br><span class="line"> #import &quot;GPUImageToonFilter.h&quot;                      //卡通效果（黑色粗线描边）</span><br><span class="line"> #import &quot;GPUImageSmoothToonFilter.h&quot;                //相比上面的效果更细腻，上面是粗旷的画风</span><br><span class="line"> #import &quot;GPUImageKuwaharaFilter.h&quot;                  //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用 </span><br><span class="line"> #import &quot;GPUImageMosaicFilter.h&quot;                    //黑白马赛克</span><br><span class="line"> #import &quot;GPUImagePixellateFilter.h&quot;                 //像素化</span><br><span class="line"> #import &quot;GPUImagePolarPixellateFilter.h&quot;            //同心圆像素化</span><br><span class="line"> #import &quot;GPUImageCrosshatchFilter.h&quot;                //交叉线阴影，形成黑白网状画面</span><br><span class="line"> #import &quot;GPUImageColorPackingFilter.h&quot;              //色彩丢失，模糊（类似监控摄像效果） </span><br><span class="line"> #import &quot;GPUImageVignetteFilter.h&quot;                  //晕影，形成黑色圆形边缘，突出中间图像的效果</span><br><span class="line"> #import &quot;GPUImageSwirlFilter.h&quot;                     //漩涡，中间形成卷曲的画面</span><br><span class="line">#import &quot;GPUImageBulgeDistortionFilter.h&quot;           //凸起失真，鱼眼效果</span><br><span class="line"> #import &quot;GPUImagePinchDistortionFilter.h&quot;           //收缩失真，凹面镜</span><br><span class="line">#import &quot;GPUImageStretchDistortionFilter.h&quot;         //伸展失真，哈哈镜</span><br><span class="line">#import &quot;GPUImageGlassSphereFilter.h&quot;               //水晶球效果</span><br><span class="line">#import &quot;GPUImageSphereRefractionFilter.h&quot;          //球形折射，图形倒立     </span><br><span class="line"> #import &quot;GPUImagePosterizeFilter.h&quot;                 //色调分离，形成噪点效果</span><br><span class="line"> #import &quot;GPUImageCGAColorspaceFilter.h&quot;             //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面</span><br><span class="line"> #import &quot;GPUImagePerlinNoiseFilter.h&quot;               //柏林噪点，花边噪点</span><br><span class="line"> #import &quot;GPUImage3x3ConvolutionFilter.h&quot;            //3x3卷积，高亮大色块变黑，加亮边缘、线条等</span><br><span class="line"> #import &quot;GPUImageEmbossFilter.h&quot;                    //浮雕效果，带有点3d的感觉</span><br><span class="line"> #import &quot;GPUImagePolkaDotFilter.h&quot;                  //像素圆点花样</span><br><span class="line">#import &quot;GPUImageHalftoneFilter.h&quot;                  //点染,图像黑白化，由黑点构成原图的大致图形 </span><br><span class="line"> </span><br><span class="line">  #pragma mark - 混合模式 Blend</span><br><span class="line"> </span><br><span class="line">  #import &quot;GPUImageMultiplyBlendFilter.h&quot;             //通常用于创建阴影和深度效果</span><br><span class="line">  #import &quot;GPUImageNormalBlendFilter.h&quot;               //正常</span><br><span class="line">  #import &quot;GPUImageAlphaBlendFilter.h&quot;                //透明混合,通常用于在背景上应用前景的透明度</span><br><span class="line">  #import &quot;GPUImageDissolveBlendFilter.h&quot;             //溶解</span><br><span class="line">  #import &quot;GPUImageOverlayBlendFilter.h&quot;              //叠加,通常用于创建阴影效果</span><br><span class="line">  #import &quot;GPUImageDarkenBlendFilter.h&quot;               //加深混合,通常用于重叠类型</span><br><span class="line">  #import &quot;GPUImageLightenBlendFilter.h&quot;              //减淡混合,通常用于重叠类型</span><br><span class="line">  #import &quot;GPUImageSourceOverBlendFilter.h&quot;           //源混合</span><br><span class="line">  #import &quot;GPUImageColorBurnBlendFilter.h&quot;            //色彩加深混合</span><br><span class="line">  #import &quot;GPUImageColorDodgeBlendFilter.h&quot;           //色彩减淡混合</span><br><span class="line">  #import &quot;GPUImageScreenBlendFilter.h&quot;               //屏幕包裹,通常用于创建亮点和镜头眩光</span><br><span class="line">  #import &quot;GPUImageExclusionBlendFilter.h&quot;            //排除混合</span><br><span class="line">  #import &quot;GPUImageDifferenceBlendFilter.h&quot;           //差异混合,通常用于创建更多变动的颜色</span><br><span class="line">  #import &quot;GPUImageSubtractBlendFilter.h&quot;             //差值混合,通常用于创建两个图像之间的动画变暗模糊效果</span><br><span class="line">  #import &quot;GPUImageHardLightBlendFilter.h&quot;            //强光混合,通常用于创建阴影效果</span><br><span class="line">  #import &quot;GPUImageSoftLightBlendFilter.h&quot;            //柔光混合</span><br><span class="line">  #import &quot;GPUImageChromaKeyBlendFilter.h&quot;            //色度键混合</span><br><span class="line">  #import &quot;GPUImageMaskFilter.h&quot;                      //遮罩混合</span><br><span class="line">  #import &quot;GPUImageHazeFilter.h&quot;                      //朦胧加暗</span><br><span class="line">  #import &quot;GPUImageLuminanceThresholdFilter.h&quot;        //亮度阈</span><br><span class="line">  #import &quot;GPUImageAdaptiveThresholdFilter.h&quot;         //自适应阈值</span><br><span class="line">  #import &quot;GPUImageAddBlendFilter.h&quot;                  //通常用于创建两个图像之间的动画变亮模糊效果</span><br><span class="line">  #import &quot;GPUImageDivideBlendFilter.h&quot;               //通常用于创建两个图像之间的动画变暗模糊效果</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br></pre></td><td class="code"><pre><span class="line">颜色调整</span><br><span class="line"></span><br><span class="line">GPUImageBrightnessFilter：调整图像的亮度</span><br><span class="line"></span><br><span class="line">亮度：调整亮度（-1.0 - 1.0，默认为0.0）</span><br><span class="line">GPUImageExposureFilter：调整图像的曝光</span><br><span class="line"></span><br><span class="line">曝光：调整曝光（-10.0 - 10.0，默认为0.0）</span><br><span class="line">GPUImageContrastFilter：调整图像的对比度</span><br><span class="line"></span><br><span class="line">对比度：调整的对比度（0.0 - 4.0，默认为1.0）</span><br><span class="line">GPUImageSaturationFilter：调整图像的饱和度</span><br><span class="line"></span><br><span class="line">饱和度：应用于图像的饱和度或去饱和度（0.0 - 2.0，默认为1.0）</span><br><span class="line">GPUImageGammaFilter：调整图像的灰度系数</span><br><span class="line"></span><br><span class="line">gamma：要应用的灰度调整（0.0 - 3.0，默认为1.0）</span><br><span class="line">GPUImageLevelsFilter：Photoshop级别调整。min ，max，minOut和maxOut参数是范围[0,1]中的浮点数如果你有来自Photoshop的参数，范围为[0,255]，则必须首先将它们转换为[0， 1] 。gamma / mid参数是一个float&gt; = 0的值。这与Photoshop的值匹配如果要对RGB以及单个通道应用级别，则需要使用此过滤器两次 - 首先用于单个通道，然后用于所有通道。</span><br><span class="line"></span><br><span class="line">GPUImageColorMatrixFilter：通过向图像应用矩阵来转换图像的颜色</span><br><span class="line"></span><br><span class="line">colorMatrix：一个4x4矩阵，用于变换图像中的每种颜色</span><br><span class="line">intensity：新变换颜色的原始颜色的程度</span><br><span class="line">GPUImageRGBFilter：调整图像的每个 RGB通道</span><br><span class="line"></span><br><span class="line">红色：每个颜色通道乘以的标准化值。范围是从0.0开始，默认为1.0。</span><br><span class="line">绿色：</span><br><span class="line">蓝色：</span><br><span class="line">GPUImageHueFilter：调整图像的色调</span><br><span class="line"></span><br><span class="line">色相角：以度为单位。默认为90度</span><br><span class="line">GPUImageVibranceFilter：调整图像的动态</span><br><span class="line"></span><br><span class="line">光彩：在光彩调整申请，使用0.0作为默认设置，分别为-1.2左右和1.2，建议最小/最大。</span><br><span class="line">GPUImageWhiteBalanceFilter：调整图像的白平衡。</span><br><span class="line"></span><br><span class="line">温度：以ºK单位为调整图像的温度值4000是非常酷，7000非常温暖。默认值为5000。请注意，4000和5000之间的刻度与5000和7000之间的刻度几乎相同。</span><br><span class="line">色调：图像调整色调的值为-200 非常绿色，200 非常粉红色。默认值为0。</span><br><span class="line">GPUImageToneCurveFilter：根据每个颜色通道的样条曲线调整图像的颜色。</span><br><span class="line"></span><br><span class="line">redControlPoints：</span><br><span class="line">greenControlPoints：</span><br><span class="line">blueControlPoints：</span><br><span class="line">rgbCompositeControlPoints：色调曲线采用一系列控制点，这些控制点为每个颜色分量或复合材料中的所有三个分量定义样条曲线。这些作为NSValue封装的CGPoints存储在NSArray中，标准化的X和Y坐标0到1.默认值为（0,0），（0.5,0.5），（1,1）。</span><br><span class="line">GPUImageHighlightShadowFilter：调整图像的阴影和高光</span><br><span class="line"></span><br><span class="line">阴影：增加到减弱阴影，从0.0到1.0，默认值为0.0。</span><br><span class="line">亮点：减少高亮显示，从1.0到0.0，默认为1.0。</span><br><span class="line">GPUImageHighlightShadowTintFilter：允许您使用颜色和强度独立地着色图像的阴影和高光</span><br><span class="line"></span><br><span class="line">shadowTintColor：阴影色调RGB颜色（GPUVector4）。默认值:( &#123;1.0f, 0.0f, 0.0f, 1.0f&#125;红色）。</span><br><span class="line">highlightTintColor：突出显示色彩RGB颜色（GPUVector4）。默认值:( &#123;0.0f, 0.0f, 1.0f, 1.0f&#125;蓝色）。</span><br><span class="line">shadowTintIntensity：阴影色调强度，从0.0到1.0。默认值：0.0</span><br><span class="line">highlightTintIntensity：突出显示从0.0到1.0的色调强度，默认值为0.0。</span><br><span class="line">GPUImageLookupFilter：使用RGB颜色查找图像重新映射图像中的颜色。首先，使用最最喜欢的照片编辑应用程序将过滤器应用于GPUImage / framework / Resources中的lookup.png。为了使其正常工作，每个像素颜色不能依赖于其他像素（例如模糊不起作用）。如果您需要更复杂的过滤器，您可以根据需要创建任意数量的查找表。准备好后，使用您的新lookup.png文件作为GPUImageLookupFilter的第二个输入。</span><br><span class="line"></span><br><span class="line">GPUImageAmatorkaFilter：基于Amatorka的Photoshop操作的照片过滤器：http：//amatorka.deviantart.com/art/Amatorka-Action-2-121069631。如果要使用此效果，您必须从lookup_amatorka.png从GPUImage资源文件夹添加到应用程序包。</span><br><span class="line"></span><br><span class="line">GPUImageMissEtikateFilter：由Etikate小姐基于Photoshop操作的照片过滤器：http：//miss-etikate.deviantart.com/art/Photoshop-Action-15-120151961。如果要使用此效果，您必须将lookup_miss_etikate.png从GPUImage资源文件夹添加到应用程序包。</span><br><span class="line"></span><br><span class="line">GPUImageSoftEleganceFilter：另一个基于查找的颜色重映射过滤器。如果要使用此效果，您必须将lookup_soft_elegance_1.png和lookup_soft_elegance_2.png从GPUImage资源文件夹添加到应用程序包。</span><br><span class="line"></span><br><span class="line">GPUImageSkinToneFilter：一个肤色调整过滤器，影响一个独特范围的轻肤色调，并相应地调整粉色/绿色或粉色/橙色的范围。默认值针对公平的白种人皮肤，但可以根据需要进行调整。</span><br><span class="line"></span><br><span class="line">skinToneAdjust：调整肤色的量。默认值：0.0，建议最小值/最大值：-0.3和0.3。</span><br><span class="line">skinHue：皮肤色调被检测到。默认值：0.05（正常的白种人到微红的皮肤）。</span><br><span class="line">skinHueThreshold：皮肤色调的方差量。</span><br><span class="line">maxHueShift：允许的最大色差偏移量。</span><br><span class="line">maxSaturationShift =要移动的最大饱和度（使用橙色时）。</span><br><span class="line">upperSkinToneColor = GPUImageSkinToneUpperColorGreen或GPUImageSkinToneUpperColorOrange</span><br><span class="line">GPUImageColorInvertFilter：反转图像的颜色</span><br><span class="line"></span><br><span class="line">GPUImageGrayscaleFilter：将图像转换为灰度（饱和度滤镜的实现略快，但无法改变颜色贡献）</span><br><span class="line"></span><br><span class="line">GPUImageMonochromeFilter：根据每个像素的亮度将图像转换为单色版本</span><br><span class="line"></span><br><span class="line">intensity：特定颜色替换正常图像颜色的程度（0.0 - 1.0，默认为1.0）</span><br><span class="line">color：用作效果基础的颜色，以（0.6,0.45,0.3,1.0）作为默认值。</span><br><span class="line">GPUImageFalseColorFilter：使用图像的亮度在两个用户指定的颜色之间混合</span><br><span class="line"></span><br><span class="line">firstColor：状语从句：第一第二颜色组分别指定什么颜色组替换图像的暗区域亮状语从句：区域默认值为（0.0,0.0,0.5）AMD公司（1.0,0.0,0.0）。</span><br><span class="line">secondColor：</span><br><span class="line">GPUImageHazeFilter：用于添加或删除雾度（类似于UV过滤器）</span><br><span class="line"></span><br><span class="line">distance：应用的颜色的强度。-.3和.3之间的值最好。</span><br><span class="line">斜率：颜色变化量。-.3和.3之间的值最好。</span><br><span class="line">GPUImageSepiaFilter：简单的棕褐色调滤波器</span><br><span class="line"></span><br><span class="line">intensity：棕黄色代替正常图像颜色的程度（0.0 - 1.0，默认为1.0）</span><br><span class="line">GPUImageOpacityFilter：调整传入图像的Alpha通道</span><br><span class="line"></span><br><span class="line">opacity：将每个像素的传入alpha通道乘以（0.0 - 1.0，默认值为1.0）的值，</span><br><span class="line">GPUImageSolidColorGenerator：这将输出生成的图像的纯色。您需要使用-forceProcessingAtSize定义图像大小：</span><br><span class="line"></span><br><span class="line">color：以四分格式显示的颜色，用于填充图像。</span><br><span class="line">GPUImageLuminanceThresholdFilter：亮度高于阈值的像素将显示为白色，下面的像素将为黑色</span><br><span class="line"></span><br><span class="line">threshold：亮度阈值，从0.0到1.0，默认值为0.5</span><br><span class="line">GPUImageAdaptiveThresholdFilter：确定像素周边的局部亮度，然后如果像素低于该局部亮度，则将像素变为黑色，如果以上则为白色。这可以用于在不同的照明条件下挑选文本。</span><br><span class="line"></span><br><span class="line">blurRadiusInPixels：背景平均模糊半径（以像素为单位）的乘数，默认值为4。</span><br><span class="line">GPUImageAverageLuminanceThresholdFilter：这个应用阈值操作，其中基于场景的平均亮度连续地调整阈值。</span><br><span class="line"></span><br><span class="line">thresholdMultiplier：这是平均亮度将被乘以的因子，以便达到要使用的最下限阈值。</span><br><span class="line">GPUImageHistogramFilter：它分析传入的图像，并且创建一个输出直方图，其中出现每个颜色值的频率。该滤波器的输出是3像素高，256像素宽的图像，其中发生各种颜色值的频率的像素。每个颜色值占据256个宽度位置中的一个，从左边的0到右边的255. 可以针对各个颜色通道（kGPUImageHistogramRed，kGPUImageHistogramGreen，kGPUImageHistogramBlue），图像的亮度（kGPUImageHistogramLuminance ）或者一次针对所有三个颜色通道（kGPUImageHistogramRGB）生成该直方图。</span><br><span class="line"></span><br><span class="line">downsamplingFactor：这不是对每个像素进行采样，而是指示图像的哪个部分被采样。默认情况下，这是16，最小值为1.这是需要防止饱和直方图，它只能记录每个颜色值的256个像素，在它变得重载之前。</span><br><span class="line">GPUImageHistogramGenerator：这是一个特殊的过滤器，因为它主要打算使用GPUImageHistogramFilter。它生成由GPUImageHistogramFilter生成的颜色直方图的输出表示，但它可以重新用于显示其他类型的值。它采取一个图像，看中心垂直）像素。然后它在输出纹理中的单独的彩色图表中绘制RGB分量的数值。您可能需要强制此过滤器的大小，以其输出可见。</span><br><span class="line"></span><br><span class="line">GPUImageAverageColor：通过对图像中每个像素的RGBA分量进行平均，处理输入图像并确定场景的平均颜色。使用缩小处理来逐步向下取样GPU上的源图像，接着在CPU进行上短的平均计算此过滤器的输出无意义，但您需要将colorAverageProcessingFinishedBlock属性设置为接收四个颜色分块和一个帧时间的块，并对它们执行某些操作。</span><br><span class="line"></span><br><span class="line">GPUImageLuminosity：像GPUImageAverageColor一样，这会将图像缩小到其平均亮度。你需要设置luminosityProcessingFinishedBlock来处理这个过滤器的输出，它会返回一个光度值和一个帧时间。</span><br><span class="line"></span><br><span class="line">GPUImageChromaKeyFilter：对于图像中的给定颜色，将Alpha通道设置为0.这与GPUImageChromaKeyBlendFilter类似，只是不是在第二个图像中混合匹配的颜色，这不在第二个图像中，颜色透明。</span><br><span class="line"></span><br><span class="line">thresholdSensitivity：颜色匹配需要存在到要求的目标颜色的接近程度（默认值为0.4）</span><br><span class="line">平滑：如何平滑地混合颜色匹配（默认值为0.1）</span><br><span class="line">图像处理</span><br><span class="line"></span><br><span class="line">GPUImageTransformFilter：这将对应图像应用任意的2-D或3-D变换</span><br><span class="line"></span><br><span class="line">affineTransform：这需要一个CGAffineTransform来调整2-D图像</span><br><span class="line">transform3D：这需要一个CATransform3D来操纵3-D中的图像</span><br><span class="line">ignoreAspectRatio：默认情况下，保持变换图像的宽高比，但可以将其设置为YES，use变换与宽高比无关</span><br><span class="line">GPUImageCropFilter：将图像裁剪到特定区域，然后只将该区域传递到过滤器的下一个阶段</span><br><span class="line"></span><br><span class="line">cropRegion：裁剪出图像的矩形区域，标准化为0.0 - 1.0的坐标。（0.0,0.0）位置在图像的左上角。</span><br><span class="line">GPUImageLanczosResamplingFilter：这使您可以使用Lanczos重采样对图像进行上采样或下采样，这将产生比标准线性或三线性插值明显更好的质量。只需使用-forceProcessingAtSize：设置过滤器的目标输出分辨率，并且将为该新大小重新采样图像。</span><br><span class="line"></span><br><span class="line">GPUImageSharpenFilter：锐化图像</span><br><span class="line"></span><br><span class="line">锐度：应用的锐度调整（-4.0 - 4.0，默认值为0.0）</span><br><span class="line">GPUImageUnsharpMaskFilter：应用反锐化掩码</span><br><span class="line"></span><br><span class="line">blurRadiusInPixels：底层高斯模糊的模糊半径。</span><br><span class="line">intensity：锐化的强度，从0.0开始，默认值为1.0</span><br><span class="line">GPUImageGaussianBlurFilter：一种硬件优化，可变半径高斯模糊</span><br><span class="line"></span><br><span class="line">texelSpacingMultiplier：范围从0.0开始，默认值为1.0。调整这可能会稍微增加模糊强度，但会在结果中引入伪影。强烈建议先使用其他参数，然后触摸此一个。</span><br><span class="line">blurRadiusInPixels：用于模糊的半径（以像素为单位），默认值为2.0。这调整了高斯分布函数中的σ变量。</span><br><span class="line">blurRadiusAsFractionOfImageWidth：</span><br><span class="line">blurRadiusAsFractionOfImageHeight：设置这些属性将允许模糊半径随图像大小缩放</span><br><span class="line">blurPasses：顺序模糊输入图像的次数。通过越多，过滤器越慢。</span><br><span class="line">GPUImageBoxBlurFilter：一个硬件优化，可变半径框模糊</span><br><span class="line"></span><br><span class="line">texelSpacingMultiplier：范围从0.0开始，默认值为1.0。调整这可能会稍微增加模糊强度，但会在结果中引入伪影。强烈建议先使用其他参数，然后触摸此一个。</span><br><span class="line">blurRadiusInPixels：用于模糊的半径（以像素为单位），默认值为2.0。这调整了高斯分布函数中的σ变量。</span><br><span class="line">blurRadiusAsFractionOfImageWidth：</span><br><span class="line">blurRadiusAsFractionOfImageHeight：设置这些属性将允许模糊半径随图像大小缩放</span><br><span class="line">blurPasses：顺序模糊输入图像的次数。通过越多，过滤器越慢。</span><br><span class="line">GPUImageSingleComponentGaussianBlurFilter：仅对红色组件操作的GPUImageGaussianBlurFilter的修改</span><br><span class="line"></span><br><span class="line">texelSpacingMultiplier：范围从0.0开始，默认值为1.0。调整这可能会稍微增加模糊强度，但会在结果中引入伪影。强烈建议先使用其他参数，然后触摸此一个。</span><br><span class="line">blurRadiusInPixels：用于模糊的半径（以像素为单位），默认值为2.0。这调整了高斯分布函数中的σ变量。</span><br><span class="line">blurRadiusAsFractionOfImageWidth：</span><br><span class="line">blurRadiusAsFractionOfImageHeight：设置这些属性将允许模糊半径随图像大小缩放</span><br><span class="line">blurPasses：顺序模糊输入图像的次数。通过越多，过滤器越慢。</span><br><span class="line">GPUImageGaussianSelectiveBlurFilter：保持圆形区域内焦点的高斯模糊</span><br><span class="line"></span><br><span class="line">blurRadiusInPixels：用于模糊的像素的半径，默认值为5.0。这调整了高斯分布函数中的σ变量。</span><br><span class="line">excludeCircleRadius：从模糊中排除的圆形区域的半径</span><br><span class="line">excludeCirclePoint：从模糊中排除的圆形区域的中心</span><br><span class="line">excludeBlurSize：模糊部分和清晰圆之间的区域的大小</span><br><span class="line">aspect ratio：图像的宽高比，用于调整对焦区域的圆形度。默认情况下，这与图像宽高比相匹配，但您可以覆盖此值。</span><br><span class="line">GPUImageGaussianBlurPositionFilter：GPUImageGaussianSelectiveBlurFilter的逆，只在特定圆圈内应用模糊</span><br><span class="line"></span><br><span class="line">blurSize：模糊大小的乘数，范围从0.0开始，默认值为1.0</span><br><span class="line">blurCenter：模糊的中心，默认为0.5,0.5</span><br><span class="line">blurRadius：模糊的半径，默认为1.0</span><br><span class="line">GPUImageiOSBlurFilter：尝试复制在图片控制中心这样的iOS 7上使用的背景模糊。</span><br><span class="line"></span><br><span class="line">blurRadiusInPixels：用于模糊的半径（以像素为单位），默认值为12.0。这调整了高斯分布函数中的σ变量。</span><br><span class="line">“饱和度”英文“饱和度” 英文“饱和度”英文“饱和度”英文“饱和度</span><br><span class="line">下采样：下采样，然后上采样输入图像以最小化高斯模糊内的计算的程度，默认为4.0。</span><br><span class="line">GPUImageMedianFilter：获取三个颜色分量的中值，超过3x3区域</span><br><span class="line"></span><br><span class="line">GPUImageBilateralFilter：双边模糊，它试图模糊相似的颜色值，同时保留锐利的边缘</span><br><span class="line"></span><br><span class="line">texelSpacingMultiplier：texel 读取间距的乘数，范围从0.0开始，默认值为4.0</span><br><span class="line">distanceNormalizationFactor：中心颜色和样本颜色之间的距离归一化因子，默认值为8.0。</span><br><span class="line">GPUImageTiltShiftFilter：模拟倾斜移位镜头效果</span><br><span class="line"></span><br><span class="line">blurRadiusInPixels：底层模糊的半径，以像素为单位。</span><br><span class="line">topFocusLevel：图片中对焦区域顶部的标准化位置，此值应低于bottomFocusLevel，默认为0.4</span><br><span class="line">bottomFocusLevel：图片中对焦区域底部的归一化位置，此值应高于topFocusLevel，默认为0.6</span><br><span class="line">focusFallOffRate：图像变得离开对焦区域的速率，默认为0.2</span><br><span class="line">GPUImage3x3ConvolutionFilter：针对映像运行3x3卷积内核</span><br><span class="line"></span><br><span class="line">卷积核：卷积核是应用于像素及其8个周围像素的值的3×3矩阵。矩阵以行主要顺序指定，左上角的像素为one.one，右下角为三。如果矩阵中的value不等于1.0，则图像可以变亮或变暗。</span><br><span class="line">GPUImageSobelEdgeDetectionFilter：Sobel边缘检测，边缘以白色突出显示</span><br><span class="line"></span><br><span class="line">texelWidth：</span><br><span class="line">texelHeight：这些参数影响检测到的边缘的可见性</span><br><span class="line">edgeStrength：调整滤波器的动态范围。值越高，边缘越强，但可以使强度色空间饱和。</span><br><span class="line">GPUImagePrewittEdgeDetectionFilter：Prewitt边缘检测，边缘以白色突出显示</span><br><span class="line"></span><br><span class="line">texelWidth：</span><br><span class="line">texelHeight：这些参数影响检测到的边缘的可见性</span><br><span class="line">edgeStrength：调整滤波器的动态范围。值越高，边缘越强，但可以使强度色空间饱和。</span><br><span class="line">GPUImageThresholdEdgeDetectionFilter：执行Sobel边缘检测，但应用阈值，而不提供渐进强度值</span><br><span class="line"></span><br><span class="line">texelWidth：</span><br><span class="line">texelHeight：这些参数影响检测到的边缘的可见性</span><br><span class="line">edgeStrength：调整滤波器的动态范围。值越高，边缘越强，但可以使强度色空间饱和。</span><br><span class="line">threshold：高于此阈值的任何边将为黑色，任何低于白色的边。范围从0.0到1.0，默认为0.8</span><br><span class="line">GPUImageCannyEdgeDetectionFilter：这使用完整的Canny过程来突出显示一个像素宽的边缘</span><br><span class="line"></span><br><span class="line">texelWidth：</span><br><span class="line">texelHeight：这些参数影响检测到的边缘的可见性</span><br><span class="line">blurRadiusInPixels：高斯模糊的基础模糊半径。</span><br><span class="line">blurTexelSpacingMultiplier：底层模糊纹理像素间距乘数。</span><br><span class="line">upperThreshold：front threshold：任意边缘，将默认值设为0.4。</span><br><span class="line">lowerThreshold：梯度幅度低于此阈值的任何边将失败，并从最终结果中删除。</span><br><span class="line">GPUImageHarrisCornerDetectionFilter：对输入图像运行哈里斯角点检测算法，并生成一个图像，这些角点为白色像素，一切为黑色。可以设置cornersDetectedBlock，并且您将获得一个角度列表（在标准化的0..1 X， Y坐标），在回调中你想要执行的任何额外的操作。</span><br><span class="line"></span><br><span class="line">blurRadiusInPixels：底层高斯模糊的半径。</span><br><span class="line">灵敏度：应用于调整过滤器中生成的角点的动态范围的内部缩放因子。</span><br><span class="line">门槛：将点检测为角的阈值。这可以根据大小，照明条件和iOS的设备摄像头类型显着变化，因此可能需要一些实验来适当的情况。默认值为0.20。</span><br><span class="line">GPUImageNobleCornerDetectionFilter：在哈里斯角点检测器上运行Noble变量。它的行为如上所述的哈里斯检测器。</span><br><span class="line"></span><br><span class="line">blurRadiusInPixels：底层高斯模糊的半径。</span><br><span class="line">灵敏度：应用于调整过滤器中生成的角点的动态范围的内部缩放因子。</span><br><span class="line">门槛：将点检测为角的阈值。这可以根据大小，照明条件和iOS的设备摄像头类型显着变化，因此可能需要一些实验来适当的情况。默认值为0.2。</span><br><span class="line">GPUImageShiTomasiCornerDetectionFilter：运行Shi-Tomasi特征检测器。它的行为如上所述的哈里斯检测器。</span><br><span class="line"></span><br><span class="line">blurRadiusInPixels：底层高斯模糊的半径。</span><br><span class="line">灵敏度：应用于调节过滤器中生成的角点的动态范围的内部缩放因子。</span><br><span class="line">门槛：将点检测为角的阈值。这可以根据大小，照明条件和iOS的设备摄像头类型显着变化，因此可能需要一些实验来适当的情况。默认值为0.2。</span><br><span class="line">GPUImageNonMaximumSuppressionFilter：当前仅用作哈里斯角点检测滤波器的一部分，这将对每个像素周围的1像素框进行采样，并中心确定的像素红色通道是否的英文该区域中的最大值如果的英文，它停留。如果不是，则对于所有颜色分量将其设置为0。</span><br><span class="line"></span><br><span class="line">GPUImageXYDerivativeFilter：哈里斯角点检测滤波器内的一个内部组件，它计算这个点左右像素之间的平方差，这个点之上和之下的像素的平方差，以及这两个差值的乘积。</span><br><span class="line"></span><br><span class="line">GPUImageCrosshairGenerator：它在图像上绘制一系列十字线，最常用于识别机器视觉特征。它不像其他过滤器那样接受标准图像，而是在其–renderCrosshairsFromArray：count：方法中包含一系列点，这是实际绘图。您将需要强制此过滤器以您需要的特定输出大小进行渲染。</span><br><span class="line"></span><br><span class="line">crosshairWidth：要在屏幕上绘制的十字准线的宽度（以像素为单位）。</span><br><span class="line">GPUImageDilationFilter：这执行图像扩张操作，其中矩形邻域的红色通道的最强强度用于该像素的强度。初始化时指定采样的矩形区域的半径，范围为1-4个像素。这是为了用灰度图像，它扩展明亮的区域。</span><br><span class="line"></span><br><span class="line">GPUImageRGBDilationFilter：这与GPUImageDilationFilter相同，只是它作用于所有颜色通道，而不只是红色通道。</span><br><span class="line"></span><br><span class="line">GPUImageErosionFilter：执行图像侵蚀操作，其中矩形邻域中的红色通道的最强度用于该像素的强度。初始化时指定采样的矩形区域的半径，范围为1-4个像素。这是用于灰度图像，它扩展黑暗区域。</span><br><span class="line"></span><br><span class="line">GPUImageRGBErosionFilter：这与GPUImageErosionFilter相同，只是它在所有颜色通道上起作用，而不只是红色通道。</span><br><span class="line"></span><br><span class="line">GPUImageOpeningFilter：这对图像的红色通道执行侵蚀，随后是相同半径的膨胀。初始化时间设置半径，范围为1-4个像素。</span><br><span class="line"></span><br><span class="line">GPUImageRGBOpeningFilter：这与GPUImageOpeningFilter相同，除了这个作用于所有颜色通道，而不只是红色通道。</span><br><span class="line"></span><br><span class="line">GPUImageClosingFilter：它对图像的红色通道执行扩展，然后是相同半径的侵蚀。初始化时间设置半径，范围为1-4个像素。</span><br><span class="line"></span><br><span class="line">GPUImageRGBClosingFilter：这与GPUImageClosingFilter相同，除了这个作用于所有颜色通道，而不只是红色通道。</span><br><span class="line"></span><br><span class="line">GPUImageLocalBinaryPatternFilter：它执行8个周围像素和中心像素的红色通道的强度的比较，将比较结果编码成成为该像素强度的位串。最低有效位是右上角比较，逆时针转向以正确的比较结束作为最高有效位。</span><br><span class="line"></span><br><span class="line">GPUImageLowPassFilter：对于输入的视频帧应用一个低通滤波器。这基本上累积了当前帧和当前帧的加权滚动平均值它可以用于去噪视频，添加运动模糊或用于创建高通滤波器。</span><br><span class="line"></span><br><span class="line">filterStrength：这控制了前一个累加帧与当前帧的混合程度。范围从0.0到1.0，默认值为0.5。</span><br><span class="line">GPUImageHighPassFilter：对输入的视频帧应用高通滤波器。这是低通滤波器的反相，示出了当前帧与前一帧的加权滚动平均值之间的差。这对运动检测最有用。</span><br><span class="line"></span><br><span class="line">filterStrength：this控制先前累加的帧被混合的程度，然后从当前的累加帧中减去。范围从0.0到1.0，默认值为0.5。</span><br><span class="line">GPUImageMotionDetector：这是一个基于高通滤波器的运动检测器。您设置motionDetectionBlock，并且在每个传入帧中，它将为您提供场景中任何检测到的运动的质心（以标准化的X，Y坐标）以及场景的运动强度。</span><br><span class="line"></span><br><span class="line">lowPassFilterStrength：this控制了幕后使用的低通滤波器的强度，以建立与输入帧进行比较的基线。范围从0.0到1.0，默认值为0.5。</span><br><span class="line">GPUImageHoughTransformLineDetector：使用霍夫变换检测图像中的线到平行坐标空间。这种方法完全基于由布尔诺科技大学的Graph @ FIT研究小组开发的PC线路过程，并在他们的出版物中描述：M.Dubská ，J.Havel，and A.Helout。使用平行坐标和OpenGL的线的实时检测。Proceedings of SCCG 2011，Bratislava，SK，第7 页（http://medusa.fit.vutbr.cz/public/data/论文/ 2011-SCCG-Dubska-Real-Time-Line-Detection-Using-PC-and-OpenGL.pdf）和M.Dubská，J.Havel，Herout。PClines -使用平行坐标的线检测。2011年计算机视觉与模式识别（CVPR）IEEE刀豆ference，对1489年至1494年（http://medusa.fit.vutbr.cz/public/data/papers /2011-CVPR-Dubska-PClines.pdf）。</span><br><span class="line"></span><br><span class="line">edgeThreshold：检测到点属于用于确定线的边缘的阈值。</span><br><span class="line">lineDetectionThreshold：检测到局部最大值属于平行坐标空间中的线的阈值。</span><br><span class="line">linesDetectedBlock：在检测行时调用此块，通常在每个处理的帧上。包含m，b对（y = mx + b）中的归一化斜率和截距的AC阵列与所检测的线的数目和视频帧的当前时间戳的计数一起被传入。</span><br><span class="line">GPUImageLineGenerator：生成可以覆盖场景的线的辅助类。这些线的颜色可以使用-setLineColorRed：green：blue：</span><br><span class="line"></span><br><span class="line">lineWidth：行的宽度（以像素为单位），默认值为1.0。</span><br><span class="line">GPUImageMotionBlurFilter：对图像应用定向运动模糊</span><br><span class="line"></span><br><span class="line">blurSize：模糊大小的乘数，范围从0.0开始，默认值为1.0</span><br><span class="line">blurAngle：模糊的角度方向，以度为单位。</span><br><span class="line">GPUImageZoomBlurFilter：对图像应用定向运动模糊</span><br><span class="line"></span><br><span class="line">blurSize：模糊大小的乘数，范围从0.0开始，默认值为1.0</span><br><span class="line">blurCenter：模糊的标准化中心。（0.5,0.5）</span><br><span class="line">混合模式</span><br><span class="line"></span><br><span class="line">GPUImageChromaKeyBlendFilter：use第二个图像选择性替换第一个图像中的颜色</span><br><span class="line"></span><br><span class="line">thresholdSensitivity：颜色匹配需要存在到要求的目标颜色的接近程度（默认值为0.4）</span><br><span class="line">平滑：如何平滑地混合颜色匹配（默认值为0.1）</span><br><span class="line">GPUImageDissolveBlendFilter：应用两个图像的溶解混合</span><br><span class="line"></span><br><span class="line">mix：第二个图像覆盖第一个图像的程度（0.0-1.0，默认为0.5）</span><br><span class="line">GPUImageMultiplyBlendFilter：应用两个图像的乘法混合</span><br><span class="line"></span><br><span class="line">GPUImageAddBlendFilter：应用两个图像的加法混合</span><br><span class="line"></span><br><span class="line">GPUImageSubtractBlendFilter：应用两个图像的减法混合</span><br><span class="line"></span><br><span class="line">GPUImageDivideBlendFilter：应用两个图像的分割混合</span><br><span class="line"></span><br><span class="line">GPUImageOverlayBlendFilter：应用两个图像的叠加混合</span><br><span class="line"></span><br><span class="line">GPUImageDarkenBlendFilter：通过获取图像之间每个颜色分量的最小值来混合两个图像</span><br><span class="line"></span><br><span class="line">GPUImageLightenBlendFilter：通过获取图像之间每个颜色分量的最大值来混合两个图像</span><br><span class="line"></span><br><span class="line">GPUImageColorBurnBlendFilter：应用两个图像的颜色混合</span><br><span class="line"></span><br><span class="line">GPUImageColorDodgeBlendFilter：应用两个图像的颜色闪避混合</span><br><span class="line"></span><br><span class="line">GPUImageScreenBlendFilter：应用两个图像的屏幕混合</span><br><span class="line"></span><br><span class="line">GPUImageExclusionBlendFilter：应用两个图像的排除混合</span><br><span class="line"></span><br><span class="line">GPUImageDifferenceBlendFilter：应用两个图像的差异混合</span><br><span class="line"></span><br><span class="line">GPUImageHardLightBlendFilter：应用一个硬光混合的两个图像</span><br><span class="line"></span><br><span class="line">GPUImageSoftLightBlendFilter：应用两个图像的柔和光混合</span><br><span class="line"></span><br><span class="line">GPUImageAlphaBlendFilter：根据第二个alpha通道，将第二个图像混合在第一个图像上</span><br><span class="line"></span><br><span class="line">mix：第二个图像覆盖第一个图像的程度（0.0 - 1.0，默认为1.0）</span><br><span class="line">GPUImageSourceOverBlendFilter：在两个图像的混合上应用源</span><br><span class="line"></span><br><span class="line">GPUImageColorBurnBlendFilter：应用两个图像的颜色混合</span><br><span class="line"></span><br><span class="line">GPUImageColorDodgeBlendFilter：应用两个图像的颜色闪避混合</span><br><span class="line"></span><br><span class="line">GPUImageNormalBlendFilter：应用两个图像的正常混合</span><br><span class="line"></span><br><span class="line">GPUImageColorBlendFilter：应用两个图像的颜色混合</span><br><span class="line"></span><br><span class="line">GPUImageHueBlendFilter：应用两个图像的色调混合</span><br><span class="line"></span><br><span class="line">GPUImageSaturationBlendFilter：应用两个图像的饱和混合</span><br><span class="line"></span><br><span class="line">GPUImageLuminosityBlendFilter：应用两个图像的亮度混合</span><br><span class="line"></span><br><span class="line">GPUImageLinearBurnBlendFilter：应用两个图像的线性刻录混合</span><br><span class="line"></span><br><span class="line">GPUImagePoissonBlendFilter：应用两个图像的泊松混合</span><br><span class="line"></span><br><span class="line">混合：混合范围从0.0（只有图像1）到1.0（只有图像2梯度），1.0为正常水平</span><br><span class="line">numIterations：传播梯度的次数如果你想获得任何接近收敛，这个高达100或甚至1000 是的，这会很慢。</span><br><span class="line">GPUImageMaskFilter：使用另一个图像掩蔽一个图像</span><br><span class="line"></span><br><span class="line">视觉效果</span><br><span class="line"></span><br><span class="line">GPUImagePixellateFilter：对图像或视频应用像素化效果</span><br><span class="line"></span><br><span class="line">fractionalWidthOfAPixel：像素的大小，作为图像宽度和高度的一部分（0.0 - 1.0，默认为0.05）</span><br><span class="line">GPUImagePolarPixellateFilter：对图片或视频应用像素化效果，基于极坐标，而不是笛卡尔坐标</span><br><span class="line"></span><br><span class="line">center：应用像素的中心，默认为（0.5,0.5）</span><br><span class="line">pixelSize：分别像素大小，拆分为width和height组件。默认值为（0.05,0.05）</span><br><span class="line">GPUImagePolkaDotFilter：将图像分割成常规网格中的彩色点</span><br><span class="line"></span><br><span class="line">fractionalWidthOfAPixel：点的大小，作为图像宽度和高度的一部分（0.0 - 1.0，默认为0.05）</span><br><span class="line">dotScaling：每个网格空间的小部分由一个点占据，从0.0到1.0，默认值为0.9。</span><br><span class="line">GPUImageHalftoneFilter：对图像应用半色调效果，如新闻打印</span><br><span class="line"></span><br><span class="line">fractionalWidthOfAPixel：半色调点的大小，作为图像宽度和高度的一部分（0.0 - 1.0，默认为0.05）</span><br><span class="line">GPUImageCrosshatchFilter：将图像转换为黑白交叉阴影图案</span><br><span class="line"></span><br><span class="line">crossHatchSpacing：图像的分数宽度，用作交叉影线的间距。</span><br><span class="line">lineWidth：交叉线的相对宽度。默认值为0.003。</span><br><span class="line">GPUImageSketchFilter：将视像转换为外观像草图。这只是Sobel边缘检测滤镜的颜色反转</span><br><span class="line"></span><br><span class="line">texelWidth：</span><br><span class="line">texelHeight：这些参数影响检测到的边缘的可见性</span><br><span class="line">edgeStrength：调整滤波器的动态范围。值越高，边缘越强，但可以使强度色空间饱和。</span><br><span class="line">GPUImageThresholdSketchFilter：与草图过滤器相同，只有边缘是阈值，而不是灰度</span><br><span class="line"></span><br><span class="line">texelWidth：</span><br><span class="line">texelHeight：这些参数影响检测到的边缘的可见性</span><br><span class="line">edgeStrength：调整滤波器的动态范围。值越高，边缘越强，但可以使强度色空间饱和。</span><br><span class="line">threshold：高于此阈值的任何边将为黑色，任何低于白色的边。范围从0.0到1.0，默认为0.8</span><br><span class="line">GPUImageToonFilter：这使用Sobel边缘检测在对象周围放置一个黑色边框，然后它量化图像中呈现的颜色，以给图像一个卡通般的质量。</span><br><span class="line"></span><br><span class="line">texelWidth：</span><br><span class="line">texelHeight：这些参数影响检测到的边缘的可见性</span><br><span class="line">threshold：边缘检测的灵敏度，较低的值更敏感。范围从0.0到1.0，默认为0.2</span><br><span class="line">quantizationLevels：在最终图像中表示的颜色级别的数量。默认值为10.0</span><br><span class="line">GPUImageSmoothToonFilter：这使用与GPUImageToonFilter类似的过程，只有它之前的toon效果与高斯模糊，以平滑噪声。</span><br><span class="line"></span><br><span class="line">texelWidth：</span><br><span class="line">texelHeight：这些参数影响检测到的边缘的可见性</span><br><span class="line">blurRadiusInPixels：底层高斯模糊的半径。</span><br><span class="line">threshold：边缘检测的灵敏度，较低的值更敏感。范围从0.0到1.0，默认为0.2</span><br><span class="line">quantizationLevels：在最终图像中表示的颜色级别的数量。默认值为10.0</span><br><span class="line">GPUImageEmbossFilter：在图像上应用浮雕效果</span><br><span class="line"></span><br><span class="line">强度：压花的强度，从0.0到4.0，用1.0作为正常水平</span><br><span class="line">GPUImagePosterizeFilter：这将颜色动态范围减少到指定的步骤数，导致图像的卡通式简单阴影。</span><br><span class="line"></span><br><span class="line">colorLevels：将图像空间缩小到的颜色级数。取值范围为1〜256，缺省值为10。</span><br><span class="line">GPUImageSwirlFilter：在图像上创建漩涡失真</span><br><span class="line"></span><br><span class="line">radius：从中心到应用失真的半径，默认值为0.5</span><br><span class="line">center：图像的中心（从0 - 1.0的归一化坐标），默认为（0.5,0.5）</span><br><span class="line">angle：应用于图像的扭曲量，默认值为1.0</span><br><span class="line">GPUImageBulgeDistortionFilter：在图像上创建凸起失真</span><br><span class="line"></span><br><span class="line">radius：从中心到应用失真的半径，默认值为0.25</span><br><span class="line">center：图像的中心（从0 - 1.0的归一化坐标），对于其将失真，默认为（0.5,0.5）</span><br><span class="line">scale：应用的失真量，从-1.0到1.0，默认值为0.5</span><br><span class="line">GPUImagePinchDistortionFilter：创建图像的混合失真</span><br><span class="line"></span><br><span class="line">radius：从中心到应用失真的半径，默认值为1.0</span><br><span class="line">center：图像的中心（从0 - 1.0的归一化坐标），对于其将失真，默认为（0.5,0.5）</span><br><span class="line">scale：应用的失真量，从-2.0到2.0，默认值为1.0</span><br><span class="line">GPUImageStretchDistortionFilter：创建图像的拉伸失真</span><br><span class="line"></span><br><span class="line">center：图像的中心（从0 - 1.0的归一化坐标），对于其将失真，默认为（0.5,0.5）</span><br><span class="line">GPUImageSphereRefractionFilter：模拟通过玻璃球的折射</span><br><span class="line"></span><br><span class="line">center：应用失真的中心，默认为（0.5,0.5）</span><br><span class="line">radius：失真的半径，范围从0.0到1.0，默认值为0.25</span><br><span class="line">refractiveindex：球体的折射率，默认值为0.71</span><br><span class="line">GPUImageGlassSphereFilter：与GPUImageSphereRefractionFilter相同，只有图像不被反转，并且在玻璃的边缘有一点点结霜</span><br><span class="line"></span><br><span class="line">center：应用失真的中心，默认为（0.5,0.5）</span><br><span class="line">radius：失真的半径，范围从0.0到1.0，默认值为0.25</span><br><span class="line">refractiveindex：球体的折射率，默认值为0.71</span><br><span class="line">GPUImageVignetteFilter：执行渐晕效果，在边缘淡出图像</span><br><span class="line"></span><br><span class="line">vignetteCenter：tex coords中的小插曲的中心（CGPoint），默认值为0.5,0.5</span><br><span class="line">vignetteColor：用于小插曲（GPUVector3）的颜色，默认为黑色</span><br><span class="line">vignetteStart：从晕影效果开始的中心的标准化距离，默认值为0.5</span><br><span class="line">vignetteEnd：从晕影效果结束的中心的标准化距离，默认值为0.75</span><br><span class="line">GPUImageKuwaharaFilter：Kuwahara图像抽象，绘制自Kyprianidis等人的工作。et al。在他们的出版物“GPU中”英文相邻词汇热门词汇“GPU” 英文“昂贵的，因此它可能需要几秒钟来渲染在iPad 2上的框架。这可能最适合用于静态图像。</span><br><span class="line"></span><br><span class="line">radius：整数，指定应用滤镜时从中心像素向外测试的像素数，默认值为4.较高的值会创建更抽象的图像，但代价是处理时间更长。</span><br><span class="line">GPUImageKuwaharaRadius3Filter：一个修改版本的Kuwahara过滤器，优化工作超过三个像素的半径</span><br><span class="line"></span><br><span class="line">GPUImagePerlinNoiseFilter：生成一个充满Perlin噪声的图像</span><br><span class="line"></span><br><span class="line">colorStart：</span><br><span class="line">colorFinish：生成噪声的颜色范围</span><br><span class="line">scale：正在生成的噪声的缩放</span><br><span class="line">GPUImageCGAColorspaceFilter：模拟CGA显示器的色彩空间</span><br><span class="line"></span><br><span class="line">GPUImageMosaicFilter：此过滤器接受一个输入的瓷砖集，瓷砖必须以亮度上升。它查看输入图像并根据该瓦片的亮度用输入瓦片替换每个显示瓦片。这个想法是复制在其他应用程序中看到的ASCII视频过滤器，但是tileset可以是任何东西。</span><br><span class="line"></span><br><span class="line">inputTileSize：</span><br><span class="line">numTiles：</span><br><span class="line">displayTileSize：</span><br><span class="line">colorOn：</span><br><span class="line">GPUImageJFAVoronoiFilter：生成Voronoi地图，供以后阶段使用。</span><br><span class="line"></span><br><span class="line">sizeInPixels：单个元素的大小</span><br><span class="line">GPUImageVoronoiConsumerFilter：在Voronoi地图中，并使用它来过滤进入的图像。</span><br><span class="line"></span><br><span class="line">sizeInPixels：单个元素的大小</span><br></pre></td></tr></table></figure>
<h2 id="先来介绍几个基础概念"><a href="#先来介绍几个基础概念" class="headerlink" title="先来介绍几个基础概念"></a>先来介绍几个基础概念</h2><h4 id="1、GPUImageFilter"><a href="#1、GPUImageFilter" class="headerlink" title="1、GPUImageFilter"></a>1、GPUImageFilter</h4><p>GPUImage的滤镜的基类<br>作用：<br>1.都遵守GPUImageInput的协议<br>2.获得响应链上游的纹理，经过自己的处理，生成新的纹理，向响应链的下一个对象传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">extern NSString *const kGPUImageVertexShaderString;//顶点着色器</span><br><span class="line">extern NSString *const kGPUImagePassthroughFragmentShaderString;//片段着色器</span><br><span class="line"></span><br><span class="line">struct GPUVector4 &#123;//4维坐标</span><br><span class="line">    GLfloat one;</span><br><span class="line">    GLfloat two;</span><br><span class="line">    GLfloat three;</span><br><span class="line">    GLfloat four;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct GPUVector4 GPUVector4;</span><br><span class="line"></span><br><span class="line">struct GPUVector3 &#123;//3维坐标系</span><br><span class="line">    GLfloat one;</span><br><span class="line">    GLfloat two;</span><br><span class="line">    GLfloat three;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct GPUVector3 GPUVector3;</span><br><span class="line"></span><br><span class="line">struct GPUMatrix4x4 &#123;//4x4矩阵</span><br><span class="line">    GPUVector4 one;</span><br><span class="line">    GPUVector4 two;</span><br><span class="line">    GPUVector4 three;</span><br><span class="line">    GPUVector4 four;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct GPUMatrix4x4 GPUMatrix4x4;</span><br><span class="line"></span><br><span class="line">struct GPUMatrix3x3 &#123;&#123;//3x3矩阵</span><br><span class="line">    GPUVector3 one;</span><br><span class="line">    GPUVector3 two;</span><br><span class="line">    GPUVector3 three;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct GPUMatrix3x3 GPUMatrix3x3;</span><br><span class="line"></span><br><span class="line">/** GPUImage&apos;s base filter class</span><br><span class="line">GPUImage的滤镜的基类</span><br><span class="line"></span><br><span class="line"> Filters and other subsequent elements in the chain conform to the GPUImageInput protocol, which lets them take in the supplied or processed texture from the previous link in the chain and do something with it. Objects one step further down the chain are considered targets, and processing can be branched by adding multiple targets to a single output or filter.</span><br><span class="line">作用：</span><br><span class="line">1.都遵守GPUImageInput的协议</span><br><span class="line">2.获得响应链上游的纹理，经过自己的处理，生成新的纹理，向响应链的下一个对象传递</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@interface GPUImageFilter : GPUImageOutput &lt;GPUImageInput&gt;</span><br><span class="line">&#123;</span><br><span class="line">    GPUImageFramebuffer *firstInputFramebuffer;//输入帧缓存</span><br><span class="line"></span><br><span class="line">    GLProgram *filterProgram;//openGL源程序</span><br><span class="line">    GLint filterPositionAttribute, filterTextureCoordinateAttribute;//顶点属性、纹理属性</span><br><span class="line">    GLint filterInputTextureUniform;//输入纹理常量</span><br><span class="line">    GLfloat backgroundColorRed, backgroundColorGreen, backgroundColorBlue, backgroundColorAlpha;//r  g  b  a</span><br><span class="line"></span><br><span class="line">    BOOL isEndProcessing;//是否处理完成</span><br><span class="line"></span><br><span class="line">    CGSize currentFilterSize;//当前滤镜的尺寸</span><br><span class="line">    GPUImageRotationMode inputRotation;//旋转模式</span><br><span class="line"></span><br><span class="line">    BOOL currentlyReceivingMonochromeInput;//是否接受黑白输入</span><br><span class="line"></span><br><span class="line">    NSMutableDictionary *uniformStateRestorationBlocks;//</span><br><span class="line">    dispatch_semaphore_t imageCaptureSemaphore;//信号量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property(readonly) CVPixelBufferRef renderTarget;//像素对象</span><br><span class="line">@property(readwrite, nonatomic) BOOL preventRendering;//是否方式渲染</span><br><span class="line">@property(readwrite, nonatomic) BOOL currentlyReceivingMonochromeInput;//是否接受黑白输入</span><br><span class="line"></span><br><span class="line">- (id)initWithVertexShaderFromString:(NSString *)vertexShaderString fragmentShaderFromString:(NSString *)fragmentShaderString;// init</span><br><span class="line">- (id)initWithFragmentShaderFromString:(NSString *)fragmentShaderString;// init</span><br><span class="line">- (id)initWithFragmentShaderFromFile:(NSString *)fragmentShaderFilename;// init</span><br><span class="line">- (void)initializeAttributes;// init属性</span><br><span class="line">- (void)setupFilterForSize:(CGSize)filterFrameSize;//设置滤镜尺寸</span><br><span class="line">- (CGSize)rotatedSize:(CGSize)sizeToRotate forIndex:(NSInteger)textureIndex;//旋转尺寸</span><br><span class="line">- (CGPoint)rotatedPoint:(CGPoint)pointToRotate forRotation:(GPUImageRotationMode)rotation;//旋转顶点</span><br><span class="line">- (CGSize)sizeOfFBO;//帧缓存大小</span><br><span class="line">+ (const GLfloat *)textureCoordinatesForRotation:(GPUImageRotationMode)rotationMode;//纹理旋转</span><br><span class="line">- (void)renderToTextureWithVertices:(const GLfloat *)vertices textureCoordinates:(const GLfloat *)textureCoordinates;//根据顶点和纹理渲染</span><br><span class="line">- (void)informTargetsAboutNewFrameAtTime:(CMTime)frameTime;//通知响应链下游的对象</span><br><span class="line">- (CGSize)outputFrameSize;//输出</span><br><span class="line">/// 一些列set方法</span><br><span class="line">- (void)setBackgroundColorRed:(GLfloat)redComponent green:(GLfloat)greenComponent blue:(GLfloat)blueComponent alpha:(GLfloat)alphaComponent;</span><br><span class="line">- (void)setInteger:(GLint)newInteger forUniformName:(NSString *)uniformName;</span><br><span class="line">- (void)setFloat:(GLfloat)newFloat forUniformName:(NSString *)uniformName;</span><br><span class="line">- (void)setSize:(CGSize)newSize forUniformName:(NSString *)uniformName;</span><br><span class="line">- (void)setPoint:(CGPoint)newPoint forUniformName:(NSString *)uniformName;</span><br><span class="line">- (void)setFloatVec3:(GPUVector3)newVec3 forUniformName:(NSString *)uniformName;</span><br><span class="line">- (void)setFloatVec4:(GPUVector4)newVec4 forUniform:(NSString *)uniformName;</span><br><span class="line">- (void)setFloatArray:(GLfloat *)array length:(GLsizei)count forUniform:(NSString*)uniformName;</span><br><span class="line"></span><br><span class="line">- (void)setMatrix3f:(GPUMatrix3x3)matrix forUniform:(GLint)uniform program:(GLProgram *)shaderProgram;</span><br><span class="line">- (void)setMatrix4f:(GPUMatrix4x4)matrix forUniform:(GLint)uniform program:(GLProgram *)shaderProgram;</span><br><span class="line">- (void)setFloat:(GLfloat)floatValue forUniform:(GLint)uniform program:(GLProgram *)shaderProgram;</span><br><span class="line">- (void)setPoint:(CGPoint)pointValue forUniform:(GLint)uniform program:(GLProgram *)shaderProgram;</span><br><span class="line">- (void)setSize:(CGSize)sizeValue forUniform:(GLint)uniform program:(GLProgram *)shaderProgram;</span><br><span class="line">- (void)setVec3:(GPUVector3)vectorValue forUniform:(GLint)uniform program:(GLProgram *)shaderProgram;</span><br><span class="line">- (void)setVec4:(GPUVector4)vectorValue forUniform:(GLint)uniform program:(GLProgram *)shaderProgram;</span><br><span class="line">- (void)setFloatArray:(GLfloat *)arrayValue length:(GLsizei)arrayLength forUniform:(GLint)uniform program:(GLProgram *)shaderProgram;</span><br><span class="line">- (void)setInteger:(GLint)intValue forUniform:(GLint)uniform program:(GLProgram *)shaderProgram;</span><br><span class="line"></span><br><span class="line">- (void)setAndExecuteUniformStateCallbackAtIndex:(GLint)uniform forProgram:(GLProgram *)shaderProgram toBlock:(dispatch_block_t)uniformStateBlock;</span><br><span class="line">- (void)setUniformsForProgramAtIndex:(NSUInteger)programIndex;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="2、GPUImageFramebuffer"><a href="#2、GPUImageFramebuffer" class="headerlink" title="2、GPUImageFramebuffer"></a>2、GPUImageFramebuffer</h4><p>GPUmageFramebuffer类用于管理帧缓冲对象，负责帧缓冲对象的创建和销毁，读取帧缓冲内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@property(readonly) CGSize size;//只读属性，在实现中，设置缓冲区的size</span><br><span class="line">@property(readonly) GPUTextureOptions textureOptions;//纹理的选项</span><br><span class="line">@property(readonly) GLuint texture;//管理纹理</span><br><span class="line">@property(readonly) BOOL missingFramebuffer;//指示是否丢失帧缓冲对象</span><br><span class="line"></span><br><span class="line">// Initialization and teardown</span><br><span class="line">/*</span><br><span class="line">创建一个size为framebufferSize大小的帧缓冲对象</span><br><span class="line">参数 framebuffer的size。</span><br><span class="line">返回：创建成功的帧缓冲对象。</span><br><span class="line">*/</span><br><span class="line">- (id)initWithSize:(CGSize)framebufferSize;</span><br><span class="line">/*</span><br><span class="line">创建一个size为framebufferSize大小的帧缓冲对象</span><br><span class="line">参数：framebufferSize为framebuffer的size。fboTextureOptions是纹理的详细配置。onlyGenerateTexture说明是否只创建纹理而不创建陈帧缓冲对象。</span><br><span class="line">返回：创建成功的帧缓冲对象。</span><br><span class="line">*/</span><br><span class="line">- (id)initWithSize:(CGSize)framebufferSize textureOptions:(GPUTextureOptions)fboTextureOptions onlyTexture:(BOOL)onlyGenerateTexture;</span><br><span class="line">/*</span><br><span class="line">创建一个size为framebufferSize大小的帧缓冲对象</span><br><span class="line">参数：inputTexture为输入的纹理，用于渲染图片。</span><br><span class="line">返回：创建成功的帧缓冲对象。</span><br><span class="line">*/</span><br><span class="line">- (id)initWithSize:(CGSize)framebufferSize overriddenTexture:(GLuint)inputTexture;</span><br><span class="line"></span><br><span class="line">// Usage</span><br><span class="line">- (void)activateFramebuffer;//激活刚创建的framebuffer对象。只有调用它后，才会起作用。</span><br><span class="line"></span><br><span class="line">// Reference counting</span><br><span class="line">- (void)lock;//引用计数管理 +1</span><br><span class="line">- (void)unlock;//引用计数管理 -1</span><br><span class="line">- (void)clearAllLocks;//引用计数管理 设置为0</span><br><span class="line">- (void)disableReferenceCounting;//引用计数管理 禁用引用计数</span><br><span class="line">- (void)enableReferenceCounting;//引用计数管理 启用引用计数</span><br><span class="line"></span><br><span class="line">// Image capture</span><br><span class="line">- (CGImageRef)newCGImageFromFramebufferContents;</span><br><span class="line">- (void)restoreRenderTarget;//还原渲染目标对象</span><br><span class="line"></span><br><span class="line">// Raw data bytes</span><br><span class="line">- (void)lockForReading;//[锁](http://www.liuhaihua.cn/archives/tag/%e9%94%81)定PixelBuffer</span><br><span class="line">- (void)unlockAfterReading;//解锁PixelBuffer</span><br><span class="line">- (NSUInteger)bytesPerRow;//获取pixel buffer的行字节数</span><br><span class="line">- (GLubyte *)byteBuffer;//获取pixel buffer的基地址</span><br></pre></td></tr></table></figure>
<h6 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h6><p><a href="https://www.jianshu.com/p/7a58a7a61f4c" target="_blank" rel="noopener">GPUImage详细解析</a><br><a href="https://link.jianshu.com/?t=http://www.liuhaihua.cn/archives/179674.html" target="_blank" rel="noopener">GPUImage API文档之GPUImageFramebuffer类</a></p>
<h6 id="简单的使用一下GPUImage"><a href="#简单的使用一下GPUImage" class="headerlink" title="简单的使用一下GPUImage"></a>简单的使用一下GPUImage</h6><p>导入头文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;GPUImageView.h&gt;</span><br><span class="line">#import &lt;GPUImage/GPUImageSepiaFilter.h&gt;//褐色怀旧</span><br></pre></td></tr></table></figure>
<p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    UIImageView* imageView = [[UIImageView alloc] initWithFrame:self.view.bounds];</span><br><span class="line">    [self.view addSubview:imageView];</span><br><span class="line">    </span><br><span class="line">    GPUImageSepiaFilter* filter = [[GPUImageSepiaFilter alloc] init];</span><br><span class="line">    UIImage* image = [UIImage imageNamed:@&quot;timg.jpeg&quot;];</span><br><span class="line">     [imageView setImage:[filter imageByFilteringImage:image]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">case 100:  </span><br><span class="line">        &#123;//            亮度  </span><br><span class="line">            GPUImageBrightnessFilter *brightness = [[GPUImageBrightnessFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            brightness.brightness = vlaue;//设置亮度 -1.0 to 1.0 默认 0.0  </span><br><span class="line">            [brightness forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [brightness useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:brightness];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">              </span><br><span class="line">        case 101:  </span><br><span class="line">        &#123;//            曝光度  </span><br><span class="line">            GPUImageExposureFilter *exposure = [[GPUImageExposureFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            exposure.exposure = vlaue;//设置亮度 -10 to 10 默认 0  </span><br><span class="line">            [exposure forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [exposure useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:exposure];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">              </span><br><span class="line">        case 102:  </span><br><span class="line">        &#123;//            对比度  </span><br><span class="line">            GPUImageContrastFilter *contrast = [[GPUImageContrastFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            contrast.contrast = vlaue;//设置对比度 0 to 4 默认 1  </span><br><span class="line">            [contrast forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [contrast useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:contrast];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">             </span><br><span class="line">        case 103:  </span><br><span class="line">        &#123;//            饱和度  </span><br><span class="line">            GPUImageSaturationFilter *saturation = [[GPUImageSaturationFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            saturation.saturation = vlaue;//设置饱和度 0 to 2 默认 1  </span><br><span class="line">            [saturation forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [saturation useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:saturation];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">              </span><br><span class="line">        case 104:  </span><br><span class="line">        &#123;//            锐化  </span><br><span class="line">            GPUImageSharpenFilter *sharpen = [[GPUImageSharpenFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            sharpen.sharpness = vlaue;//设置饱和度 -4 to 4 默认 0  </span><br><span class="line">            [sharpen forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [sharpen useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:sharpen];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">              </span><br><span class="line">        case 105:  </span><br><span class="line">        &#123;//            形变  </span><br><span class="line">            GPUImageTransformFilter *transform = [[GPUImageTransformFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            transform.transform3D = CATransform3DMakeScale(vlaue, vlaue, vlaue);//设置属性  </span><br><span class="line">            [transform forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [transform useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:transform];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">              </span><br><span class="line">        case 106:  </span><br><span class="line">        &#123;//            高斯模糊  </span><br><span class="line">        GPUImageGaussianBlurFilter *gaussianBlur = [[GPUImageGaussianBlurFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            gaussianBlur.texelSpacingMultiplier = vlaue;  </span><br><span class="line">            [gaussianBlur forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [gaussianBlur useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:gaussianBlur];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">              </span><br><span class="line">        case 107:  </span><br><span class="line">        &#123;//            卡通效果  </span><br><span class="line">             GPUImageToonFilter *sketch = [[GPUImageToonFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            sketch.quantizationLevels = 10;  </span><br><span class="line">            [sketch forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [sketch useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:sketch];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">              </span><br><span class="line">        case 108:  </span><br><span class="line">        &#123;//            球形倒立效果  </span><br><span class="line">            GPUImageSphereRefractionFilter *glass = [[GPUImageSphereRefractionFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            glass.radius = vlaue; //设置球 半径  </span><br><span class="line">            [glass forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [glass useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:glass];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">              </span><br><span class="line">        case 109:  </span><br><span class="line">        &#123;//            怀旧效果  </span><br><span class="line">            GPUImageSepiaFilter *sepia = [[GPUImageSepiaFilter alloc] init];//创建滤镜对象  </span><br><span class="line">  </span><br><span class="line">            [sepia forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [sepia useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:sepia];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">              </span><br><span class="line">        case 110:  </span><br><span class="line">        &#123;//            反色效果  </span><br><span class="line">            GPUImageColorInvertFilter *colorInvert = [[GPUImageColorInvertFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            [colorInvert forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [colorInvert useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:colorInvert];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">              </span><br><span class="line">        case 111:  </span><br><span class="line">        &#123;//            色彩丢失效果  </span><br><span class="line">        GPUImageColorPackingFilter *colorPacking = [[GPUImageColorPackingFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            [colorPacking forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [colorPacking useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:colorPacking];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">           </span><br><span class="line">        case 112:  </span><br><span class="line">        &#123;//            晕影效果  </span><br><span class="line">            GPUImageVignetteFilter *vigette = [[GPUImageVignetteFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            vigette.vignetteStart = 0;  </span><br><span class="line">            [vigette forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [vigette useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:vigette];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">              </span><br><span class="line">        case 113:  </span><br><span class="line">        &#123;//            交叉线效果  </span><br><span class="line">            GPUImageCrosshatchFilter *crosshatch = [[GPUImageCrosshatchFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            crosshatch.crossHatchSpacing = vlaue;  </span><br><span class="line">            [crosshatch forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [crosshatch useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:crosshatch];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;  </span><br><span class="line">          </span><br><span class="line">        case 114:  </span><br><span class="line">        &#123;//            哈哈镜效果  </span><br><span class="line">        GPUImageStretchDistortionFilter *stretch = [[GPUImageStretchDistortionFilter alloc] init];//创建滤镜对象  </span><br><span class="line">            stretch.center = CGPointMake(vlaue, vlaue);  </span><br><span class="line">            [stretch forceProcessingAtSize:self.image.size];//设置要渲染的区域  </span><br><span class="line">            [stretch useNextFrameForImageCapture];//捕获图片效果  </span><br><span class="line">            [self filterWithObject:stretch];//渲染图片并显示  </span><br><span class="line">        &#125;  </span><br><span class="line">            break;</span><br></pre></td></tr></table></figure>
<h6 id="大概使用步骤是"><a href="#大概使用步骤是" class="headerlink" title="大概使用步骤是"></a>大概使用步骤是</h6><p>1、创建亮度滤镜对象<br><code>GPUImageBrightnessFilter *filter = [[GPUImageBrightnessFilter alloc] init];</code><br>2、设置亮度的值<br><code>filter.brightness = value;</code><br>3、设置纹理尺寸<br><code>[filter forceProcessingAtSize:image.size];</code><br>4、创建GPUImagePicture对象<br><code>GPUImagePicture *pic = [[GPUImagePicture alloc] initWithImage:image];</code><br>5、向创建好的GPUImagePicture对象添加addTarget<br><code>[pic addTarget:filter];</code><br>6、处理图像（需要注意 使用processImage这个方法尽量要调用useNextFrameForImageCapture)<br><code>[pic processImage]; [filter useNextFrameForImageCapture];</code><br>7、获取处理后的图像<br><code>image ＝ [filter imageFromCurrentFramebuffer];</code></p>
<h4 id="3、GPUImagePicture-图片处理类"><a href="#3、GPUImagePicture-图片处理类" class="headerlink" title="3、GPUImagePicture 图片处理类"></a>3、GPUImagePicture 图片处理类</h4><p>GPUImagePicture是PGUImage的图像处理类，继承GPUImageOutput，一般作为响应链的源头。<br>GPUImagePicture类静态图像处理操作，它可以是需要处理的静态图像，也可以是一张作为纹理使用的图片，调用向它发送processImage消息，进行图像滤镜处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">属性介绍</span><br><span class="line">pixelSizeOfImage 图像的像素大小。</span><br><span class="line">hasProcessedImage 图像是否已处理。</span><br><span class="line">imageUpdateSemaphore 图像处理的GCD信号量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法介绍</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (id)initWithURL:(NSURL *)url</span><br><span class="line">说明：使用指定url的图片来初始化GPUImagePicture</span><br><span class="line">- (id)initWithImage:(UIImage *)newImageSource</span><br><span class="line">说明：使用指定的UIImage对象来初始化GPUImagePicture</span><br><span class="line">- (id)initWithCGImage:(CGImageRef)newImageSource</span><br><span class="line">说明：使用指定的CGImageRef对象来初始化GPUImagePicture</span><br><span class="line">- (id)initWithImage:(UIImage *)newImageSource smoothlyScaleOutput:(BOOL)smoothlyScaleOutput</span><br><span class="line">说明：使用指定的UIImage对象来初始化GPUImagePicture，是否按比例调整输入图像的尺寸</span><br><span class="line">- (void)processImage</span><br><span class="line">说明：进行图像处理实际操作。</span><br><span class="line">- (BOOL)processImageWithCompletionHandler:(void (^)(void))completion</span><br><span class="line">说明：进行图像处理实际的操作，completion为当处理结束执行的操作。</span><br></pre></td></tr></table></figure>
<h4 id="4、GPUImageFilterGroup（组合滤镜）"><a href="#4、GPUImageFilterGroup（组合滤镜）" class="headerlink" title="4、GPUImageFilterGroup（组合滤镜）"></a>4、GPUImageFilterGroup（组合滤镜）</h4><p>GPUImageFilterGroup是多个filter的集合，terminalFilter为最终的filter，initialFilters为filter数组。GPUImageFilterGroup本身不绘制图像，对GPUImageFilterGroup添加删除Target操作的操作都会转为terminalFilter的操作。</p>
<h6 id="常用混合滤镜"><a href="#常用混合滤镜" class="headerlink" title="常用混合滤镜"></a><em>常用混合滤镜</em></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;GPUImageMultiplyBlendFilter.h&quot;             //通常用于创建阴影和深度效果</span><br><span class="line">  #import &quot;GPUImageNormalBlendFilter.h&quot;               //正常</span><br><span class="line">  #import &quot;GPUImageAlphaBlendFilter.h&quot;                //透明混合,通常用于在背景上应用前景的透明度</span><br><span class="line">  #import &quot;GPUImageDissolveBlendFilter.h&quot;             //溶解</span><br><span class="line">  #import &quot;GPUImageOverlayBlendFilter.h&quot;              //叠加,通常用于创建阴影效果</span><br><span class="line">  #import &quot;GPUImageDarkenBlendFilter.h&quot;               //加深混合,通常用于重叠类型</span><br><span class="line">  #import &quot;GPUImageLightenBlendFilter.h&quot;              //减淡混合,通常用于重叠类型</span><br><span class="line">  #import &quot;GPUImageSourceOverBlendFilter.h&quot;           //源混合</span><br><span class="line">  #import &quot;GPUImageColorBurnBlendFilter.h&quot;            //色彩加深混合</span><br><span class="line">  #import &quot;GPUImageColorDodgeBlendFilter.h&quot;           //色彩减淡混合</span><br><span class="line">  #import &quot;GPUImageScreenBlendFilter.h&quot;               //屏幕包裹,通常用于创建亮点和镜头眩光</span><br><span class="line">  #import &quot;GPUImageExclusionBlendFilter.h&quot;            //排除混合</span><br><span class="line">  #import &quot;GPUImageDifferenceBlendFilter.h&quot;           //差异混合,通常用于创建更多变动的颜色</span><br><span class="line">  #import &quot;GPUImageSubtractBlendFilter.h&quot;             //差值混合,通常用于创建两个图像之间的动画变暗模糊效果</span><br><span class="line">  #import &quot;GPUImageHardLightBlendFilter.h&quot;            //强光混合,通常用于创建阴影效果</span><br><span class="line">  #import &quot;GPUImageSoftLightBlendFilter.h&quot;            //柔光混合</span><br><span class="line">  #import &quot;GPUImageChromaKeyBlendFilter.h&quot;            //色度键混合</span><br><span class="line">  #import &quot;GPUImageMaskFilter.h&quot;                      //遮罩混合</span><br><span class="line">  #import &quot;GPUImageHazeFilter.h&quot;                      //朦胧加暗</span><br><span class="line">  #import &quot;GPUImageLuminanceThresholdFilter.h&quot;        //亮度阈</span><br><span class="line">  #import &quot;GPUImageAdaptiveThresholdFilter.h&quot;         //自适应阈值</span><br><span class="line">  #import &quot;GPUImageAddBlendFilter.h&quot;                  //通常用于创建两个图像之间的动画变亮模糊效果</span><br><span class="line">  #import &quot;GPUImageDivideBlendFilter.h&quot;               //通常用于创建两个图像之间的动画变暗模糊效果</span><br></pre></td></tr></table></figure>
<p>示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 图片输入源</span><br><span class="line">    _inputImage = [UIImage imageNamed:@&quot;icon&quot;];</span><br><span class="line"></span><br><span class="line">    // 初始化 picture</span><br><span class="line">    _picture    = [[GPUImagePicture alloc] initWithImage:_inputImage smoothlyScaleOutput:YES];</span><br><span class="line"></span><br><span class="line">    // 初始化 imageView</span><br><span class="line">    _imageView  = [[GPUImageView alloc] initWithFrame:self.iconImageView.bounds];</span><br><span class="line">    [self.iconImageView addSubview:_imageView];</span><br><span class="line"></span><br><span class="line">    // 初始化 filterGroup</span><br><span class="line">    _filterGroup = [[GPUImageFilterGroup alloc] init];</span><br><span class="line">    [_picture addTarget:_filterGroup];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 添加 filter</span><br><span class="line">    /**</span><br><span class="line">     原理：</span><br><span class="line">     1. filterGroup(addFilter) 滤镜组添加每个滤镜</span><br><span class="line">     2. 按添加顺序（可自行调整）前一个filter(addTarget) 添加后一个filter</span><br><span class="line">     3. filterGroup.initialFilters = @[第一个filter]];</span><br><span class="line">     4. filterGroup.terminalFilter = 最后一个filter;</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line">    GPUImageRGBFilter *filter1         = [[GPUImageRGBFilter alloc] init];</span><br><span class="line">    GPUImageToonFilter *filter2        = [[GPUImageToonFilter alloc] init];</span><br><span class="line">    GPUImageColorInvertFilter *filter3 = [[GPUImageColorInvertFilter alloc] init];</span><br><span class="line">    GPUImageSepiaFilter       *filter4 = [[GPUImageSepiaFilter alloc] init];</span><br><span class="line">    [self addGPUImageFilter:filter1];</span><br><span class="line">    [self addGPUImageFilter:filter2];</span><br><span class="line">    [self addGPUImageFilter:filter3];</span><br><span class="line">    [self addGPUImageFilter:filter4];</span><br><span class="line"></span><br><span class="line">    // 处理图片</span><br><span class="line">    [_picture processImage];</span><br><span class="line">    [_filterGroup useNextFrameForImageCapture];</span><br><span class="line"></span><br><span class="line">    self.iconImageView.image = [_filterGroup imageFromCurrentFramebuffer];</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[runtime]]></title>
      <url>/2018/03/30/runtime/</url>
      <content type="html"><![CDATA[<p>import ObjectiveC</p>
<p>import _SwiftObjectiveCOverlayShims</p>
<p>/*</p>
<ul>
<li><p>Copyright (c) 1999-2007 Apple Inc.  All Rights Reserved.</p>
</li>
<li></li>
<li><p>@APPLE_LICENSE_HEADER_START@</p>
</li>
<li></li>
<li><p>This file contains Original Code and/or Modifications of Original Code</p>
</li>
<li><p>as defined in and that are subject to the Apple Public Source License</p>
</li>
<li><p>Version 2.0 (the ‘License’). You may not use this file except in</p>
</li>
<li><p>compliance with the License. Please obtain a copy of the License at</p>
</li>
<li><p><a href="http://www.opensource.apple.com/apsl/" target="_blank" rel="noopener">http://www.opensource.apple.com/apsl/</a> and read it before using this</p>
</li>
<li><p>file.</p>
</li>
<li><a id="more"></a></li>
<li><p>The Original Code and all software distributed under the License are</p>
</li>
<li><p>distributed on an ‘AS IS’ basis, WITHOUT WARRANTY OF ANY KIND, EITHER</p>
</li>
<li><p>EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,</p>
</li>
<li><p>INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,</p>
</li>
<li><p>FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.</p>
</li>
<li><p>Please see the License for the specific language governing rights and</p>
</li>
<li><p>limitations under the License.</p>
</li>
<li></li>
<li><p>@APPLE_LICENSE_HEADER_END@</p>
<p>*/</p>
</li>
</ul>
<p>/<em> Types </em>/</p>
<p>/// An opaque type that represents a method in a class definition.</p>
<p>public typealias Method = OpaquePointer</p>
<p>/// An opaque type that represents an instance variable.</p>
<p>public typealias Ivar = OpaquePointer</p>
<p>/// An opaque type that represents a category.</p>
<p>public typealias Category = OpaquePointer</p>
<p>/// An opaque type that represents an Objective-C declared property.</p>
<p>public typealias objc_property_t = OpaquePointer</p>
<p>/<em> Use <code>Class</code> instead of `struct objc_class </em>` */</p>
<p>open class Protocol {</p>
<p>}</p>
<p>/// Defines a method</p>
<p>public struct objc_method_description {</p>
<p>​    /<em>*&lt; The name of the method </em>/</p>
<p>​    public var name: Selector?</p>
<p>​    /<em>*&lt; The types of the method arguments </em>/</p>
<p>​    public var types: UnsafeMutablePointer<int8>?</int8></p>
<p>​    public init()</p>
<p>​    public init(name: Selector?, types: UnsafeMutablePointer<int8>?)</int8></p>
<p>}</p>
<p>/// Defines a property attribute</p>
<p>public struct objc_property_attribute_t {</p>
<p>​    /<em>*&lt; The name of the attribute </em>/</p>
<p>​    public var name: UnsafePointer<int8></int8></p>
<p>​    /<em>*&lt; The value of the attribute (usually empty) </em>/</p>
<p>​    public var value: UnsafePointer<int8></int8></p>
<p>}</p>
<p>/<em> Functions </em>/</p>
<p>/<em> Working with Instances </em>/</p>
<p>/** </p>
<ul>
<li><p>Returns a copy of a given object.</p>
</li>
<li></li>
<li><p>@param obj An Objective-C object.</p>
</li>
<li><p>@param size The size of the object \e obj.</p>
</li>
<li></li>
<li><p>@return A copy of \e obj.</p>
<p>*/</p>
</li>
</ul>
<p>/** </p>
<ul>
<li><p>Frees the memory occupied by a given object.</p>
</li>
<li></li>
<li><p>@param obj An Objective-C object.</p>
</li>
<li></li>
<li><p>@return nil</p>
<p>*/</p>
</li>
</ul>
<p>/** </p>
<ul>
<li><p>Returns the class of an object.</p>
</li>
<li></li>
<li><p>@param obj The object you want to inspect.</p>
</li>
<li></li>
<li><p>@return The class object of which \e object is an instance, </p>
</li>
<li><p>or \c Nil if \e object is \c nil.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func object<em>getClass(</em> obj: Any?) -&gt; Swift.AnyClass?</p>
<p>/** </p>
<ul>
<li><p>Sets the class of an object.</p>
</li>
<li></li>
<li><p>@param obj The object to modify.</p>
</li>
<li><p>@param cls A class object.</p>
</li>
<li></li>
<li><p>@return The previous value of \e object’s class, or \c Nil if \e object is \c nil.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func object<em>setClass(</em> obj: Any?, _ cls: Swift.AnyClass) -&gt; Swift.AnyClass?</p>
<p>/** </p>
<ul>
<li><p>Returns whether an object is a class object.</p>
</li>
<li></li>
<li><p>@param obj An Objective-C object.</p>
</li>
<li></li>
<li><p>@return true if the object is a class or metaclass, false otherwise.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 8.0, *)</p>
<p>public func object<em>isClass(</em> obj: Any?) -&gt; Bool</p>
<p>/** </p>
<ul>
<li><p>Reads the value of an instance variable in an object.</p>
</li>
<li></li>
<li><p>@param obj The object containing the instance variable whose value you want to read.</p>
</li>
<li><p>@param ivar The Ivar describing the instance variable whose value you want to read.</p>
</li>
<li></li>
<li><p>@return The value of the instance variable specified by \e ivar, or \c nil if \e object is \c nil.</p>
</li>
<li></li>
<li><p>@note \c object_getIvar is faster than \c object_getInstanceVariable if the Ivar</p>
</li>
<li><p>for the instance variable is already known.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func object<em>getIvar(</em> obj: Any?, _ ivar: Ivar) -&gt; Any?</p>
<p>/** </p>
<ul>
<li><p>Sets the value of an instance variable in an object.</p>
</li>
<li></li>
<li><p>@param obj The object containing the instance variable whose value you want to set.</p>
</li>
<li><p>@param ivar The Ivar describing the instance variable whose value you want to set.</p>
</li>
<li><p>@param value The new value for the instance variable.</p>
</li>
<li></li>
<li><p>@note Instance variables with known memory management (such as ARC strong and weak)</p>
</li>
<li><p>use that memory management. Instance variables with unknown memory management </p>
</li>
<li><p>are assigned as if they were unsafe_unretained.</p>
</li>
<li><p>@note \c object_setIvar is faster than \c object_setInstanceVariable if the Ivar</p>
</li>
<li><p>for the instance variable is already known.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func object<em>setIvar(</em> obj: Any?, <em> ivar: Ivar, </em> value: Any?)</p>
<p>/** </p>
<ul>
<li><p>Sets the value of an instance variable in an object.</p>
</li>
<li></li>
<li><p>@param obj The object containing the instance variable whose value you want to set.</p>
</li>
<li><p>@param ivar The Ivar describing the instance variable whose value you want to set.</p>
</li>
<li><p>@param value The new value for the instance variable.</p>
</li>
<li></li>
<li><p>@note Instance variables with known memory management (such as ARC strong and weak)</p>
</li>
<li><p>use that memory management. Instance variables with unknown memory management </p>
</li>
<li><p>are assigned as if they were strong.</p>
</li>
<li><p>@note \c object_setIvar is faster than \c object_setInstanceVariable if the Ivar</p>
</li>
<li><p>for the instance variable is already known.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 10.0, *)</p>
<p>public func object<em>setIvarWithStrongDefault(</em> obj: Any?, <em> ivar: Ivar, </em> value: Any?)</p>
<p>/** </p>
<ul>
<li><p>Changes the value of an instance variable of a class instance.</p>
</li>
<li></li>
<li><p>@param obj A pointer to an instance of a class. Pass the object containing</p>
</li>
<li><p>the instance variable whose value you wish to modify.</p>
</li>
<li><p>@param name A C string. Pass the name of the instance variable whose value you wish to modify.</p>
</li>
<li><p>@param value The new value for the instance variable.</p>
</li>
<li></li>
<li><p>@return A pointer to the \c Ivar data structure that defines the type and </p>
</li>
<li><p>name of the instance variable specified by \e name.</p>
<p>*</p>
</li>
<li><p>@note Instance variables with known memory management (such as ARC strong and weak)</p>
</li>
<li><p>use that memory management. Instance variables with unknown memory management </p>
</li>
<li><p>are assigned as if they were unsafe_unretained.</p>
<p>*/</p>
</li>
</ul>
<p>/** </p>
<ul>
<li><p>Changes the value of an instance variable of a class instance.</p>
</li>
<li></li>
<li><p>@param obj A pointer to an instance of a class. Pass the object containing</p>
</li>
<li><p>the instance variable whose value you wish to modify.</p>
</li>
<li><p>@param name A C string. Pass the name of the instance variable whose value you wish to modify.</p>
</li>
<li><p>@param value The new value for the instance variable.</p>
</li>
<li></li>
<li><p>@return A pointer to the \c Ivar data structure that defines the type and </p>
</li>
<li><p>name of the instance variable specified by \e name.</p>
<p>*</p>
</li>
<li><p>@note Instance variables with known memory management (such as ARC strong and weak)</p>
</li>
<li><p>use that memory management. Instance variables with unknown memory management </p>
</li>
<li><p>are assigned as if they were strong.</p>
<p>*/</p>
</li>
</ul>
<p>/** </p>
<ul>
<li><p>Obtains the value of an instance variable of a class instance.</p>
</li>
<li></li>
<li><p>@param obj A pointer to an instance of a class. Pass the object containing</p>
</li>
<li><p>the instance variable whose value you wish to obtain.</p>
</li>
<li><p>@param name A C string. Pass the name of the instance variable whose value you wish to obtain.</p>
</li>
<li><p>@param outValue On return, contains a pointer to the value of the instance variable.</p>
</li>
<li></li>
<li><p>@return A pointer to the \c Ivar data structure that defines the type and name of</p>
</li>
<li><p>the instance variable specified by \e name.</p>
<p>*/</p>
</li>
</ul>
<p>/<em> Obtaining Class Definitions </em>/</p>
<p>/** </p>
<ul>
<li><p>Returns the class definition of a specified class.</p>
</li>
<li></li>
<li><p>@param name The name of the class to look up.</p>
</li>
<li></li>
<li><p>@return The Class object for the named class, or \c nil</p>
</li>
<li><p>if the class is not registered with the Objective-C runtime.</p>
</li>
<li></li>
<li><p>@note \c objc_getClass is different from \c objc_lookUpClass in that if the class</p>
</li>
<li><p>is not registered, \c objc_getClass calls the class handler callback and then checks</p>
</li>
<li><p>a second time to see whether the class is registered. \c objc_lookUpClass does </p>
</li>
<li><p>not call the class handler callback.</p>
</li>
<li></li>
<li><p>@warning Earlier implementations of this function (prior to OS X v10.0)</p>
</li>
<li><p>terminate the program if the class does not exist.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>getClass(</em> name: UnsafePointer<int8>) -&gt; Any!</int8></p>
<p>/** </p>
<ul>
<li><p>Returns the metaclass definition of a specified class.</p>
</li>
<li></li>
<li><p>@param name The name of the class to look up.</p>
</li>
<li></li>
<li><p>@return The \c Class object for the metaclass of the named class, or \c nil if the class</p>
</li>
<li><p>is not registered with the Objective-C runtime.</p>
</li>
<li></li>
<li><p>@note If the definition for the named class is not registered, this function calls the class handler</p>
</li>
<li><p>callback and then checks a second time to see if the class is registered. However, every class</p>
</li>
<li><p>definition must have a valid metaclass definition, and so the metaclass definition is always returned,</p>
</li>
<li><p>whether it’s valid or not.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>getMetaClass(</em> name: UnsafePointer<int8>) -&gt; Any!</int8></p>
<p>/** </p>
<ul>
<li><p>Returns the class definition of a specified class.</p>
</li>
<li></li>
<li><p>@param name The name of the class to look up.</p>
</li>
<li></li>
<li><p>@return The Class object for the named class, or \c nil if the class</p>
</li>
<li><p>is not registered with the Objective-C runtime.</p>
</li>
<li></li>
<li><p>@note \c objc_getClass is different from this function in that if the class is not</p>
</li>
<li><p>registered, \c objc_getClass calls the class handler callback and then checks a second</p>
</li>
<li><p>time to see whether the class is registered. This function does not call the class handler callback.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>lookUpClass(</em> name: UnsafePointer<int8>) -&gt; Swift.AnyClass?</int8></p>
<p>/** </p>
<ul>
<li><p>Returns the class definition of a specified class.</p>
</li>
<li></li>
<li><p>@param name The name of the class to look up.</p>
</li>
<li></li>
<li><p>@return The Class object for the named class.</p>
</li>
<li></li>
<li><p>@note This function is the same as \c objc_getClass, but kills the process if the class is not found.</p>
</li>
<li><p>@note This function is used by ZeroLink, where failing to find a class would be a compile-time link error without ZeroLink.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>getRequiredClass(</em> name: UnsafePointer<int8>) -&gt; Swift.AnyClass</int8></p>
<p>/** </p>
<ul>
<li><p>Obtains the list of registered class definitions.</p>
</li>
<li></li>
<li><p>@param buffer An array of \c Class values. On output, each \c Class value points to</p>
</li>
<li><p>one class definition, up to either \e bufferCount or the total number of registered classes,</p>
</li>
<li><p>whichever is less. You can pass \c NULL to obtain the total number of registered class</p>
</li>
<li><p>definitions without actually retrieving any class definitions.</p>
</li>
<li><p>@param bufferCount An integer value. Pass the number of pointers for which you have allocated space</p>
</li>
<li><p>in \e buffer. On return, this function fills in only this number of elements. If this number is less</p>
</li>
<li><p>than the number of registered classes, this function returns an arbitrary subset of the registered classes.</p>
</li>
<li></li>
<li><p>@return An integer value indicating the total number of registered classes.</p>
</li>
<li></li>
<li><p>@note The Objective-C runtime library automatically registers all the classes defined in your source code.</p>
</li>
<li><p>You can create class definitions at runtime and register them with the \c objc_addClass function.</p>
</li>
<li></li>
<li><p>@warning You cannot assume that class objects you get from this function are classes that inherit from \c NSObject,</p>
</li>
<li><p>so you cannot safely call any methods on such classes without detecting that the method is implemented first.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>getClassList(</em> buffer: AutoreleasingUnsafeMutablePointer<swift.anyclass>?, _ bufferCount: Int32) -&gt; Int32</swift.anyclass></p>
<p>/** </p>
<ul>
<li><p>Creates and returns a list of pointers to all registered class definitions.</p>
</li>
<li></li>
<li><p>@param outCount An integer pointer used to store the number of classes returned by</p>
</li>
<li><p>this function in the list. It can be \c nil.</p>
</li>
<li></li>
<li><p>@return A nil terminated array of classes. It must be freed with \c free().</p>
</li>
<li></li>
<li><p>@see objc_getClassList</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 3.1, *)</p>
<p>public func objc<em>copyClassList(</em> outCount: UnsafeMutablePointer<uint32>?) -&gt; AutoreleasingUnsafeMutablePointer<swift.anyclass>?</swift.anyclass></uint32></p>
<p>/<em> Working with Classes </em>/</p>
<p>/** </p>
<ul>
<li><p>Returns the name of a class.</p>
</li>
<li></li>
<li><p>@param cls A class object.</p>
</li>
<li></li>
<li><p>@return The name of the class, or the empty string if \e cls is \c Nil.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getName(</em> cls: Swift.AnyClass?) -&gt; UnsafePointer<int8></int8></p>
<p>/** </p>
<ul>
<li><p>Returns a Boolean value that indicates whether a class object is a metaclass.</p>
</li>
<li></li>
<li><p>@param cls A class object.</p>
</li>
<li></li>
<li><p>@return \c YES if \e cls is a metaclass, \c NO if \e cls is a non-meta class, </p>
</li>
<li><p>\c NO if \e cls is \c Nil.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>isMetaClass(</em> cls: Swift.AnyClass?) -&gt; Bool</p>
<p>/** </p>
<ul>
<li><p>Returns the superclass of a class.</p>
</li>
<li></li>
<li><p>@param cls A class object.</p>
</li>
<li></li>
<li><p>@return The superclass of the class, or \c Nil if</p>
</li>
<li><p>\e cls is a root class, or \c Nil if \e cls is \c Nil.</p>
<p>*</p>
</li>
<li><p>@note You should usually use \c NSObject’s \c superclass method instead of this function.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getSuperclass(</em> cls: Swift.AnyClass?) -&gt; Swift.AnyClass?</p>
<p>/** </p>
<ul>
<li><p>Sets the superclass of a given class.</p>
</li>
<li></li>
<li><p>@param cls The class whose superclass you want to set.</p>
</li>
<li><p>@param newSuper The new superclass for cls.</p>
</li>
<li></li>
<li><p>@return The old superclass for cls.</p>
</li>
<li></li>
<li><p>@warning You should not use this function.</p>
<p>*/</p>
</li>
</ul>
<p>/** </p>
<ul>
<li><p>Returns the version number of a class definition.</p>
</li>
<li></li>
<li><p>@param cls A pointer to a \c Class data structure. Pass</p>
</li>
<li><p>the class definition for which you wish to obtain the version.</p>
</li>
<li></li>
<li><p>@return An integer indicating the version number of the class definition.</p>
<p>*</p>
</li>
<li><p>@see class_setVersion</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getVersion(</em> cls: Swift.AnyClass?) -&gt; Int32</p>
<p>/** </p>
<ul>
<li><p>Sets the version number of a class definition.</p>
</li>
<li></li>
<li><p>@param cls A pointer to an Class data structure. </p>
</li>
<li><p>Pass the class definition for which you wish to set the version.</p>
</li>
<li><p>@param version An integer. Pass the new version number of the class definition.</p>
<p>*</p>
</li>
<li><p>@note You can use the version number of the class definition to provide versioning of the</p>
</li>
<li><p>interface that your class represents to other classes. This is especially useful for object</p>
</li>
<li><p>serialization (that is, archiving of the object in a flattened form), where it is important to</p>
</li>
<li><p>recognize changes to the layout of the instance variables in different class-definition versions.</p>
</li>
<li><p>@note Classes derived from the Foundation framework \c NSObject class can set the class-definition</p>
</li>
<li><p>version number using the \c setVersion: class method, which is implemented using the \c class_setVersion function.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>setVersion(</em> cls: Swift.AnyClass?, _ version: Int32)</p>
<p>/** </p>
<ul>
<li><p>Returns the size of instances of a class.</p>
</li>
<li></li>
<li><p>@param cls A class object.</p>
</li>
<li></li>
<li><p>@return The size in bytes of instances of the class \e cls, or \c 0 if \e cls is \c Nil.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getInstanceSize(</em> cls: Swift.AnyClass?) -&gt; Int</p>
<p>/** </p>
<ul>
<li><p>Returns the \c Ivar for a specified instance variable of a given class.</p>
</li>
<li></li>
<li><p>@param cls The class whose instance variable you wish to obtain.</p>
</li>
<li><p>@param name The name of the instance variable definition to obtain.</p>
</li>
<li></li>
<li><p>@return A pointer to an \c Ivar data structure containing information about </p>
</li>
<li><p>the instance variable specified by \e name.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getInstanceVariable(</em> cls: Swift.AnyClass?, _ name: UnsafePointer<int8>) -&gt; Ivar?</int8></p>
<p>/** </p>
<ul>
<li><p>Returns the Ivar for a specified class variable of a given class.</p>
</li>
<li></li>
<li><p>@param cls The class definition whose class variable you wish to obtain.</p>
</li>
<li><p>@param name The name of the class variable definition to obtain.</p>
</li>
<li></li>
<li><p>@return A pointer to an \c Ivar data structure containing information about the class variable specified by \e name.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getClassVariable(</em> cls: Swift.AnyClass?, _ name: UnsafePointer<int8>) -&gt; Ivar?</int8></p>
<p>/** </p>
<ul>
<li><p>Describes the instance variables declared by a class.</p>
</li>
<li></li>
<li><p>@param cls The class to inspect.</p>
</li>
<li><p>@param outCount On return, contains the length of the returned array. </p>
</li>
<li><p>If outCount is NULL, the length is not returned.</p>
</li>
<li></li>
<li><p>@return An array of pointers of type Ivar describing the instance variables declared by the class. </p>
</li>
<li><p>Any instance variables declared by superclasses are not included. The array contains *outCount </p>
</li>
<li><p>pointers followed by a NULL terminator. You must free the array with free().</p>
</li>
<li></li>
<li><p>If the class declares no instance variables, or cls is Nil, NULL is returned and *outCount is 0.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>copyIvarList(</em> cls: Swift.AnyClass?, _ outCount: UnsafeMutablePointer<uint32>?) -&gt; UnsafeMutablePointer<ivar>?</ivar></uint32></p>
<p>/** </p>
<ul>
<li><p>Returns a specified instance method for a given class.</p>
</li>
<li></li>
<li><p>@param cls The class you want to inspect.</p>
</li>
<li><p>@param name The selector of the method you want to retrieve.</p>
</li>
<li></li>
<li><p>@return The method that corresponds to the implementation of the selector specified by </p>
</li>
<li><p>\e name for the class specified by \e cls, or \c NULL if the specified class or its </p>
</li>
<li><p>superclasses do not contain an instance method with the specified selector.</p>
<p>*</p>
</li>
<li><p>@note This function searches superclasses for implementations, whereas \c class_copyMethodList does not.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getInstanceMethod(</em> cls: Swift.AnyClass?, _ name: Selector) -&gt; Method?</p>
<p>/** </p>
<ul>
<li><p>Returns a pointer to the data structure describing a given class method for a given class.</p>
</li>
<li></li>
<li><p>@param cls A pointer to a class definition. Pass the class that contains the method you want to retrieve.</p>
</li>
<li><p>@param name A pointer of type \c SEL. Pass the selector of the method you want to retrieve.</p>
</li>
<li></li>
<li><p>@return A pointer to the \c Method data structure that corresponds to the implementation of the </p>
</li>
<li><p>selector specified by aSelector for the class specified by aClass, or NULL if the specified </p>
</li>
<li><p>class or its superclasses do not contain an instance method with the specified selector.</p>
<p>*</p>
</li>
<li><p>@note Note that this function searches superclasses for implementations, </p>
</li>
<li><p>whereas \c class_copyMethodList does not.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getClassMethod(</em> cls: Swift.AnyClass?, _ name: Selector) -&gt; Method?</p>
<p>/** </p>
<ul>
<li><p>Returns the function pointer that would be called if a </p>
</li>
<li><p>particular message were sent to an instance of a class.</p>
</li>
<li></li>
<li><p>@param cls The class you want to inspect.</p>
</li>
<li><p>@param name A selector.</p>
</li>
<li></li>
<li><p>@return The function pointer that would be called if \c [object name] were called</p>
</li>
<li><p>with an instance of the class, or \c NULL if \e cls is \c Nil.</p>
<p>*</p>
</li>
<li><p>@note \c class_getMethodImplementation may be faster than \c method_getImplementation(class_getInstanceMethod(cls, name)).</p>
</li>
<li><p>@note The function pointer returned may be a function internal to the runtime instead of</p>
</li>
<li><p>an actual method implementation. For example, if instances of the class do not respond to</p>
</li>
<li><p>the selector, the function pointer returned will be part of the runtime’s message forwarding machinery.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getMethodImplementation(</em> cls: Swift.AnyClass?, _ name: Selector) -&gt; IMP?</p>
<p>/** </p>
<ul>
<li><p>Returns the function pointer that would be called if a particular </p>
</li>
<li><p>message were sent to an instance of a class.</p>
</li>
<li></li>
<li><p>@param cls The class you want to inspect.</p>
</li>
<li><p>@param name A selector.</p>
</li>
<li></li>
<li><p>@return The function pointer that would be called if \c [object name] were called</p>
</li>
<li><p>with an instance of the class, or \c NULL if \e cls is \c Nil.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class_getMethodImplementation<em>stret(</em> cls: Swift.AnyClass?, _ name: Selector) -&gt; IMP?</p>
<p>/** </p>
<ul>
<li><p>Returns a Boolean value that indicates whether instances of a class respond to a particular selector.</p>
</li>
<li></li>
<li><p>@param cls The class you want to inspect.</p>
</li>
<li><p>@param sel A selector.</p>
</li>
<li></li>
<li><p>@return \c YES if instances of the class respond to the selector, otherwise \c NO.</p>
</li>
<li></li>
<li><p>@note You should usually use \c NSObject’s \c respondsToSelector: or \c instancesRespondToSelector: </p>
</li>
<li><p>methods instead of this function.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>respondsToSelector(</em> cls: Swift.AnyClass?, _ sel: Selector) -&gt; Bool</p>
<p>/** </p>
<ul>
<li><p>Describes the instance methods implemented by a class.</p>
</li>
<li></li>
<li><p>@param cls The class you want to inspect.</p>
</li>
<li><p>@param outCount On return, contains the length of the returned array. </p>
</li>
<li><p>If outCount is NULL, the length is not returned.</p>
</li>
<li></li>
<li><p>@return An array of pointers of type Method describing the instance methods </p>
</li>
<li><p>implemented by the class—any instance methods implemented by superclasses are not included. </p>
</li>
<li><p>The array contains *outCount pointers followed by a NULL terminator. You must free the array with free().</p>
</li>
<li></li>
<li><p>If cls implements no instance methods, or cls is Nil, returns NULL and *outCount is 0.</p>
</li>
<li></li>
<li><p>@note To get the class methods of a class, use \c class_copyMethodList(object_getClass(cls), &amp;count).</p>
</li>
<li><p>@note To get the implementations of methods that may be implemented by superclasses, </p>
</li>
<li><p>use \c class_getInstanceMethod or \c class_getClassMethod.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>copyMethodList(</em> cls: Swift.AnyClass?, _ outCount: UnsafeMutablePointer<uint32>?) -&gt; UnsafeMutablePointer<method>?</method></uint32></p>
<p>/** </p>
<ul>
<li><p>Returns a Boolean value that indicates whether a class conforms to a given protocol.</p>
</li>
<li></li>
<li><p>@param cls The class you want to inspect.</p>
</li>
<li><p>@param protocol A protocol.</p>
<p>*</p>
</li>
<li><p>@return YES if cls conforms to protocol, otherwise NO.</p>
<p>*</p>
</li>
<li><p>@note You should usually use NSObject’s conformsToProtocol: method instead of this function.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>conformsToProtocol(</em> cls: Swift.AnyClass?, _ protocol: Protocol?) -&gt; Bool</p>
<p>/** </p>
<ul>
<li><p>Describes the protocols adopted by a class.</p>
</li>
<li></li>
<li><p>@param cls The class you want to inspect.</p>
</li>
<li><p>@param outCount On return, contains the length of the returned array. </p>
</li>
<li><p>If outCount is NULL, the length is not returned.</p>
</li>
<li></li>
<li><p>@return An array of pointers of type Protocol* describing the protocols adopted </p>
</li>
<li><p>by the class. Any protocols adopted by superclasses or other protocols are not included. </p>
</li>
<li><p>The array contains *outCount pointers followed by a NULL terminator. You must free the array with free().</p>
</li>
<li></li>
<li><p>If cls adopts no protocols, or cls is Nil, returns NULL and *outCount is 0.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>copyProtocolList(</em> cls: Swift.AnyClass?, _ outCount: UnsafeMutablePointer<uint32>?) -&gt; AutoreleasingUnsafeMutablePointer<protocol>?</protocol></uint32></p>
<p>/** </p>
<ul>
<li><p>Returns a property with a given name of a given class.</p>
</li>
<li></li>
<li><p>@param cls The class you want to inspect.</p>
</li>
<li><p>@param name The name of the property you want to inspect.</p>
</li>
<li></li>
<li><p>@return A pointer of type \c objc_property_t describing the property, or</p>
</li>
<li><p>\c NULL if the class does not declare a property with that name, </p>
</li>
<li><p>or \c NULL if \e cls is \c Nil.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getProperty(</em> cls: Swift.AnyClass?, _ name: UnsafePointer<int8>) -&gt; objc_property_t?</int8></p>
<p>/** </p>
<ul>
<li><p>Describes the properties declared by a class.</p>
</li>
<li></li>
<li><p>@param cls The class you want to inspect.</p>
</li>
<li><p>@param outCount On return, contains the length of the returned array. </p>
</li>
<li><p>If \e outCount is \c NULL, the length is not returned.        </p>
</li>
<li></li>
<li><p>@return An array of pointers of type \c objc_property_t describing the properties </p>
</li>
<li><p>declared by the class. Any properties declared by superclasses are not included. </p>
</li>
<li><p>The array contains \c *outCount pointers followed by a \c NULL terminator. You must free the array with \c free().</p>
</li>
<li></li>
<li><p>If \e cls declares no properties, or \e cls is \c Nil, returns \c NULL and \c *outCount is \c 0.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>copyPropertyList(</em> cls: Swift.AnyClass?, _ outCount: UnsafeMutablePointer<uint32>?) -&gt; UnsafeMutablePointer<objc_property_t>?</objc_property_t></uint32></p>
<p>/** </p>
<ul>
<li><p>Returns a description of the \c Ivar layout for a given class.</p>
</li>
<li></li>
<li><p>@param cls The class to inspect.</p>
</li>
<li></li>
<li><p>@return A description of the \c Ivar layout for \e cls.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getIvarLayout(</em> cls: Swift.AnyClass?) -&gt; UnsafePointer<uint8>?</uint8></p>
<p>/** </p>
<ul>
<li><p>Returns a description of the layout of weak Ivars for a given class.</p>
</li>
<li></li>
<li><p>@param cls The class to inspect.</p>
</li>
<li></li>
<li><p>@return A description of the layout of the weak \c Ivars for \e cls.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getWeakIvarLayout(</em> cls: Swift.AnyClass?) -&gt; UnsafePointer<uint8>?</uint8></p>
<p>/** </p>
<ul>
<li><p>Adds a new method to a class with a given name and implementation.</p>
</li>
<li></li>
<li><p>@param cls The class to which to add a method.</p>
</li>
<li><p>@param name A selector that specifies the name of the method being added.</p>
</li>
<li><p>@param imp A function which is the implementation of the new method. The function must take at least two arguments—self and _cmd.</p>
</li>
<li><p>@param types An array of characters that describe the types of the arguments to the method. </p>
</li>
<li></li>
<li><p>@return YES if the method was added successfully, otherwise NO </p>
</li>
<li><p>(for example, the class already contains a method implementation with that name).</p>
<p>*</p>
</li>
<li><p>@note class_addMethod will add an override of a superclass’s implementation, </p>
</li>
<li><p>but will not replace an existing implementation in this class. </p>
</li>
<li><p>To change an existing implementation, use method_setImplementation.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>addMethod(</em> cls: Swift.AnyClass?, <em> name: Selector, </em> imp: IMP, _ types: UnsafePointer<int8>?) -&gt; Bool</int8></p>
<p>/** </p>
<ul>
<li><p>Replaces the implementation of a method for a given class.</p>
</li>
<li></li>
<li><p>@param cls The class you want to modify.</p>
</li>
<li><p>@param name A selector that identifies the method whose implementation you want to replace.</p>
</li>
<li><p>@param imp The new implementation for the method identified by name for the class identified by cls.</p>
</li>
<li><p>@param types An array of characters that describe the types of the arguments to the method. </p>
</li>
<li><p>Since the function must take at least two arguments—self and _cmd, the second and third characters</p>
</li>
<li><p>must be “@:” (the first character is the return type).</p>
</li>
<li></li>
<li><p>@return The previous implementation of the method identified by \e name for the class identified by \e cls.</p>
</li>
<li></li>
<li><p>@note This function behaves in two different ways:</p>
</li>
<li><ul>
<li>If the method identified by \e name does not yet exist, it is added as if \c class_addMethod were called. </li>
</ul>
</li>
<li><p>The type encoding specified by \e types is used as given.</p>
</li>
<li><ul>
<li>If the method identified by \e name does exist, its \c IMP is replaced as if \c method_setImplementation were called.</li>
</ul>
</li>
<li><p>The type encoding specified by \e types is ignored.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>replaceMethod(</em> cls: Swift.AnyClass?, <em> name: Selector, </em> imp: IMP, _ types: UnsafePointer<int8>?) -&gt; IMP?</int8></p>
<p>/** </p>
<ul>
<li><p>Adds a new instance variable to a class.</p>
</li>
<li></li>
<li><p>@return YES if the instance variable was added successfully, otherwise NO </p>
</li>
<li><p>(for example, the class already contains an instance variable with that name).</p>
<p>*</p>
</li>
<li><p>@note This function may only be called after objc_allocateClassPair and before objc_registerClassPair. </p>
</li>
<li><p>Adding an instance variable to an existing class is not supported.</p>
</li>
<li><p>@note The class must not be a metaclass. Adding an instance variable to a metaclass is not supported.</p>
</li>
<li><p>@note The instance variable’s minimum alignment in bytes is 1&lt;&lt;align. The minimum alignment of an instance </p>
</li>
<li><p>variable depends on the ivar’s type and the machine architecture. </p>
</li>
<li><p>For variables of any pointer type, pass log2(sizeof(pointer_type)).</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>addIvar(</em> cls: Swift.AnyClass?, <em> name: UnsafePointer<int8>, </int8></em> size: Int, <em> alignment: UInt8, </em> types: UnsafePointer<int8>?) -&gt; Bool</int8></p>
<p>/** </p>
<ul>
<li><p>Adds a protocol to a class.</p>
</li>
<li></li>
<li><p>@param cls The class to modify.</p>
</li>
<li><p>@param protocol The protocol to add to \e cls.</p>
</li>
<li></li>
<li><p>@return \c YES if the method was added successfully, otherwise \c NO </p>
</li>
<li><p>(for example, the class already conforms to that protocol).</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>addProtocol(</em> cls: Swift.AnyClass?, _ protocol: Protocol) -&gt; Bool</p>
<p>/** </p>
<ul>
<li><p>Adds a property to a class.</p>
</li>
<li></li>
<li><p>@param cls The class to modify.</p>
</li>
<li><p>@param name The name of the property.</p>
</li>
<li><p>@param attributes An array of property attributes.</p>
</li>
<li><p>@param attributeCount The number of attributes in \e attributes.</p>
</li>
<li></li>
<li><p>@return \c YES if the property was added successfully, otherwise \c NO</p>
</li>
<li><p>(for example, the class already has that property).</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func class<em>addProperty(</em> cls: Swift.AnyClass?, <em> name: UnsafePointer<int8>, </int8></em> attributes: UnsafePointer<objc_property_attribute_t>?, _ attributeCount: UInt32) -&gt; Bool</objc_property_attribute_t></p>
<p>/** </p>
<ul>
<li><p>Replace a property of a class. </p>
</li>
<li></li>
<li><p>@param cls The class to modify.</p>
</li>
<li><p>@param name The name of the property.</p>
</li>
<li><p>@param attributes An array of property attributes.</p>
</li>
<li><p>@param attributeCount The number of attributes in \e attributes. </p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func class<em>replaceProperty(</em> cls: Swift.AnyClass?, <em> name: UnsafePointer<int8>, </int8></em> attributes: UnsafePointer<objc_property_attribute_t>?, _ attributeCount: UInt32)</objc_property_attribute_t></p>
<p>/** </p>
<ul>
<li><p>Sets the Ivar layout for a given class.</p>
</li>
<li></li>
<li><p>@param cls The class to modify.</p>
</li>
<li><p>@param layout The layout of the \c Ivars for \e cls.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>setIvarLayout(</em> cls: Swift.AnyClass?, _ layout: UnsafePointer<uint8>?)</uint8></p>
<p>/** </p>
<ul>
<li><p>Sets the layout for weak Ivars for a given class.</p>
</li>
<li></li>
<li><p>@param cls The class to modify.</p>
</li>
<li><p>@param layout The layout of the weak Ivars for \e cls.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>setWeakIvarLayout(</em> cls: Swift.AnyClass?, _ layout: UnsafePointer<uint8>?)</uint8></p>
<p>/** </p>
<ul>
<li><p>Used by CoreFoundation’s toll-free bridging.</p>
</li>
<li><p>Return the id of the named class.</p>
</li>
<li></li>
<li><p>@return The id of the named class, or an uninitialized class</p>
</li>
<li><p>structure that will be used for the class when and if it does </p>
</li>
<li><p>get loaded.</p>
</li>
<li></li>
<li><p>@warning Do not call this function yourself.</p>
<p>*/</p>
</li>
</ul>
<p>/<em> Instantiating Classes </em>/</p>
<p>/** </p>
<ul>
<li><p>Creates an instance of a class, allocating memory for the class in the </p>
</li>
<li><p>default malloc memory zone.</p>
</li>
<li></li>
<li><p>@param cls The class that you wish to allocate an instance of.</p>
</li>
<li><p>@param extraBytes An integer indicating the number of extra bytes to allocate. </p>
</li>
<li><p>The additional bytes can be used to store additional instance variables beyond </p>
</li>
<li><p>those defined in the class definition.</p>
</li>
<li></li>
<li><p>@return An instance of the class \e cls.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>createInstance(</em> cls: Swift.AnyClass?, _ extraBytes: Int) -&gt; Any?</p>
<p>/** </p>
<ul>
<li><p>Creates an instance of a class at the specific location provided.</p>
</li>
<li></li>
<li><p>@param cls The class that you wish to allocate an instance of.</p>
</li>
<li><p>@param bytes The location at which to allocate an instance of \e cls.</p>
</li>
<li><p>Must point to at least \c class_getInstanceSize(cls) bytes of well-aligned,</p>
</li>
<li><p>zero-filled memory.</p>
<p>*</p>
</li>
<li><p>@return \e bytes on success, \c nil otherwise. (For example, \e cls or \e bytes</p>
</li>
<li><p>might be \c nil)</p>
<p>*</p>
</li>
<li><p>@see class_createInstance</p>
<p>*/</p>
</li>
</ul>
<p>/** </p>
<ul>
<li><p>Destroys an instance of a class without freeing memory and removes any</p>
</li>
<li><p>associated references this instance might have had.</p>
</li>
<li></li>
<li><p>@param obj The class instance to destroy.</p>
</li>
<li></li>
<li><p>@return \e obj. Does nothing if \e obj is nil.</p>
</li>
<li></li>
<li><p>@note CF and other clients do call this under GC.</p>
<p>*/</p>
</li>
</ul>
<p>/<em> Adding Classes </em>/</p>
<p>/** </p>
<ul>
<li><p>Creates a new class and metaclass.</p>
</li>
<li></li>
<li><p>@param superclass The class to use as the new class’s superclass, or \c Nil to create a new root class.</p>
</li>
<li><p>@param name The string to use as the new class’s name. The string will be copied.</p>
</li>
<li><p>@param extraBytes The number of bytes to allocate for indexed ivars at the end of </p>
</li>
<li><p>the class and metaclass objects. This should usually be \c 0.</p>
</li>
<li></li>
<li><p>@return The new class, or Nil if the class could not be created (for example, the desired name is already in use).</p>
</li>
<li></li>
<li><p>@note You can get a pointer to the new metaclass by calling \c object_getClass(newClass).</p>
</li>
<li><p>@note To create a new class, start by calling \c objc_allocateClassPair. </p>
</li>
<li><p>Then set the class’s attributes with functions like \c class_addMethod and \c class_addIvar.</p>
</li>
<li><p>When you are done building the class, call \c objc_registerClassPair. The new class is now ready for use.</p>
</li>
<li><p>@note Instance methods and instance variables should be added to the class itself. </p>
</li>
<li><p>Class methods should be added to the metaclass.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>allocateClassPair(</em> superclass: Swift.AnyClass?, <em> name: UnsafePointer<int8>, </int8></em> extraBytes: Int) -&gt; Swift.AnyClass?</p>
<p>/** </p>
<ul>
<li><p>Registers a class that was allocated using \c objc_allocateClassPair.</p>
</li>
<li></li>
<li><p>@param cls The class you want to register.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>registerClassPair(</em> cls: Swift.AnyClass)</p>
<p>/** </p>
<ul>
<li><p>Used by Foundation’s Key-Value Observing.</p>
</li>
<li></li>
<li><p>@warning Do not call this function yourself.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>duplicateClass(</em> original: Swift.AnyClass, <em> name: UnsafePointer<int8>, </int8></em> extraBytes: Int) -&gt; Swift.AnyClass</p>
<p>/** </p>
<ul>
<li><p>Destroy a class and its associated metaclass. </p>
</li>
<li></li>
<li><p>@param cls The class to be destroyed. It must have been allocated with </p>
</li>
<li><p>\c objc_allocateClassPair</p>
</li>
<li></li>
<li><p>@warning Do not call if instances of this class or a subclass exist.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>disposeClassPair(</em> cls: Swift.AnyClass)</p>
<p>/<em> Working with Methods </em>/</p>
<p>/** </p>
<ul>
<li><p>Returns the name of a method.</p>
</li>
<li></li>
<li><p>@param m The method to inspect.</p>
</li>
<li></li>
<li><p>@return A pointer of type SEL.</p>
</li>
<li></li>
<li><p>@note To get the method name as a C string, call \c sel_getName(method_getName(method)).</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func method<em>getName(</em> m: Method) -&gt; Selector</p>
<p>/** </p>
<ul>
<li><p>Returns the implementation of a method.</p>
</li>
<li></li>
<li><p>@param m The method to inspect.</p>
</li>
<li></li>
<li><p>@return A function pointer of type IMP.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func method<em>getImplementation(</em> m: Method) -&gt; IMP</p>
<p>/** </p>
<ul>
<li><p>Returns a string describing a method’s parameter and return types.</p>
</li>
<li></li>
<li><p>@param m The method to inspect.</p>
</li>
<li></li>
<li><p>@return A C string. The string may be \c NULL.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func method<em>getTypeEncoding(</em> m: Method) -&gt; UnsafePointer<int8>?</int8></p>
<p>/** </p>
<ul>
<li><p>Returns the number of arguments accepted by a method.</p>
</li>
<li></li>
<li><p>@param m A pointer to a \c Method data structure. Pass the method in question.</p>
</li>
<li></li>
<li><p>@return An integer containing the number of arguments accepted by the given method.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func method<em>getNumberOfArguments(</em> m: Method) -&gt; UInt32</p>
<p>/** </p>
<ul>
<li><p>Returns a string describing a method’s return type.</p>
</li>
<li></li>
<li><p>@param m The method to inspect.</p>
</li>
<li></li>
<li><p>@return A C string describing the return type. You must free the string with \c free().</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func method<em>copyReturnType(</em> m: Method) -&gt; UnsafeMutablePointer<int8></int8></p>
<p>/** </p>
<ul>
<li><p>Returns a string describing a single parameter type of a method.</p>
</li>
<li></li>
<li><p>@param m The method to inspect.</p>
</li>
<li><p>@param index The index of the parameter to inspect.</p>
</li>
<li></li>
<li><p>@return A C string describing the type of the parameter at index \e index, or \c NULL</p>
</li>
<li><p>if method has no parameter index \e index. You must free the string with \c free().</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func method<em>copyArgumentType(</em> m: Method, _ index: UInt32) -&gt; UnsafeMutablePointer<int8>?</int8></p>
<p>/** </p>
<ul>
<li><p>Returns by reference a string describing a method’s return type.</p>
</li>
<li></li>
<li><p>@param m The method you want to inquire about. </p>
</li>
<li><p>@param dst The reference string to store the description.</p>
</li>
<li><p>@param dst_len The maximum number of characters that can be stored in \e dst.</p>
<p>*</p>
</li>
<li><p>@note The method’s return type string is copied to \e dst.</p>
</li>
<li><p>\e dst is filled as if \c strncpy(dst, parameter_type, dst_len) were called.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func method<em>getReturnType(</em> m: Method, <em> dst: UnsafeMutablePointer<int8>, </int8></em> dst_len: Int)</p>
<p>/** </p>
<ul>
<li><p>Returns by reference a string describing a single parameter type of a method.</p>
</li>
<li></li>
<li><p>@param m The method you want to inquire about. </p>
</li>
<li><p>@param index The index of the parameter you want to inquire about.</p>
</li>
<li><p>@param dst The reference string to store the description.</p>
</li>
<li><p>@param dst_len The maximum number of characters that can be stored in \e dst.</p>
</li>
<li></li>
<li><p>@note The parameter type string is copied to \e dst. \e dst is filled as if \c strncpy(dst, parameter_type, dst_len) </p>
</li>
<li><p>were called. If the method contains no parameter with that index, \e dst is filled as</p>
</li>
<li><p>if \c strncpy(dst, “”, dst_len) were called.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func method<em>getArgumentType(</em> m: Method, <em> index: UInt32, </em> dst: UnsafeMutablePointer<int8>?, _ dst_len: Int)</int8></p>
<p>@available(iOS 2.0, *)</p>
<p>public func method<em>getDescription(</em> m: Method) -&gt; UnsafeMutablePointer<objc_method_description></objc_method_description></p>
<p>/** </p>
<ul>
<li><p>Sets the implementation of a method.</p>
</li>
<li></li>
<li><p>@param m The method for which to set an implementation.</p>
</li>
<li><p>@param imp The implemention to set to this method.</p>
</li>
<li></li>
<li><p>@return The previous implementation of the method.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func method<em>setImplementation(</em> m: Method, _ imp: IMP) -&gt; IMP</p>
<p>/** </p>
<ul>
<li><p>Exchanges the implementations of two methods.</p>
</li>
<li></li>
<li><p>@param m1 Method to exchange with second method.</p>
</li>
<li><p>@param m2 Method to exchange with first method.</p>
</li>
<li></li>
<li><p>@note This is an atomic version of the following:</p>
</li>
<li><p>\code </p>
</li>
<li><p>IMP imp1 = method_getImplementation(m1);</p>
</li>
<li><p>IMP imp2 = method_getImplementation(m2);</p>
</li>
<li><p>method_setImplementation(m1, imp2);</p>
</li>
<li><p>method_setImplementation(m2, imp1);</p>
</li>
<li><p>\endcode</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func method<em>exchangeImplementations(</em> m1: Method, _ m2: Method)</p>
<p>/<em> Working with Instance Variables </em>/</p>
<p>/** </p>
<ul>
<li><p>Returns the name of an instance variable.</p>
</li>
<li></li>
<li><p>@param v The instance variable you want to enquire about.</p>
</li>
<li></li>
<li><p>@return A C string containing the instance variable’s name.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func ivar<em>getName(</em> v: Ivar) -&gt; UnsafePointer<int8>?</int8></p>
<p>/** </p>
<ul>
<li><p>Returns the type string of an instance variable.</p>
</li>
<li></li>
<li><p>@param v The instance variable you want to enquire about.</p>
</li>
<li></li>
<li><p>@return A C string containing the instance variable’s type encoding.</p>
<p>*</p>
</li>
<li><p>@note For possible values, see Objective-C Runtime Programming Guide &gt; Type Encodings.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func ivar<em>getTypeEncoding(</em> v: Ivar) -&gt; UnsafePointer<int8>?</int8></p>
<p>/** </p>
<ul>
<li><p>Returns the offset of an instance variable.</p>
</li>
<li></li>
<li><p>@param v The instance variable you want to enquire about.</p>
</li>
<li></li>
<li><p>@return The offset of \e v.</p>
</li>
<li></li>
<li><p>@note For instance variables of type \c id or other object types, call \c object_getIvar</p>
</li>
<li><p>and \c object_setIvar instead of using this offset to access the instance variable data directly.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func ivar<em>getOffset(</em> v: Ivar) -&gt; Int</p>
<p>/<em> Working with Properties </em>/</p>
<p>/** </p>
<ul>
<li><p>Returns the name of a property.</p>
</li>
<li></li>
<li><p>@param property The property you want to inquire about.</p>
</li>
<li></li>
<li><p>@return A C string containing the property’s name.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func property<em>getName(</em> property: objc_property_t) -&gt; UnsafePointer<int8></int8></p>
<p>/** </p>
<ul>
<li><p>Returns the attribute string of a property.</p>
</li>
<li></li>
<li><p>@param property A property.</p>
<p>*</p>
</li>
<li><p>@return A C string containing the property’s attributes.</p>
</li>
<li></li>
<li><p>@note The format of the attribute string is described in Declared Properties in Objective-C Runtime Programming Guide.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func property<em>getAttributes(</em> property: objc_property_t) -&gt; UnsafePointer<int8>?</int8></p>
<p>/** </p>
<ul>
<li><p>Returns an array of property attributes for a property. </p>
</li>
<li></li>
<li><p>@param property The property whose attributes you want copied.</p>
</li>
<li><p>@param outCount The number of attributes returned in the array.</p>
</li>
<li></li>
<li><p>@return An array of property attributes; must be free’d() by the caller. </p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func property<em>copyAttributeList(</em> property: objc_property<em>t, </em> outCount: UnsafeMutablePointer<uint32>?) -&gt; UnsafeMutablePointer<objc_property_attribute_t>?</objc_property_attribute_t></uint32></p>
<p>/** </p>
<ul>
<li><p>Returns the value of a property attribute given the attribute name.</p>
</li>
<li></li>
<li><p>@param property The property whose attribute value you are interested in.</p>
</li>
<li><p>@param attributeName C string representing the attribute name.</p>
<p>*</p>
</li>
<li><p>@return The value string of the attribute \e attributeName if it exists in</p>
</li>
<li><p>\e property, \c nil otherwise. </p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func property<em>copyAttributeValue(</em> property: objc_property<em>t, </em> attributeName: UnsafePointer<int8>) -&gt; UnsafeMutablePointer<int8>?</int8></int8></p>
<p>/<em> Working with Protocols </em>/</p>
<p>/** </p>
<ul>
<li><p>Returns a specified protocol.</p>
</li>
<li></li>
<li><p>@param name The name of a protocol.</p>
</li>
<li></li>
<li><p>@return The protocol named \e name, or \c NULL if no protocol named \e name could be found.</p>
</li>
<li></li>
<li><p>@note This function acquires the runtime lock.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>getProtocol(</em> name: UnsafePointer<int8>) -&gt; Protocol?</int8></p>
<p>/** </p>
<ul>
<li><p>Returns an array of all the protocols known to the runtime.</p>
</li>
<li></li>
<li><p>@param outCount Upon return, contains the number of protocols in the returned array.</p>
</li>
<li></li>
<li><p>@return A C array of all the protocols known to the runtime. The array contains \c *outCount</p>
</li>
<li><p>pointers followed by a \c NULL terminator. You must free the list with \c free().</p>
</li>
<li></li>
<li><p>@note This function acquires the runtime lock.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>copyProtocolList(</em> outCount: UnsafeMutablePointer<uint32>?) -&gt; AutoreleasingUnsafeMutablePointer<protocol>?</protocol></uint32></p>
<p>/** </p>
<ul>
<li><p>Returns a Boolean value that indicates whether one protocol conforms to another protocol.</p>
</li>
<li></li>
<li><p>@param proto A protocol.</p>
</li>
<li><p>@param other A protocol.</p>
</li>
<li></li>
<li><p>@return \c YES if \e proto conforms to \e other, otherwise \c NO.</p>
</li>
<li></li>
<li><p>@note One protocol can incorporate other protocols using the same syntax </p>
</li>
<li><p>that classes use to adopt a protocol:</p>
</li>
<li><p>\code</p>
</li>
<li><p>@protocol ProtocolName &lt; protocol list &gt;</p>
</li>
<li><p>\endcode</p>
</li>
<li><p>All the protocols listed between angle brackets are considered part of the ProtocolName protocol.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func protocol<em>conformsToProtocol(</em> proto: Protocol?, _ other: Protocol?) -&gt; Bool</p>
<p>/** </p>
<ul>
<li><p>Returns a Boolean value that indicates whether two protocols are equal.</p>
</li>
<li></li>
<li><p>@param proto A protocol.</p>
</li>
<li><p>@param other A protocol.</p>
</li>
<li></li>
<li><p>@return \c YES if \e proto is the same as \e other, otherwise \c NO.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func protocol<em>isEqual(</em> proto: Protocol?, _ other: Protocol?) -&gt; Bool</p>
<p>/** </p>
<ul>
<li><p>Returns the name of a protocol.</p>
</li>
<li></li>
<li><p>@param p A protocol.</p>
</li>
<li></li>
<li><p>@return The name of the protocol \e p as a C string.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func protocol<em>getName(</em> proto: Protocol) -&gt; UnsafePointer<int8></int8></p>
<p>/** </p>
<ul>
<li><p>Returns a method description structure for a specified method of a given protocol.</p>
</li>
<li></li>
<li><p>@param p A protocol.</p>
</li>
<li><p>@param aSel A selector.</p>
</li>
<li><p>@param isRequiredMethod A Boolean value that indicates whether aSel is a required method.</p>
</li>
<li><p>@param isInstanceMethod A Boolean value that indicates whether aSel is an instance method.</p>
</li>
<li></li>
<li><p>@return An \c objc_method_description structure that describes the method specified by \e aSel,</p>
</li>
<li><p>\e isRequiredMethod, and \e isInstanceMethod for the protocol \e p.</p>
</li>
<li><p>If the protocol does not contain the specified method, returns an \c objc_method_description structure</p>
</li>
<li><p>with the value \c {NULL, \c NULL}.</p>
</li>
<li></li>
<li><p>@note This function recursively searches any protocols that this protocol conforms to.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func protocol<em>getMethodDescription(</em> proto: Protocol, <em> aSel: Selector, </em> isRequiredMethod: Bool, _ isInstanceMethod: Bool) -&gt; objc_method_description</p>
<p>/** </p>
<ul>
<li><p>Returns an array of method descriptions of methods meeting a given specification for a given protocol.</p>
</li>
<li></li>
<li><p>@param p A protocol.</p>
</li>
<li><p>@param isRequiredMethod A Boolean value that indicates whether returned methods should</p>
</li>
<li><p>be required methods (pass YES to specify required methods).</p>
</li>
<li><p>@param isInstanceMethod A Boolean value that indicates whether returned methods should</p>
</li>
<li><p>be instance methods (pass YES to specify instance methods).</p>
</li>
<li><p>@param outCount Upon return, contains the number of method description structures in the returned array.</p>
</li>
<li></li>
<li><p>@return A C array of \c objc_method_description structures containing the names and types of \e p’s methods </p>
</li>
<li><p>specified by \e isRequiredMethod and \e isInstanceMethod. The array contains \c *outCount pointers followed</p>
</li>
<li><p>by a \c NULL terminator. You must free the list with \c free().</p>
</li>
<li><p>If the protocol declares no methods that meet the specification, \c NULL is returned and \c *outCount is 0.</p>
</li>
<li></li>
<li><p>@note Methods in other protocols adopted by this protocol are not included.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func protocol<em>copyMethodDescriptionList(</em> proto: Protocol, <em> isRequiredMethod: Bool, </em> isInstanceMethod: Bool, _ outCount: UnsafeMutablePointer<uint32>?) -&gt; UnsafeMutablePointer<objc_method_description>?</objc_method_description></uint32></p>
<p>/** </p>
<ul>
<li><p>Returns the specified property of a given protocol.</p>
</li>
<li></li>
<li><p>@param proto A protocol.</p>
</li>
<li><p>@param name The name of a property.</p>
</li>
<li><p>@param isRequiredProperty \c YES searches for a required property, \c NO searches for an optional property.</p>
</li>
<li><p>@param isInstanceProperty \c YES searches for an instance property, \c NO searches for a class property.</p>
</li>
<li></li>
<li><p>@return The property specified by \e name, \e isRequiredProperty, and \e isInstanceProperty for \e proto,</p>
</li>
<li><p>or \c NULL if none of \e proto’s properties meets the specification.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func protocol<em>getProperty(</em> proto: Protocol, <em> name: UnsafePointer<int8>, </int8></em> isRequiredProperty: Bool, _ isInstanceProperty: Bool) -&gt; objc_property_t?</p>
<p>/** </p>
<ul>
<li><p>Returns an array of the required instance properties declared by a protocol.</p>
</li>
<li></li>
<li><p>@note Identical to </p>
</li>
<li><p>\code</p>
</li>
<li><p>protocol_copyPropertyList2(proto, outCount, YES, YES);</p>
</li>
<li><p>\endcode</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func protocol<em>copyPropertyList(</em> proto: Protocol, _ outCount: UnsafeMutablePointer<uint32>?) -&gt; UnsafeMutablePointer<objc_property_t>?</objc_property_t></uint32></p>
<p>/** </p>
<ul>
<li><p>Returns an array of properties declared by a protocol.</p>
</li>
<li></li>
<li><p>@param proto A protocol.</p>
</li>
<li><p>@param outCount Upon return, contains the number of elements in the returned array.</p>
</li>
<li><p>@param isRequiredProperty \c YES returns required properties, \c NO returns optional properties.</p>
</li>
<li><p>@param isInstanceProperty \c YES returns instance properties, \c NO returns class properties.</p>
</li>
<li></li>
<li><p>@return A C array of pointers of type \c objc_property_t describing the properties declared by \e proto.</p>
</li>
<li><p>Any properties declared by other protocols adopted by this protocol are not included. The array contains</p>
</li>
<li><p>\c *outCount pointers followed by a \c NULL terminator. You must free the array with \c free().</p>
</li>
<li><p>If the protocol declares no matching properties, \c NULL is returned and \c *outCount is \c 0.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 10.0, *)</p>
<p>public func protocol<em>copyPropertyList2(</em> proto: Protocol, <em> outCount: UnsafeMutablePointer<uint32>?, </uint32></em> isRequiredProperty: Bool, _ isInstanceProperty: Bool) -&gt; UnsafeMutablePointer<objc_property_t>?</objc_property_t></p>
<p>/** </p>
<ul>
<li><p>Returns an array of the protocols adopted by a protocol.</p>
</li>
<li></li>
<li><p>@param proto A protocol.</p>
</li>
<li><p>@param outCount Upon return, contains the number of elements in the returned array.</p>
</li>
<li></li>
<li><p>@return A C array of protocols adopted by \e proto. The array contains \e *outCount pointers</p>
</li>
<li><p>followed by a \c NULL terminator. You must free the array with \c free().</p>
</li>
<li><p>If the protocol declares no properties, \c NULL is returned and \c *outCount is \c 0.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func protocol<em>copyProtocolList(</em> proto: Protocol, _ outCount: UnsafeMutablePointer<uint32>?) -&gt; AutoreleasingUnsafeMutablePointer<protocol>?</protocol></uint32></p>
<p>/** </p>
<ul>
<li><p>Creates a new protocol instance that cannot be used until registered with</p>
</li>
<li><p>\c objc_registerProtocol()</p>
</li>
<li></li>
<li><p>@param name The name of the protocol to create.</p>
<p>*</p>
</li>
<li><p>@return The Protocol instance on success, \c nil if a protocol</p>
</li>
<li><p>with the same name already exists. </p>
</li>
<li><p>@note There is no dispose method for this. </p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func objc<em>allocateProtocol(</em> name: UnsafePointer<int8>) -&gt; Protocol?</int8></p>
<p>/** </p>
<ul>
<li><p>Registers a newly constructed protocol with the runtime. The protocol</p>
</li>
<li><p>will be ready for use and is immutable after this.</p>
</li>
<li></li>
<li><p>@param proto The protocol you want to register.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func objc<em>registerProtocol(</em> proto: Protocol)</p>
<p>/** </p>
<ul>
<li><p>Adds a method to a protocol. The protocol must be under construction.</p>
</li>
<li></li>
<li><p>@param proto The protocol to add a method to.</p>
</li>
<li><p>@param name The name of the method to add.</p>
</li>
<li><p>@param types A C string that represents the method signature.</p>
</li>
<li><p>@param isRequiredMethod YES if the method is not an optional method.</p>
</li>
<li><p>@param isInstanceMethod YES if the method is an instance method. </p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func protocol<em>addMethodDescription(</em> proto: Protocol, <em> name: Selector, </em> types: UnsafePointer<int8>?, <em> isRequiredMethod: Bool, </em> isInstanceMethod: Bool)</int8></p>
<p>/** </p>
<ul>
<li><p>Adds an incorporated protocol to another protocol. The protocol being</p>
</li>
<li><p>added to must still be under construction, while the additional protocol</p>
</li>
<li><p>must be already constructed.</p>
</li>
<li></li>
<li><p>@param proto The protocol you want to add to, it must be under construction.</p>
</li>
<li><p>@param addition The protocol you want to incorporate into \e proto, it must be registered.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func protocol<em>addProtocol(</em> proto: Protocol, _ addition: Protocol)</p>
<p>/** </p>
<ul>
<li><p>Adds a property to a protocol. The protocol must be under construction. </p>
</li>
<li></li>
<li><p>@param proto The protocol to add a property to.</p>
</li>
<li><p>@param name The name of the property.</p>
</li>
<li><p>@param attributes An array of property attributes.</p>
</li>
<li><p>@param attributeCount The number of attributes in \e attributes.</p>
</li>
<li><p>@param isRequiredProperty YES if the property (accessor methods) is not optional. </p>
</li>
<li><p>@param isInstanceProperty YES if the property (accessor methods) are instance methods. </p>
</li>
<li><p>This is the only case allowed fo a property, as a result, setting this to NO will </p>
</li>
<li><p>not add the property to the protocol at all. </p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func protocol<em>addProperty(</em> proto: Protocol, <em> name: UnsafePointer<int8>, </int8></em> attributes: UnsafePointer<objc_property_attribute_t>?, <em> attributeCount: UInt32, </em> isRequiredProperty: Bool, _ isInstanceProperty: Bool)</objc_property_attribute_t></p>
<p>/<em> Working with Libraries </em>/</p>
<p>/** </p>
<ul>
<li><p>Returns the names of all the loaded Objective-C frameworks and dynamic</p>
</li>
<li><p>libraries.</p>
</li>
<li></li>
<li><p>@param outCount The number of names returned.</p>
</li>
<li></li>
<li><p>@return An array of C strings of names. Must be free()’d by caller.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>copyImageNames(</em> outCount: UnsafeMutablePointer<uint32>?) -&gt; UnsafeMutablePointer&lt;UnsafePointer<int8>&gt;</int8></uint32></p>
<p>/** </p>
<ul>
<li><p>Returns the dynamic library name a class originated from.</p>
</li>
<li></li>
<li><p>@param cls The class you are inquiring about.</p>
</li>
<li></li>
<li><p>@return The name of the library containing this class.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func class<em>getImageName(</em> cls: Swift.AnyClass?) -&gt; UnsafePointer<int8>?</int8></p>
<p>/** </p>
<ul>
<li><p>Returns the names of all the classes within a library.</p>
</li>
<li></li>
<li><p>@param image The library or framework you are inquiring about.</p>
</li>
<li><p>@param outCount The number of class names returned.</p>
</li>
<li></li>
<li><p>@return An array of C strings representing the class names.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>copyClassNamesForImage(</em> image: UnsafePointer<int8>, _ outCount: UnsafeMutablePointer<uint32>?) -&gt; UnsafeMutablePointer&lt;UnsafePointer<int8>&gt;?</int8></uint32></int8></p>
<p>/<em> Working with Selectors </em>/</p>
<p>/** </p>
<ul>
<li><p>Returns the name of the method specified by a given selector.</p>
</li>
<li></li>
<li><p>@param sel A pointer of type \c SEL. Pass the selector whose name you wish to determine.</p>
</li>
<li></li>
<li><p>@return A C string indicating the name of the selector.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func sel<em>getName(</em> sel: Selector) -&gt; UnsafePointer<int8></int8></p>
<p>/** </p>
<ul>
<li><p>Registers a method with the Objective-C runtime system, maps the method </p>
</li>
<li><p>name to a selector, and returns the selector value.</p>
</li>
<li></li>
<li><p>@param str A pointer to a C string. Pass the name of the method you wish to register.</p>
</li>
<li></li>
<li><p>@return A pointer of type SEL specifying the selector for the named method.</p>
</li>
<li></li>
<li><p>@note You must register a method name with the Objective-C runtime system to obtain the</p>
</li>
<li><p>method’s selector before you can add the method to a class definition. If the method name</p>
</li>
<li><p>has already been registered, this function simply returns the selector.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func sel<em>registerName(</em> str: UnsafePointer<int8>) -&gt; Selector</int8></p>
<p>/** </p>
<ul>
<li><p>Returns a Boolean value that indicates whether two selectors are equal.</p>
</li>
<li></li>
<li><p>@param lhs The selector to compare with rhs.</p>
</li>
<li><p>@param rhs The selector to compare with lhs.</p>
</li>
<li></li>
<li><p>@return \c YES if \e lhs and \e rhs are equal, otherwise \c NO.</p>
</li>
<li></li>
<li><p>@note sel_isEqual is equivalent to ==.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func sel<em>isEqual(</em> lhs: Selector, _ rhs: Selector) -&gt; Bool</p>
<p>/<em> Objective-C Language Features </em>/</p>
<p>/** </p>
<ul>
<li><p>This function is inserted by the compiler when a mutation</p>
</li>
<li><p>is detected during a foreach iteration. It gets called </p>
</li>
<li><p>when a mutation occurs, and the enumerationMutationHandler</p>
</li>
<li><p>is enacted if it is set up. A fatal error occurs if a handler is not set up.</p>
<p>*</p>
</li>
<li><p>@param obj The object being mutated.</p>
</li>
<li><p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>enumerationMutation(</em> obj: Any)</p>
<p>/** </p>
<ul>
<li><p>Sets the current mutation handler. </p>
</li>
<li></li>
<li><p>@param handler Function pointer to the new mutation handler.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>setEnumerationMutationHandler(</em> handler: (@convention(c) (Any) -&gt; Swift.Void)?)</p>
<p>/** </p>
<ul>
<li><p>Set the function to be called by objc_msgForward.</p>
</li>
<li></li>
<li><p>@param fwd Function to be jumped to by objc_msgForward.</p>
</li>
<li><p>@param fwd_stret Function to be jumped to by objc_msgForward_stret.</p>
</li>
<li></li>
<li><p>@see message.h::_objc_msgForward</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 2.0, *)</p>
<p>public func objc<em>setForwardHandler(</em> fwd: UnsafeMutableRawPointer, _ fwd_stret: UnsafeMutableRawPointer)</p>
<p>/** </p>
<ul>
<li><p>Creates a pointer to a function that will call the block</p>
</li>
<li><p>when the method is called.</p>
</li>
<li></li>
<li><p>@param block The block that implements this method. Its signature should</p>
</li>
<li><p>be: method_return_type ^(id self, method_args…). </p>
</li>
<li><p>The selector is not available as a parameter to this block.</p>
</li>
<li><p>The block is copied with \c Block_copy().</p>
</li>
<li></li>
<li><p>@return The IMP that calls this block. Must be disposed of with</p>
</li>
<li><p>\c imp_removeBlock.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func imp<em>implementationWithBlock(</em> block: Any) -&gt; IMP</p>
<p>/** </p>
<ul>
<li><p>Return the block associated with an IMP that was created using</p>
</li>
<li><p>\c imp_implementationWithBlock.</p>
</li>
<li></li>
<li><p>@param anImp The IMP that calls this block.</p>
</li>
<li></li>
<li><p>@return The block called by \e anImp.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func imp<em>getBlock(</em> anImp: IMP) -&gt; Any?</p>
<p>/** </p>
<ul>
<li><p>Disassociates a block from an IMP that was created using</p>
</li>
<li><p>\c imp_implementationWithBlock and releases the copy of the </p>
</li>
<li><p>block that was created.</p>
</li>
<li></li>
<li><p>@param anImp An IMP that was created using \c imp_implementationWithBlock.</p>
</li>
<li></li>
<li><p>@return YES if the block was released successfully, NO otherwise. </p>
</li>
<li><p>(For example, the block might not have been used to create an IMP previously).</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 4.3, *)</p>
<p>public func imp<em>removeBlock(</em> anImp: IMP) -&gt; Bool</p>
<p>/** </p>
<ul>
<li><p>This loads the object referenced by a weak pointer and returns it, after</p>
</li>
<li><p>retaining and autoreleasing the object to ensure that it stays alive</p>
</li>
<li><p>long enough for the caller to use it. This function would be used</p>
</li>
<li><p>anywhere a __weak variable is used in an expression.</p>
</li>
<li></li>
<li><p>@param location The weak pointer address</p>
</li>
<li></li>
<li><p>@return The object pointed to by \e location, or \c nil if \e *location is \c nil.</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 5.0, *)</p>
<p>public func objc<em>loadWeak(</em> location: AutoreleasingUnsafeMutablePointer<anyobject?>) -&gt; Any?</anyobject?></p>
<p>/** </p>
<ul>
<li><p>This function stores a new value into a __weak variable. It would</p>
</li>
<li><p>be used anywhere a __weak variable is the target of an assignment.</p>
</li>
<li></li>
<li><p>@param location The address of the weak pointer itself</p>
</li>
<li><p>@param obj The new object this weak ptr should now point to</p>
</li>
<li></li>
<li><p>@return The value stored into \e location, i.e. \e obj</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 5.0, *)</p>
<p>public func objc<em>storeWeak(</em> location: AutoreleasingUnsafeMutablePointer<anyobject?>, _ obj: Any?) -&gt; Any?</anyobject?></p>
<p>/<em> Associative References </em>/</p>
<p>/**</p>
<ul>
<li><p>Policies related to associative references.</p>
</li>
<li><p>These are options to objc_setAssociatedObject()</p>
<p>*/</p>
</li>
</ul>
<p>public enum objc_AssociationPolicy : UInt {</p>
<p>​    </p>
<p>​    /<em>*&lt; Specifies a weak reference to the associated object. </em>/</p>
<p>​    case OBJC_ASSOCIATION_ASSIGN</p>
<p>​    /**&lt; Specifies a strong reference to the associated object. </p>
<p>​     <em>   The association is not made atomically. </em>/</p>
<p>​    case OBJC_ASSOCIATION_RETAIN_NONATOMIC</p>
<p>​    </p>
<p>​    /**&lt; Specifies that the associated object is copied. </p>
<p>​     <em>   The association is not made atomically. </em>/</p>
<p>​    case OBJC_ASSOCIATION_COPY_NONATOMIC</p>
<p>​    </p>
<p>​    /**&lt; Specifies a strong reference to the associated object.</p>
<p>​     <em>   The association is made atomically. </em>/</p>
<p>​    case OBJC_ASSOCIATION_RETAIN</p>
<p>​    </p>
<p>​    /**&lt; Specifies that the associated object is copied.</p>
<p>​     <em>   The association is made atomically. </em>/</p>
<p>​    case OBJC_ASSOCIATION_COPY</p>
<p>}</p>
<p>/** </p>
<ul>
<li><p>Sets an associated value for a given object using a given key and association policy.</p>
</li>
<li></li>
<li><p>@param object The source object for the association.</p>
</li>
<li><p>@param key The key for the association.</p>
</li>
<li><p>@param value The value to associate with the key key for object. Pass nil to clear an existing association.</p>
</li>
<li><p>@param policy The policy for the association. For possible values, see “Associative Object Behaviors.”</p>
</li>
<li></li>
<li><p>@see objc_setAssociatedObject</p>
</li>
<li><p>@see objc_removeAssociatedObjects</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 3.1, *)</p>
<p>public func objc<em>setAssociatedObject(</em> object: Any, <em> key: UnsafeRawPointer, </em> value: Any?, _ policy: objc_AssociationPolicy)</p>
<p>/** </p>
<ul>
<li><p>Returns the value associated with a given object for a given key.</p>
</li>
<li></li>
<li><p>@param object The source object for the association.</p>
</li>
<li><p>@param key The key for the association.</p>
</li>
<li></li>
<li><p>@return The value associated with the key \e key for \e object.</p>
</li>
<li></li>
<li><p>@see objc_setAssociatedObject</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 3.1, *)</p>
<p>public func objc<em>getAssociatedObject(</em> object: Any, _ key: UnsafeRawPointer) -&gt; Any?</p>
<p>/** </p>
<ul>
<li><p>Removes all associations for a given object.</p>
</li>
<li></li>
<li><p>@param object An object that maintains associated objects.</p>
</li>
<li></li>
<li><p>@note The main purpose of this function is to make it easy to return an object </p>
</li>
<li><p>to a “pristine state”. You should not use this function for general removal of</p>
</li>
<li><p>associations from objects, since it also removes associations that other clients</p>
</li>
<li><p>may have added to the object. Typically you should use \c objc_setAssociatedObject </p>
</li>
<li><p>with a nil value to clear an association.</p>
</li>
<li></li>
<li><p>@see objc_setAssociatedObject</p>
</li>
<li><p>@see objc_getAssociatedObject</p>
<p>*/</p>
</li>
</ul>
<p>@available(iOS 3.1, *)</p>
<p>public func objc<em>removeAssociatedObjects(</em> object: Any)</p>
<p>/<em> Obsolete types </em>/</p>
<p>// class is not a metaclass</p>
<p>// class is a metaclass</p>
<p>// class’s +initialize method has completed</p>
<p>// class is posing</p>
<p>// unused</p>
<p>// class and subclasses need cache flush during image loading</p>
<p>// method cache should grow when full</p>
<p>// unused</p>
<p>// methodLists is array of method lists</p>
<p>// the JavaBridge constructs classes with these markers</p>
<p>// thread-safe +initialize</p>
<p>// bundle unloading</p>
<p>// C++ ivar support</p>
<p>// Lazy method list arrays</p>
<p>// +load implementation</p>
<p>// objc_allocateClassPair API</p>
<p>// class compiled with bigger class structure</p>
<p>/<em> variable length structure </em>/</p>
<p>/<em> variable length structure </em>/</p>
<p>/<em> variable size </em>/</p>
<p>/<em> total = mask + 1 </em>/</p>
<p>/<em> Obsolete functions </em>/</p>
<p>public var OBSOLETE_OBJC_GETCLASSES: Int32 { get }</p>
<p>public var OBJC_NEXT_METHOD_LIST: Int32 { get }</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[navigationBar   返回 、title。不显示问题]]></title>
      <url>/2018/03/29/navigationBar%20%20%20%E8%BF%94%E5%9B%9E%20%E3%80%81title%20%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>iOS 9:</p>
<p>`if #available(iOS 11.0, *) {</p>
<p>​            </p>
<p>​        } else {</p>
<p>​            navigationItemInit()</p>
<p>​        }`</p>
<p>`func  navigationItemInit(){</p>
<p>​        </p>
<p>​        self.createLeftBarBtnItem(iconstr:  “”, title: “返回”, method: #selector(back))</p>
<p>​    }`</p>
<p>`func createLeftBarBtnItem(iconstr: String, title: String,method: Selector ) {</p>
<p>​        // 设置导航栏右侧按钮</p>
<p>​        let menuBtn = UIButton(frame: CGRect(x: 0, y: 0, width: 40, height: 40))</p>
<p>​        menuBtn.addTarget(self, action: method, for: .touchUpInside)</p>
<p>​        if iconstr.count &gt; 0 {</p>
<p>​            menuBtn.setImage(UIImage.init(named: iconstr), for: .normal)</p>
<p>​        }</p>
<p>​        if title.count &gt; 0 {</p>
<p>​            menuBtn.setTitle(title, for: .normal)</p>
<p>​        }</p>
<p>​        let leftBtn = UIBarButtonItem(customView: menuBtn)</p>
<p>​        </p>
<p>​        self.addFixedSpace(with: leftBtn, direction: .left)</p>
<p>​    }</p>
<p>​    func addFixedSpace(with barItem: UIBarButtonItem, direction: BarBtnItemDirection) {</p>
<p>​        let negativeSpacer = UIBarButtonItem(barButtonSystemItem: .fixedSpace, target: nil, action: nil)</p>
<p>​        negativeSpacer.width = -11</p>
<p>​        switch direction {</p>
<p>​        case .left:</p>
<p>​            navigationItem.leftBarButtonItems = [negativeSpacer, barItem]</p>
<p>​        default:</p>
<p>​            navigationItem.rightBarButtonItems = [negativeSpacer, barItem]</p>
<p>​        }</p>
<p>​        </p>
<p>​    }`</p>
<p>iOS 10.3.1:还需加上</p>
<p>`override func viewWillAppear(_ animated: Bool) {</p>
<p>​        super.viewWillAppear(animated)</p>
<p>​     self.navigationController?.setNavigationBarHidden(true, animated: false)</p>
<p>​        self.navigationController?.setNavigationBarHidden(false, animated: false)</p>
<p>​    }`</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[随机图片获取]]></title>
      <url>/2018/03/23/%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87%E8%8E%B7%E5%8F%96/</url>
      <content type="html"><![CDATA[<p><a href="http://lorempixel.com/" target="_blank" rel="noopener">http://lorempixel.com/</a></p>
<p>Placeholder Images for every case. Webdesign or Print. It’s simple and absolutely free! Just put the custom url in your code like this:<img src="http://lorempixel.com/400/200">to get your FPO / dummy image.</p>
<ul>
<li>​</li>
<li>​</li>
<li><a href="http://lorempixel.com/400/200" target="_blank" rel="noopener">http://lorempixel.com/400/200</a>     to get a random picture of 400 x 200 pixels</li>
<li>&lt;<a href="http://lorempixel.com/g/400/200" target="_blank" rel="noopener">http://lorempixel.com/g/400/200</a>    to get a random gray picture of 400 x 200 pixels</li>
<li>&lt;<a href="http://lorempixel.com/400/200/sports" target="_blank" rel="noopener">http://lorempixel.com/400/200/sports</a>             to get a random picture of the sports category</li>
<li>&lt;<a href="http://lorempixel.com/400/200/sports/1" target="_blank" rel="noopener">http://lorempixel.com/400/200/sports/1</a>      to get picture no. 1/10 from the sports category</li>
<li>&lt;<a href="http://lorempixel.com/400/200/sports/Dummy-Text" target="_blank" rel="noopener">http://lorempixel.com/400/200/sports/Dummy-Text</a>      …with a custom text on the <strong>random</strong> Picture</li>
<li><a href="http://lorempixel.com/400/200/sports/1/Dummy-Text" target="_blank" rel="noopener">http://lorempixel.com/400/200/sports/1/Dummy-Text</a>        …with a custom text on the <strong>selected</strong> Picture</li>
</ul>
<h5 id="self-profileImageView-setRandomDownloadImage-80-height-80"><a href="#self-profileImageView-setRandomDownloadImage-80-height-80" class="headerlink" title="self.profileImageView.setRandomDownloadImage(80, height: 80)"></a>self.profileImageView.setRandomDownloadImage(80, height: 80)</h5><p>func setRandomDownloadImage(_ width: Int, height: Int) {</p>
<p>​        if self.image != nil {</p>
<p>​            self.alpha = 1</p>
<p>​            return</p>
<p>​        }</p>
<p>​        self.alpha = 0</p>
<p>​        let url = URL(string: “<a href="http://lorempixel.com/\(width)/\(height)/&quot;)!" target="_blank" rel="noopener">http://lorempixel.com/\(width)/\(height)/&quot;)!</a></p>
<p>​        let configuration = URLSessionConfiguration.default</p>
<p>​        configuration.timeoutIntervalForRequest = 15</p>
<p>​        configuration.timeoutIntervalForResource = 15</p>
<p>​        configuration.requestCachePolicy = NSURLRequest.CachePolicy.reloadIgnoringLocalCacheData</p>
<p>​        let session = URLSession(configuration: configuration)</p>
<p>​        let task = session.dataTask(with: url) { (data, response, error) in</p>
<p>​            if error != nil {</p>
<p>​                return</p>
<p>​            }</p>
<p>​            </p>
<p>​            if let response = response as? HTTPURLResponse {</p>
<p>​                if response.statusCode / 100 != 2 {</p>
<p>​                    return</p>
<p>​                }</p>
<p>​                if let data = data, let image = UIImage(data: data) {</p>
<p>​                    DispatchQueue.main.async(execute: { () -&gt; Void in</p>
<p>​                        self.image = image</p>
<p>​                        UIView.animate(withDuration: 0.3, animations: { () -&gt; Void in</p>
<p>​                            self.alpha = 1</p>
<p>​                        }, completion: { (finished: Bool) -&gt; Void in</p>
<p>​                        })</p>
<p>​                    })</p>
<p>​                }</p>
<p>​            }</p>
<p>​        }</p>
<p>​        task.resume()</p>
<p>}</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift开发之 ---- Swift4.0 GCD实现计时器]]></title>
      <url>/2018/03/21/Swift%E5%BC%80%E5%8F%91%E4%B9%8B%20----%20Swift4.0%20GCD%E5%AE%9E%E7%8E%B0%E8%AE%A1%E6%97%B6%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>// 定义需要计时的时间</p>
<p>​        var timeCount = 60</p>
<p>​        // 在global线程里创建一个时间源</p>
<p>​        let codeTimer = DispatchSource.makeTimerSource(queue:      DispatchQueue.global())</p>
<p>​        // 设定这个时间源是每秒循环一次，立即开始</p>
<p>​        codeTimer.schedule(deadline: .now(), repeating: .seconds(1))</p>
<p>​        // 设定时间源的触发事件</p>
<p>​        codeTimer.setEventHandler(handler: {</p>
<p>​            // 每秒计时一次</p>
<p>​            timeCount = timeCount - 1</p>
<p>​            // 时间到了取消时间源</p>
<p>​            if timeCount &lt;= 0 {</p>
<p>​                codeTimer.cancel()</p>
<p>​            }</p>
<p>​            // 返回主线程处理一些事件，更新UI等等</p>
<p>​            DispatchQueue.main.async {</p>
<p>​            }</p>
<p>​        })</p>
<p>​        // 启动时间源</p>
<p>​        codeTimer.resume()</p>
<p>​        </p>
<p>//        codeTimer.suspend()//定时器暂停；</p>
<p>//        codeTimer.cancel()//定时器取消，会销毁；</p>
<p>//        codeTimer.activate()//定时器开始激活  此方法需要在 iOS10以上才有</p>
<p>//        codeTimer.resume()//定时器继续</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ijkplayer设置rtmp秒开]]></title>
      <url>/2018/03/19/ijkplayer%E8%AE%BE%E7%BD%AErtmp%E7%A7%92%E5%BC%80/</url>
      <content type="html"><![CDATA[<p>ijkplayer和ffplay在打开rtmp串流视频时，大多数都会遇到5~10秒的延迟，在ffplay播放时，如果加上<strong>-fflags nobuffer</strong>可以缩短播放的rtmp视频延迟在1s内，而在ijkVideoView中加入</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lp8800/article/details/65629187#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/lp8800/article/details/65629187#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>IjkMediaPlayer ijkMediaPlayer = null;  </li>
<li>ijkMediaPlayer = new IjkMediaPlayer();  </li>
<li>ijkMediaPlayer.setOption(1, “analyzemaxduration”, 100L);  </li>
<li>ijkMediaPlayer.setOption(1, “probesize”, 10240L);  </li>
<li>ijkMediaPlayer.setOption(1, “flush_packets”, 1L);  </li>
<li>ijkMediaPlayer.setOption(4, “packet-buffering”, 0L);  </li>
<li>ijkMediaPlayer.setOption(4, “framedrop”, 1L);  </li>
</ol>
<p>这几个选项设置，可以让rtmp加载时间从5~10秒缩短到1s以内，以达到秒开且低延迟的目的。</p>
<p>同样，只要是基于ffmpeg中的ffplay播放器，都可以通过加上类似设置达到这个效果。比如在PLDroidPlayer当中，也可以加入这个选项：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lp8800/article/details/65629187#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/lp8800/article/details/65629187#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>AVOptions options = new AVOptions();  </li>
<li></li>
<li>options.setInteger(AVOptions.VALUE_FFLAGS_NOBUFFER, 1);  </li>
<li></li>
<li>options.setInteger(AVOptions.KEY_PROBESIZE,10240);  </li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ble多字节传送]]></title>
      <url>/2018/03/19/50%E6%AF%AB%E7%A7%92%E8%A7%A6%E5%8F%91%E4%B8%80%E6%AC%A1%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%E5%BD%93%E6%88%91%E5%8F%91%E5%AE%8C1024%E6%95%B0%E6%8D%AE%E5%B0%B1%E8%B7%B3%E5%87%BAtimer%20/</url>
      <content type="html"><![CDATA[<h3 id="50毫秒触发一次的方法。当我发完1024数据就跳出timer"><a href="#50毫秒触发一次的方法。当我发完1024数据就跳出timer" class="headerlink" title="50毫秒触发一次的方法。当我发完1024数据就跳出timer"></a>50毫秒触发一次的方法。当我发完1024数据就跳出timer</h3><p>{</p>
<pre><code>dataCount = 0;
packageCount ++;

com.buff[0] = 0x55;
com.buff[1] = 0xaa;
com.buff[2] = 0x01;
com.buff[3] = 0x01;
com.buff[4] = packageCount;
chk = com.buff[0]+com.buff[1]+com.buff[2]+com.buff[3]+com.buff[4];
for (int i = 5; i &lt; 1029; i++) {
    if ([fileDataArray count]) {
        int value;
        sscanf([[fileDataArray firstObject] cStringUsingEncoding:NSUTF8StringEncoding], &quot;%X&quot;, &amp;value);
        com.buff = value;
        chkTemp += com.buff;
        [fileDataArray removeObjectAtIndex:0];
    }
    chk += com.buff;
}
for (int i = 1029; i &lt; 1039; i++) {
    chk += com.buff;
}
com.buff[1039] = chk;
sendTimer = [NSTimer scheduledTimerWithTimeInterval:.05 target:self selector:@selector(sendDataPackage) userInfo:nil repeats:YES];
</code></pre><p>}</p>
<p>{</p>
<pre><code>Command commandData;
for (int i = 0; i &lt; 20; i++) {
    commandData.buff = com.buff[dataCount];
    dataCount++;
    if (dataCount == 1040) {
        [sendTimer invalidate];
    }
}
NSData* data = [[NSData alloc] initWithBytes:(char *)&amp;commandData.buff length:20];
[self write:selectPeripheral data:data];
if ([delegate respondsToSelector:@selector(onUploadProgress:totalParts:Package:)]) {
    [delegate onUploadProgress:((1040.0*packageCount)+dataCount)/(1040.0*totalPackage) totalParts:1040*totalPackage Package:packageCount];
}
</code></pre><p>}</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[关于Dictionary根据键值Key字母升降序排列的解决方法]]></title>
      <url>/2018/03/16/%E5%85%B3%E4%BA%8EDictionary%E6%A0%B9%E6%8D%AE%E9%94%AE%E5%80%BCKey%E5%AD%97%E6%AF%8D%E5%8D%87%E9%99%8D%E5%BA%8F%E6%8E%92%E5%88%97%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="目标Dictionary："><a href="#目标Dictionary：" class="headerlink" title="目标Dictionary："></a>目标Dictionary：</h2><p>addressBookDict: [string:[ZZWPersonGetAllMembersModel]]</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>// 将addressBookDict字典中的所有Key值进行排序: A~Z，，得到key值排序数组</p>
<p>​            nameKeys = Array(addressBookDict.keys).sorted()</p>
<p>// 将addressBookDict字典中的所有Value值根据key键值进行排序: A~Z，，得到[(key:string,Value:[ZZWPersonGetAllMembersModel])]值排序的新数组</p>
<p>var addressBkeys  = addressBookDict.sorted(by: { (t1, t2) -&gt; Bool in</p>
<p>​                return t1.0 &lt; t2.0 ? true:false</p>
<p>​            })</p>
<p>//获取键值数组 [[ZZWPersonGetAllMembersModel]]</p>
<p>var personArray =<a href="">[ZZWPersonGetAllMembersModel]</a></p>
<p>​                for (_,value) in addressBkeys {</p>
<p>​                    personArray.append(value)</p>
<p>​                }</p>
<p>​    继续获得Dictionary 只要用key和value做一个初始化赋值即可</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[使用UISearchController跳转新控制器时搜索框依然出现]]></title>
      <url>/2018/03/09/%E4%BD%BF%E7%94%A8UISearchController%E8%B7%B3%E8%BD%AC%E6%96%B0%E6%8E%A7%E5%88%B6%E5%99%A8%E6%97%B6%E6%90%9C%E7%B4%A2%E6%A1%86%E4%BE%9D%E7%84%B6%E5%87%BA%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>最近偶遇一个问题，当使用UISearchController来push一个新的界面时，push成功后搜索框依然存在，不知道是不是苹果的一个bug，但是可以通过增加一句代码来解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.definesPresentationContext = YES;</span><br></pre></td></tr></table></figure>
<p>definesPresentationContext这是一个布尔变量，表示该视图被覆盖时，视图或者它的子类提供了一个视图控制器。默认为NO，我们在做跳转时，需要一个跳转的环境，如果呈现的视图控制器不提供的话，需要呈现这个控制器的父视图控制器。此处因为UISearchController为呈现的视图控制器，它不提供这个跳转的环境，所以需要它的父视图控制器提供，所以设置父视图控制器的这个布尔变量为YES。 </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[NSAttributedStringKey]]></title>
      <url>/2018/03/08/NSAttributedStringKey/</url>
      <content type="html"><![CDATA[<p>系统关键字段</p>
<p>import Foundation</p>
<p>import UIKit</p>
<p>import _SwiftUIKitOverlayShims</p>
<p>extension NSAttributedStringKey {</p>
<p>​    </p>
<p>​    /<strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong> Attributes <strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong>/</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let font: NSAttributedStringKey</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let paragraphStyle: NSAttributedStringKey // NSParagraphStyle, default defaultParagraphStyle</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let foregroundColor: NSAttributedStringKey // UIColor, default blackColor</p>
<a id="more"></a>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let backgroundColor: NSAttributedStringKey // UIColor, default nil: no background</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let ligature: NSAttributedStringKey // NSNumber containing integer, default 1: default ligatures, 0: no ligatures</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let kern: NSAttributedStringKey // NSNumber containing floating point value, in points; amount to modify default kerning. 0 means kerning is disabled.</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let strikethroughStyle: NSAttributedStringKey // NSNumber containing integer, default 0: no strikethrough</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let underlineStyle: NSAttributedStringKey // NSNumber containing integer, default 0: no underline</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let strokeColor: NSAttributedStringKey // UIColor, default nil: same as foreground color</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let strokeWidth: NSAttributedStringKey // NSNumber containing floating point value, in percent of font point size, default 0: no stroke; positive for stroke alone, negative for stroke and fill (a typical value for outlined text would be 3.0)</p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let shadow: NSAttributedStringKey // NSShadow, default nil: no shadow</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let textEffect: NSAttributedStringKey // NSString, default nil: no text effect</p>
<p>​    </p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let attachment: NSAttributedStringKey // NSTextAttachment, default nil</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let link: NSAttributedStringKey // NSURL (preferred) or NSString</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let baselineOffset: NSAttributedStringKey // NSNumber containing floating point value, in points; offset from baseline, default 0</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let underlineColor: NSAttributedStringKey // UIColor, default nil: same as foreground color</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let strikethroughColor: NSAttributedStringKey // UIColor, default nil: same as foreground color</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let obliqueness: NSAttributedStringKey // NSNumber containing floating point value; skew to be applied to glyphs, default 0: no skew</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let expansion: NSAttributedStringKey // NSNumber containing floating point value; log of expansion factor to be applied to glyphs, default 0: no expansion</p>
<p>​    </p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let writingDirection: NSAttributedStringKey // NSArray of NSNumbers representing the nested levels of writing direction overrides as defined by Unicode LRE, RLE, LRO, and RLO characters.  The control characters can be obtained by masking NSWritingDirection and NSWritingDirectionFormatType values.  LRE: NSWritingDirectionLeftToRight|NSWritingDirectionEmbedding, RLE: NSWritingDirectionRightToLeft|NSWritingDirectionEmbedding, LRO: NSWritingDirectionLeftToRight|NSWritingDirectionOverride, RLO: NSWritingDirectionRightToLeft|NSWritingDirectionOverride,</p>
<p>​    </p>
<p>​    @available(iOS 6.0, *)</p>
<p>​    public static let verticalGlyphForm: NSAttributedStringKey // An NSNumber containing an integer value.  0 means horizontal text.  1 indicates vertical text.  If not specified, it could follow higher-level vertical orientation settings.  Currently on iOS, it’s always horizontal.  The behavior for any other value is undefined.</p>
<p>}</p>
<p>// This defines currently supported values for NSUnderlineStyleAttributeName and NSStrikethroughStyleAttributeName. NSUnderlineStyle<em>, NSUnderlinePattern</em>, and NSUnderlineByWord are or’ed together to produce an underline style.</p>
<p>/<strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong> Attribute values <strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong>/</p>
<p>@available(iOS 6.0, *)</p>
<p>public enum NSUnderlineStyle : Int {</p>
<p>​    </p>
<p>​    case styleNone</p>
<p>​    case styleSingle</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    case styleThick</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    case styleDouble</p>
<p>​    </p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static var patternSolid: NSUnderlineStyle { get }</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    case patternDot</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    case patternDash</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    case patternDashDot</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    case patternDashDotDot</p>
<p>​    </p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    case byWord</p>
<p>}</p>
<p>// NSWritingDirectionFormatType values used by NSWritingDirectionAttributeName. It is or’ed with either NSWritingDirectionLeftToRight or NSWritingDirectionRightToLeft. Can specify the formatting controls defined by Unicode Bidirectional Algorithm.</p>
<p>@available(iOS 9.0, *)</p>
<p>public enum NSWritingDirectionFormatType : Int {</p>
<p>​    </p>
<p>​    case embedding</p>
<p>​    case override</p>
<p>}</p>
<p>extension NSAttributedString {</p>
<p>​    </p>
<p>​    public struct TextEffectStyle : RawRepresentable, Equatable, Hashable {</p>
<p>​        public init(rawValue: String)</p>
<p>​    }</p>
<p>​    </p>
<p>​    /<strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong> Attribute fixing <strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong>/</p>
<p>​    </p>
<p>​    // This method fixes attribute inconsistencies inside range.  It ensures NSFontAttributeName covers the characters, NSParagraphStyleAttributeName is only changing at paragraph boundaries, and NSTextAttachmentAttributeName is assigned to NSAttachmentCharacter.  NSTextStorage automatically invokes this method via -ensureAttributesAreFixedInRange:.</p>
<p>​    </p>
<p>​    </p>
<p>​    /<strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong> Document formats <strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong>/</p>
<p>​    public struct DocumentType : RawRepresentable, Equatable, Hashable {</p>
<p>​        public init(_ rawValue: String)</p>
<p>​        public init(rawValue: String)</p>
<p>​    }</p>
<p>​    </p>
<p>​    // Supported document types for the NSDocumentTypeDocumentAttribute key in the document attributes dictionary.</p>
<p>​    </p>
<p>​    public struct TextLayoutSectionKey : RawRepresentable, Equatable, Hashable {</p>
<p>​        public init(rawValue: String)</p>
<p>​    }</p>
<p>​    </p>
<p>​    // Keys for NSLayoutOrientationSectionsAttribute.</p>
<p>​    // NSNumber containing NSTextLayoutOrientation value. default: NSTextLayoutOrientationHorizontal</p>
<p>​    // NSValue containing NSRange representing a character range. default: a range covering the whole document</p>
<p>​    </p>
<p>​    public struct DocumentAttributeKey : RawRepresentable, Equatable, Hashable {</p>
<p>​        public init(_ rawValue: String)</p>
<p>​        public init(rawValue: String)</p>
<p>​    }</p>
<p>​    </p>
<p>​    // Keys for options and document attributes dictionaries.  They are in and out document properties used by both read/write methods.</p>
<p>​    </p>
<p>​    // @”DocumentType”, one of the document types declared above.  For reader methods, this key in options can specify the document type for interpreting the contents.  Upon return, the document attributes can contain this key for indicating the actual format used to read the contents.  For write methods, this key specifies the format for generating the data.</p>
<p>​    </p>
<p>​    // NSPlainTextDocumentType document attributes</p>
<p>​    // @”CharacterEncoding”, NSNumber containing integer specifying NSStringEncoding for the file; default for plain text is the default encoding.  This key in options can specify the string encoding for reading the data.  Upon return, the document attributes can contain the actual encoding used.  For writing methods, this value is used for generating the plain text data.</p>
<p>​    // @”DefaultAttributes”, NSDictionary containing attributes to be applied to plain files.  Used by reader methods.  This key in options can specify the default attributes applied to the entire document contents.  The document attributes can contain this key indicating the actual attributes used.</p>
<p>​    </p>
<p>​    // NSRTFTextDocumentType and NSRTFDTextDocumentType document attributes</p>
<p>​    // Document dimension</p>
<p>​    // They are document attributes used by read/write methods.</p>
<p>​    // @”PaperSize”, NSValue containing CGSize (in points)</p>
<p>​    // @”PaperMargin”, NSValue containing UIEdgeInsets</p>
<p>​    </p>
<p>​    // @”ViewSize”, NSValue containing CGSize (in points)</p>
<p>​    // @”ViewZoom”, NSNumber containing floating point value (100 == 100% zoom)</p>
<p>​    // @”ViewMode”, NSNumber containing integer; 0 = normal; 1 = page layout</p>
<p>​    </p>
<p>​    // Document settings</p>
<p>​    // They are document attributes used by read/write methods.</p>
<p>​    // @”ReadOnly”, NSNumber containing integer; if missing, or 0 or negative, not readonly; 1 or more, readonly. Note that this has nothing to do with the file system protection on the file, but instead, on how the file should be displayed to the user</p>
<p>​    // @”BackgroundColor”, UIColor, representing the document-wide page background color</p>
<p>​    // @”HyphenationFactor”, NSNumber containing floating point value (0=off, 1=full hyphenation)</p>
<p>​    // @”DefaultTabInterval”, NSNumber containing floating point value, representing the document-wide default tab stop interval, in points</p>
<p>​    // NSArray of dictionaries.  Each dictionary describing a layout orientation section.  The dictionary can have two attributes: NSTextLayoutSectionOrientation and NSTextLayoutSectionRange.  When there is a gap between sections, it’s assumed to have NSTextLayoutOrientationHorizontal.</p>
<p>​    </p>
<p>​    public struct DocumentReadingOptionKey : RawRepresentable, Equatable, Hashable {</p>
<p>​        public init(_ rawValue: String)</p>
<p>​        public init(rawValue: String)</p>
<p>​    }</p>
<p>}</p>
<p>extension NSAttributedString.TextEffectStyle {</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let letterpressStyle: NSAttributedString.TextEffectStyle</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong> Attribute fixing <strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong>/</p>
<p>extension NSMutableAttributedString {</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    open func fixAttributes(in range: NSRange)</p>
<p>}</p>
<p>extension NSAttributedString.DocumentType {</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let plain: NSAttributedString.DocumentType</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let rtf: NSAttributedString.DocumentType</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let rtfd: NSAttributedString.DocumentType</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let html: NSAttributedString.DocumentType</p>
<p>}</p>
<p>extension NSAttributedString.TextLayoutSectionKey {</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let orientation: NSAttributedString.TextLayoutSectionKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let range: NSAttributedString.TextLayoutSectionKey</p>
<p>}</p>
<p>extension NSAttributedString.DocumentAttributeKey {</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let documentType: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let characterEncoding: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let defaultAttributes: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let paperSize: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let paperMargin: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let viewSize: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let viewZoom: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let viewMode: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let readOnly: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let backgroundColor: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let hyphenationFactor: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let defaultTabInterval: NSAttributedString.DocumentAttributeKey</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public static let textLayoutSections: NSAttributedString.DocumentAttributeKey</p>
<p>}</p>
<p>extension NSAttributedString.DocumentReadingOptionKey {</p>
<p>​    </p>
<p>​    public static let documentType: NSAttributedString.DocumentReadingOptionKey</p>
<p>​    public static let defaultAttributes: NSAttributedString.DocumentReadingOptionKey // @”DefaultAttributes”, for plain text only; NSDictionary containing attributes to be applied to plain files</p>
<p>​    public static let characterEncoding: NSAttributedString.DocumentReadingOptionKey // @”CharacterEncoding”, for plain text and HTML; NSNumber containing integer specifying NSStringEncoding to be used to interpret the file</p>
<p>}</p>
<p>extension NSAttributedString {</p>
<p>​    // Methods initializing the receiver contents with an external document data.  options specify document attributes for interpreting the document contents.  NSDocumentTypeDocumentAttribute, NSCharacterEncodingDocumentAttribute, and NSDefaultAttributesDocumentAttribute are supported options key.  When they are not specified, these methods will examine the data and do their best to detect the appropriate attributes.  If dict is non-NULL, it will return a dictionary with various document-wide attributes accessible via NS…DocumentAttribute keys.</p>
<p>​    @available(iOS 9.0, *)</p>
<p>​    public init(url: URL, options: [NSAttributedString.DocumentReadingOptionKey : Any] = [:], documentAttributes dict: AutoreleasingUnsafeMutablePointer<nsdictionary?>?) throws</nsdictionary?></p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    public init(data: Data, options: [NSAttributedString.DocumentReadingOptionKey : Any] = [:], documentAttributes dict: AutoreleasingUnsafeMutablePointer<nsdictionary?>?) throws</nsdictionary?></p>
<p>​    </p>
<p>​    // Generates an NSData object for the receiver contents in range.  It requires a document attributes dict specifying at least the NSDocumentTypeDocumentAttribute to determine the format to be written.</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    open func data(from range: NSRange, documentAttributes dict: [NSAttributedString.DocumentAttributeKey : Any] = [:]) throws -&gt; Data</p>
<p>​    </p>
<p>​    // Returns an NSFileWrapper object for the receiver contents in range.  It requires a document attributes dict specifying at least the NSDocumentTypeDocumentAttribute to determine the format to be written.  The method returns a directory file wrapper for those document types represented by a file package such as NSRTFDTextDocumentType; otherwise, it returns a regular-file file wrapper.</p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    open func fileWrapper(from range: NSRange, documentAttributes dict: [NSAttributedString.DocumentAttributeKey : Any] = [:]) throws -&gt; FileWrapper</p>
<p>}</p>
<p>extension NSMutableAttributedString {</p>
<p>​    // Methods replacing the receiver contents with an external document data.  options specify document attributes for interpreting the document contents.  NSDocumentTypeDocumentAttribute, NSCharacterEncodingDocumentAttribute, and NSDefaultAttributesDocumentAttribute are supported options key.  When they are not specified, these methods will examine the data and do their best to detect the appropriate attributes.  If dict is non-NULL, it will return a dictionary with various document-wide attributes accessible via NS…DocumentAttribute keys.</p>
<p>​    @available(iOS 9.0, *)</p>
<p>​    open func read(from url: URL, options opts: [NSAttributedString.DocumentReadingOptionKey : Any] = [:], documentAttributes dict: AutoreleasingUnsafeMutablePointer<nsdictionary?>?) throws</nsdictionary?></p>
<p>​    @available(iOS 7.0, *)</p>
<p>​    open func read(from data: Data, options opts: [NSAttributedString.DocumentReadingOptionKey : Any] = [:], documentAttributes dict: AutoreleasingUnsafeMutablePointer<nsdictionary?>?) throws</nsdictionary?></p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong> Misc methods <strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong>/</p>
<p>extension NSAttributedString {</p>
<p>​    // Returns YES if the receiver contains a property configured (NSAttachmentAttributeName with NSAttachmentCharacter) in range</p>
<p>​    @available(iOS 9.0, *)</p>
<p>​    open func containsAttachments(in range: NSRange) -&gt; Bool</p>
<p>}</p>
<p>extension NSAttributedString : NSItemProviderReading, NSItemProviderWriting {</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong> Deprecated <strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong>/</p>
<p>@available(iOS, introduced: 7.0, deprecated: 9.0, message: “Use NSWritingDirectionFormatType instead”)</p>
<p>public enum NSTextWritingDirection : Int {</p>
<p>​    </p>
<p>​    case embedding</p>
<p>​    case override</p>
<p>}</p>
<p>extension NSAttributedString {</p>
<p>​    @available(iOS, introduced: 7.0, deprecated: 9.0, message: “Use -initWithURL:options:documentAttributes:error: instead”)</p>
<p>​    public init(fileURL url: URL, options: [AnyHashable : Any] = [:], documentAttributes dict: AutoreleasingUnsafeMutablePointer<nsdictionary?>?) throws</nsdictionary?></p>
<p>}</p>
<p>extension NSMutableAttributedString {</p>
<p>​    @available(iOS, introduced: 7.0, deprecated: 9.0, message: “Use -readFromURL:options:documentAttributes:error: instead”)</p>
<p>​    open func read(fromFileURL url: URL, options opts: [AnyHashable : Any] = [:], documentAttributes dict: AutoreleasingUnsafeMutablePointer<nsdictionary?>?) throws</nsdictionary?></p>
<p>}</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[AvoidCrash - oc-no-crash 福音]]></title>
      <url>/2018/02/02/AvoidCrash%20-%20oc-no-crash%20%E7%A6%8F%E9%9F%B3/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/chenfanfang/AvoidCrash" target="_blank" rel="noopener">https://github.com/chenfanfang/AvoidCrash</a></p>
<p>感觉像是在发广告，虽然我已经转到swift，但是这几天的测试还是忍不住要向oc同仁们安利一番</p>
<p>以下内容ctrl+c and ctrl+v完成</p>
<h3 id="Foundation框架存在许多潜在崩溃的危险"><a href="#Foundation框架存在许多潜在崩溃的危险" class="headerlink" title="Foundation框架存在许多潜在崩溃的危险"></a>Foundation框架存在许多潜在崩溃的危险</h3><p>===</p>
<p>- 将 nil 插入可变数组中会导致崩溃。</p>
<p>- 数组越界会导致崩溃。</p>
<p>- 根据key给字典某个元素重新赋值时，若key为 nil 会导致崩溃。</p>
<p>- ……</p>
<h3 id="AvoidCrash简介"><a href="#AvoidCrash简介" class="headerlink" title="AvoidCrash简介"></a>AvoidCrash简介</h3><h1 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h1><p>- 这个框架利用runtime技术对一些常用并且容易导致崩溃的方法进行处理，可以有效的防止崩溃。</p>
<p>- 并且打印出具体是哪个方法会导致崩溃，让你快速定位导致崩溃的代码。</p>
<p>- 你可以获取到原本导致崩溃的主要信息&lt;由于这个框架的存在，并不会崩溃&gt;，进行相应的处理。比如：</p>
<ul>
<li><p>你可以将这些崩溃信息发送到自己服务器。</p>
</li>
<li><p>你若集成了第三方崩溃日志收集的SDK,比如你用了腾讯的Bugly,你可以上报自定义异常。</p>
</li>
</ul>
<p>- 或许你会问就算防止了崩溃，但是所获取到的数据变成nil或者并非是你所需要的数据，这又有什么用？对于防止崩溃，我的理解是，宁愿一个功能不能用，都要让app活着，至少其他功能还能用。</p>
<h3 id="尾声：谁用谁知道！————可惜了swift目前测试用不了"><a href="#尾声：谁用谁知道！————可惜了swift目前测试用不了" class="headerlink" title="尾声：谁用谁知道！————可惜了swift目前测试用不了"></a>尾声：谁用谁知道！————可惜了swift目前测试用不了</h3>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Alamofire serversTool]]></title>
      <url>/2018/02/02/hello-world/</url>
      <content type="html"><![CDATA[<p>更新”moya”~&gt;11.0.1；swift4.0。后   </p>
<p>ApiService.swift</p>
<p>//</p>
<p>//  ApiService.swift</p>
<p>//</p>
<a id="more"></a>
<p>import Foundation</p>
<p>import Moya</p>
<p>import SwiftyJSON</p>
<p>var strActionPath = “index.php/action=”</p>
<p>let headerFields: Dictionary<string, string=""> = [</string,></p>
<p>​    “platform”: “iOS”,</p>
<p>​    “sys_ver”: String(UIDevice.version())</p>
<p>​    ,</p>
<p>​    “Content-Type” : “application/json”</p>
<p>]</p>
<p>let appendedParams: Dictionary<string, anyobject=""> = [</string,></p>
<p>//    “uid”: “123456” as AnyObject</p>
<p>:]</p>
<p>public var parameterEncoding: ParameterEncoding {</p>
<p>​    return JSONEncoding.prettyPrinted</p>
<p>}</p>
<p>let endpointClosure = { (target: ApiService) -&gt; Endpoint<apiservice> in</apiservice></p>
<p>​    let url = target.baseURL.appendingPathComponent(target.path).absoluteString</p>
<p>​    LTLog(“URL “+url)</p>
<p>​    return Endpoint<apiservice>(</apiservice></p>
<p>​        url: url,</p>
<p>​        sampleResponseClosure: {.networkResponse(200, target.sampleData)},</p>
<p>​        method: target.method,</p>
<p>​        task: target.task,</p>
<p>​         httpHeaderFields: headerFields)</p>
<p>​    </p>
<p>}</p>
<p>let endpointClosureWeb = { (target: ApiService) -&gt; Endpoint<apiservice> in</apiservice></p>
<p>​    let url = target.path</p>
<p>​    LTLog(“URL “+url)</p>
<p>​    return Endpoint<apiservice>(url: url, sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, task: target.task,  httpHeaderFields: headerFields)    </apiservice></p>
<p>}</p>
<p>private extension String {</p>
<p>​    var urlEscaped: String {</p>
<p>​        return self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!</p>
<p>​    }</p>
<p>}</p>
<p>let apiProvider = MoyaProvider<apiservice>(endpointClosure: endpointClosure)</apiservice></p>
<p>let webProvider = MoyaProvider<apiservice>(endpointClosure:endpointClosureWeb)</apiservice></p>
<p>enum ApiService {</p>
<p>​    case action(pathUrl:String,parameter:ParameterBase)</p>
<p>​    //加载非标准接口</p>
<p>​    case loadWebPage(pageUrl:String)</p>
<p>}</p>
<p>extension ApiService: TargetType {</p>
<p>​    var headers: [String : String]? {</p>
<p>​        return nil</p>
<p>​    }</p>
<p>​    </p>
<p>​    var parameterEncoding: ParameterEncoding {</p>
<p>​        return JSONEncoding.prettyPrinted</p>
<p>​    }</p>
<p>​        var baseURL: URL {return URL(string: “<a href="http://xxxxxxxxxxxx&quot;)!}" target="_blank" rel="noopener">http://xxxxxxxxxxxx&quot;)!}</a></p>
<p>​    var path: String {</p>
<p>​        switch self {</p>
<p>​        case .action(let pathName,_):</p>
<p>​            return strActionPath+pathName</p>
<p>​            </p>
<p>​        case .loadWebPage(let pathPage):</p>
<p>​            return pathPage</p>
<p>​        }</p>
<p>​        </p>
<p>​    }</p>
<p>​    </p>
<p>​    var method: Moya.Method {</p>
<p>​        return .post</p>
<p>​    }</p>
<p>​    </p>
<p>​    var parameters: [String: Any]? {</p>
<p>​        </p>
<p>​        switch self {</p>
<p>​        case .action(_,let parameter):</p>
<p>​        </p>
<p>//            let request = parameter.toString()</p>
<p>//             let jsondata = try? JSONSerialization.data(withJSONObject: parameter, options: .prettyPrinted)</p>
<p>​            return parameter.toString()</p>
<p>​           </p>
<p>​        case .loadWebPage(_):</p>
<p>​            return nil</p>
<p>​        }</p>
<p>​    }</p>
<p>​    public var task: Task {</p>
<p>​    </p>
<p>​        return .requestParameters(parameters: parameters!, encoding: JSONEncoding.prettyPrinted)</p>
<p>​    }</p>
<p>​    public var sampleData: Data {</p>
<p>​        switch self {</p>
<p>​        default:</p>
<p>​            return “Success”.data(using: String.Encoding.utf8)!</p>
<p>​        </p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>}</p>
<p>第一篇测试文章，就不说那么多废话了</p>
<h2 id="主要解决Xcode升级9-0后swift版会出bug的问题"><a href="#主要解决Xcode升级9-0后swift版会出bug的问题" class="headerlink" title="主要解决Xcode升级9.0后swift版会出bug的问题"></a>主要解决Xcode升级9.0后swift版会出bug的问题</h2><h3 id="环境Xcode9-2。-pod-‘Alamofire’-‘-gt-4-5’-”moya”-gt-8-0"><a href="#环境Xcode9-2。-pod-‘Alamofire’-‘-gt-4-5’-”moya”-gt-8-0" class="headerlink" title="环境Xcode9.2。 pod ‘Alamofire’, ‘~&gt; 4.5’ ,”moya”~&gt;8.0"></a>环境Xcode9.2。 pod ‘Alamofire’, ‘~&gt; 4.5’ ,”moya”~&gt;8.0</h3><p>直接上代码了</p>
<p>//<br>//  ApiService.swift<br>//</p>
<p>import Foundation<br>import Moya<br>import SwiftyJSON</p>
<p>var strActionPath = “index.php/action=”</p>
<p>let headerFields: Dictionary<string, string=""> = [<br>“platform”: “iOS”,<br>“sys_ver”: String(UIDevice.version())<br>,<br>“Content-Type” : “application/json”<br>]</string,></p>
<p>let appendedParams: Dictionary<string, anyobject=""> = [<br>:]</string,></p>
<p>public var parameterEncoding: ParameterEncoding {<br>return JSONEncoding.prettyPrinted<br>}</p>
<p>let endpointClosure = { (target: ApiService) -&gt; Endpoint<apiservice> in<br>let url = target.baseURL.appendingPathComponent(target.path).absoluteString<br>LTLog(“URL “+url)<br>return Endpoint<apiservice>(<br>url: url,<br>sampleResponseClosure: {.networkResponse(200, target.sampleData)},<br>method: target.method,<br>parameters: target.parameters,<br>parameterEncoding: parameterEncoding,<br>httpHeaderFields: headerFields)</apiservice></apiservice></p>
<p>.adding(parameters: appendedParams)<br>}</p>
<p>let endpointClosureWeb = { (target: ApiService) -&gt; Endpoint<apiservice> in<br>let url = target.path<br>LTLog(“URL “+url)<br>return Endpoint<apiservice>(url: url, sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method)<br>.adding(parameters: appendedParams)<br>.adding(newHTTPHeaderFields: headerFields)</apiservice></apiservice></p>
<p>}</p>
<p>private extension String {<br>var urlEscaped: String {<br>return self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!<br>}<br>}</p>
<p>let apiProvider = RxMoyaProvider<apiservice>(endpointClosure: endpointClosure)<br>let webProvider = RxMoyaProvider<apiservice>(endpointClosure:endpointClosureWeb)</apiservice></apiservice></p>
<p>enum ApiService {<br>case action(pathUrl:String,parameter:ParameterBase)<br>//加载非标准接口<br>case loadWebPage(pageUrl:String)<br>}</p>
<p>extension ApiService: TargetType {<br>var parameterEncoding: ParameterEncoding {<br>return JSONEncoding.prettyPrinted<br>}</p>
<p>/// The method used for parameter encoding.</p>
<p>var baseURL: URL {return URL(string: “接口地址”)!}<br>var path: String {<br>switch self {<br>case .action(let pathName,_):<br>return strActionPath+pathName</p>
<p>case .loadWebPage(let pathPage):<br>return pathPage<br>}<br>}</p>
<p>var method: Moya.Method {<br>return .post<br>}</p>
<p>var parameters: [String: Any]? {</p>
<p>switch self {<br>case .action(_,let parameter):</p>
<p>return parameter.toString()</p>
<p>case .loadWebPage(_):<br>return nil<br>}<br>}</p>
<p>public var task: Task {</p>
<p>return Task.request<br>}<br>public var sampleData: Data {<br>switch self {<br>default:<br>return “Success”.data(using: String.Encoding.utf8)!</p>
<p>}<br>}</p>
<p>}</p>
<p>直接打成swift类就可以用，只有POST请求，没有写GET因为Alamofire示例里有也简单。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS Swift Crash的捕获]]></title>
      <url>/2018/02/02/iOS%20Swift%20Crash%E7%9A%84%E6%8D%95%E8%8E%B7/</url>
      <content type="html"><![CDATA[<h2 id="crash捕获介绍"><a href="#crash捕获介绍" class="headerlink" title="crash捕获介绍"></a>crash捕获介绍</h2><p>文章转载至 <a href="https://www.jianshu.com/p/d2b7a2eb36ba" target="_blank" rel="noopener">https://www.jianshu.com/p/d2b7a2eb36ba</a></p>
<p>## </p>
<ul>
<li><p>如果对crash捕获不太了解，可以先参考这篇<a href="https://link.jianshu.com?t=https://nianxi.net/ios/ios-crash-reporter.html" target="_blank" rel="noopener">文章</a>,本文进行<code>Mach异常+Unix信号方式</code>捕获crash。</p>
</li>
<li><p>NSException一般只在OC当中被捕获，一般情况下在捕获NSException异常后同时也会捕获到一个对应的signal异常。但如果你使用的是纯swift开发，如下代码并不会捕获相关的crash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSSetUncaughtExceptionHandler(UncaughtExceptionHandler)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="swift崩溃捕获"><a href="#swift崩溃捕获" class="headerlink" title="swift崩溃捕获"></a>swift崩溃捕获</h2><ul>
<li><p>swift通常都是通过对应的signal来捕获crash。对于swift的崩溃捕获，Apple的<a href="https://link.jianshu.com?t=https://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-ANALYZING_CRASH_REPORTS-EXCEPTION_CODES" target="_blank" rel="noopener">文档</a>中有描述说需要通过<code>SIGTRAP</code>信号捕获强转失败，及非可选的nil值导致的崩溃.具体描述如下：</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Trace Trap[EXC_BREAKPOINT // SIGTRAP]</span><br><span class="line">类似于异常退出，此异常旨在使附加的调试器有机会在其执行中的特定点中断进程。您可以使用该__builtin_trap()函数从您自己的代码触发此异常。如果没有附加调试器，则该过程将终止并生成崩溃报告。</span><br><span class="line">较低级的库（例如，libdispatch）会在遇到致命错误时捕获进程。有关错误的其他信息可以在崩溃报告的“ 附加诊断信息”部分或设备的控制台中找到。</span><br><span class="line"></span><br><span class="line">如果在运行时遇到意外情况，Swift代码将以此异常类型终止，例如：</span><br><span class="line">    1.具有nil值的非可选类型</span><br><span class="line">    2.一个失败的强制类型转换</span><br></pre></td></tr></table></figure>
<p>对于swift还有一种崩溃需要捕获(Intel处理器,我认为应该是指在模拟器上的崩溃)，为保险起见，也需要将信号<code>SIGILL</code>进行注册，Apple同样对其中做了描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Illegal Instruction[EXC_BAD_INSTRUCTION // SIGILL]</span><br><span class="line">  该过程尝试执行非法或未定义的指令。该过程可能尝试通过错误配置的函数指针跳转到无效地址。</span><br><span class="line">  在Intel处理器上，ud2操作码引起EXC_BAD_INSTRUCTION异常，但通常用于进程调试目的。如果在运行时遇到意外情况，Intel处理器上的Swift代码将以此异常类型终止。有关详细信息，请参阅Trace Trap。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="crash捕获实现代码参考"><a href="#crash捕获实现代码参考" class="headerlink" title="crash捕获实现代码参考"></a>crash捕获实现代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//对于OC的exception采取如下方式捕获</span><br><span class="line">NSSetUncaughtExceptionHandler(UncaughtExceptionHandler)</span><br><span class="line">//对于Swift则捕获相关signa，一般来说如下几种已经能够捕获大部分crash。(其中SIGTRAP一定要捕获,swift大量的crash都会通过它）</span><br><span class="line"> signal(SIGABRT, SignalExceptionHandler)</span><br><span class="line">signal(SIGSEGV, SignalExceptionHandler)</span><br><span class="line">signal(SIGBUS, SignalExceptionHandler)</span><br><span class="line">signal(SIGTRAP, SignalExceptionHandler)</span><br><span class="line">signal(SIGILL, SignalExceptionHandler)</span><br></pre></td></tr></table></figure>
<h2 id="获取Slide-Address"><a href="#获取Slide-Address" class="headerlink" title="获取Slide Address"></a>获取Slide Address</h2><a id="more"></a>
<p>通过获取到偏移量地址<code>Slide Address</code>和<code>错误信息的内存地址</code>基本即可定位错误，错误信息的内存地址在捕获的crash信息中会体现，<code>Slide Address</code>则需要我们自己获取，通过调用如下C方法我们可以获取到偏移量地址，这里通过OC文件来调用C方法。方法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//MARK: - 获取偏移量地址</span><br><span class="line">long  calculate(void)&#123;</span><br><span class="line">long slide = 0;</span><br><span class="line">for (uint32_t i = 0; i &lt; _dyld_image_count(); i++) &#123;</span><br><span class="line">    if (_dyld_get_image_header(i)-&gt;filetype == MH_EXECUTE) &#123;</span><br><span class="line">        slide = _dyld_get_image_vmaddr_slide(i);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return slide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="crash分析介绍"><a href="#crash分析介绍" class="headerlink" title="crash分析介绍"></a>crash分析介绍</h2><ul>
<li>如果想要定位错误，通过拿到<code>Slide Address</code>和<code>错误信息的内存地址</code>即可定位(实际上错误信息地址可以通过Slide Address加上偏移量获得)</li>
<li>拿到<code>Slide Address</code>和<code>错误信息的内存地址</code>后我们可以通过一个<a href="https://link.jianshu.com?t=https://github.com/answer-huang/dSYMTools" target="_blank" rel="noopener">开源工具dSYMTools</a>直接定位到我们想要的信息。感谢作者的贡献，让我们更加方便快捷的分析问题。</li>
<li>dSYMTools 需要传入.xcarchive文件，你可以通过Xcode找到你对应提交版本的.xcarchive。你也可以在提交前保留对应的.xcarchive，以供万一产生crash分析使用,这里的.xcarchive一定要与产生crash信息的版本对应，否则无法定位到崩溃信息</li>
</ul>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><ul>
<li><p>当自己捕获NSException Crash并上传到服务器之后，正常crash大概会显示信息如下，我们大概能够知道是由于数组溢出导致的崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Stack:</span><br><span class="line">slideAdress:0xec000</span><br><span class="line">name:NSRangeException </span><br><span class="line">reason:Optional(&quot;*** -[__NSArray0 objectAtIndex:]: index 66         beyond bounds for empty NSArray&quot;) </span><br><span class="line">0   CoreFoundation                      0x0000000181646ff0      &lt;redacted&gt; + 148</span><br><span class="line">1   libobjc.A.dylib                     0x00000001800a8538      objc_exception_throw + 56</span><br><span class="line">2   CoreFoundation                      0x00000001815b2eb8      &lt;redacted&gt; + 0</span><br><span class="line">3   CrashManager                        0x00000001000f3000      CrashManager + 28672</span><br><span class="line">4   UIKit                               0x00000001877ab0ec      &lt;redacted&gt; + 96</span><br><span class="line">5   UIKit                               0x00000001877ab06c      &lt;redacted&gt; + 80</span><br><span class="line">6   UIKit                               0x00000001877955e0      &lt;redacted&gt; + 440</span><br><span class="line">7   UIKit                               0x00000001877aa950      &lt;redacted&gt; + 576</span><br><span class="line">8   UIKit                               0x00000001877aa46c      &lt;redacted&gt; + 2480</span><br><span class="line">9   UIKit                               0x00000001877a5804      &lt;redacted&gt; + 3192</span><br><span class="line">10  UIKit                               0x0000000187776418      &lt;redacted&gt; + 340</span><br><span class="line">11  UIKit                               0x0000000187f6ff64      &lt;redacted&gt; + 2400</span><br><span class="line">12  UIKit                               0x0000000187f6a6c0      &lt;redacted&gt; + 4268</span><br><span class="line">13  UIKit                               0x0000000187f6aaec      &lt;redacted&gt; + 148</span><br><span class="line">14  CoreFoundation                      0x00000001815f5424      &lt;redacted&gt; + 24</span><br><span class="line">15  CoreFoundation                      0x00000001815f4d94      &lt;redacted&gt; + 540</span><br><span class="line">16  CoreFoundation                      0x00000001815f29a0      &lt;redacted&gt; + 744</span><br><span class="line">17  CoreFoundation                      0x0000000181522d94      CFRunLoopRunSpecific + 424</span><br><span class="line">18  GraphicsServices                    0x0000000182f8c074      GSEventRunModal + 100</span><br><span class="line">19  UIKit                               0x00000001877db130      UIApplicationMain + 208</span><br><span class="line">20  CrashManager                        0x00000001000f139c      CrashManager + 21404</span><br><span class="line">21  libdyld.dylib                       0x000000018053159c &lt;redacted&gt; + 4</span><br></pre></td></tr></table></figure>
<p>如上所示，slideAdress我们已经通过程序获取，这里是0xec000，由上往下找，我们可以看到<code>3 CrashManager 0x00000001000f3000 CrashManager + 28672</code>出现了CrashManager信息，那么0x00000001000f3000则有可能为我们想要定位的错误信息地址。将我们得到数据带入工具可清晰定位到错误：</p>
<p>​</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4421348-16d324965a499e64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/514" alt="img"></p>
<p>NSException错误信息.png</p>
<p>​</p>
</li>
</ul>
<ul>
<li><p>如果捕获到的Signal Crash，可能crash显示的信息大概会如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Stack:</span><br><span class="line">slideAdress:0xa4000</span><br><span class="line">0   CrashManager                        0x00000001000a8f10      CrashManager + 20240</span><br><span class="line">1   CrashManager                        0x00000001000a9024      CrashManager + 20516</span><br><span class="line">2   libsystem_platform.dylib            0x000000018070530c      _sigtramp + 36</span><br><span class="line">3   CrashManager                        0x00000001000ab1bc CrashManager + 29116</span><br><span class="line">4   CrashManager                        0x00000001000aaa64 CrashManager + 27236</span><br><span class="line">5   UIKit                               0x00000001877ab0ec &lt;redacted&gt; + 96</span><br><span class="line">6   UIKit                               0x00000001877ab06c &lt;redacted&gt; + 80</span><br><span class="line">7   UIKit                               0x00000001877955e0 &lt;redacted&gt; + 440</span><br><span class="line">8   UIKit                               0x00000001877aa950 &lt;redacted&gt; + 576</span><br><span class="line">9   UIKit                               0x00000001877aa46c &lt;redacted&gt; + 2480</span><br><span class="line">10  UIKit                               0x00000001877a5804 &lt;redacted&gt; + 3192</span><br><span class="line">11  UIKit                               0x0000000187776418 &lt;redacted&gt; + 340</span><br><span class="line">12  UIKit                               0x0000000187f6ff64 &lt;redacted&gt; + 2400</span><br><span class="line">13  UIKit                               0x0000000187f6a6c0 &lt;redacted&gt; + 4268</span><br><span class="line">14  UIKit                               0x0000000187f6aaec &lt;redacted&gt; + 148</span><br><span class="line">15  CoreFoundation                      0x00000001815f5424 &lt;redacted&gt; + 24</span><br><span class="line">16  CoreFoundation                      0x00000001815f4d94 &lt;redacted&gt; + 540</span><br><span class="line">17  CoreFoundation                      0x00000001815f29a0 &lt;redacted&gt; + 744</span><br><span class="line">18  CoreFoundation                      0x0000000181522d94 CFRunLoopRunSpecific + 424</span><br><span class="line">19  GraphicsServices                    0x0000000182f8c074 GSEventRunModal + 100</span><br><span class="line">20  UIKit                               0x00000001877db130 UIApplicationMain + 208</span><br><span class="line">21  CrashManager                        0x00000001000a939c CrashManager + 21404</span><br><span class="line">22  libdyld.dylib                       0x000000018053159c &lt;redacted&gt; +</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一般我们无法从signal产生的这些信息中直观获取到crash产生的原因，这里崩溃的地址我们一般优先选择_sigtramp后第一条有我们程序信息的地址，所以这里将slideAdress：0xa4000和可能的错误信息地址0x00000001000ab1bc代入：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4421348-dbc64bf8a2accdba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518" alt="img"></p>
<p>signalCrash.png</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>如果你使用工具解析后得到的信息是类似于这样的<code>_hidden#30_ (in libswiftObjectiveC.dylib) (__hidden#70_:0)</code>,那么极有可能是因为你提交版本的时候勾选了BitCode，勾选了Bitcode之后,用户安装的二进制文件是苹果服务器经过优化后生成的,其对应的调试符号信息丢失了,所以你看到的全部是类似于<code>__hidden#70_:0</code>这样的信息，所以也无法通过还原奔溃现场找原因了.如果你如果你不太理解BitCode,可以参考这篇<a href="https://www.jianshu.com/p/f42a33f5eb61" target="_blank" rel="noopener">BitCode介绍</a>和这篇<a href="https://link.jianshu.com?t=https://support.hockeyapp.net/discussions/problems/50204-symbolicated-crash-contains-hidden-symbol-names" target="_blank" rel="noopener">讨论</a></li>
<li>如果你使用模拟器，那么由于本身绑定相关dSYM文件，你获取到的crash信息中可能不是错误地址而是很明显的相关错误信息，这不在本文讨论范围内，毕竟在调试过程中获取崩溃信息相对容易，本文阐述的是你的应用已经提交后捕获和分析用户使用过程中产生的crash</li>
</ul>
<h2 id="资源支持"><a href="#资源支持" class="headerlink" title="资源支持"></a>资源支持</h2><p>这是一个<a href="https://link.jianshu.com?t=https://github.com/xiaoyi6409/XYCrashManager.git" target="_blank" rel="noopener">完整的Demo</a>,本篇文章所阐述的内容在Demo中都有体现，你可以直接使用Demo中的模块完成Crash捕获，也可以参考Demo阅读本文，相信可以更快理解，如果对你有帮助，给个star呗。<br><a href="https://link.jianshu.com?t=https://stackoverflow.com/questions/36325140/how-to-catch-a-swift-crash-and-do-some-logging" target="_blank" rel="noopener">crash捕获参考文档连接</a></p>
<ul>
<li>​</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[swift4.0 适配]]></title>
      <url>/2018/02/02/swift4.0%20%E9%80%82%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>转载<a href="http://blog.csdn.net/andanlan/article/details/78491599?locationNum=1&amp;fps=1" target="_blank" rel="noopener">http://blog.csdn.net/andanlan/article/details/78491599?locationNum=1&amp;fps=1</a><br>一、前言<br>在我们的工程中处于swift和OC混编的状态，使用swift已经有一年半的时间了，随着Xcode9的更新，swift3.2和swift4.0也随之到来，swift3.2相较于Xcode8的swift3.1变动极小，适配没遇到问题，主要关注swift4.0的适配。</p>
<p>二、查看当前工程的 swift 版本<br>image.png</p>
<p>三、使用 Xcode 将工程转换到 swift4.0<br>1、环境<br>Xcode9.1<br>当前 swift 版本 3.2<br>2、转换步骤：<br>选中要转换的 target<br>Edit -&gt; Convert -&gt; To Current Swift Syntax<br>image.png<br>勾选需要转换的 target （pod 引用不用勾选），Next<br>image.png<br>选择转换选项，Next<br>这两个选项是关于 swift 的 @objc 推断特性的，如果使用了 swift4.0 显式的 @objc 属性，能减少整体代码的大小。此时我们选 Minimize Inference（recommend），<br>image.png<br>关于两个选项：<br><a id="more"></a><br>Minimize Inference（recommend）<br>根据静态推断，仅在需要的地方添加@objc属性。使用此选项后，需要按照Completing a Swift 4 minimize inference migration来完成转换。</p>
<p>Match Swift 3 Behavior<br>在编译器隐式推断的任何地方向代码添加一个@objc属性。这个选项不会改变你的二进制文件的大小，因为被Swift 3隐式推断在所有的地方都添加了显式的@objc属性。</p>
<p>预览转换代码，没问题，Save。</p>
<p>3、修改错误<br>完成上述5步之后，看一下 swift 版本，已经是4.0了：<br>image.png</p>
<p>至此打完收工，适配结束。然而并没有，当你运行的时候会看到这个：<br>image.png</p>
<p>是否欲哭无泪，居然这么多错误，不用怕，其实要改动的地方并不多，有些都是重复的，可以直接全局替换就行。</p>
<p>举个栗子：</p>
<ul>
<li>class dynamic func</li>
</ul>
<p>// 转换前<br>class dynamic func bookMoneyToUpController() -&gt; MPBookMoneyToUpController {<br>let vc = MPBookMoneyToUpController.init(nibName: “MPBookMoneyToUpController”, bundle: Bundle.main)<br>return vc<br>}</p>
<p>// 转换后<br>class @objc dynamic func bookMoneyToUpController() -&gt; MPBookMoneyToUpController {<br>let vc = MPBookMoneyToUpController.init(nibName: “MPBookMoneyToUpController”, bundle: Bundle.main)<br>return vc<br>}</p>
<p>// 问题 @objc 修饰符需要前置<br>// 修改成下面即可<br>@objc class dynamic func bookMoneyToUpController() -&gt; MPBookMoneyToUpController {<br>let vc = MPBookMoneyToUpController.init(nibName: “MPBookMoneyToUpController”, bundle: Bundle.main)<br>return vc<br>}</p>
<p>// 全局替换即可<br>class @objc dynamic func  -&gt; @objc class dynamic func<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>image.png</p>
<p>注：<br>上面使用 dynamic 修饰符是由于以前使用 JSPatch 来做 hotfix，需要用到原来OC的运行时特性。</p>
<p>四、@objc<br>swift4.0 最大的特性之一就是 @objc 修饰符的变化了，它主要处理 OC 和 swift 混编时一些方法的调用以及属性获取问题，swift4.0 将在 swift3.x 中一些隐式类型推断的特性去除以后，需要我们来手动管理 @objc 修饰符。<br>在上文中使用 Xcode 转换 swift4.0 时我们勾选了 Minimize Inference 选项，那么我们就需要手动处理相关的 @objc 修饰符，来保证 OC 和 swift 代码能正常相互调用。</p>
<p>1、@objc 修饰符手动处理步骤<br>使用“最小化”转换代码后，需要处理构建和运行时的问题，在完成初始的 swift4.0 转换后，需要按照下面步骤来处理其它问题。</p>
<ol>
<li>运行你的工程</li>
<li>修复编译器提示需要添加 @objc 的地方</li>
<li>测试你的代码，并修复编译器提示使用了不推荐的隐式 @objc 引用的警告。直到没有警告发生。</li>
</ol>
<p>打开工程的 build settings.</p>
<p>将 Swift 3 @objc inference 设置为 Default.</p>
<p>2、@objc 修饰符需要处理的问题<br>编译警告<br>swift 中编译的警告</p>
<p>#selector 参数指定的实例方法必须使用 @objc 修饰，因为swift4中弃用了 @objc属性推断。<br>// 下面的代码会有警告<br>class MyClass : NSObject {<br>func foo() {<br>}</p>
<p>func bar() {<br>self.perform(#selector(MyClass.foo)<br>}<br>}<br>warning: argument of ‘#selector’ refers to instance method ‘foo’ in ‘MyClass’ that depends on ‘@objc’ attribute inference deprecated in Swift 4<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>Objective-C 编译时警告<br>在 OC 中调用的 swift 方法，在 swift 中需要追加 @objc 修饰，swift4 废弃了该类型推断。<br>// 下面的代码会有警告<br>@implementation MyClass (ObjCMethods)</p>
<ul>
<li>(void)other {<br>[self foo];<br>}<br>@end<br>warning: Swift method MyClass.foo uses @objc inference deprecated in Swift 4; add @objc to provide an Objective-C entrypoint<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>修复编译时警告<br>// 通过追加 @objc 来消除警告<br>class MyClass : NSObject {<br>@objc func foo() {<br>}</li>
</ul>
<p>func bar() {<br>self.perform(#selector(MyClass.foo)<br>}<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>查看所有需要添加 @objc 的编译警告<br>image.png<br>直接选中定位到相应位置，追加 @objc 修饰即可。</p>
<p>运行时警告<br>运行时警告会打印在控制台：<br><em>*</em>Swift runtime:<br>ClassName.swift:lineInFile:columnInLine:<br>entrypoint -[ClassName methodName] generated by implicit @objc inference is deprecated and will be removed in Swift 4;<br>add explicit @objc to the declaration to emit the Objective-C entrypoint in Swift 4 and suppress this message<br>1<br>2<br>3<br>4<br>在 Xcode9.1 中，运行时警告在这里也能看到：<br>image.png</p>
<p>想要修复运行时警告，需要添加 @objc 修饰符到对应的方法或者符号。</p>
<p>运行时警告的常见原因:</p>
<p>在 OC 中使用 SEL<br>在 swift 中使用了 perform methods<br>在 OC 中使用了 performSelector methods<br>使用了 @IBOutlet 或者 @IBAction<br>// 下面 swift 代码会产生运行时警告<br>class MyClass : NSObject {<br>func foo() {<br>}</p>
<p>func bar() {<br>let selectorName = “foo”<br>self.perform(Selector(selectorName)<br>}<br>}<br><em>*</em>Swift runtime: MyClass.swift:7:7: entrypoint -[MyClass foo] generated by implicit @objc inference is deprecated and will be removed in Swift 4; add explicit @objc to the declaration to emit the Objective-C entrypoint in Swift 4 and suppress this message<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>五、swift4.0 其它部分特性<br>1、NSAttributedStringKey<br>NSAttributedString 的初始化方法变化：</p>
<p>// swift3.x<br>public init(string str: String, attributes attrs: [AnyHashable : Any]? = nil)</p>
<p>// swift4.0<br>public init(string str: String, attributes attrs: [NSAttributedStringKey : Any]? = nil)<br>1<br>2<br>3<br>4<br>5<br>示例：</p>
<p>// 转换前<br>let attributes = [NSForegroundColorAttributeName: RGB(128, g: 134, b: 146),<br>NSParagraphStyleAttributeName: paragraph,<br>NSFontAttributeName: UIFont.systemFont(ofSize: 14)] as [String : Any]<br>var tipAttrText = NSAttributedString.init(string: tipText, attributes: attributes)</p>
<p>// 转换后<br>let attributes = [NSAttributedStringKey.foregroundColor.rawValue: RGB(128, g: 134, b: 146),<br>NSAttributedStringKey.paragraphStyle: paragraph,<br>NSAttributedStringKey.font: UIFont.systemFont(ofSize: 14)] as! [String : Any]<br>var tipAttrText = NSAttributedString(string: tipText, attributes: attributes)</p>
<p>// tipAttrText 初始化报错提示<br>Cannot convert value of type ‘[String : Any]’ to expected argument type ‘[NSAttributedStringKey : Any]?’</p>
<p>// 修改<br>NSAttributedStringKey.foregroundColor.rawValue -&gt; NSAttributedStringKey.foregroundColor<br>去掉 as! [String : Any]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>2、String<br>String 的 characters 属性被废弃了<br>let string = “abc”<br>var count = string.characters.count</p>
<p>// 第二行报错<br>‘characters’ is deprecated: Please use String or Substring directly</p>
<p>// 对应新方法<br>count = string.count<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>String 的 addingPercentEscapes 方法被废弃了<br>// swift3.x<br>var url = @”<a href="http://www.example.com?username=姓名" target="_blank" rel="noopener">http://www.example.com?username=姓名</a>“<br>url = url.addingPercentEscapes(using: String.Encoding.utf8)!</p>
<p>// 报错<br>‘addingPercentEscapes(using:)’ is unavailable: Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.</p>
<p>// 修改<br>uri = uri.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)!<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>substring(to:) 被废弃了<br>let index = tagText.index(tagText.startIndex, offsetBy: MPMultipleStyleListItemTagMaxLength)</p>
<p>// 警告：’substring(to:)’ is deprecated: Please use String slicing subscript with a ‘partial range upto’ operator.<br>let b = tagText.substring(to: index)</p>
<p>// 新 API<br>// 注意：a 的类型是 Substring，不是 String<br>let a = tagText.prefix(upTo: index)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>3、initialize 废弃<br>// swift3.x<br>override class func initialize() {<br>// some code<br>}</p>
<p>// 报错<br>Method ‘initialize()’ defines Objective-C class method ‘initialize’, which is not permitted by Swift<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>Swift3.x 继续 Method Swizzling这篇文章里面介绍了一种解决思路。</p>
<p>4、swift3 使用 #selector 指定的方法，只有当方法权限为 private 时需要加 @objc 修饰符，swift4.0 都要加 @objc 修饰符<br>// 示例代码<br>func startMonitor() {<br>NotificationCenter.default.addObserver(self, selector: #selector(self.refreshUserLoginStatus), name: NSNotification.Name.XSLUserLogin, object: nil)<br>}<br>func refreshUserLoginStatus() {<br>// some code<br>}</p>
<p>// 第二行警告<br>Argument of ‘#selector’ refers to instance method ‘refreshUserLoginStatus()’ in ‘MPUnreadMessageCountManager’ that depends on ‘@objc’ inference deprecated in Swift 4</p>
<p>// 追加 private<br>func startMonitor() {<br>NotificationCenter.default.addObserver(self, selector: #selector(self.refreshUserLoginStatus), name: NSNotification.Name.XSLUserLogin, object: nil)<br>}<br>private func refreshUserLoginStatus() {<br>// some code<br>}</p>
<p>// 第二行报错<br>Argument of ‘#selector’ refers to instance method ‘refreshUserLoginStatus()’ that is not exposed to Objective-C<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>swift4.0 不再允许重载 extension 中的方法(包括instance、static、class方法)<br>// 示例代码<br>class TestSuperClass: NSObject {<br>}<br>extension TestSuperClass {<br>func test() {<br>// some code<br>}<br>}<br>class TestClass: TestSuperClass {<br>// 报错：Declarations from extensions cannot be overridden yet<br>override func test() {<br>// some code<br>}<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>六、pod 引用<br>添加以下内容到 Podfile。</p>
<p>post_install do |installer|<br>installer.pods_project.targets.each do |target|<br>if [‘WTCarouselFlowLayout’, ‘XSLRevenue’, ‘OHHTTPStubs/Swift’].include? target.name<br>target.build_configurations.each do |config|<br>config.build_settings[‘SWIFT_VERSION’] = ‘3.2’<br>end<br>end<br>end<br>end<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>七、踩坑<br>UITableViewDelegate 协议方法名变更，没有错误提示：</p>
<p>// swift3.x<br>func tableView(_ tableView: UITableView, heightForRowAtIndexPath indexPath: IndexPath) -&gt; CGFloat</p>
<p>// swift4.0<br>func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat</p>
]]></content>
      
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>/baidu_verify_TDAZtyIKEF.html</url>
      <content type="html"><![CDATA[TDAZtyIKEF]]></content>
    </entry>
    
  
</search>
